// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AppConfigClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case roleArn = "RoleArn"
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AppConfigClientTypes {
    /// An action defines the tasks that the extension performs during the AppConfig workflow. Each action includes an action point such as ON_CREATE_HOSTED_CONFIGURATION, PRE_DEPLOYMENT, or ON_DEPLOYMENT. Each action also includes a name, a URI to an Lambda function, and an Amazon Resource Name (ARN) for an Identity and Access Management assume role. You specify the name, URI, and ARN for each action point defined in the extension. You can specify the following actions for an extension:
    ///
    /// * PRE_CREATE_HOSTED_CONFIGURATION_VERSION
    ///
    /// * PRE_START_DEPLOYMENT
    ///
    /// * ON_DEPLOYMENT_START
    ///
    /// * ON_DEPLOYMENT_STEP
    ///
    /// * ON_DEPLOYMENT_BAKING
    ///
    /// * ON_DEPLOYMENT_COMPLETE
    ///
    /// * ON_DEPLOYMENT_ROLLED_BACK
    public struct Action: Swift.Equatable {
        /// Information about the action.
        public var description: Swift.String?
        /// The action name.
        public var name: Swift.String?
        /// An Amazon Resource Name (ARN) for an Identity and Access Management assume role.
        public var roleArn: Swift.String?
        /// The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.
        public var uri: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            uri: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.roleArn = roleArn
            self.uri = uri
        }
    }

}

extension AppConfigClientTypes.ActionInvocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionName = "ActionName"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case extensionIdentifier = "ExtensionIdentifier"
        case invocationId = "InvocationId"
        case roleArn = "RoleArn"
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let extensionIdentifier = self.extensionIdentifier {
            try encodeContainer.encode(extensionIdentifier, forKey: .extensionIdentifier)
        }
        if let invocationId = self.invocationId {
            try encodeContainer.encode(invocationId, forKey: .invocationId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extensionIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extensionIdentifier)
        extensionIdentifier = extensionIdentifierDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let invocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationId)
        invocationId = invocationIdDecoded
    }
}

extension AppConfigClientTypes {
    /// An extension that was invoked as part of a deployment event.
    public struct ActionInvocation: Swift.Equatable {
        /// The name of the action.
        public var actionName: Swift.String?
        /// The error code when an extension invocation fails.
        public var errorCode: Swift.String?
        /// The error message when an extension invocation fails.
        public var errorMessage: Swift.String?
        /// The name, the ID, or the Amazon Resource Name (ARN) of the extension.
        public var extensionIdentifier: Swift.String?
        /// A system-generated ID for this invocation.
        public var invocationId: Swift.String?
        /// An Amazon Resource Name (ARN) for an Identity and Access Management assume role.
        public var roleArn: Swift.String?
        /// The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.
        public var uri: Swift.String?

        public init(
            actionName: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            extensionIdentifier: Swift.String? = nil,
            invocationId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            uri: Swift.String? = nil
        )
        {
            self.actionName = actionName
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.extensionIdentifier = extensionIdentifier
            self.invocationId = invocationId
            self.roleArn = roleArn
            self.uri = uri
        }
    }

}

extension AppConfigClientTypes {
    public enum ActionPoint: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case onDeploymentBaking
        case onDeploymentComplete
        case onDeploymentRolledBack
        case onDeploymentStart
        case onDeploymentStep
        case preCreateHostedConfigurationVersion
        case preStartDeployment
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionPoint] {
            return [
                .onDeploymentBaking,
                .onDeploymentComplete,
                .onDeploymentRolledBack,
                .onDeploymentStart,
                .onDeploymentStep,
                .preCreateHostedConfigurationVersion,
                .preStartDeployment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .onDeploymentBaking: return "ON_DEPLOYMENT_BAKING"
            case .onDeploymentComplete: return "ON_DEPLOYMENT_COMPLETE"
            case .onDeploymentRolledBack: return "ON_DEPLOYMENT_ROLLED_BACK"
            case .onDeploymentStart: return "ON_DEPLOYMENT_START"
            case .onDeploymentStep: return "ON_DEPLOYMENT_STEP"
            case .preCreateHostedConfigurationVersion: return "PRE_CREATE_HOSTED_CONFIGURATION_VERSION"
            case .preStartDeployment: return "PRE_START_DEPLOYMENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionPoint(rawValue: rawValue) ?? ActionPoint.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes.Application: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AppConfigClientTypes {
    public struct Application: Swift.Equatable {
        /// The description of the application.
        public var description: Swift.String?
        /// The application ID.
        public var id: Swift.String?
        /// The application name.
        public var name: Swift.String?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
            self.name = name
        }
    }

}

extension AppConfigClientTypes.AppliedExtension: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case extensionAssociationId = "ExtensionAssociationId"
        case extensionId = "ExtensionId"
        case parameters = "Parameters"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let extensionAssociationId = self.extensionAssociationId {
            try encodeContainer.encode(extensionAssociationId, forKey: .extensionAssociationId)
        }
        if let extensionId = self.extensionId {
            try encodeContainer.encode(extensionId, forKey: .extensionId)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameterValueMap0) in parameters {
                try parametersContainer.encode(parameterValueMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if versionNumber != 0 {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extensionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extensionId)
        extensionId = extensionIdDecoded
        let extensionAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extensionAssociationId)
        extensionAssociationId = extensionAssociationIdDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber) ?? 0
        versionNumber = versionNumberDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and20480) in parametersContainer {
                if let stringwithlengthbetween1and20480 = stringwithlengthbetween1and20480 {
                    parametersDecoded0?[key0] = stringwithlengthbetween1and20480
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension AppConfigClientTypes {
    /// An extension that was invoked during a deployment.
    public struct AppliedExtension: Swift.Equatable {
        /// The system-generated ID for the association.
        public var extensionAssociationId: Swift.String?
        /// The system-generated ID of the extension.
        public var extensionId: Swift.String?
        /// One or more parameters for the actions called by the extension.
        public var parameters: [Swift.String:Swift.String]?
        /// The extension version number.
        public var versionNumber: Swift.Int

        public init(
            extensionAssociationId: Swift.String? = nil,
            extensionId: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            versionNumber: Swift.Int = 0
        )
        {
            self.extensionAssociationId = extensionAssociationId
            self.extensionId = extensionId
            self.parameters = parameters
            self.versionNumber = versionNumber
        }
    }

}

extension AppConfigClientTypes.BadRequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidconfiguration = "InvalidConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .invalidconfiguration(invalidconfiguration):
                var invalidconfigurationContainer = container.nestedUnkeyedContainer(forKey: .invalidconfiguration)
                for invalidconfigurationdetail0 in invalidconfiguration {
                    try invalidconfigurationContainer.encode(invalidconfigurationdetail0)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let invalidconfigurationContainer = try values.decodeIfPresent([AppConfigClientTypes.InvalidConfigurationDetail?].self, forKey: .invalidconfiguration)
        var invalidconfigurationDecoded0:[AppConfigClientTypes.InvalidConfigurationDetail]? = nil
        if let invalidconfigurationContainer = invalidconfigurationContainer {
            invalidconfigurationDecoded0 = [AppConfigClientTypes.InvalidConfigurationDetail]()
            for structure0 in invalidconfigurationContainer {
                if let structure0 = structure0 {
                    invalidconfigurationDecoded0?.append(structure0)
                }
            }
        }
        if let invalidconfiguration = invalidconfigurationDecoded0 {
            self = .invalidconfiguration(invalidconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppConfigClientTypes {
    /// Detailed information about the input that failed to satisfy the constraints specified by a call.
    public enum BadRequestDetails: Swift.Equatable {
        /// Detailed information about the bad request exception error when creating a hosted configuration version.
        case invalidconfiguration([AppConfigClientTypes.InvalidConfigurationDetail])
        case sdkUnknown(Swift.String)
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.details = output.details
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.details = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Detailed information about the input that failed to satisfy the constraints specified by a call.
        public internal(set) var details: AppConfigClientTypes.BadRequestDetails? = nil
        public internal(set) var message: Swift.String? = nil
        public internal(set) var reason: AppConfigClientTypes.BadRequestReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        details: AppConfigClientTypes.BadRequestDetails? = nil,
        message: Swift.String? = nil,
        reason: AppConfigClientTypes.BadRequestReason? = nil
    )
    {
        self.properties.details = details
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: AppConfigClientTypes.BadRequestReason?
    let details: AppConfigClientTypes.BadRequestDetails?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.BadRequestReason.self, forKey: .reason)
        reason = reasonDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.BadRequestDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension AppConfigClientTypes {
    public enum BadRequestReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [BadRequestReason] {
            return [
                .invalidConfiguration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidConfiguration: return "InvalidConfiguration"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BadRequestReason(rawValue: rawValue) ?? BadRequestReason.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes {
    public enum BytesMeasure: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kilobytes
        case sdkUnknown(Swift.String)

        public static var allCases: [BytesMeasure] {
            return [
                .kilobytes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kilobytes: return "KILOBYTES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BytesMeasure(rawValue: rawValue) ?? BytesMeasure.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes.ConfigurationProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case id = "Id"
        case locationUri = "LocationUri"
        case name = "Name"
        case type = "Type"
        case validatorTypes = "ValidatorTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let locationUri = self.locationUri {
            try encodeContainer.encode(locationUri, forKey: .locationUri)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let validatorTypes = validatorTypes {
            var validatorTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validatorTypes)
            for validatortype0 in validatorTypes {
                try validatorTypesContainer.encode(validatortype0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let validatorTypesContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.ValidatorType?].self, forKey: .validatorTypes)
        var validatorTypesDecoded0:[AppConfigClientTypes.ValidatorType]? = nil
        if let validatorTypesContainer = validatorTypesContainer {
            validatorTypesDecoded0 = [AppConfigClientTypes.ValidatorType]()
            for enum0 in validatorTypesContainer {
                if let enum0 = enum0 {
                    validatorTypesDecoded0?.append(enum0)
                }
            }
        }
        validatorTypes = validatorTypesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension AppConfigClientTypes {
    /// A summary of a configuration profile.
    public struct ConfigurationProfileSummary: Swift.Equatable {
        /// The application ID.
        public var applicationId: Swift.String?
        /// The ID of the configuration profile.
        public var id: Swift.String?
        /// The URI location of the configuration.
        public var locationUri: Swift.String?
        /// The name of the configuration profile.
        public var name: Swift.String?
        /// The type of configurations contained in the profile. AppConfig supports feature flags and freeform configurations. We recommend you create feature flag configurations to enable or disable new features and freeform configurations to distribute configurations to an application. When calling this API, enter one of the following values for Type: AWS.AppConfig.FeatureFlags
        ///     AWS.Freeform
        public var type: Swift.String?
        /// The types of validators in the configuration profile.
        public var validatorTypes: [AppConfigClientTypes.ValidatorType]?

        public init(
            applicationId: Swift.String? = nil,
            id: Swift.String? = nil,
            locationUri: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            validatorTypes: [AppConfigClientTypes.ValidatorType]? = nil
        )
        {
            self.applicationId = applicationId
            self.id = id
            self.locationUri = locationUri
            self.name = name
            self.type = type
            self.validatorTypes = validatorTypes
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/applications"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// A description of the application.
    public var description: Swift.String?
    /// A name for the application.
    /// This member is required.
    public var name: Swift.String?
    /// Metadata to assign to the application. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct CreateApplicationOutput: Swift.Equatable {
    /// The description of the application.
    public var description: Swift.String?
    /// The application ID.
    public var id: Swift.String?
    /// The application name.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct CreateApplicationOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension CreateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum CreateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConfigurationProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case kmsKeyIdentifier = "KmsKeyIdentifier"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case tags = "Tags"
        case type = "Type"
        case validators = "Validators"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyIdentifier = self.kmsKeyIdentifier {
            try encodeContainer.encode(kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
        }
        if let locationUri = self.locationUri {
            try encodeContainer.encode(locationUri, forKey: .locationUri)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retrievalRoleArn = self.retrievalRoleArn {
            try encodeContainer.encode(retrievalRoleArn, forKey: .retrievalRoleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let validators = validators {
            var validatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validators)
            for validator0 in validators {
                try validatorsContainer.encode(validator0)
            }
        }
    }
}

extension CreateConfigurationProfileInput {

    static func urlPathProvider(_ value: CreateConfigurationProfileInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles"
    }
}

public struct CreateConfigurationProfileInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A description of the configuration profile.
    public var description: Swift.String?
    /// The identifier for an Key Management Service key to encrypt new configuration data versions in the AppConfig hosted configuration store. This attribute is only used for hosted configuration types. The identifier can be an KMS key ID, alias, or the Amazon Resource Name (ARN) of the key ID or alias. To encrypt data managed in other configuration stores, see the documentation for how to specify an KMS key for that particular service.
    public var kmsKeyIdentifier: Swift.String?
    /// A URI to locate the configuration. You can specify the following:
    ///
    /// * For the AppConfig hosted configuration store and for feature flags, specify hosted.
    ///
    /// * For an Amazon Web Services Systems Manager Parameter Store parameter, specify either the parameter name in the format ssm-parameter:// or the ARN.
    ///
    /// * For an Amazon Web Services CodePipeline pipeline, specify the URI in the following format: codepipeline://.
    ///
    /// * For an Secrets Manager secret, specify the URI in the following format: secretsmanager://.
    ///
    /// * For an Amazon S3 object, specify the URI in the following format: s3:/// . Here is an example: s3://my-bucket/my-app/us-east-1/my-config.json
    ///
    /// * For an SSM document, specify either the document name in the format ssm-document:// or the Amazon Resource Name (ARN).
    /// This member is required.
    public var locationUri: Swift.String?
    /// A name for the configuration profile.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of an IAM role with permission to access the configuration at the specified LocationUri. A retrieval role ARN is not required for configurations stored in the AppConfig hosted configuration store. It is required for all other sources that store your configuration.
    public var retrievalRoleArn: Swift.String?
    /// Metadata to assign to the configuration profile. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
    public var tags: [Swift.String:Swift.String]?
    /// The type of configurations contained in the profile. AppConfig supports feature flags and freeform configurations. We recommend you create feature flag configurations to enable or disable new features and freeform configurations to distribute configurations to an application. When calling this API, enter one of the following values for Type: AWS.AppConfig.FeatureFlags
    ///     AWS.Freeform
    public var type: Swift.String?
    /// A list of methods for validating the configuration.
    public var validators: [AppConfigClientTypes.Validator]?

    public init(
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        locationUri: Swift.String? = nil,
        name: Swift.String? = nil,
        retrievalRoleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        validators: [AppConfigClientTypes.Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.tags = tags
        self.type = type
        self.validators = validators
    }
}

struct CreateConfigurationProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let locationUri: Swift.String?
    let retrievalRoleArn: Swift.String?
    let validators: [AppConfigClientTypes.Validator]?
    let tags: [Swift.String:Swift.String]?
    let type: Swift.String?
    let kmsKeyIdentifier: Swift.String?
}

extension CreateConfigurationProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case kmsKeyIdentifier = "KmsKeyIdentifier"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case tags = "Tags"
        case type = "Type"
        case validators = "Validators"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[AppConfigClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [AppConfigClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

extension CreateConfigurationProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConfigurationProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.kmsKeyArn = output.kmsKeyArn
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.locationUri = output.locationUri
            self.name = output.name
            self.retrievalRoleArn = output.retrievalRoleArn
            self.type = output.type
            self.validators = output.validators
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.kmsKeyArn = nil
            self.kmsKeyIdentifier = nil
            self.locationUri = nil
            self.name = nil
            self.retrievalRoleArn = nil
            self.type = nil
            self.validators = nil
        }
    }
}

public struct CreateConfigurationProfileOutput: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The configuration profile description.
    public var description: Swift.String?
    /// The configuration profile ID.
    public var id: Swift.String?
    /// The Amazon Resource Name of the Key Management Service key to encrypt new configuration data versions in the AppConfig hosted configuration store. This attribute is only used for hosted configuration types. To encrypt data managed in other configuration stores, see the documentation for how to specify an KMS key for that particular service.
    public var kmsKeyArn: Swift.String?
    /// The Key Management Service key identifier (key ID, key alias, or key ARN) provided when the resource was created or updated.
    public var kmsKeyIdentifier: Swift.String?
    /// The URI location of the configuration.
    public var locationUri: Swift.String?
    /// The name of the configuration profile.
    public var name: Swift.String?
    /// The ARN of an IAM role with permission to access the configuration at the specified LocationUri.
    public var retrievalRoleArn: Swift.String?
    /// The type of configurations contained in the profile. AppConfig supports feature flags and freeform configurations. We recommend you create feature flag configurations to enable or disable new features and freeform configurations to distribute configurations to an application. When calling this API, enter one of the following values for Type: AWS.AppConfig.FeatureFlags
    ///     AWS.Freeform
    public var type: Swift.String?
    /// A list of methods for validating the configuration.
    public var validators: [AppConfigClientTypes.Validator]?

    public init(
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        locationUri: Swift.String? = nil,
        name: Swift.String? = nil,
        retrievalRoleArn: Swift.String? = nil,
        type: Swift.String? = nil,
        validators: [AppConfigClientTypes.Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.kmsKeyArn = kmsKeyArn
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.type = type
        self.validators = validators
    }
}

struct CreateConfigurationProfileOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let locationUri: Swift.String?
    let retrievalRoleArn: Swift.String?
    let validators: [AppConfigClientTypes.Validator]?
    let type: Swift.String?
    let kmsKeyArn: Swift.String?
    let kmsKeyIdentifier: Swift.String?
}

extension CreateConfigurationProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case kmsKeyArn = "KmsKeyArn"
        case kmsKeyIdentifier = "KmsKeyIdentifier"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case type = "Type"
        case validators = "Validators"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[AppConfigClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [AppConfigClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

enum CreateConfigurationProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDeploymentStrategyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case name = "Name"
        case replicateTo = "ReplicateTo"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentDurationInMinutes = self.deploymentDurationInMinutes {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let finalBakeTimeInMinutes = self.finalBakeTimeInMinutes {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if let growthFactor = self.growthFactor {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = self.growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicateTo = self.replicateTo {
            try encodeContainer.encode(replicateTo.rawValue, forKey: .replicateTo)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDeploymentStrategyInput {

    static func urlPathProvider(_ value: CreateDeploymentStrategyInput) -> Swift.String? {
        return "/deploymentstrategies"
    }
}

public struct CreateDeploymentStrategyInput: Swift.Equatable {
    /// Total amount of time for a deployment to last.
    /// This member is required.
    public var deploymentDurationInMinutes: Swift.Int?
    /// A description of the deployment strategy.
    public var description: Swift.String?
    /// Specifies the amount of time AppConfig monitors for Amazon CloudWatch alarms after the configuration has been deployed to 100% of its targets, before considering the deployment to be complete. If an alarm is triggered during this time, AppConfig rolls back the deployment. You must configure permissions for AppConfig to roll back based on CloudWatch alarms. For more information, see [Configuring permissions for rollback based on Amazon CloudWatch alarms](https://docs.aws.amazon.com/appconfig/latest/userguide/getting-started-with-appconfig-cloudwatch-alarms-permissions.html) in the AppConfig User Guide.
    public var finalBakeTimeInMinutes: Swift.Int?
    /// The percentage of targets to receive a deployed configuration during each interval.
    /// This member is required.
    public var growthFactor: Swift.Float?
    /// The algorithm used to define how percentage grows over time. AppConfig supports the following growth types: Linear: For this type, AppConfig processes the deployment by dividing the total number of targets by the value specified for Step percentage. For example, a linear deployment that uses a Step percentage of 10 deploys the configuration to 10 percent of the hosts. After those deployments are complete, the system deploys the configuration to the next 10 percent. This continues until 100% of the targets have successfully received the configuration. Exponential: For this type, AppConfig processes the deployment exponentially using the following formula: G*(2^N). In this formula, G is the growth factor specified by the user and N is the number of steps until the configuration is deployed to all targets. For example, if you specify a growth factor of 2, then the system rolls out the configuration as follows: 2*(2^0)
    ///     2*(2^1)
    ///
    /// 2*(2^2) Expressed numerically, the deployment rolls out as follows: 2% of the targets, 4% of the targets, 8% of the targets, and continues until the configuration has been deployed to all targets.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// A name for the deployment strategy.
    /// This member is required.
    public var name: Swift.String?
    /// Save the deployment strategy to a Systems Manager (SSM) document.
    public var replicateTo: AppConfigClientTypes.ReplicateTo?
    /// Metadata to assign to the deployment strategy. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
    public var tags: [Swift.String:Swift.String]?

    public init(
        deploymentDurationInMinutes: Swift.Int? = nil,
        description: Swift.String? = nil,
        finalBakeTimeInMinutes: Swift.Int? = nil,
        growthFactor: Swift.Float? = nil,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        name: Swift.String? = nil,
        replicateTo: AppConfigClientTypes.ReplicateTo? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.name = name
        self.replicateTo = replicateTo
        self.tags = tags
    }
}

struct CreateDeploymentStrategyInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int?
    let finalBakeTimeInMinutes: Swift.Int?
    let growthFactor: Swift.Float?
    let growthType: AppConfigClientTypes.GrowthType?
    let replicateTo: AppConfigClientTypes.ReplicateTo?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDeploymentStrategyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case name = "Name"
        case replicateTo = "ReplicateTo"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let growthFactorDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeploymentStrategyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDeploymentStrategyOutputBody = try responseDecoder.decode(responseBody: data)
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.description = output.description
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.id = output.id
            self.name = output.name
            self.replicateTo = output.replicateTo
        } else {
            self.deploymentDurationInMinutes = 0
            self.description = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = nil
            self.growthType = nil
            self.id = nil
            self.name = nil
            self.replicateTo = nil
        }
    }
}

public struct CreateDeploymentStrategyOutput: Swift.Equatable {
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The description of the deployment strategy.
    public var description: Swift.String?
    /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets that received a deployed configuration during each interval.
    public var growthFactor: Swift.Float?
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The deployment strategy ID.
    public var id: Swift.String?
    /// The name of the deployment strategy.
    public var name: Swift.String?
    /// Save the deployment strategy to a Systems Manager (SSM) document.
    public var replicateTo: AppConfigClientTypes.ReplicateTo?

    public init(
        deploymentDurationInMinutes: Swift.Int = 0,
        description: Swift.String? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float? = nil,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        replicateTo: AppConfigClientTypes.ReplicateTo? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.id = id
        self.name = name
        self.replicateTo = replicateTo
    }
}

struct CreateDeploymentStrategyOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int
    let growthType: AppConfigClientTypes.GrowthType?
    let growthFactor: Swift.Float?
    let finalBakeTimeInMinutes: Swift.Int
    let replicateTo: AppConfigClientTypes.ReplicateTo?
}

extension CreateDeploymentStrategyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deploymentDurationInMinutes) ?? 0
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .finalBakeTimeInMinutes) ?? 0
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

enum CreateDeploymentStrategyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let monitors = monitors {
            var monitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitors)
            for monitor0 in monitors {
                try monitorsContainer.encode(monitor0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateEnvironmentInput {

    static func urlPathProvider(_ value: CreateEnvironmentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments"
    }
}

public struct CreateEnvironmentInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A description of the environment.
    public var description: Swift.String?
    /// Amazon CloudWatch alarms to monitor during the deployment process.
    public var monitors: [AppConfigClientTypes.Monitor]?
    /// A name for the environment.
    /// This member is required.
    public var name: Swift.String?
    /// Metadata to assign to the environment. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
    public var tags: [Swift.String:Swift.String]?

    public init(
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        monitors: [AppConfigClientTypes.Monitor]? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.monitors = monitors
        self.name = name
        self.tags = tags
    }
}

struct CreateEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let monitors: [AppConfigClientTypes.Monitor]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.monitors = output.monitors
            self.name = output.name
            self.state = output.state
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.monitors = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct CreateEnvironmentOutput: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The description of the environment.
    public var description: Swift.String?
    /// The environment ID.
    public var id: Swift.String?
    /// Amazon CloudWatch alarms monitored during the deployment.
    public var monitors: [AppConfigClientTypes.Monitor]?
    /// The name of the environment.
    public var name: Swift.String?
    /// The state of the environment. An environment can be in one of the following states: READY_FOR_DEPLOYMENT, DEPLOYING, ROLLING_BACK, or ROLLED_BACK
    public var state: AppConfigClientTypes.EnvironmentState?

    public init(
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        monitors: [AppConfigClientTypes.Monitor]? = nil,
        name: Swift.String? = nil,
        state: AppConfigClientTypes.EnvironmentState? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.monitors = monitors
        self.name = name
        self.state = state
    }
}

struct CreateEnvironmentOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let state: AppConfigClientTypes.EnvironmentState?
    let monitors: [AppConfigClientTypes.Monitor]?
}

extension CreateEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

enum CreateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateExtensionAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case extensionIdentifier = "ExtensionIdentifier"
        case extensionVersionNumber = "ExtensionVersionNumber"
        case parameters = "Parameters"
        case resourceIdentifier = "ResourceIdentifier"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let extensionIdentifier = self.extensionIdentifier {
            try encodeContainer.encode(extensionIdentifier, forKey: .extensionIdentifier)
        }
        if let extensionVersionNumber = self.extensionVersionNumber {
            try encodeContainer.encode(extensionVersionNumber, forKey: .extensionVersionNumber)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameterValueMap0) in parameters {
                try parametersContainer.encode(parameterValueMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateExtensionAssociationInput {

    static func urlPathProvider(_ value: CreateExtensionAssociationInput) -> Swift.String? {
        return "/extensionassociations"
    }
}

public struct CreateExtensionAssociationInput: Swift.Equatable {
    /// The name, the ID, or the Amazon Resource Name (ARN) of the extension.
    /// This member is required.
    public var extensionIdentifier: Swift.String?
    /// The version number of the extension. If not specified, AppConfig uses the maximum version of the extension.
    public var extensionVersionNumber: Swift.Int?
    /// The parameter names and values defined in the extensions. Extension parameters marked Required must be entered for this field.
    public var parameters: [Swift.String:Swift.String]?
    /// The ARN of an application, configuration profile, or environment.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// Adds one or more tags for the specified extension association. Tags are metadata that help you categorize resources in different ways, for example, by purpose, owner, or environment. Each tag consists of a key and an optional value, both of which you define.
    public var tags: [Swift.String:Swift.String]?

    public init(
        extensionIdentifier: Swift.String? = nil,
        extensionVersionNumber: Swift.Int? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        resourceIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.extensionIdentifier = extensionIdentifier
        self.extensionVersionNumber = extensionVersionNumber
        self.parameters = parameters
        self.resourceIdentifier = resourceIdentifier
        self.tags = tags
    }
}

struct CreateExtensionAssociationInputBody: Swift.Equatable {
    let extensionIdentifier: Swift.String?
    let extensionVersionNumber: Swift.Int?
    let resourceIdentifier: Swift.String?
    let parameters: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateExtensionAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case extensionIdentifier = "ExtensionIdentifier"
        case extensionVersionNumber = "ExtensionVersionNumber"
        case parameters = "Parameters"
        case resourceIdentifier = "ResourceIdentifier"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extensionIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extensionIdentifier)
        extensionIdentifier = extensionIdentifierDecoded
        let extensionVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .extensionVersionNumber)
        extensionVersionNumber = extensionVersionNumberDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and20480) in parametersContainer {
                if let stringwithlengthbetween1and20480 = stringwithlengthbetween1and20480 {
                    parametersDecoded0?[key0] = stringwithlengthbetween1and20480
                }
            }
        }
        parameters = parametersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateExtensionAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateExtensionAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.extensionArn = output.extensionArn
            self.extensionVersionNumber = output.extensionVersionNumber
            self.id = output.id
            self.parameters = output.parameters
            self.resourceArn = output.resourceArn
        } else {
            self.arn = nil
            self.extensionArn = nil
            self.extensionVersionNumber = 0
            self.id = nil
            self.parameters = nil
            self.resourceArn = nil
        }
    }
}

public struct CreateExtensionAssociationOutput: Swift.Equatable {
    /// The system-generated Amazon Resource Name (ARN) for the extension.
    public var arn: Swift.String?
    /// The ARN of the extension defined in the association.
    public var extensionArn: Swift.String?
    /// The version number for the extension defined in the association.
    public var extensionVersionNumber: Swift.Int
    /// The system-generated ID for the association.
    public var id: Swift.String?
    /// The parameter names and values defined in the association.
    public var parameters: [Swift.String:Swift.String]?
    /// The ARNs of applications, configuration profiles, or environments defined in the association.
    public var resourceArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        extensionArn: Swift.String? = nil,
        extensionVersionNumber: Swift.Int = 0,
        id: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.extensionArn = extensionArn
        self.extensionVersionNumber = extensionVersionNumber
        self.id = id
        self.parameters = parameters
        self.resourceArn = resourceArn
    }
}

struct CreateExtensionAssociationOutputBody: Swift.Equatable {
    let id: Swift.String?
    let extensionArn: Swift.String?
    let resourceArn: Swift.String?
    let arn: Swift.String?
    let parameters: [Swift.String:Swift.String]?
    let extensionVersionNumber: Swift.Int
}

extension CreateExtensionAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case extensionArn = "ExtensionArn"
        case extensionVersionNumber = "ExtensionVersionNumber"
        case id = "Id"
        case parameters = "Parameters"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let extensionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extensionArn)
        extensionArn = extensionArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and20480) in parametersContainer {
                if let stringwithlengthbetween1and20480 = stringwithlengthbetween1and20480 {
                    parametersDecoded0?[key0] = stringwithlengthbetween1and20480
                }
            }
        }
        parameters = parametersDecoded0
        let extensionVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .extensionVersionNumber) ?? 0
        extensionVersionNumber = extensionVersionNumberDecoded
    }
}

enum CreateExtensionAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateExtensionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .actions)
            for (dictKey0, actionsMap0) in actions {
                var actionsMap0Container = actionsContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for action1 in actionsMap0 {
                    try actionsMap0Container.encode(action1)
                }
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameterMap0) in parameters {
                try parametersContainer.encode(parameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateExtensionInput {

    static func headerProvider(_ value: CreateExtensionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let latestVersionNumber = value.latestVersionNumber {
            items.add(Header(name: "Latest-Version-Number", value: Swift.String(latestVersionNumber)))
        }
        return items
    }
}

extension CreateExtensionInput {

    static func urlPathProvider(_ value: CreateExtensionInput) -> Swift.String? {
        return "/extensions"
    }
}

public struct CreateExtensionInput: Swift.Equatable {
    /// The actions defined in the extension.
    /// This member is required.
    public var actions: [Swift.String:[AppConfigClientTypes.Action]]?
    /// Information about the extension.
    public var description: Swift.String?
    /// You can omit this field when you create an extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field.
    public var latestVersionNumber: Swift.Int?
    /// A name for the extension. Each extension name in your account must be unique. Extension versions use the same name.
    /// This member is required.
    public var name: Swift.String?
    /// The parameters accepted by the extension. You specify parameter values when you associate the extension to an AppConfig resource by using the CreateExtensionAssociation API action. For Lambda extension actions, these parameters are included in the Lambda request object.
    public var parameters: [Swift.String:AppConfigClientTypes.Parameter]?
    /// Adds one or more tags for the specified extension. Tags are metadata that help you categorize resources in different ways, for example, by purpose, owner, or environment. Each tag consists of a key and an optional value, both of which you define.
    public var tags: [Swift.String:Swift.String]?

    public init(
        actions: [Swift.String:[AppConfigClientTypes.Action]]? = nil,
        description: Swift.String? = nil,
        latestVersionNumber: Swift.Int? = nil,
        name: Swift.String? = nil,
        parameters: [Swift.String:AppConfigClientTypes.Parameter]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.latestVersionNumber = latestVersionNumber
        self.name = name
        self.parameters = parameters
        self.tags = tags
    }
}

struct CreateExtensionInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let actions: [Swift.String:[AppConfigClientTypes.Action]]?
    let parameters: [Swift.String:AppConfigClientTypes.Parameter]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateExtensionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: [AppConfigClientTypes.Action?]?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:[AppConfigClientTypes.Action]]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:[AppConfigClientTypes.Action]]()
            for (key0, actionlist0) in actionsContainer {
                var actionlist0Decoded0: [AppConfigClientTypes.Action]? = nil
                if let actionlist0 = actionlist0 {
                    actionlist0Decoded0 = [AppConfigClientTypes.Action]()
                    for structure1 in actionlist0 {
                        if let structure1 = structure1 {
                            actionlist0Decoded0?.append(structure1)
                        }
                    }
                }
                actionsDecoded0?[key0] = actionlist0Decoded0
            }
        }
        actions = actionsDecoded0
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: AppConfigClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:AppConfigClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:AppConfigClientTypes.Parameter]()
            for (key0, parameter0) in parametersContainer {
                if let parameter0 = parameter0 {
                    parametersDecoded0?[key0] = parameter0
                }
            }
        }
        parameters = parametersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateExtensionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateExtensionOutputBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.arn = output.arn
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.parameters = output.parameters
            self.versionNumber = output.versionNumber
        } else {
            self.actions = nil
            self.arn = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.parameters = nil
            self.versionNumber = 0
        }
    }
}

public struct CreateExtensionOutput: Swift.Equatable {
    /// The actions defined in the extension.
    public var actions: [Swift.String:[AppConfigClientTypes.Action]]?
    /// The system-generated Amazon Resource Name (ARN) for the extension.
    public var arn: Swift.String?
    /// Information about the extension.
    public var description: Swift.String?
    /// The system-generated ID of the extension.
    public var id: Swift.String?
    /// The extension name.
    public var name: Swift.String?
    /// The parameters accepted by the extension. You specify parameter values when you associate the extension to an AppConfig resource by using the CreateExtensionAssociation API action. For Lambda extension actions, these parameters are included in the Lambda request object.
    public var parameters: [Swift.String:AppConfigClientTypes.Parameter]?
    /// The extension version number.
    public var versionNumber: Swift.Int

    public init(
        actions: [Swift.String:[AppConfigClientTypes.Action]]? = nil,
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: [Swift.String:AppConfigClientTypes.Parameter]? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.actions = actions
        self.arn = arn
        self.description = description
        self.id = id
        self.name = name
        self.parameters = parameters
        self.versionNumber = versionNumber
    }
}

struct CreateExtensionOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let versionNumber: Swift.Int
    let arn: Swift.String?
    let description: Swift.String?
    let actions: [Swift.String:[AppConfigClientTypes.Action]]?
    let parameters: [Swift.String:AppConfigClientTypes.Parameter]?
}

extension CreateExtensionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case parameters = "Parameters"
        case versionNumber = "VersionNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber) ?? 0
        versionNumber = versionNumberDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: [AppConfigClientTypes.Action?]?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:[AppConfigClientTypes.Action]]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:[AppConfigClientTypes.Action]]()
            for (key0, actionlist0) in actionsContainer {
                var actionlist0Decoded0: [AppConfigClientTypes.Action]? = nil
                if let actionlist0 = actionlist0 {
                    actionlist0Decoded0 = [AppConfigClientTypes.Action]()
                    for structure1 in actionlist0 {
                        if let structure1 = structure1 {
                            actionlist0Decoded0?.append(structure1)
                        }
                    }
                }
                actionsDecoded0?[key0] = actionlist0Decoded0
            }
        }
        actions = actionsDecoded0
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: AppConfigClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:AppConfigClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:AppConfigClientTypes.Parameter]()
            for (key0, parameter0) in parametersContainer {
                if let parameter0 = parameter0 {
                    parametersDecoded0?[key0] = parameter0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

enum CreateExtensionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateHostedConfigurationVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHostedConfigurationVersionInput(applicationId: \(Swift.String(describing: applicationId)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), contentType: \(Swift.String(describing: contentType)), description: \(Swift.String(describing: description)), latestVersionNumber: \(Swift.String(describing: latestVersionNumber)), versionLabel: \(Swift.String(describing: versionLabel)), content: \"CONTENT_REDACTED\")"}
}

extension CreateHostedConfigurationVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content.base64EncodedString(), forKey: .content)
        }
    }
}

extension CreateHostedConfigurationVersionInput {

    static func headerProvider(_ value: CreateHostedConfigurationVersionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentType = value.contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let description = value.description {
            items.add(Header(name: "Description", value: Swift.String(description)))
        }
        if let latestVersionNumber = value.latestVersionNumber {
            items.add(Header(name: "Latest-Version-Number", value: Swift.String(latestVersionNumber)))
        }
        if let versionLabel = value.versionLabel {
            items.add(Header(name: "VersionLabel", value: Swift.String(versionLabel)))
        }
        return items
    }
}

extension CreateHostedConfigurationVersionInput {

    static func urlPathProvider(_ value: CreateHostedConfigurationVersionInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let configurationProfileId = value.configurationProfileId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())/hostedconfigurationversions"
    }
}

public struct CreateHostedConfigurationVersionInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The content of the configuration or the configuration data.
    /// This member is required.
    public var content: ClientRuntime.Data?
    /// A standard MIME type describing the format of the configuration content. For more information, see [Content-Type](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17).
    /// This member is required.
    public var contentType: Swift.String?
    /// A description of the configuration.
    public var description: Swift.String?
    /// An optional locking token used to prevent race conditions from overwriting configuration updates when creating a new version. To ensure your data is not overwritten when creating multiple hosted configuration versions in rapid succession, specify the version number of the latest hosted configuration version.
    public var latestVersionNumber: Swift.Int?
    /// An optional, user-defined label for the AppConfig hosted configuration version. This value must contain at least one non-numeric character. For example, "v2.2.0".
    public var versionLabel: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        content: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        latestVersionNumber: Swift.Int? = nil,
        versionLabel: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.content = content
        self.contentType = contentType
        self.description = description
        self.latestVersionNumber = latestVersionNumber
        self.versionLabel = versionLabel
    }
}

struct CreateHostedConfigurationVersionInputBody: Swift.Equatable {
    let content: ClientRuntime.Data?
}

extension CreateHostedConfigurationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
    }
}

extension CreateHostedConfigurationVersionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHostedConfigurationVersionOutput(applicationId: \(Swift.String(describing: applicationId)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), contentType: \(Swift.String(describing: contentType)), description: \(Swift.String(describing: description)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), versionLabel: \(Swift.String(describing: versionLabel)), versionNumber: \(Swift.String(describing: versionNumber)), content: \"CONTENT_REDACTED\")"}
}

extension CreateHostedConfigurationVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let applicationIdHeaderValue = httpResponse.headers.value(for: "Application-Id") {
            self.applicationId = applicationIdHeaderValue
        } else {
            self.applicationId = nil
        }
        if let configurationProfileIdHeaderValue = httpResponse.headers.value(for: "Configuration-Profile-Id") {
            self.configurationProfileId = configurationProfileIdHeaderValue
        } else {
            self.configurationProfileId = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let descriptionHeaderValue = httpResponse.headers.value(for: "Description") {
            self.description = descriptionHeaderValue
        } else {
            self.description = nil
        }
        if let kmsKeyArnHeaderValue = httpResponse.headers.value(for: "KmsKeyArn") {
            self.kmsKeyArn = kmsKeyArnHeaderValue
        } else {
            self.kmsKeyArn = nil
        }
        if let versionLabelHeaderValue = httpResponse.headers.value(for: "VersionLabel") {
            self.versionLabel = versionLabelHeaderValue
        } else {
            self.versionLabel = nil
        }
        if let versionNumberHeaderValue = httpResponse.headers.value(for: "Version-Number") {
            self.versionNumber = Swift.Int(versionNumberHeaderValue) ?? 0
        } else {
            self.versionNumber = 0
        }
        switch httpResponse.body {
        case .data(let data):
            self.content = data
        case .stream(let stream):
            self.content = try stream.readToEnd()
        case .noStream:
            self.content = nil
        }
    }
}

public struct CreateHostedConfigurationVersionOutput: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    public var configurationProfileId: Swift.String?
    /// The content of the configuration or the configuration data.
    public var content: ClientRuntime.Data?
    /// A standard MIME type describing the format of the configuration content. For more information, see [Content-Type](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17).
    public var contentType: Swift.String?
    /// A description of the configuration.
    public var description: Swift.String?
    /// The Amazon Resource Name of the Key Management Service key that was used to encrypt this specific version of the configuration data in the AppConfig hosted configuration store.
    public var kmsKeyArn: Swift.String?
    /// A user-defined label for an AppConfig hosted configuration version.
    public var versionLabel: Swift.String?
    /// The configuration version.
    public var versionNumber: Swift.Int

    public init(
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        content: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        versionLabel: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.content = content
        self.contentType = contentType
        self.description = description
        self.kmsKeyArn = kmsKeyArn
        self.versionLabel = versionLabel
        self.versionNumber = versionNumber
    }
}

struct CreateHostedConfigurationVersionOutputBody: Swift.Equatable {
    let content: ClientRuntime.Data?
}

extension CreateHostedConfigurationVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
    }
}

enum CreateHostedConfigurationVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PayloadTooLargeException": return try await PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApplicationInput {

    static func urlPathProvider(_ value: DeleteApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The ID of the application to delete.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
}

extension DeleteApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConfigurationProfileInput {

    static func urlPathProvider(_ value: DeleteConfigurationProfileInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let configurationProfileId = value.configurationProfileId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())"
    }
}

public struct DeleteConfigurationProfileInput: Swift.Equatable {
    /// The application ID that includes the configuration profile you want to delete.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the configuration profile you want to delete.
    /// This member is required.
    public var configurationProfileId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
    }
}

struct DeleteConfigurationProfileInputBody: Swift.Equatable {
}

extension DeleteConfigurationProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigurationProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteConfigurationProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConfigurationProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDeploymentStrategyInput {

    static func urlPathProvider(_ value: DeleteDeploymentStrategyInput) -> Swift.String? {
        guard let deploymentStrategyId = value.deploymentStrategyId else {
            return nil
        }
        return "/deployementstrategies/\(deploymentStrategyId.urlPercentEncoding())"
    }
}

public struct DeleteDeploymentStrategyInput: Swift.Equatable {
    /// The ID of the deployment strategy you want to delete.
    /// This member is required.
    public var deploymentStrategyId: Swift.String?

    public init(
        deploymentStrategyId: Swift.String? = nil
    )
    {
        self.deploymentStrategyId = deploymentStrategyId
    }
}

struct DeleteDeploymentStrategyInputBody: Swift.Equatable {
}

extension DeleteDeploymentStrategyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeploymentStrategyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDeploymentStrategyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDeploymentStrategyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEnvironmentInput {

    static func urlPathProvider(_ value: DeleteEnvironmentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())"
    }
}

public struct DeleteEnvironmentInput: Swift.Equatable {
    /// The application ID that includes the environment that you want to delete.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the environment that you want to delete.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.environmentId = environmentId
    }
}

struct DeleteEnvironmentInputBody: Swift.Equatable {
}

extension DeleteEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEnvironmentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteExtensionAssociationInput {

    static func urlPathProvider(_ value: DeleteExtensionAssociationInput) -> Swift.String? {
        guard let extensionAssociationId = value.extensionAssociationId else {
            return nil
        }
        return "/extensionassociations/\(extensionAssociationId.urlPercentEncoding())"
    }
}

public struct DeleteExtensionAssociationInput: Swift.Equatable {
    /// The ID of the extension association to delete.
    /// This member is required.
    public var extensionAssociationId: Swift.String?

    public init(
        extensionAssociationId: Swift.String? = nil
    )
    {
        self.extensionAssociationId = extensionAssociationId
    }
}

struct DeleteExtensionAssociationInputBody: Swift.Equatable {
}

extension DeleteExtensionAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteExtensionAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteExtensionAssociationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteExtensionAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteExtensionInput {

    static func queryItemProvider(_ value: DeleteExtensionInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let versionNumber = value.versionNumber {
            let versionNumberQueryItem = ClientRuntime.SDKURLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension DeleteExtensionInput {

    static func urlPathProvider(_ value: DeleteExtensionInput) -> Swift.String? {
        guard let extensionIdentifier = value.extensionIdentifier else {
            return nil
        }
        return "/extensions/\(extensionIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteExtensionInput: Swift.Equatable {
    /// The name, ID, or Amazon Resource Name (ARN) of the extension you want to delete.
    /// This member is required.
    public var extensionIdentifier: Swift.String?
    /// A specific version of an extension to delete. If omitted, the highest version is deleted.
    public var versionNumber: Swift.Int?

    public init(
        extensionIdentifier: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.extensionIdentifier = extensionIdentifier
        self.versionNumber = versionNumber
    }
}

struct DeleteExtensionInputBody: Swift.Equatable {
}

extension DeleteExtensionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteExtensionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteExtensionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteExtensionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteHostedConfigurationVersionInput {

    static func urlPathProvider(_ value: DeleteHostedConfigurationVersionInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let configurationProfileId = value.configurationProfileId else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())/hostedconfigurationversions/\(versionNumber)"
    }
}

public struct DeleteHostedConfigurationVersionInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The versions number to delete.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.versionNumber = versionNumber
    }
}

struct DeleteHostedConfigurationVersionInputBody: Swift.Equatable {
}

extension DeleteHostedConfigurationVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteHostedConfigurationVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteHostedConfigurationVersionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteHostedConfigurationVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppConfigClientTypes.DeploymentEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionInvocations = "ActionInvocations"
        case description = "Description"
        case eventType = "EventType"
        case occurredAt = "OccurredAt"
        case triggeredBy = "TriggeredBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionInvocations = actionInvocations {
            var actionInvocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionInvocations)
            for actioninvocation0 in actionInvocations {
                try actionInvocationsContainer.encode(actioninvocation0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let occurredAt = self.occurredAt {
            try encodeContainer.encodeTimestamp(occurredAt, format: .dateTime, forKey: .occurredAt)
        }
        if let triggeredBy = self.triggeredBy {
            try encodeContainer.encode(triggeredBy.rawValue, forKey: .triggeredBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.DeploymentEventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let triggeredByDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.TriggeredBy.self, forKey: .triggeredBy)
        triggeredBy = triggeredByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionInvocationsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.ActionInvocation?].self, forKey: .actionInvocations)
        var actionInvocationsDecoded0:[AppConfigClientTypes.ActionInvocation]? = nil
        if let actionInvocationsContainer = actionInvocationsContainer {
            actionInvocationsDecoded0 = [AppConfigClientTypes.ActionInvocation]()
            for structure0 in actionInvocationsContainer {
                if let structure0 = structure0 {
                    actionInvocationsDecoded0?.append(structure0)
                }
            }
        }
        actionInvocations = actionInvocationsDecoded0
        let occurredAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .occurredAt)
        occurredAt = occurredAtDecoded
    }
}

extension AppConfigClientTypes {
    /// An object that describes a deployment event.
    public struct DeploymentEvent: Swift.Equatable {
        /// The list of extensions that were invoked as part of the deployment.
        public var actionInvocations: [AppConfigClientTypes.ActionInvocation]?
        /// A description of the deployment event. Descriptions include, but are not limited to, the following:
        ///
        /// * The Amazon Web Services account or the Amazon CloudWatch alarm ARN that initiated a rollback.
        ///
        /// * The percentage of hosts that received the deployment.
        ///
        /// * A recommendation to attempt a new deployment (in the case of an internal error).
        public var description: Swift.String?
        /// The type of deployment event. Deployment event types include the start, stop, or completion of a deployment; a percentage update; the start or stop of a bake period; and the start or completion of a rollback.
        public var eventType: AppConfigClientTypes.DeploymentEventType?
        /// The date and time the event occurred.
        public var occurredAt: ClientRuntime.Date?
        /// The entity that triggered the deployment event. Events can be triggered by a user, AppConfig, an Amazon CloudWatch alarm, or an internal error.
        public var triggeredBy: AppConfigClientTypes.TriggeredBy?

        public init(
            actionInvocations: [AppConfigClientTypes.ActionInvocation]? = nil,
            description: Swift.String? = nil,
            eventType: AppConfigClientTypes.DeploymentEventType? = nil,
            occurredAt: ClientRuntime.Date? = nil,
            triggeredBy: AppConfigClientTypes.TriggeredBy? = nil
        )
        {
            self.actionInvocations = actionInvocations
            self.description = description
            self.eventType = eventType
            self.occurredAt = occurredAt
            self.triggeredBy = triggeredBy
        }
    }

}

extension AppConfigClientTypes {
    public enum DeploymentEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bakeTimeStarted
        case deploymentCompleted
        case deploymentStarted
        case percentageUpdated
        case rollbackCompleted
        case rollbackStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentEventType] {
            return [
                .bakeTimeStarted,
                .deploymentCompleted,
                .deploymentStarted,
                .percentageUpdated,
                .rollbackCompleted,
                .rollbackStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bakeTimeStarted: return "BAKE_TIME_STARTED"
            case .deploymentCompleted: return "DEPLOYMENT_COMPLETED"
            case .deploymentStarted: return "DEPLOYMENT_STARTED"
            case .percentageUpdated: return "PERCENTAGE_UPDATED"
            case .rollbackCompleted: return "ROLLBACK_COMPLETED"
            case .rollbackStarted: return "ROLLBACK_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentEventType(rawValue: rawValue) ?? DeploymentEventType.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes {
    public enum DeploymentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case baking
        case complete
        case deploying
        case rolledBack
        case rollingBack
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentState] {
            return [
                .baking,
                .complete,
                .deploying,
                .rolledBack,
                .rollingBack,
                .validating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .baking: return "BAKING"
            case .complete: return "COMPLETE"
            case .deploying: return "DEPLOYING"
            case .rolledBack: return "ROLLED_BACK"
            case .rollingBack: return "ROLLING_BACK"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentState(rawValue: rawValue) ?? DeploymentState.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes.DeploymentStrategy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deploymentDurationInMinutes != 0 {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if finalBakeTimeInMinutes != 0 {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if let growthFactor = self.growthFactor {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = self.growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicateTo = self.replicateTo {
            try encodeContainer.encode(replicateTo.rawValue, forKey: .replicateTo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deploymentDurationInMinutes) ?? 0
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .finalBakeTimeInMinutes) ?? 0
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

extension AppConfigClientTypes {
    public struct DeploymentStrategy: Swift.Equatable {
        /// Total amount of time the deployment lasted.
        public var deploymentDurationInMinutes: Swift.Int
        /// The description of the deployment strategy.
        public var description: Swift.String?
        /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
        public var finalBakeTimeInMinutes: Swift.Int
        /// The percentage of targets that received a deployed configuration during each interval.
        public var growthFactor: Swift.Float?
        /// The algorithm used to define how percentage grew over time.
        public var growthType: AppConfigClientTypes.GrowthType?
        /// The deployment strategy ID.
        public var id: Swift.String?
        /// The name of the deployment strategy.
        public var name: Swift.String?
        /// Save the deployment strategy to a Systems Manager (SSM) document.
        public var replicateTo: AppConfigClientTypes.ReplicateTo?

        public init(
            deploymentDurationInMinutes: Swift.Int = 0,
            description: Swift.String? = nil,
            finalBakeTimeInMinutes: Swift.Int = 0,
            growthFactor: Swift.Float? = nil,
            growthType: AppConfigClientTypes.GrowthType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            replicateTo: AppConfigClientTypes.ReplicateTo? = nil
        )
        {
            self.deploymentDurationInMinutes = deploymentDurationInMinutes
            self.description = description
            self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
            self.growthFactor = growthFactor
            self.growthType = growthType
            self.id = id
            self.name = name
            self.replicateTo = replicateTo
        }
    }

}

extension AppConfigClientTypes.DeploymentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completedAt = "CompletedAt"
        case configurationName = "ConfigurationName"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
        case versionLabel = "VersionLabel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedAt = self.completedAt {
            try encodeContainer.encodeTimestamp(completedAt, format: .dateTime, forKey: .completedAt)
        }
        if let configurationName = self.configurationName {
            try encodeContainer.encode(configurationName, forKey: .configurationName)
        }
        if let configurationVersion = self.configurationVersion {
            try encodeContainer.encode(configurationVersion, forKey: .configurationVersion)
        }
        if deploymentDurationInMinutes != 0 {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if deploymentNumber != 0 {
            try encodeContainer.encode(deploymentNumber, forKey: .deploymentNumber)
        }
        if finalBakeTimeInMinutes != 0 {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if let growthFactor = self.growthFactor {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = self.growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
        if let percentageComplete = self.percentageComplete {
            try encodeContainer.encode(percentageComplete, forKey: .percentageComplete)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let versionLabel = self.versionLabel {
            try encodeContainer.encode(versionLabel, forKey: .versionLabel)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deploymentNumber) ?? 0
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deploymentDurationInMinutes) ?? 0
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .finalBakeTimeInMinutes) ?? 0
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.DeploymentState.self, forKey: .state)
        state = stateDecoded
        let percentageCompleteDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completedAt)
        completedAt = completedAtDecoded
        let versionLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionLabel)
        versionLabel = versionLabelDecoded
    }
}

extension AppConfigClientTypes {
    /// Information about the deployment.
    public struct DeploymentSummary: Swift.Equatable {
        /// Time the deployment completed.
        public var completedAt: ClientRuntime.Date?
        /// The name of the configuration.
        public var configurationName: Swift.String?
        /// The version of the configuration.
        public var configurationVersion: Swift.String?
        /// Total amount of time the deployment lasted.
        public var deploymentDurationInMinutes: Swift.Int
        /// The sequence number of the deployment.
        public var deploymentNumber: Swift.Int
        /// The amount of time that AppConfig monitors for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
        public var finalBakeTimeInMinutes: Swift.Int
        /// The percentage of targets to receive a deployed configuration during each interval.
        public var growthFactor: Swift.Float?
        /// The algorithm used to define how percentage grows over time.
        public var growthType: AppConfigClientTypes.GrowthType?
        /// The percentage of targets for which the deployment is available.
        public var percentageComplete: Swift.Float?
        /// Time the deployment started.
        public var startedAt: ClientRuntime.Date?
        /// The state of the deployment.
        public var state: AppConfigClientTypes.DeploymentState?
        /// A user-defined label for an AppConfig hosted configuration version.
        public var versionLabel: Swift.String?

        public init(
            completedAt: ClientRuntime.Date? = nil,
            configurationName: Swift.String? = nil,
            configurationVersion: Swift.String? = nil,
            deploymentDurationInMinutes: Swift.Int = 0,
            deploymentNumber: Swift.Int = 0,
            finalBakeTimeInMinutes: Swift.Int = 0,
            growthFactor: Swift.Float? = nil,
            growthType: AppConfigClientTypes.GrowthType? = nil,
            percentageComplete: Swift.Float? = nil,
            startedAt: ClientRuntime.Date? = nil,
            state: AppConfigClientTypes.DeploymentState? = nil,
            versionLabel: Swift.String? = nil
        )
        {
            self.completedAt = completedAt
            self.configurationName = configurationName
            self.configurationVersion = configurationVersion
            self.deploymentDurationInMinutes = deploymentDurationInMinutes
            self.deploymentNumber = deploymentNumber
            self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
            self.growthFactor = growthFactor
            self.growthType = growthType
            self.percentageComplete = percentageComplete
            self.startedAt = startedAt
            self.state = state
            self.versionLabel = versionLabel
        }
    }

}

extension AppConfigClientTypes.Environment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let monitors = monitors {
            var monitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitors)
            for monitor0 in monitors {
                try monitorsContainer.encode(monitor0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

extension AppConfigClientTypes {
    public struct Environment: Swift.Equatable {
        /// The application ID.
        public var applicationId: Swift.String?
        /// The description of the environment.
        public var description: Swift.String?
        /// The environment ID.
        public var id: Swift.String?
        /// Amazon CloudWatch alarms monitored during the deployment.
        public var monitors: [AppConfigClientTypes.Monitor]?
        /// The name of the environment.
        public var name: Swift.String?
        /// The state of the environment. An environment can be in one of the following states: READY_FOR_DEPLOYMENT, DEPLOYING, ROLLING_BACK, or ROLLED_BACK
        public var state: AppConfigClientTypes.EnvironmentState?

        public init(
            applicationId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            monitors: [AppConfigClientTypes.Monitor]? = nil,
            name: Swift.String? = nil,
            state: AppConfigClientTypes.EnvironmentState? = nil
        )
        {
            self.applicationId = applicationId
            self.description = description
            self.id = id
            self.monitors = monitors
            self.name = name
            self.state = state
        }
    }

}

extension AppConfigClientTypes {
    public enum EnvironmentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deploying
        case readyForDeployment
        case rolledBack
        case rollingBack
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentState] {
            return [
                .deploying,
                .readyForDeployment,
                .rolledBack,
                .rollingBack,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deploying: return "DEPLOYING"
            case .readyForDeployment: return "READY_FOR_DEPLOYMENT"
            case .rolledBack: return "ROLLED_BACK"
            case .rollingBack: return "ROLLING_BACK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentState(rawValue: rawValue) ?? EnvironmentState.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes.ExtensionAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case extensionArn = "ExtensionArn"
        case id = "Id"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let extensionArn = self.extensionArn {
            try encodeContainer.encode(extensionArn, forKey: .extensionArn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let extensionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extensionArn)
        extensionArn = extensionArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension AppConfigClientTypes {
    /// Information about an association between an extension and an AppConfig resource such as an application, environment, or configuration profile. Call GetExtensionAssociation to get more information about an association.
    public struct ExtensionAssociationSummary: Swift.Equatable {
        /// The system-generated Amazon Resource Name (ARN) for the extension.
        public var extensionArn: Swift.String?
        /// The extension association ID. This ID is used to call other ExtensionAssociation API actions such as GetExtensionAssociation or DeleteExtensionAssociation.
        public var id: Swift.String?
        /// The ARNs of applications, configuration profiles, or environments defined in the association.
        public var resourceArn: Swift.String?

        public init(
            extensionArn: Swift.String? = nil,
            id: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.extensionArn = extensionArn
            self.id = id
            self.resourceArn = resourceArn
        }
    }

}

extension AppConfigClientTypes.ExtensionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if versionNumber != 0 {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber) ?? 0
        versionNumber = versionNumberDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AppConfigClientTypes {
    /// Information about an extension. Call GetExtension to get more information about an extension.
    public struct ExtensionSummary: Swift.Equatable {
        /// The system-generated Amazon Resource Name (ARN) for the extension.
        public var arn: Swift.String?
        /// Information about the extension.
        public var description: Swift.String?
        /// The system-generated ID of the extension.
        public var id: Swift.String?
        /// The extension name.
        public var name: Swift.String?
        /// The extension version number.
        public var versionNumber: Swift.Int

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            versionNumber: Swift.Int = 0
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
            self.versionNumber = versionNumber
        }
    }

}

extension GetApplicationInput {

    static func urlPathProvider(_ value: GetApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct GetApplicationInput: Swift.Equatable {
    /// The ID of the application you want to get.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApplicationInputBody: Swift.Equatable {
}

extension GetApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct GetApplicationOutput: Swift.Equatable {
    /// The description of the application.
    public var description: Swift.String?
    /// The application ID.
    public var id: Swift.String?
    /// The application name.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct GetApplicationOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension GetApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum GetApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConfigurationInput {

    static func queryItemProvider(_ value: GetConfigurationInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let clientId = value.clientId else {
            let message = "Creating a URL Query Item failed. clientId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let clientIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "client_id".urlPercentEncoding(), value: Swift.String(clientId).urlPercentEncoding())
        items.append(clientIdQueryItem)
        if let clientConfigurationVersion = value.clientConfigurationVersion {
            let clientConfigurationVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "client_configuration_version".urlPercentEncoding(), value: Swift.String(clientConfigurationVersion).urlPercentEncoding())
            items.append(clientConfigurationVersionQueryItem)
        }
        return items
    }
}

extension GetConfigurationInput {

    static func urlPathProvider(_ value: GetConfigurationInput) -> Swift.String? {
        guard let application = value.application else {
            return nil
        }
        guard let environment = value.environment else {
            return nil
        }
        guard let configuration = value.configuration else {
            return nil
        }
        return "/applications/\(application.urlPercentEncoding())/environments/\(environment.urlPercentEncoding())/configurations/\(configuration.urlPercentEncoding())"
    }
}

public struct GetConfigurationInput: Swift.Equatable {
    /// The application to get. Specify either the application name or the application ID.
    /// This member is required.
    public var application: Swift.String?
    /// The configuration version returned in the most recent GetConfiguration response. AppConfig uses the value of the ClientConfigurationVersion parameter to identify the configuration version on your clients. If you dont send ClientConfigurationVersion with each call to GetConfiguration, your clients receive the current configuration. You are charged each time your clients receive a configuration. To avoid excess charges, we recommend you use the [StartConfigurationSession](https://docs.aws.amazon.com/appconfig/2019-10-09/APIReference/StartConfigurationSession.html) and [GetLatestConfiguration](https://docs.aws.amazon.com/appconfig/2019-10-09/APIReference/GetLatestConfiguration.html) APIs, which track the client configuration version on your behalf. If you choose to continue using GetConfiguration, we recommend that you include the ClientConfigurationVersion value with every call to GetConfiguration. The value to use for ClientConfigurationVersion comes from the ConfigurationVersion attribute returned by GetConfiguration when there is new or updated data, and should be saved for subsequent calls to GetConfiguration. For more information about working with configurations, see [Retrieving the Configuration](http://docs.aws.amazon.com/appconfig/latest/userguide/appconfig-retrieving-the-configuration.html) in the AppConfig User Guide.
    public var clientConfigurationVersion: Swift.String?
    /// The clientId parameter in the following command is a unique, user-specified ID to identify the client for the configuration. This ID enables AppConfig to deploy the configuration in intervals, as defined in the deployment strategy.
    /// This member is required.
    public var clientId: Swift.String?
    /// The configuration to get. Specify either the configuration name or the configuration ID.
    /// This member is required.
    public var configuration: Swift.String?
    /// The environment to get. Specify either the environment name or the environment ID.
    /// This member is required.
    public var environment: Swift.String?

    public init(
        application: Swift.String? = nil,
        clientConfigurationVersion: Swift.String? = nil,
        clientId: Swift.String? = nil,
        configuration: Swift.String? = nil,
        environment: Swift.String? = nil
    )
    {
        self.application = application
        self.clientConfigurationVersion = clientConfigurationVersion
        self.clientId = clientId
        self.configuration = configuration
        self.environment = environment
    }
}

struct GetConfigurationInputBody: Swift.Equatable {
}

extension GetConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigurationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConfigurationOutput(configurationVersion: \(Swift.String(describing: configurationVersion)), contentType: \(Swift.String(describing: contentType)), content: \"CONTENT_REDACTED\")"}
}

extension GetConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let configurationVersionHeaderValue = httpResponse.headers.value(for: "Configuration-Version") {
            self.configurationVersion = configurationVersionHeaderValue
        } else {
            self.configurationVersion = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.content = data
        case .stream(let stream):
            self.content = try stream.readToEnd()
        case .noStream:
            self.content = nil
        }
    }
}

public struct GetConfigurationOutput: Swift.Equatable {
    /// The configuration version.
    public var configurationVersion: Swift.String?
    /// The content of the configuration or the configuration data. The Content attribute only contains data if the system finds new or updated configuration data. If there is no new or updated data and ClientConfigurationVersion matches the version of the current configuration, AppConfig returns a 204 No Content HTTP response code and the Content value will be empty.
    public var content: ClientRuntime.Data?
    /// A standard MIME type describing the format of the configuration content. For more information, see [Content-Type](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17).
    public var contentType: Swift.String?

    public init(
        configurationVersion: Swift.String? = nil,
        content: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.configurationVersion = configurationVersion
        self.content = content
        self.contentType = contentType
    }
}

struct GetConfigurationOutputBody: Swift.Equatable {
    let content: ClientRuntime.Data?
}

extension GetConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
    }
}

enum GetConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConfigurationProfileInput {

    static func urlPathProvider(_ value: GetConfigurationProfileInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let configurationProfileId = value.configurationProfileId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())"
    }
}

public struct GetConfigurationProfileInput: Swift.Equatable {
    /// The ID of the application that includes the configuration profile you want to get.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the configuration profile that you want to get.
    /// This member is required.
    public var configurationProfileId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
    }
}

struct GetConfigurationProfileInputBody: Swift.Equatable {
}

extension GetConfigurationProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigurationProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConfigurationProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.kmsKeyArn = output.kmsKeyArn
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.locationUri = output.locationUri
            self.name = output.name
            self.retrievalRoleArn = output.retrievalRoleArn
            self.type = output.type
            self.validators = output.validators
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.kmsKeyArn = nil
            self.kmsKeyIdentifier = nil
            self.locationUri = nil
            self.name = nil
            self.retrievalRoleArn = nil
            self.type = nil
            self.validators = nil
        }
    }
}

public struct GetConfigurationProfileOutput: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The configuration profile description.
    public var description: Swift.String?
    /// The configuration profile ID.
    public var id: Swift.String?
    /// The Amazon Resource Name of the Key Management Service key to encrypt new configuration data versions in the AppConfig hosted configuration store. This attribute is only used for hosted configuration types. To encrypt data managed in other configuration stores, see the documentation for how to specify an KMS key for that particular service.
    public var kmsKeyArn: Swift.String?
    /// The Key Management Service key identifier (key ID, key alias, or key ARN) provided when the resource was created or updated.
    public var kmsKeyIdentifier: Swift.String?
    /// The URI location of the configuration.
    public var locationUri: Swift.String?
    /// The name of the configuration profile.
    public var name: Swift.String?
    /// The ARN of an IAM role with permission to access the configuration at the specified LocationUri.
    public var retrievalRoleArn: Swift.String?
    /// The type of configurations contained in the profile. AppConfig supports feature flags and freeform configurations. We recommend you create feature flag configurations to enable or disable new features and freeform configurations to distribute configurations to an application. When calling this API, enter one of the following values for Type: AWS.AppConfig.FeatureFlags
    ///     AWS.Freeform
    public var type: Swift.String?
    /// A list of methods for validating the configuration.
    public var validators: [AppConfigClientTypes.Validator]?

    public init(
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        locationUri: Swift.String? = nil,
        name: Swift.String? = nil,
        retrievalRoleArn: Swift.String? = nil,
        type: Swift.String? = nil,
        validators: [AppConfigClientTypes.Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.kmsKeyArn = kmsKeyArn
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.type = type
        self.validators = validators
    }
}

struct GetConfigurationProfileOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let locationUri: Swift.String?
    let retrievalRoleArn: Swift.String?
    let validators: [AppConfigClientTypes.Validator]?
    let type: Swift.String?
    let kmsKeyArn: Swift.String?
    let kmsKeyIdentifier: Swift.String?
}

extension GetConfigurationProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case kmsKeyArn = "KmsKeyArn"
        case kmsKeyIdentifier = "KmsKeyIdentifier"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case type = "Type"
        case validators = "Validators"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[AppConfigClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [AppConfigClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

enum GetConfigurationProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeploymentInput {

    static func urlPathProvider(_ value: GetDeploymentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let deploymentNumber = value.deploymentNumber else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())/deployments/\(deploymentNumber)"
    }
}

public struct GetDeploymentInput: Swift.Equatable {
    /// The ID of the application that includes the deployment you want to get.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The sequence number of the deployment.
    /// This member is required.
    public var deploymentNumber: Swift.Int?
    /// The ID of the environment that includes the deployment you want to get.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        deploymentNumber: Swift.Int? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.deploymentNumber = deploymentNumber
        self.environmentId = environmentId
    }
}

struct GetDeploymentInputBody: Swift.Equatable {
}

extension GetDeploymentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.appliedExtensions = output.appliedExtensions
            self.completedAt = output.completedAt
            self.configurationLocationUri = output.configurationLocationUri
            self.configurationName = output.configurationName
            self.configurationProfileId = output.configurationProfileId
            self.configurationVersion = output.configurationVersion
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.deploymentNumber = output.deploymentNumber
            self.deploymentStrategyId = output.deploymentStrategyId
            self.description = output.description
            self.environmentId = output.environmentId
            self.eventLog = output.eventLog
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.kmsKeyArn = output.kmsKeyArn
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.percentageComplete = output.percentageComplete
            self.startedAt = output.startedAt
            self.state = output.state
            self.versionLabel = output.versionLabel
        } else {
            self.applicationId = nil
            self.appliedExtensions = nil
            self.completedAt = nil
            self.configurationLocationUri = nil
            self.configurationName = nil
            self.configurationProfileId = nil
            self.configurationVersion = nil
            self.deploymentDurationInMinutes = 0
            self.deploymentNumber = 0
            self.deploymentStrategyId = nil
            self.description = nil
            self.environmentId = nil
            self.eventLog = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = nil
            self.growthType = nil
            self.kmsKeyArn = nil
            self.kmsKeyIdentifier = nil
            self.percentageComplete = nil
            self.startedAt = nil
            self.state = nil
            self.versionLabel = nil
        }
    }
}

public struct GetDeploymentOutput: Swift.Equatable {
    /// The ID of the application that was deployed.
    public var applicationId: Swift.String?
    /// A list of extensions that were processed as part of the deployment. The extensions that were previously associated to the configuration profile, environment, or the application when StartDeployment was called.
    public var appliedExtensions: [AppConfigClientTypes.AppliedExtension]?
    /// The time the deployment completed.
    public var completedAt: ClientRuntime.Date?
    /// Information about the source location of the configuration.
    public var configurationLocationUri: Swift.String?
    /// The name of the configuration.
    public var configurationName: Swift.String?
    /// The ID of the configuration profile that was deployed.
    public var configurationProfileId: Swift.String?
    /// The configuration version that was deployed.
    public var configurationVersion: Swift.String?
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The sequence number of the deployment.
    public var deploymentNumber: Swift.Int
    /// The ID of the deployment strategy that was deployed.
    public var deploymentStrategyId: Swift.String?
    /// The description of the deployment.
    public var description: Swift.String?
    /// The ID of the environment that was deployed.
    public var environmentId: Swift.String?
    /// A list containing all events related to a deployment. The most recent events are displayed first.
    public var eventLog: [AppConfigClientTypes.DeploymentEvent]?
    /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets to receive a deployed configuration during each interval.
    public var growthFactor: Swift.Float?
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The Amazon Resource Name of the Key Management Service key used to encrypt configuration data. You can encrypt secrets stored in Secrets Manager, Amazon Simple Storage Service (Amazon S3) objects encrypted with SSE-KMS, or secure string parameters stored in Amazon Web Services Systems Manager Parameter Store.
    public var kmsKeyArn: Swift.String?
    /// The Key Management Service key identifier (key ID, key alias, or key ARN) provided when the resource was created or updated.
    public var kmsKeyIdentifier: Swift.String?
    /// The percentage of targets for which the deployment is available.
    public var percentageComplete: Swift.Float?
    /// The time the deployment started.
    public var startedAt: ClientRuntime.Date?
    /// The state of the deployment.
    public var state: AppConfigClientTypes.DeploymentState?
    /// A user-defined label for an AppConfig hosted configuration version.
    public var versionLabel: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        appliedExtensions: [AppConfigClientTypes.AppliedExtension]? = nil,
        completedAt: ClientRuntime.Date? = nil,
        configurationLocationUri: Swift.String? = nil,
        configurationName: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        configurationVersion: Swift.String? = nil,
        deploymentDurationInMinutes: Swift.Int = 0,
        deploymentNumber: Swift.Int = 0,
        deploymentStrategyId: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        eventLog: [AppConfigClientTypes.DeploymentEvent]? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float? = nil,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        kmsKeyArn: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        percentageComplete: Swift.Float? = nil,
        startedAt: ClientRuntime.Date? = nil,
        state: AppConfigClientTypes.DeploymentState? = nil,
        versionLabel: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.appliedExtensions = appliedExtensions
        self.completedAt = completedAt
        self.configurationLocationUri = configurationLocationUri
        self.configurationName = configurationName
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentNumber = deploymentNumber
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.eventLog = eventLog
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.kmsKeyArn = kmsKeyArn
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.percentageComplete = percentageComplete
        self.startedAt = startedAt
        self.state = state
        self.versionLabel = versionLabel
    }
}

struct GetDeploymentOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let environmentId: Swift.String?
    let deploymentStrategyId: Swift.String?
    let configurationProfileId: Swift.String?
    let deploymentNumber: Swift.Int
    let configurationName: Swift.String?
    let configurationLocationUri: Swift.String?
    let configurationVersion: Swift.String?
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int
    let growthType: AppConfigClientTypes.GrowthType?
    let growthFactor: Swift.Float?
    let finalBakeTimeInMinutes: Swift.Int
    let state: AppConfigClientTypes.DeploymentState?
    let eventLog: [AppConfigClientTypes.DeploymentEvent]?
    let percentageComplete: Swift.Float?
    let startedAt: ClientRuntime.Date?
    let completedAt: ClientRuntime.Date?
    let appliedExtensions: [AppConfigClientTypes.AppliedExtension]?
    let kmsKeyArn: Swift.String?
    let kmsKeyIdentifier: Swift.String?
    let versionLabel: Swift.String?
}

extension GetDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case appliedExtensions = "AppliedExtensions"
        case completedAt = "CompletedAt"
        case configurationLocationUri = "ConfigurationLocationUri"
        case configurationName = "ConfigurationName"
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case eventLog = "EventLog"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case kmsKeyArn = "KmsKeyArn"
        case kmsKeyIdentifier = "KmsKeyIdentifier"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
        case versionLabel = "VersionLabel"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let deploymentNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deploymentNumber) ?? 0
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationLocationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationLocationUri)
        configurationLocationUri = configurationLocationUriDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deploymentDurationInMinutes) ?? 0
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .finalBakeTimeInMinutes) ?? 0
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.DeploymentState.self, forKey: .state)
        state = stateDecoded
        let eventLogContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.DeploymentEvent?].self, forKey: .eventLog)
        var eventLogDecoded0:[AppConfigClientTypes.DeploymentEvent]? = nil
        if let eventLogContainer = eventLogContainer {
            eventLogDecoded0 = [AppConfigClientTypes.DeploymentEvent]()
            for structure0 in eventLogContainer {
                if let structure0 = structure0 {
                    eventLogDecoded0?.append(structure0)
                }
            }
        }
        eventLog = eventLogDecoded0
        let percentageCompleteDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completedAt)
        completedAt = completedAtDecoded
        let appliedExtensionsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.AppliedExtension?].self, forKey: .appliedExtensions)
        var appliedExtensionsDecoded0:[AppConfigClientTypes.AppliedExtension]? = nil
        if let appliedExtensionsContainer = appliedExtensionsContainer {
            appliedExtensionsDecoded0 = [AppConfigClientTypes.AppliedExtension]()
            for structure0 in appliedExtensionsContainer {
                if let structure0 = structure0 {
                    appliedExtensionsDecoded0?.append(structure0)
                }
            }
        }
        appliedExtensions = appliedExtensionsDecoded0
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let versionLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionLabel)
        versionLabel = versionLabelDecoded
    }
}

enum GetDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeploymentStrategyInput {

    static func urlPathProvider(_ value: GetDeploymentStrategyInput) -> Swift.String? {
        guard let deploymentStrategyId = value.deploymentStrategyId else {
            return nil
        }
        return "/deploymentstrategies/\(deploymentStrategyId.urlPercentEncoding())"
    }
}

public struct GetDeploymentStrategyInput: Swift.Equatable {
    /// The ID of the deployment strategy to get.
    /// This member is required.
    public var deploymentStrategyId: Swift.String?

    public init(
        deploymentStrategyId: Swift.String? = nil
    )
    {
        self.deploymentStrategyId = deploymentStrategyId
    }
}

struct GetDeploymentStrategyInputBody: Swift.Equatable {
}

extension GetDeploymentStrategyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentStrategyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeploymentStrategyOutputBody = try responseDecoder.decode(responseBody: data)
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.description = output.description
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.id = output.id
            self.name = output.name
            self.replicateTo = output.replicateTo
        } else {
            self.deploymentDurationInMinutes = 0
            self.description = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = nil
            self.growthType = nil
            self.id = nil
            self.name = nil
            self.replicateTo = nil
        }
    }
}

public struct GetDeploymentStrategyOutput: Swift.Equatable {
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The description of the deployment strategy.
    public var description: Swift.String?
    /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets that received a deployed configuration during each interval.
    public var growthFactor: Swift.Float?
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The deployment strategy ID.
    public var id: Swift.String?
    /// The name of the deployment strategy.
    public var name: Swift.String?
    /// Save the deployment strategy to a Systems Manager (SSM) document.
    public var replicateTo: AppConfigClientTypes.ReplicateTo?

    public init(
        deploymentDurationInMinutes: Swift.Int = 0,
        description: Swift.String? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float? = nil,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        replicateTo: AppConfigClientTypes.ReplicateTo? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.id = id
        self.name = name
        self.replicateTo = replicateTo
    }
}

struct GetDeploymentStrategyOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int
    let growthType: AppConfigClientTypes.GrowthType?
    let growthFactor: Swift.Float?
    let finalBakeTimeInMinutes: Swift.Int
    let replicateTo: AppConfigClientTypes.ReplicateTo?
}

extension GetDeploymentStrategyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deploymentDurationInMinutes) ?? 0
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .finalBakeTimeInMinutes) ?? 0
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

enum GetDeploymentStrategyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEnvironmentInput {

    static func urlPathProvider(_ value: GetEnvironmentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())"
    }
}

public struct GetEnvironmentInput: Swift.Equatable {
    /// The ID of the application that includes the environment you want to get.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the environment that you want to get.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.environmentId = environmentId
    }
}

struct GetEnvironmentInputBody: Swift.Equatable {
}

extension GetEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.monitors = output.monitors
            self.name = output.name
            self.state = output.state
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.monitors = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct GetEnvironmentOutput: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The description of the environment.
    public var description: Swift.String?
    /// The environment ID.
    public var id: Swift.String?
    /// Amazon CloudWatch alarms monitored during the deployment.
    public var monitors: [AppConfigClientTypes.Monitor]?
    /// The name of the environment.
    public var name: Swift.String?
    /// The state of the environment. An environment can be in one of the following states: READY_FOR_DEPLOYMENT, DEPLOYING, ROLLING_BACK, or ROLLED_BACK
    public var state: AppConfigClientTypes.EnvironmentState?

    public init(
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        monitors: [AppConfigClientTypes.Monitor]? = nil,
        name: Swift.String? = nil,
        state: AppConfigClientTypes.EnvironmentState? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.monitors = monitors
        self.name = name
        self.state = state
    }
}

struct GetEnvironmentOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let state: AppConfigClientTypes.EnvironmentState?
    let monitors: [AppConfigClientTypes.Monitor]?
}

extension GetEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

enum GetEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetExtensionAssociationInput {

    static func urlPathProvider(_ value: GetExtensionAssociationInput) -> Swift.String? {
        guard let extensionAssociationId = value.extensionAssociationId else {
            return nil
        }
        return "/extensionassociations/\(extensionAssociationId.urlPercentEncoding())"
    }
}

public struct GetExtensionAssociationInput: Swift.Equatable {
    /// The extension association ID to get.
    /// This member is required.
    public var extensionAssociationId: Swift.String?

    public init(
        extensionAssociationId: Swift.String? = nil
    )
    {
        self.extensionAssociationId = extensionAssociationId
    }
}

struct GetExtensionAssociationInputBody: Swift.Equatable {
}

extension GetExtensionAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetExtensionAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetExtensionAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.extensionArn = output.extensionArn
            self.extensionVersionNumber = output.extensionVersionNumber
            self.id = output.id
            self.parameters = output.parameters
            self.resourceArn = output.resourceArn
        } else {
            self.arn = nil
            self.extensionArn = nil
            self.extensionVersionNumber = 0
            self.id = nil
            self.parameters = nil
            self.resourceArn = nil
        }
    }
}

public struct GetExtensionAssociationOutput: Swift.Equatable {
    /// The system-generated Amazon Resource Name (ARN) for the extension.
    public var arn: Swift.String?
    /// The ARN of the extension defined in the association.
    public var extensionArn: Swift.String?
    /// The version number for the extension defined in the association.
    public var extensionVersionNumber: Swift.Int
    /// The system-generated ID for the association.
    public var id: Swift.String?
    /// The parameter names and values defined in the association.
    public var parameters: [Swift.String:Swift.String]?
    /// The ARNs of applications, configuration profiles, or environments defined in the association.
    public var resourceArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        extensionArn: Swift.String? = nil,
        extensionVersionNumber: Swift.Int = 0,
        id: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.extensionArn = extensionArn
        self.extensionVersionNumber = extensionVersionNumber
        self.id = id
        self.parameters = parameters
        self.resourceArn = resourceArn
    }
}

struct GetExtensionAssociationOutputBody: Swift.Equatable {
    let id: Swift.String?
    let extensionArn: Swift.String?
    let resourceArn: Swift.String?
    let arn: Swift.String?
    let parameters: [Swift.String:Swift.String]?
    let extensionVersionNumber: Swift.Int
}

extension GetExtensionAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case extensionArn = "ExtensionArn"
        case extensionVersionNumber = "ExtensionVersionNumber"
        case id = "Id"
        case parameters = "Parameters"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let extensionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extensionArn)
        extensionArn = extensionArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and20480) in parametersContainer {
                if let stringwithlengthbetween1and20480 = stringwithlengthbetween1and20480 {
                    parametersDecoded0?[key0] = stringwithlengthbetween1and20480
                }
            }
        }
        parameters = parametersDecoded0
        let extensionVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .extensionVersionNumber) ?? 0
        extensionVersionNumber = extensionVersionNumberDecoded
    }
}

enum GetExtensionAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetExtensionInput {

    static func queryItemProvider(_ value: GetExtensionInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let versionNumber = value.versionNumber {
            let versionNumberQueryItem = ClientRuntime.SDKURLQueryItem(name: "version_number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension GetExtensionInput {

    static func urlPathProvider(_ value: GetExtensionInput) -> Swift.String? {
        guard let extensionIdentifier = value.extensionIdentifier else {
            return nil
        }
        return "/extensions/\(extensionIdentifier.urlPercentEncoding())"
    }
}

public struct GetExtensionInput: Swift.Equatable {
    /// The name, the ID, or the Amazon Resource Name (ARN) of the extension.
    /// This member is required.
    public var extensionIdentifier: Swift.String?
    /// The extension version number. If no version number was defined, AppConfig uses the highest version.
    public var versionNumber: Swift.Int?

    public init(
        extensionIdentifier: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.extensionIdentifier = extensionIdentifier
        self.versionNumber = versionNumber
    }
}

struct GetExtensionInputBody: Swift.Equatable {
}

extension GetExtensionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetExtensionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetExtensionOutputBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.arn = output.arn
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.parameters = output.parameters
            self.versionNumber = output.versionNumber
        } else {
            self.actions = nil
            self.arn = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.parameters = nil
            self.versionNumber = 0
        }
    }
}

public struct GetExtensionOutput: Swift.Equatable {
    /// The actions defined in the extension.
    public var actions: [Swift.String:[AppConfigClientTypes.Action]]?
    /// The system-generated Amazon Resource Name (ARN) for the extension.
    public var arn: Swift.String?
    /// Information about the extension.
    public var description: Swift.String?
    /// The system-generated ID of the extension.
    public var id: Swift.String?
    /// The extension name.
    public var name: Swift.String?
    /// The parameters accepted by the extension. You specify parameter values when you associate the extension to an AppConfig resource by using the CreateExtensionAssociation API action. For Lambda extension actions, these parameters are included in the Lambda request object.
    public var parameters: [Swift.String:AppConfigClientTypes.Parameter]?
    /// The extension version number.
    public var versionNumber: Swift.Int

    public init(
        actions: [Swift.String:[AppConfigClientTypes.Action]]? = nil,
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: [Swift.String:AppConfigClientTypes.Parameter]? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.actions = actions
        self.arn = arn
        self.description = description
        self.id = id
        self.name = name
        self.parameters = parameters
        self.versionNumber = versionNumber
    }
}

struct GetExtensionOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let versionNumber: Swift.Int
    let arn: Swift.String?
    let description: Swift.String?
    let actions: [Swift.String:[AppConfigClientTypes.Action]]?
    let parameters: [Swift.String:AppConfigClientTypes.Parameter]?
}

extension GetExtensionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case parameters = "Parameters"
        case versionNumber = "VersionNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber) ?? 0
        versionNumber = versionNumberDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: [AppConfigClientTypes.Action?]?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:[AppConfigClientTypes.Action]]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:[AppConfigClientTypes.Action]]()
            for (key0, actionlist0) in actionsContainer {
                var actionlist0Decoded0: [AppConfigClientTypes.Action]? = nil
                if let actionlist0 = actionlist0 {
                    actionlist0Decoded0 = [AppConfigClientTypes.Action]()
                    for structure1 in actionlist0 {
                        if let structure1 = structure1 {
                            actionlist0Decoded0?.append(structure1)
                        }
                    }
                }
                actionsDecoded0?[key0] = actionlist0Decoded0
            }
        }
        actions = actionsDecoded0
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: AppConfigClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:AppConfigClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:AppConfigClientTypes.Parameter]()
            for (key0, parameter0) in parametersContainer {
                if let parameter0 = parameter0 {
                    parametersDecoded0?[key0] = parameter0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

enum GetExtensionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetHostedConfigurationVersionInput {

    static func urlPathProvider(_ value: GetHostedConfigurationVersionInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let configurationProfileId = value.configurationProfileId else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())/hostedconfigurationversions/\(versionNumber)"
    }
}

public struct GetHostedConfigurationVersionInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The version.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.versionNumber = versionNumber
    }
}

struct GetHostedConfigurationVersionInputBody: Swift.Equatable {
}

extension GetHostedConfigurationVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetHostedConfigurationVersionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetHostedConfigurationVersionOutput(applicationId: \(Swift.String(describing: applicationId)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), contentType: \(Swift.String(describing: contentType)), description: \(Swift.String(describing: description)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), versionLabel: \(Swift.String(describing: versionLabel)), versionNumber: \(Swift.String(describing: versionNumber)), content: \"CONTENT_REDACTED\")"}
}

extension GetHostedConfigurationVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let applicationIdHeaderValue = httpResponse.headers.value(for: "Application-Id") {
            self.applicationId = applicationIdHeaderValue
        } else {
            self.applicationId = nil
        }
        if let configurationProfileIdHeaderValue = httpResponse.headers.value(for: "Configuration-Profile-Id") {
            self.configurationProfileId = configurationProfileIdHeaderValue
        } else {
            self.configurationProfileId = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let descriptionHeaderValue = httpResponse.headers.value(for: "Description") {
            self.description = descriptionHeaderValue
        } else {
            self.description = nil
        }
        if let kmsKeyArnHeaderValue = httpResponse.headers.value(for: "KmsKeyArn") {
            self.kmsKeyArn = kmsKeyArnHeaderValue
        } else {
            self.kmsKeyArn = nil
        }
        if let versionLabelHeaderValue = httpResponse.headers.value(for: "VersionLabel") {
            self.versionLabel = versionLabelHeaderValue
        } else {
            self.versionLabel = nil
        }
        if let versionNumberHeaderValue = httpResponse.headers.value(for: "Version-Number") {
            self.versionNumber = Swift.Int(versionNumberHeaderValue) ?? 0
        } else {
            self.versionNumber = 0
        }
        switch httpResponse.body {
        case .data(let data):
            self.content = data
        case .stream(let stream):
            self.content = try stream.readToEnd()
        case .noStream:
            self.content = nil
        }
    }
}

public struct GetHostedConfigurationVersionOutput: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    public var configurationProfileId: Swift.String?
    /// The content of the configuration or the configuration data.
    public var content: ClientRuntime.Data?
    /// A standard MIME type describing the format of the configuration content. For more information, see [Content-Type](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17).
    public var contentType: Swift.String?
    /// A description of the configuration.
    public var description: Swift.String?
    /// The Amazon Resource Name of the Key Management Service key that was used to encrypt this specific version of the configuration data in the AppConfig hosted configuration store.
    public var kmsKeyArn: Swift.String?
    /// A user-defined label for an AppConfig hosted configuration version.
    public var versionLabel: Swift.String?
    /// The configuration version.
    public var versionNumber: Swift.Int

    public init(
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        content: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        versionLabel: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.content = content
        self.contentType = contentType
        self.description = description
        self.kmsKeyArn = kmsKeyArn
        self.versionLabel = versionLabel
        self.versionNumber = versionNumber
    }
}

struct GetHostedConfigurationVersionOutputBody: Swift.Equatable {
    let content: ClientRuntime.Data?
}

extension GetHostedConfigurationVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
    }
}

enum GetHostedConfigurationVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppConfigClientTypes {
    public enum GrowthType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case exponential
        case linear
        case sdkUnknown(Swift.String)

        public static var allCases: [GrowthType] {
            return [
                .exponential,
                .linear,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .exponential: return "EXPONENTIAL"
            case .linear: return "LINEAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GrowthType(rawValue: rawValue) ?? GrowthType.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes.HostedConfigurationVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case configurationProfileId = "ConfigurationProfileId"
        case contentType = "ContentType"
        case description = "Description"
        case kmsKeyArn = "KmsKeyArn"
        case versionLabel = "VersionLabel"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let configurationProfileId = self.configurationProfileId {
            try encodeContainer.encode(configurationProfileId, forKey: .configurationProfileId)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let versionLabel = self.versionLabel {
            try encodeContainer.encode(versionLabel, forKey: .versionLabel)
        }
        if versionNumber != 0 {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber) ?? 0
        versionNumber = versionNumberDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let versionLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionLabel)
        versionLabel = versionLabelDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension AppConfigClientTypes {
    /// Information about the configuration.
    public struct HostedConfigurationVersionSummary: Swift.Equatable {
        /// The application ID.
        public var applicationId: Swift.String?
        /// The configuration profile ID.
        public var configurationProfileId: Swift.String?
        /// A standard MIME type describing the format of the configuration content. For more information, see [Content-Type](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17).
        public var contentType: Swift.String?
        /// A description of the configuration.
        public var description: Swift.String?
        /// The Amazon Resource Name of the Key Management Service key that was used to encrypt this specific version of the configuration data in the AppConfig hosted configuration store.
        public var kmsKeyArn: Swift.String?
        /// A user-defined label for an AppConfig hosted configuration version.
        public var versionLabel: Swift.String?
        /// The configuration version.
        public var versionNumber: Swift.Int

        public init(
            applicationId: Swift.String? = nil,
            configurationProfileId: Swift.String? = nil,
            contentType: Swift.String? = nil,
            description: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            versionLabel: Swift.String? = nil,
            versionNumber: Swift.Int = 0
        )
        {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
            self.contentType = contentType
            self.description = description
            self.kmsKeyArn = kmsKeyArn
            self.versionLabel = versionLabel
            self.versionNumber = versionNumber
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an internal failure in the AppConfig service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppConfigClientTypes.InvalidConfigurationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraint = "Constraint"
        case location = "Location"
        case reason = "Reason"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constraint = self.constraint {
            try encodeContainer.encode(constraint, forKey: .constraint)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constraint)
        constraint = constraintDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AppConfigClientTypes {
    /// Detailed information about the bad request exception error when creating a hosted configuration version.
    public struct InvalidConfigurationDetail: Swift.Equatable {
        /// The invalid or out-of-range validation constraint in your JSON schema that failed validation.
        public var constraint: Swift.String?
        /// Location of the validation constraint in the configuration JSON schema that failed validation.
        public var location: Swift.String?
        /// The reason for an invalid configuration error.
        public var reason: Swift.String?
        /// The type of error for an invalid configuration.
        public var type: Swift.String?
        /// Details about an error with Lambda when a synchronous extension experiences an error during an invocation.
        public var value: Swift.String?

        public init(
            constraint: Swift.String? = nil,
            location: Swift.String? = nil,
            reason: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.constraint = constraint
            self.location = location
            self.reason = reason
            self.type = type
            self.value = value
        }
    }

}

extension ListApplicationsInput {

    static func queryItemProvider(_ value: ListApplicationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListApplicationsInput {

    static func urlPathProvider(_ value: ListApplicationsInput) -> Swift.String? {
        return "/applications"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Next token is a pagination token generated by AppConfig to describe what page the previous List call ended on. For the first List request, the nextToken should not be set. On subsequent calls, the nextToken parameter should be set to the previous responses nextToken value. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
}

extension ListApplicationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.Application]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [AppConfigClientTypes.Application]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputBody: Swift.Equatable {
    let items: [AppConfigClientTypes.Application]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Application?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.Application]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.Application]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConfigurationProfilesInput {

    static func queryItemProvider(_ value: ListConfigurationProfilesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let type = value.type {
            let typeQueryItem = ClientRuntime.SDKURLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConfigurationProfilesInput {

    static func urlPathProvider(_ value: ListConfigurationProfilesInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles"
    }
}

public struct ListConfigurationProfilesInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A filter based on the type of configurations that the configuration profile contains. A configuration can be a feature flag or a freeform configuration.
    public var type: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListConfigurationProfilesInputBody: Swift.Equatable {
}

extension ListConfigurationProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConfigurationProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationProfilesOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.ConfigurationProfileSummary]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [AppConfigClientTypes.ConfigurationProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListConfigurationProfilesOutputBody: Swift.Equatable {
    let items: [AppConfigClientTypes.ConfigurationProfileSummary]?
    let nextToken: Swift.String?
}

extension ListConfigurationProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.ConfigurationProfileSummary?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.ConfigurationProfileSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.ConfigurationProfileSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListConfigurationProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDeploymentStrategiesInput {

    static func queryItemProvider(_ value: ListDeploymentStrategiesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDeploymentStrategiesInput {

    static func urlPathProvider(_ value: ListDeploymentStrategiesInput) -> Swift.String? {
        return "/deploymentstrategies"
    }
}

public struct ListDeploymentStrategiesInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentStrategiesInputBody: Swift.Equatable {
}

extension ListDeploymentStrategiesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDeploymentStrategiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDeploymentStrategiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentStrategiesOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.DeploymentStrategy]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [AppConfigClientTypes.DeploymentStrategy]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDeploymentStrategiesOutputBody: Swift.Equatable {
    let items: [AppConfigClientTypes.DeploymentStrategy]?
    let nextToken: Swift.String?
}

extension ListDeploymentStrategiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.DeploymentStrategy?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.DeploymentStrategy]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.DeploymentStrategy]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDeploymentStrategiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDeploymentsInput {

    static func queryItemProvider(_ value: ListDeploymentsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDeploymentsInput {

    static func urlPathProvider(_ value: ListDeploymentsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())/deployments"
    }
}

public struct ListDeploymentsInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The environment ID.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of items that may be returned for this call. If there are items that have not yet been returned, the response will include a non-null NextToken that you can provide in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token returned by a prior call to this operation indicating the next set of results to be returned. If not specified, the operation will return the first set of results.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentsInputBody: Swift.Equatable {
}

extension ListDeploymentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDeploymentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDeploymentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentsOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.DeploymentSummary]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [AppConfigClientTypes.DeploymentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDeploymentsOutputBody: Swift.Equatable {
    let items: [AppConfigClientTypes.DeploymentSummary]?
    let nextToken: Swift.String?
}

extension ListDeploymentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.DeploymentSummary?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.DeploymentSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.DeploymentSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDeploymentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnvironmentsInput {

    static func queryItemProvider(_ value: ListEnvironmentsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEnvironmentsInput {

    static func urlPathProvider(_ value: ListEnvironmentsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments"
    }
}

public struct ListEnvironmentsInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Swift.Equatable {
}

extension ListEnvironmentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.Environment]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [AppConfigClientTypes.Environment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputBody: Swift.Equatable {
    let items: [AppConfigClientTypes.Environment]?
    let nextToken: Swift.String?
}

extension ListEnvironmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Environment?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.Environment]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.Environment]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnvironmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListExtensionAssociationsInput {

    static func queryItemProvider(_ value: ListExtensionAssociationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let resourceIdentifier = value.resourceIdentifier {
            let resourceIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "resource_identifier".urlPercentEncoding(), value: Swift.String(resourceIdentifier).urlPercentEncoding())
            items.append(resourceIdentifierQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let extensionIdentifier = value.extensionIdentifier {
            let extensionIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "extension_identifier".urlPercentEncoding(), value: Swift.String(extensionIdentifier).urlPercentEncoding())
            items.append(extensionIdentifierQueryItem)
        }
        if let extensionVersionNumber = value.extensionVersionNumber {
            let extensionVersionNumberQueryItem = ClientRuntime.SDKURLQueryItem(name: "extension_version_number".urlPercentEncoding(), value: Swift.String(extensionVersionNumber).urlPercentEncoding())
            items.append(extensionVersionNumberQueryItem)
        }
        return items
    }
}

extension ListExtensionAssociationsInput {

    static func urlPathProvider(_ value: ListExtensionAssociationsInput) -> Swift.String? {
        return "/extensionassociations"
    }
}

public struct ListExtensionAssociationsInput: Swift.Equatable {
    /// The name, the ID, or the Amazon Resource Name (ARN) of the extension.
    public var extensionIdentifier: Swift.String?
    /// The version number for the extension defined in the association.
    public var extensionVersionNumber: Swift.Int?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results or pass null to get the first set of results.
    public var nextToken: Swift.String?
    /// The ARN of an application, configuration profile, or environment.
    public var resourceIdentifier: Swift.String?

    public init(
        extensionIdentifier: Swift.String? = nil,
        extensionVersionNumber: Swift.Int? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.extensionIdentifier = extensionIdentifier
        self.extensionVersionNumber = extensionVersionNumber
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
    }
}

struct ListExtensionAssociationsInputBody: Swift.Equatable {
}

extension ListExtensionAssociationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListExtensionAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExtensionAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListExtensionAssociationsOutput: Swift.Equatable {
    /// The list of extension associations. Each item represents an extension association to an application, environment, or configuration profile.
    public var items: [AppConfigClientTypes.ExtensionAssociationSummary]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [AppConfigClientTypes.ExtensionAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListExtensionAssociationsOutputBody: Swift.Equatable {
    let items: [AppConfigClientTypes.ExtensionAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListExtensionAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.ExtensionAssociationSummary?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.ExtensionAssociationSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.ExtensionAssociationSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListExtensionAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListExtensionsInput {

    static func queryItemProvider(_ value: ListExtensionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = ClientRuntime.SDKURLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        return items
    }
}

extension ListExtensionsInput {

    static func urlPathProvider(_ value: ListExtensionsInput) -> Swift.String? {
        return "/extensions"
    }
}

public struct ListExtensionsInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The extension name.
    public var name: Swift.String?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListExtensionsInputBody: Swift.Equatable {
}

extension ListExtensionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListExtensionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExtensionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListExtensionsOutput: Swift.Equatable {
    /// The list of available extensions. The list includes Amazon Web Services authored and user-created extensions.
    public var items: [AppConfigClientTypes.ExtensionSummary]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [AppConfigClientTypes.ExtensionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListExtensionsOutputBody: Swift.Equatable {
    let items: [AppConfigClientTypes.ExtensionSummary]?
    let nextToken: Swift.String?
}

extension ListExtensionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.ExtensionSummary?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.ExtensionSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.ExtensionSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListExtensionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListHostedConfigurationVersionsInput {

    static func queryItemProvider(_ value: ListHostedConfigurationVersionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let versionLabel = value.versionLabel {
            let versionLabelQueryItem = ClientRuntime.SDKURLQueryItem(name: "version_label".urlPercentEncoding(), value: Swift.String(versionLabel).urlPercentEncoding())
            items.append(versionLabelQueryItem)
        }
        return items
    }
}

extension ListHostedConfigurationVersionsInput {

    static func urlPathProvider(_ value: ListHostedConfigurationVersionsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let configurationProfileId = value.configurationProfileId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())/hostedconfigurationversions"
    }
}

public struct ListHostedConfigurationVersionsInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// An optional filter that can be used to specify the version label of an AppConfig hosted configuration version. This parameter supports filtering by prefix using a wildcard, for example "v2*". If you don't specify an asterisk at the end of the value, only an exact match is returned.
    public var versionLabel: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        versionLabel: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.versionLabel = versionLabel
    }
}

struct ListHostedConfigurationVersionsInputBody: Swift.Equatable {
}

extension ListHostedConfigurationVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListHostedConfigurationVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListHostedConfigurationVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListHostedConfigurationVersionsOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.HostedConfigurationVersionSummary]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [AppConfigClientTypes.HostedConfigurationVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListHostedConfigurationVersionsOutputBody: Swift.Equatable {
    let items: [AppConfigClientTypes.HostedConfigurationVersionSummary]?
    let nextToken: Swift.String?
}

extension ListHostedConfigurationVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.HostedConfigurationVersionSummary?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.HostedConfigurationVersionSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.HostedConfigurationVersionSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListHostedConfigurationVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Metadata to assign to AppConfig resources. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppConfigClientTypes.Monitor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmArn = "AlarmArn"
        case alarmRoleArn = "AlarmRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmArn = self.alarmArn {
            try encodeContainer.encode(alarmArn, forKey: .alarmArn)
        }
        if let alarmRoleArn = self.alarmRoleArn {
            try encodeContainer.encode(alarmRoleArn, forKey: .alarmRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmArn)
        alarmArn = alarmArnDecoded
        let alarmRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmRoleArn)
        alarmRoleArn = alarmRoleArnDecoded
    }
}

extension AppConfigClientTypes {
    /// Amazon CloudWatch alarms to monitor during the deployment process.
    public struct Monitor: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the Amazon CloudWatch alarm.
        /// This member is required.
        public var alarmArn: Swift.String?
        /// ARN of an Identity and Access Management (IAM) role for AppConfig to monitor AlarmArn.
        public var alarmRoleArn: Swift.String?

        public init(
            alarmArn: Swift.String? = nil,
            alarmRoleArn: Swift.String? = nil
        )
        {
            self.alarmArn = alarmArn
            self.alarmRoleArn = alarmRoleArn
        }
    }

}

extension AppConfigClientTypes.Parameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case `required` = "Required"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if `required` != false {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required) ?? false
        `required` = requiredDecoded
    }
}

extension AppConfigClientTypes {
    /// A value such as an Amazon Resource Name (ARN) or an Amazon Simple Notification Service topic entered in an extension when invoked. Parameter values are specified in an extension association. For more information about extensions, see [Working with AppConfig extensions](https://docs.aws.amazon.com/appconfig/latest/userguide/working-with-appconfig-extensions.html) in the AppConfig User Guide.
    public struct Parameter: Swift.Equatable {
        /// Information about the parameter.
        public var description: Swift.String?
        /// A parameter value must be specified in the extension association.
        public var `required`: Swift.Bool

        public init(
            description: Swift.String? = nil,
            `required`: Swift.Bool = false
        )
        {
            self.description = description
            self.`required` = `required`
        }
    }

}

extension PayloadTooLargeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PayloadTooLargeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.limit = output.limit
            self.properties.measure = output.measure
            self.properties.message = output.message
            self.properties.size = output.size
        } else {
            self.properties.limit = 0.0
            self.properties.measure = nil
            self.properties.message = nil
            self.properties.size = 0.0
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The configuration size is too large.
public struct PayloadTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var limit: Swift.Float = 0.0
        public internal(set) var measure: AppConfigClientTypes.BytesMeasure? = nil
        public internal(set) var message: Swift.String? = nil
        public internal(set) var size: Swift.Float = 0.0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PayloadTooLargeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limit: Swift.Float = 0.0,
        measure: AppConfigClientTypes.BytesMeasure? = nil,
        message: Swift.String? = nil,
        size: Swift.Float = 0.0
    )
    {
        self.properties.limit = limit
        self.properties.measure = measure
        self.properties.message = message
        self.properties.size = size
    }
}

struct PayloadTooLargeExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let measure: AppConfigClientTypes.BytesMeasure?
    let limit: Swift.Float
    let size: Swift.Float
}

extension PayloadTooLargeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case measure = "Measure"
        case message = "Message"
        case size = "Size"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let measureDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.BytesMeasure.self, forKey: .measure)
        measure = measureDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .limit) ?? 0.0
        limit = limitDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .size) ?? 0.0
        size = sizeDecoded
    }
}

extension AppConfigClientTypes {
    public enum ReplicateTo: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case ssmDocument
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicateTo] {
            return [
                .none,
                .ssmDocument,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .ssmDocument: return "SSM_DOCUMENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicateTo(rawValue: rawValue) ?? ReplicateTo.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of one more AppConfig resources exceeds the maximum allowed. Verify that your environment doesn't exceed the following service quotas: Applications: 100 max Deployment strategies: 20 max Configuration profiles: 100 max per application Environments: 20 max per application To resolve this issue, you can delete one or more resources and try again. Or, you can request a quota increase. For more information about quotas and to request an increase, see [Service quotas for AppConfig](https://docs.aws.amazon.com/general/latest/gr/appconfig.html#limits_appconfig) in the Amazon Web Services General Reference.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case kmsKeyIdentifier = "KmsKeyIdentifier"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationProfileId = self.configurationProfileId {
            try encodeContainer.encode(configurationProfileId, forKey: .configurationProfileId)
        }
        if let configurationVersion = self.configurationVersion {
            try encodeContainer.encode(configurationVersion, forKey: .configurationVersion)
        }
        if let deploymentStrategyId = self.deploymentStrategyId {
            try encodeContainer.encode(deploymentStrategyId, forKey: .deploymentStrategyId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyIdentifier = self.kmsKeyIdentifier {
            try encodeContainer.encode(kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartDeploymentInput {

    static func urlPathProvider(_ value: StartDeploymentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())/deployments"
    }
}

public struct StartDeploymentInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The configuration version to deploy. If deploying an AppConfig hosted configuration version, you can specify either the version number or version label. For all other configurations, you must specify the version number.
    /// This member is required.
    public var configurationVersion: Swift.String?
    /// The deployment strategy ID.
    /// This member is required.
    public var deploymentStrategyId: Swift.String?
    /// A description of the deployment.
    public var description: Swift.String?
    /// The environment ID.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The KMS key identifier (key ID, key alias, or key ARN). AppConfig uses this ID to encrypt the configuration data using a customer managed key.
    public var kmsKeyIdentifier: Swift.String?
    /// Metadata to assign to the deployment. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
    public var tags: [Swift.String:Swift.String]?

    public init(
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        configurationVersion: Swift.String? = nil,
        deploymentStrategyId: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.tags = tags
    }
}

struct StartDeploymentInputBody: Swift.Equatable {
    let deploymentStrategyId: Swift.String?
    let configurationProfileId: Swift.String?
    let configurationVersion: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let kmsKeyIdentifier: Swift.String?
}

extension StartDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case kmsKeyIdentifier = "KmsKeyIdentifier"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

extension StartDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.appliedExtensions = output.appliedExtensions
            self.completedAt = output.completedAt
            self.configurationLocationUri = output.configurationLocationUri
            self.configurationName = output.configurationName
            self.configurationProfileId = output.configurationProfileId
            self.configurationVersion = output.configurationVersion
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.deploymentNumber = output.deploymentNumber
            self.deploymentStrategyId = output.deploymentStrategyId
            self.description = output.description
            self.environmentId = output.environmentId
            self.eventLog = output.eventLog
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.kmsKeyArn = output.kmsKeyArn
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.percentageComplete = output.percentageComplete
            self.startedAt = output.startedAt
            self.state = output.state
            self.versionLabel = output.versionLabel
        } else {
            self.applicationId = nil
            self.appliedExtensions = nil
            self.completedAt = nil
            self.configurationLocationUri = nil
            self.configurationName = nil
            self.configurationProfileId = nil
            self.configurationVersion = nil
            self.deploymentDurationInMinutes = 0
            self.deploymentNumber = 0
            self.deploymentStrategyId = nil
            self.description = nil
            self.environmentId = nil
            self.eventLog = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = nil
            self.growthType = nil
            self.kmsKeyArn = nil
            self.kmsKeyIdentifier = nil
            self.percentageComplete = nil
            self.startedAt = nil
            self.state = nil
            self.versionLabel = nil
        }
    }
}

public struct StartDeploymentOutput: Swift.Equatable {
    /// The ID of the application that was deployed.
    public var applicationId: Swift.String?
    /// A list of extensions that were processed as part of the deployment. The extensions that were previously associated to the configuration profile, environment, or the application when StartDeployment was called.
    public var appliedExtensions: [AppConfigClientTypes.AppliedExtension]?
    /// The time the deployment completed.
    public var completedAt: ClientRuntime.Date?
    /// Information about the source location of the configuration.
    public var configurationLocationUri: Swift.String?
    /// The name of the configuration.
    public var configurationName: Swift.String?
    /// The ID of the configuration profile that was deployed.
    public var configurationProfileId: Swift.String?
    /// The configuration version that was deployed.
    public var configurationVersion: Swift.String?
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The sequence number of the deployment.
    public var deploymentNumber: Swift.Int
    /// The ID of the deployment strategy that was deployed.
    public var deploymentStrategyId: Swift.String?
    /// The description of the deployment.
    public var description: Swift.String?
    /// The ID of the environment that was deployed.
    public var environmentId: Swift.String?
    /// A list containing all events related to a deployment. The most recent events are displayed first.
    public var eventLog: [AppConfigClientTypes.DeploymentEvent]?
    /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets to receive a deployed configuration during each interval.
    public var growthFactor: Swift.Float?
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The Amazon Resource Name of the Key Management Service key used to encrypt configuration data. You can encrypt secrets stored in Secrets Manager, Amazon Simple Storage Service (Amazon S3) objects encrypted with SSE-KMS, or secure string parameters stored in Amazon Web Services Systems Manager Parameter Store.
    public var kmsKeyArn: Swift.String?
    /// The Key Management Service key identifier (key ID, key alias, or key ARN) provided when the resource was created or updated.
    public var kmsKeyIdentifier: Swift.String?
    /// The percentage of targets for which the deployment is available.
    public var percentageComplete: Swift.Float?
    /// The time the deployment started.
    public var startedAt: ClientRuntime.Date?
    /// The state of the deployment.
    public var state: AppConfigClientTypes.DeploymentState?
    /// A user-defined label for an AppConfig hosted configuration version.
    public var versionLabel: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        appliedExtensions: [AppConfigClientTypes.AppliedExtension]? = nil,
        completedAt: ClientRuntime.Date? = nil,
        configurationLocationUri: Swift.String? = nil,
        configurationName: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        configurationVersion: Swift.String? = nil,
        deploymentDurationInMinutes: Swift.Int = 0,
        deploymentNumber: Swift.Int = 0,
        deploymentStrategyId: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        eventLog: [AppConfigClientTypes.DeploymentEvent]? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float? = nil,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        kmsKeyArn: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        percentageComplete: Swift.Float? = nil,
        startedAt: ClientRuntime.Date? = nil,
        state: AppConfigClientTypes.DeploymentState? = nil,
        versionLabel: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.appliedExtensions = appliedExtensions
        self.completedAt = completedAt
        self.configurationLocationUri = configurationLocationUri
        self.configurationName = configurationName
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentNumber = deploymentNumber
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.eventLog = eventLog
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.kmsKeyArn = kmsKeyArn
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.percentageComplete = percentageComplete
        self.startedAt = startedAt
        self.state = state
        self.versionLabel = versionLabel
    }
}

struct StartDeploymentOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let environmentId: Swift.String?
    let deploymentStrategyId: Swift.String?
    let configurationProfileId: Swift.String?
    let deploymentNumber: Swift.Int
    let configurationName: Swift.String?
    let configurationLocationUri: Swift.String?
    let configurationVersion: Swift.String?
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int
    let growthType: AppConfigClientTypes.GrowthType?
    let growthFactor: Swift.Float?
    let finalBakeTimeInMinutes: Swift.Int
    let state: AppConfigClientTypes.DeploymentState?
    let eventLog: [AppConfigClientTypes.DeploymentEvent]?
    let percentageComplete: Swift.Float?
    let startedAt: ClientRuntime.Date?
    let completedAt: ClientRuntime.Date?
    let appliedExtensions: [AppConfigClientTypes.AppliedExtension]?
    let kmsKeyArn: Swift.String?
    let kmsKeyIdentifier: Swift.String?
    let versionLabel: Swift.String?
}

extension StartDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case appliedExtensions = "AppliedExtensions"
        case completedAt = "CompletedAt"
        case configurationLocationUri = "ConfigurationLocationUri"
        case configurationName = "ConfigurationName"
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case eventLog = "EventLog"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case kmsKeyArn = "KmsKeyArn"
        case kmsKeyIdentifier = "KmsKeyIdentifier"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
        case versionLabel = "VersionLabel"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let deploymentNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deploymentNumber) ?? 0
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationLocationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationLocationUri)
        configurationLocationUri = configurationLocationUriDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deploymentDurationInMinutes) ?? 0
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .finalBakeTimeInMinutes) ?? 0
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.DeploymentState.self, forKey: .state)
        state = stateDecoded
        let eventLogContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.DeploymentEvent?].self, forKey: .eventLog)
        var eventLogDecoded0:[AppConfigClientTypes.DeploymentEvent]? = nil
        if let eventLogContainer = eventLogContainer {
            eventLogDecoded0 = [AppConfigClientTypes.DeploymentEvent]()
            for structure0 in eventLogContainer {
                if let structure0 = structure0 {
                    eventLogDecoded0?.append(structure0)
                }
            }
        }
        eventLog = eventLogDecoded0
        let percentageCompleteDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completedAt)
        completedAt = completedAtDecoded
        let appliedExtensionsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.AppliedExtension?].self, forKey: .appliedExtensions)
        var appliedExtensionsDecoded0:[AppConfigClientTypes.AppliedExtension]? = nil
        if let appliedExtensionsContainer = appliedExtensionsContainer {
            appliedExtensionsDecoded0 = [AppConfigClientTypes.AppliedExtension]()
            for structure0 in appliedExtensionsContainer {
                if let structure0 = structure0 {
                    appliedExtensionsDecoded0?.append(structure0)
                }
            }
        }
        appliedExtensions = appliedExtensionsDecoded0
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let versionLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionLabel)
        versionLabel = versionLabelDecoded
    }
}

enum StartDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopDeploymentInput {

    static func urlPathProvider(_ value: StopDeploymentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let environmentId = value.environmentId else {
            return nil
        }
        guard let deploymentNumber = value.deploymentNumber else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())/deployments/\(deploymentNumber)"
    }
}

public struct StopDeploymentInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The sequence number of the deployment.
    /// This member is required.
    public var deploymentNumber: Swift.Int?
    /// The environment ID.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        deploymentNumber: Swift.Int? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.deploymentNumber = deploymentNumber
        self.environmentId = environmentId
    }
}

struct StopDeploymentInputBody: Swift.Equatable {
}

extension StopDeploymentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.appliedExtensions = output.appliedExtensions
            self.completedAt = output.completedAt
            self.configurationLocationUri = output.configurationLocationUri
            self.configurationName = output.configurationName
            self.configurationProfileId = output.configurationProfileId
            self.configurationVersion = output.configurationVersion
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.deploymentNumber = output.deploymentNumber
            self.deploymentStrategyId = output.deploymentStrategyId
            self.description = output.description
            self.environmentId = output.environmentId
            self.eventLog = output.eventLog
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.kmsKeyArn = output.kmsKeyArn
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.percentageComplete = output.percentageComplete
            self.startedAt = output.startedAt
            self.state = output.state
            self.versionLabel = output.versionLabel
        } else {
            self.applicationId = nil
            self.appliedExtensions = nil
            self.completedAt = nil
            self.configurationLocationUri = nil
            self.configurationName = nil
            self.configurationProfileId = nil
            self.configurationVersion = nil
            self.deploymentDurationInMinutes = 0
            self.deploymentNumber = 0
            self.deploymentStrategyId = nil
            self.description = nil
            self.environmentId = nil
            self.eventLog = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = nil
            self.growthType = nil
            self.kmsKeyArn = nil
            self.kmsKeyIdentifier = nil
            self.percentageComplete = nil
            self.startedAt = nil
            self.state = nil
            self.versionLabel = nil
        }
    }
}

public struct StopDeploymentOutput: Swift.Equatable {
    /// The ID of the application that was deployed.
    public var applicationId: Swift.String?
    /// A list of extensions that were processed as part of the deployment. The extensions that were previously associated to the configuration profile, environment, or the application when StartDeployment was called.
    public var appliedExtensions: [AppConfigClientTypes.AppliedExtension]?
    /// The time the deployment completed.
    public var completedAt: ClientRuntime.Date?
    /// Information about the source location of the configuration.
    public var configurationLocationUri: Swift.String?
    /// The name of the configuration.
    public var configurationName: Swift.String?
    /// The ID of the configuration profile that was deployed.
    public var configurationProfileId: Swift.String?
    /// The configuration version that was deployed.
    public var configurationVersion: Swift.String?
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The sequence number of the deployment.
    public var deploymentNumber: Swift.Int
    /// The ID of the deployment strategy that was deployed.
    public var deploymentStrategyId: Swift.String?
    /// The description of the deployment.
    public var description: Swift.String?
    /// The ID of the environment that was deployed.
    public var environmentId: Swift.String?
    /// A list containing all events related to a deployment. The most recent events are displayed first.
    public var eventLog: [AppConfigClientTypes.DeploymentEvent]?
    /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets to receive a deployed configuration during each interval.
    public var growthFactor: Swift.Float?
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The Amazon Resource Name of the Key Management Service key used to encrypt configuration data. You can encrypt secrets stored in Secrets Manager, Amazon Simple Storage Service (Amazon S3) objects encrypted with SSE-KMS, or secure string parameters stored in Amazon Web Services Systems Manager Parameter Store.
    public var kmsKeyArn: Swift.String?
    /// The Key Management Service key identifier (key ID, key alias, or key ARN) provided when the resource was created or updated.
    public var kmsKeyIdentifier: Swift.String?
    /// The percentage of targets for which the deployment is available.
    public var percentageComplete: Swift.Float?
    /// The time the deployment started.
    public var startedAt: ClientRuntime.Date?
    /// The state of the deployment.
    public var state: AppConfigClientTypes.DeploymentState?
    /// A user-defined label for an AppConfig hosted configuration version.
    public var versionLabel: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        appliedExtensions: [AppConfigClientTypes.AppliedExtension]? = nil,
        completedAt: ClientRuntime.Date? = nil,
        configurationLocationUri: Swift.String? = nil,
        configurationName: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        configurationVersion: Swift.String? = nil,
        deploymentDurationInMinutes: Swift.Int = 0,
        deploymentNumber: Swift.Int = 0,
        deploymentStrategyId: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        eventLog: [AppConfigClientTypes.DeploymentEvent]? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float? = nil,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        kmsKeyArn: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        percentageComplete: Swift.Float? = nil,
        startedAt: ClientRuntime.Date? = nil,
        state: AppConfigClientTypes.DeploymentState? = nil,
        versionLabel: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.appliedExtensions = appliedExtensions
        self.completedAt = completedAt
        self.configurationLocationUri = configurationLocationUri
        self.configurationName = configurationName
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentNumber = deploymentNumber
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.eventLog = eventLog
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.kmsKeyArn = kmsKeyArn
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.percentageComplete = percentageComplete
        self.startedAt = startedAt
        self.state = state
        self.versionLabel = versionLabel
    }
}

struct StopDeploymentOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let environmentId: Swift.String?
    let deploymentStrategyId: Swift.String?
    let configurationProfileId: Swift.String?
    let deploymentNumber: Swift.Int
    let configurationName: Swift.String?
    let configurationLocationUri: Swift.String?
    let configurationVersion: Swift.String?
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int
    let growthType: AppConfigClientTypes.GrowthType?
    let growthFactor: Swift.Float?
    let finalBakeTimeInMinutes: Swift.Int
    let state: AppConfigClientTypes.DeploymentState?
    let eventLog: [AppConfigClientTypes.DeploymentEvent]?
    let percentageComplete: Swift.Float?
    let startedAt: ClientRuntime.Date?
    let completedAt: ClientRuntime.Date?
    let appliedExtensions: [AppConfigClientTypes.AppliedExtension]?
    let kmsKeyArn: Swift.String?
    let kmsKeyIdentifier: Swift.String?
    let versionLabel: Swift.String?
}

extension StopDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case appliedExtensions = "AppliedExtensions"
        case completedAt = "CompletedAt"
        case configurationLocationUri = "ConfigurationLocationUri"
        case configurationName = "ConfigurationName"
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case eventLog = "EventLog"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case kmsKeyArn = "KmsKeyArn"
        case kmsKeyIdentifier = "KmsKeyIdentifier"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
        case versionLabel = "VersionLabel"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let deploymentNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deploymentNumber) ?? 0
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationLocationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationLocationUri)
        configurationLocationUri = configurationLocationUriDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deploymentDurationInMinutes) ?? 0
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .finalBakeTimeInMinutes) ?? 0
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.DeploymentState.self, forKey: .state)
        state = stateDecoded
        let eventLogContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.DeploymentEvent?].self, forKey: .eventLog)
        var eventLogDecoded0:[AppConfigClientTypes.DeploymentEvent]? = nil
        if let eventLogContainer = eventLogContainer {
            eventLogDecoded0 = [AppConfigClientTypes.DeploymentEvent]()
            for structure0 in eventLogContainer {
                if let structure0 = structure0 {
                    eventLogDecoded0?.append(structure0)
                }
            }
        }
        eventLog = eventLogDecoded0
        let percentageCompleteDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completedAt)
        completedAt = completedAtDecoded
        let appliedExtensionsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.AppliedExtension?].self, forKey: .appliedExtensions)
        var appliedExtensionsDecoded0:[AppConfigClientTypes.AppliedExtension]? = nil
        if let appliedExtensionsContainer = appliedExtensionsContainer {
            appliedExtensionsDecoded0 = [AppConfigClientTypes.AppliedExtension]()
            for structure0 in appliedExtensionsContainer {
                if let structure0 = structure0 {
                    appliedExtensionsDecoded0?.append(structure0)
                }
            }
        }
        appliedExtensions = appliedExtensionsDecoded0
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let versionLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionLabel)
        versionLabel = versionLabelDecoded
    }
}

enum StopDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource for which to retrieve tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value string map. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppConfigClientTypes {
    public enum TriggeredBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appconfig
        case cloudwatchAlarm
        case internalError
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggeredBy] {
            return [
                .appconfig,
                .cloudwatchAlarm,
                .internalError,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appconfig: return "APPCONFIG"
            case .cloudwatchAlarm: return "CLOUDWATCH_ALARM"
            case .internalError: return "INTERNAL_ERROR"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TriggeredBy(rawValue: rawValue) ?? TriggeredBy.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource for which to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to delete.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A description of the application.
    public var description: Swift.String?
    /// The name of the application.
    public var name: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.name = name
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct UpdateApplicationOutput: Swift.Equatable {
    /// The description of the application.
    public var description: Swift.String?
    /// The application ID.
    public var id: Swift.String?
    /// The application name.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateApplicationOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum UpdateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConfigurationProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case kmsKeyIdentifier = "KmsKeyIdentifier"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case validators = "Validators"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyIdentifier = self.kmsKeyIdentifier {
            try encodeContainer.encode(kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retrievalRoleArn = self.retrievalRoleArn {
            try encodeContainer.encode(retrievalRoleArn, forKey: .retrievalRoleArn)
        }
        if let validators = validators {
            var validatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validators)
            for validator0 in validators {
                try validatorsContainer.encode(validator0)
            }
        }
    }
}

extension UpdateConfigurationProfileInput {

    static func urlPathProvider(_ value: UpdateConfigurationProfileInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let configurationProfileId = value.configurationProfileId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())"
    }
}

public struct UpdateConfigurationProfileInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the configuration profile.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// A description of the configuration profile.
    public var description: Swift.String?
    /// The identifier for a Key Management Service key to encrypt new configuration data versions in the AppConfig hosted configuration store. This attribute is only used for hosted configuration types. The identifier can be an KMS key ID, alias, or the Amazon Resource Name (ARN) of the key ID or alias. To encrypt data managed in other configuration stores, see the documentation for how to specify an KMS key for that particular service.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the configuration profile.
    public var name: Swift.String?
    /// The ARN of an IAM role with permission to access the configuration at the specified LocationUri.
    public var retrievalRoleArn: Swift.String?
    /// A list of methods for validating the configuration.
    public var validators: [AppConfigClientTypes.Validator]?

    public init(
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        retrievalRoleArn: Swift.String? = nil,
        validators: [AppConfigClientTypes.Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.description = description
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.validators = validators
    }
}

struct UpdateConfigurationProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let retrievalRoleArn: Swift.String?
    let validators: [AppConfigClientTypes.Validator]?
    let kmsKeyIdentifier: Swift.String?
}

extension UpdateConfigurationProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case kmsKeyIdentifier = "KmsKeyIdentifier"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case validators = "Validators"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[AppConfigClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [AppConfigClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

extension UpdateConfigurationProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConfigurationProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.kmsKeyArn = output.kmsKeyArn
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.locationUri = output.locationUri
            self.name = output.name
            self.retrievalRoleArn = output.retrievalRoleArn
            self.type = output.type
            self.validators = output.validators
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.kmsKeyArn = nil
            self.kmsKeyIdentifier = nil
            self.locationUri = nil
            self.name = nil
            self.retrievalRoleArn = nil
            self.type = nil
            self.validators = nil
        }
    }
}

public struct UpdateConfigurationProfileOutput: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The configuration profile description.
    public var description: Swift.String?
    /// The configuration profile ID.
    public var id: Swift.String?
    /// The Amazon Resource Name of the Key Management Service key to encrypt new configuration data versions in the AppConfig hosted configuration store. This attribute is only used for hosted configuration types. To encrypt data managed in other configuration stores, see the documentation for how to specify an KMS key for that particular service.
    public var kmsKeyArn: Swift.String?
    /// The Key Management Service key identifier (key ID, key alias, or key ARN) provided when the resource was created or updated.
    public var kmsKeyIdentifier: Swift.String?
    /// The URI location of the configuration.
    public var locationUri: Swift.String?
    /// The name of the configuration profile.
    public var name: Swift.String?
    /// The ARN of an IAM role with permission to access the configuration at the specified LocationUri.
    public var retrievalRoleArn: Swift.String?
    /// The type of configurations contained in the profile. AppConfig supports feature flags and freeform configurations. We recommend you create feature flag configurations to enable or disable new features and freeform configurations to distribute configurations to an application. When calling this API, enter one of the following values for Type: AWS.AppConfig.FeatureFlags
    ///     AWS.Freeform
    public var type: Swift.String?
    /// A list of methods for validating the configuration.
    public var validators: [AppConfigClientTypes.Validator]?

    public init(
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        locationUri: Swift.String? = nil,
        name: Swift.String? = nil,
        retrievalRoleArn: Swift.String? = nil,
        type: Swift.String? = nil,
        validators: [AppConfigClientTypes.Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.kmsKeyArn = kmsKeyArn
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.type = type
        self.validators = validators
    }
}

struct UpdateConfigurationProfileOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let locationUri: Swift.String?
    let retrievalRoleArn: Swift.String?
    let validators: [AppConfigClientTypes.Validator]?
    let type: Swift.String?
    let kmsKeyArn: Swift.String?
    let kmsKeyIdentifier: Swift.String?
}

extension UpdateConfigurationProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case kmsKeyArn = "KmsKeyArn"
        case kmsKeyIdentifier = "KmsKeyIdentifier"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case type = "Type"
        case validators = "Validators"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[AppConfigClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [AppConfigClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

enum UpdateConfigurationProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDeploymentStrategyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentDurationInMinutes = self.deploymentDurationInMinutes {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let finalBakeTimeInMinutes = self.finalBakeTimeInMinutes {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if let growthFactor = self.growthFactor {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = self.growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
    }
}

extension UpdateDeploymentStrategyInput {

    static func urlPathProvider(_ value: UpdateDeploymentStrategyInput) -> Swift.String? {
        guard let deploymentStrategyId = value.deploymentStrategyId else {
            return nil
        }
        return "/deploymentstrategies/\(deploymentStrategyId.urlPercentEncoding())"
    }
}

public struct UpdateDeploymentStrategyInput: Swift.Equatable {
    /// Total amount of time for a deployment to last.
    public var deploymentDurationInMinutes: Swift.Int?
    /// The deployment strategy ID.
    /// This member is required.
    public var deploymentStrategyId: Swift.String?
    /// A description of the deployment strategy.
    public var description: Swift.String?
    /// The amount of time that AppConfig monitors for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
    public var finalBakeTimeInMinutes: Swift.Int?
    /// The percentage of targets to receive a deployed configuration during each interval.
    public var growthFactor: Swift.Float?
    /// The algorithm used to define how percentage grows over time. AppConfig supports the following growth types: Linear: For this type, AppConfig processes the deployment by increments of the growth factor evenly distributed over the deployment time. For example, a linear deployment that uses a growth factor of 20 initially makes the configuration available to 20 percent of the targets. After 1/5th of the deployment time has passed, the system updates the percentage to 40 percent. This continues until 100% of the targets are set to receive the deployed configuration. Exponential: For this type, AppConfig processes the deployment exponentially using the following formula: G*(2^N). In this formula, G is the growth factor specified by the user and N is the number of steps until the configuration is deployed to all targets. For example, if you specify a growth factor of 2, then the system rolls out the configuration as follows: 2*(2^0)
    ///     2*(2^1)
    ///
    /// 2*(2^2) Expressed numerically, the deployment rolls out as follows: 2% of the targets, 4% of the targets, 8% of the targets, and continues until the configuration has been deployed to all targets.
    public var growthType: AppConfigClientTypes.GrowthType?

    public init(
        deploymentDurationInMinutes: Swift.Int? = nil,
        deploymentStrategyId: Swift.String? = nil,
        description: Swift.String? = nil,
        finalBakeTimeInMinutes: Swift.Int? = nil,
        growthFactor: Swift.Float? = nil,
        growthType: AppConfigClientTypes.GrowthType? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
    }
}

struct UpdateDeploymentStrategyInputBody: Swift.Equatable {
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int?
    let finalBakeTimeInMinutes: Swift.Int?
    let growthFactor: Swift.Float?
    let growthType: AppConfigClientTypes.GrowthType?
}

extension UpdateDeploymentStrategyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let growthFactorDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
    }
}

extension UpdateDeploymentStrategyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDeploymentStrategyOutputBody = try responseDecoder.decode(responseBody: data)
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.description = output.description
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.id = output.id
            self.name = output.name
            self.replicateTo = output.replicateTo
        } else {
            self.deploymentDurationInMinutes = 0
            self.description = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = nil
            self.growthType = nil
            self.id = nil
            self.name = nil
            self.replicateTo = nil
        }
    }
}

public struct UpdateDeploymentStrategyOutput: Swift.Equatable {
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The description of the deployment strategy.
    public var description: Swift.String?
    /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets that received a deployed configuration during each interval.
    public var growthFactor: Swift.Float?
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The deployment strategy ID.
    public var id: Swift.String?
    /// The name of the deployment strategy.
    public var name: Swift.String?
    /// Save the deployment strategy to a Systems Manager (SSM) document.
    public var replicateTo: AppConfigClientTypes.ReplicateTo?

    public init(
        deploymentDurationInMinutes: Swift.Int = 0,
        description: Swift.String? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float? = nil,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        replicateTo: AppConfigClientTypes.ReplicateTo? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.id = id
        self.name = name
        self.replicateTo = replicateTo
    }
}

struct UpdateDeploymentStrategyOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int
    let growthType: AppConfigClientTypes.GrowthType?
    let growthFactor: Swift.Float?
    let finalBakeTimeInMinutes: Swift.Int
    let replicateTo: AppConfigClientTypes.ReplicateTo?
}

extension UpdateDeploymentStrategyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deploymentDurationInMinutes) ?? 0
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .finalBakeTimeInMinutes) ?? 0
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

enum UpdateDeploymentStrategyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let monitors = monitors {
            var monitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitors)
            for monitor0 in monitors {
                try monitorsContainer.encode(monitor0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateEnvironmentInput {

    static func urlPathProvider(_ value: UpdateEnvironmentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())"
    }
}

public struct UpdateEnvironmentInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A description of the environment.
    public var description: Swift.String?
    /// The environment ID.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Amazon CloudWatch alarms to monitor during the deployment process.
    public var monitors: [AppConfigClientTypes.Monitor]?
    /// The name of the environment.
    public var name: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        monitors: [AppConfigClientTypes.Monitor]? = nil,
        name: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.environmentId = environmentId
        self.monitors = monitors
        self.name = name
    }
}

struct UpdateEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let monitors: [AppConfigClientTypes.Monitor]?
}

extension UpdateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

extension UpdateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.monitors = output.monitors
            self.name = output.name
            self.state = output.state
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.monitors = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct UpdateEnvironmentOutput: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The description of the environment.
    public var description: Swift.String?
    /// The environment ID.
    public var id: Swift.String?
    /// Amazon CloudWatch alarms monitored during the deployment.
    public var monitors: [AppConfigClientTypes.Monitor]?
    /// The name of the environment.
    public var name: Swift.String?
    /// The state of the environment. An environment can be in one of the following states: READY_FOR_DEPLOYMENT, DEPLOYING, ROLLING_BACK, or ROLLED_BACK
    public var state: AppConfigClientTypes.EnvironmentState?

    public init(
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        monitors: [AppConfigClientTypes.Monitor]? = nil,
        name: Swift.String? = nil,
        state: AppConfigClientTypes.EnvironmentState? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.monitors = monitors
        self.name = name
        self.state = state
    }
}

struct UpdateEnvironmentOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let state: AppConfigClientTypes.EnvironmentState?
    let monitors: [AppConfigClientTypes.Monitor]?
}

extension UpdateEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

enum UpdateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateExtensionAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameterValueMap0) in parameters {
                try parametersContainer.encode(parameterValueMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateExtensionAssociationInput {

    static func urlPathProvider(_ value: UpdateExtensionAssociationInput) -> Swift.String? {
        guard let extensionAssociationId = value.extensionAssociationId else {
            return nil
        }
        return "/extensionassociations/\(extensionAssociationId.urlPercentEncoding())"
    }
}

public struct UpdateExtensionAssociationInput: Swift.Equatable {
    /// The system-generated ID for the association.
    /// This member is required.
    public var extensionAssociationId: Swift.String?
    /// The parameter names and values defined in the extension.
    public var parameters: [Swift.String:Swift.String]?

    public init(
        extensionAssociationId: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil
    )
    {
        self.extensionAssociationId = extensionAssociationId
        self.parameters = parameters
    }
}

struct UpdateExtensionAssociationInputBody: Swift.Equatable {
    let parameters: [Swift.String:Swift.String]?
}

extension UpdateExtensionAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters = "Parameters"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and20480) in parametersContainer {
                if let stringwithlengthbetween1and20480 = stringwithlengthbetween1and20480 {
                    parametersDecoded0?[key0] = stringwithlengthbetween1and20480
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension UpdateExtensionAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateExtensionAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.extensionArn = output.extensionArn
            self.extensionVersionNumber = output.extensionVersionNumber
            self.id = output.id
            self.parameters = output.parameters
            self.resourceArn = output.resourceArn
        } else {
            self.arn = nil
            self.extensionArn = nil
            self.extensionVersionNumber = 0
            self.id = nil
            self.parameters = nil
            self.resourceArn = nil
        }
    }
}

public struct UpdateExtensionAssociationOutput: Swift.Equatable {
    /// The system-generated Amazon Resource Name (ARN) for the extension.
    public var arn: Swift.String?
    /// The ARN of the extension defined in the association.
    public var extensionArn: Swift.String?
    /// The version number for the extension defined in the association.
    public var extensionVersionNumber: Swift.Int
    /// The system-generated ID for the association.
    public var id: Swift.String?
    /// The parameter names and values defined in the association.
    public var parameters: [Swift.String:Swift.String]?
    /// The ARNs of applications, configuration profiles, or environments defined in the association.
    public var resourceArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        extensionArn: Swift.String? = nil,
        extensionVersionNumber: Swift.Int = 0,
        id: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.extensionArn = extensionArn
        self.extensionVersionNumber = extensionVersionNumber
        self.id = id
        self.parameters = parameters
        self.resourceArn = resourceArn
    }
}

struct UpdateExtensionAssociationOutputBody: Swift.Equatable {
    let id: Swift.String?
    let extensionArn: Swift.String?
    let resourceArn: Swift.String?
    let arn: Swift.String?
    let parameters: [Swift.String:Swift.String]?
    let extensionVersionNumber: Swift.Int
}

extension UpdateExtensionAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case extensionArn = "ExtensionArn"
        case extensionVersionNumber = "ExtensionVersionNumber"
        case id = "Id"
        case parameters = "Parameters"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let extensionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extensionArn)
        extensionArn = extensionArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and20480) in parametersContainer {
                if let stringwithlengthbetween1and20480 = stringwithlengthbetween1and20480 {
                    parametersDecoded0?[key0] = stringwithlengthbetween1and20480
                }
            }
        }
        parameters = parametersDecoded0
        let extensionVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .extensionVersionNumber) ?? 0
        extensionVersionNumber = extensionVersionNumberDecoded
    }
}

enum UpdateExtensionAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateExtensionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case description = "Description"
        case parameters = "Parameters"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .actions)
            for (dictKey0, actionsMap0) in actions {
                var actionsMap0Container = actionsContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for action1 in actionsMap0 {
                    try actionsMap0Container.encode(action1)
                }
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameterMap0) in parameters {
                try parametersContainer.encode(parameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versionNumber = self.versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }
}

extension UpdateExtensionInput {

    static func urlPathProvider(_ value: UpdateExtensionInput) -> Swift.String? {
        guard let extensionIdentifier = value.extensionIdentifier else {
            return nil
        }
        return "/extensions/\(extensionIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateExtensionInput: Swift.Equatable {
    /// The actions defined in the extension.
    public var actions: [Swift.String:[AppConfigClientTypes.Action]]?
    /// Information about the extension.
    public var description: Swift.String?
    /// The name, the ID, or the Amazon Resource Name (ARN) of the extension.
    /// This member is required.
    public var extensionIdentifier: Swift.String?
    /// One or more parameters for the actions called by the extension.
    public var parameters: [Swift.String:AppConfigClientTypes.Parameter]?
    /// The extension version number.
    public var versionNumber: Swift.Int?

    public init(
        actions: [Swift.String:[AppConfigClientTypes.Action]]? = nil,
        description: Swift.String? = nil,
        extensionIdentifier: Swift.String? = nil,
        parameters: [Swift.String:AppConfigClientTypes.Parameter]? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.extensionIdentifier = extensionIdentifier
        self.parameters = parameters
        self.versionNumber = versionNumber
    }
}

struct UpdateExtensionInputBody: Swift.Equatable {
    let description: Swift.String?
    let actions: [Swift.String:[AppConfigClientTypes.Action]]?
    let parameters: [Swift.String:AppConfigClientTypes.Parameter]?
    let versionNumber: Swift.Int?
}

extension UpdateExtensionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case description = "Description"
        case parameters = "Parameters"
        case versionNumber = "VersionNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: [AppConfigClientTypes.Action?]?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:[AppConfigClientTypes.Action]]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:[AppConfigClientTypes.Action]]()
            for (key0, actionlist0) in actionsContainer {
                var actionlist0Decoded0: [AppConfigClientTypes.Action]? = nil
                if let actionlist0 = actionlist0 {
                    actionlist0Decoded0 = [AppConfigClientTypes.Action]()
                    for structure1 in actionlist0 {
                        if let structure1 = structure1 {
                            actionlist0Decoded0?.append(structure1)
                        }
                    }
                }
                actionsDecoded0?[key0] = actionlist0Decoded0
            }
        }
        actions = actionsDecoded0
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: AppConfigClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:AppConfigClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:AppConfigClientTypes.Parameter]()
            for (key0, parameter0) in parametersContainer {
                if let parameter0 = parameter0 {
                    parametersDecoded0?[key0] = parameter0
                }
            }
        }
        parameters = parametersDecoded0
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
    }
}

extension UpdateExtensionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateExtensionOutputBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.arn = output.arn
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.parameters = output.parameters
            self.versionNumber = output.versionNumber
        } else {
            self.actions = nil
            self.arn = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.parameters = nil
            self.versionNumber = 0
        }
    }
}

public struct UpdateExtensionOutput: Swift.Equatable {
    /// The actions defined in the extension.
    public var actions: [Swift.String:[AppConfigClientTypes.Action]]?
    /// The system-generated Amazon Resource Name (ARN) for the extension.
    public var arn: Swift.String?
    /// Information about the extension.
    public var description: Swift.String?
    /// The system-generated ID of the extension.
    public var id: Swift.String?
    /// The extension name.
    public var name: Swift.String?
    /// The parameters accepted by the extension. You specify parameter values when you associate the extension to an AppConfig resource by using the CreateExtensionAssociation API action. For Lambda extension actions, these parameters are included in the Lambda request object.
    public var parameters: [Swift.String:AppConfigClientTypes.Parameter]?
    /// The extension version number.
    public var versionNumber: Swift.Int

    public init(
        actions: [Swift.String:[AppConfigClientTypes.Action]]? = nil,
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: [Swift.String:AppConfigClientTypes.Parameter]? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.actions = actions
        self.arn = arn
        self.description = description
        self.id = id
        self.name = name
        self.parameters = parameters
        self.versionNumber = versionNumber
    }
}

struct UpdateExtensionOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let versionNumber: Swift.Int
    let arn: Swift.String?
    let description: Swift.String?
    let actions: [Swift.String:[AppConfigClientTypes.Action]]?
    let parameters: [Swift.String:AppConfigClientTypes.Parameter]?
}

extension UpdateExtensionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case parameters = "Parameters"
        case versionNumber = "VersionNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber) ?? 0
        versionNumber = versionNumberDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: [AppConfigClientTypes.Action?]?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:[AppConfigClientTypes.Action]]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:[AppConfigClientTypes.Action]]()
            for (key0, actionlist0) in actionsContainer {
                var actionlist0Decoded0: [AppConfigClientTypes.Action]? = nil
                if let actionlist0 = actionlist0 {
                    actionlist0Decoded0 = [AppConfigClientTypes.Action]()
                    for structure1 in actionlist0 {
                        if let structure1 = structure1 {
                            actionlist0Decoded0?.append(structure1)
                        }
                    }
                }
                actionsDecoded0?[key0] = actionlist0Decoded0
            }
        }
        actions = actionsDecoded0
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: AppConfigClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:AppConfigClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:AppConfigClientTypes.Parameter]()
            for (key0, parameter0) in parametersContainer {
                if let parameter0 = parameter0 {
                    parametersDecoded0?[key0] = parameter0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

enum UpdateExtensionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidateConfigurationInput {

    static func queryItemProvider(_ value: ValidateConfigurationInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let configurationVersion = value.configurationVersion else {
            let message = "Creating a URL Query Item failed. configurationVersion is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let configurationVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "configuration_version".urlPercentEncoding(), value: Swift.String(configurationVersion).urlPercentEncoding())
        items.append(configurationVersionQueryItem)
        return items
    }
}

extension ValidateConfigurationInput {

    static func urlPathProvider(_ value: ValidateConfigurationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let configurationProfileId = value.configurationProfileId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())/validators"
    }
}

public struct ValidateConfigurationInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The version of the configuration to validate.
    /// This member is required.
    public var configurationVersion: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        configurationVersion: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
    }
}

struct ValidateConfigurationInputBody: Swift.Equatable {
}

extension ValidateConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ValidateConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ValidateConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum ValidateConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppConfigClientTypes.Validator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ValidatorType.self, forKey: .type)
        type = typeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension AppConfigClientTypes.Validator: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Validator(type: \(Swift.String(describing: type)), content: \"CONTENT_REDACTED\")"}
}

extension AppConfigClientTypes {
    /// A validator provides a syntactic or semantic check to ensure the configuration that you want to deploy functions as intended. To validate your application configuration data, you provide a schema or an Amazon Web Services Lambda function that runs against the configuration. The configuration deployment or update can only proceed when the configuration data is valid.
    public struct Validator: Swift.Equatable {
        /// Either the JSON Schema content or the Amazon Resource Name (ARN) of an Lambda function.
        /// This member is required.
        public var content: Swift.String?
        /// AppConfig supports validators of type JSON_SCHEMA and LAMBDA
        /// This member is required.
        public var type: AppConfigClientTypes.ValidatorType?

        public init(
            content: Swift.String? = nil,
            type: AppConfigClientTypes.ValidatorType? = nil
        )
        {
            self.content = content
            self.type = type
        }
    }

}

extension AppConfigClientTypes {
    public enum ValidatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jsonSchema
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidatorType] {
            return [
                .jsonSchema,
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jsonSchema: return "JSON_SCHEMA"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidatorType(rawValue: rawValue) ?? ValidatorType.sdkUnknown(rawValue)
        }
    }
}
