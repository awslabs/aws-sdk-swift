//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ByteStream
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You are not authorized to perform the action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LookoutVisionClientTypes {

    /// Information about the pixels in an anomaly mask. For more information, see [Anomaly]. PixelAnomaly is only returned by image segmentation models.
    public struct PixelAnomaly: Swift.Sendable {
        /// A hex color value for the mask that covers an anomaly type. Each anomaly type has a different mask color. The color maps to the color of the anomaly type used in the training dataset.
        public var color: Swift.String?
        /// The percentage area of the image that the anomaly type covers.
        public var totalPercentageArea: Swift.Float?

        public init(
            color: Swift.String? = nil,
            totalPercentageArea: Swift.Float? = nil
        )
        {
            self.color = color
            self.totalPercentageArea = totalPercentageArea
        }
    }
}

extension LookoutVisionClientTypes {

    /// Information about an anomaly type found on an image by an image segmentation model. For more information, see [DetectAnomalies].
    public struct Anomaly: Swift.Sendable {
        /// The name of an anomaly type found in an image. Name maps to an anomaly type in the training dataset, apart from the anomaly type background. The service automatically inserts the background anomaly type into the response from DetectAnomalies.
        public var name: Swift.String?
        /// Information about the pixel mask that covers an anomaly type.
        public var pixelAnomaly: LookoutVisionClientTypes.PixelAnomaly?

        public init(
            name: Swift.String? = nil,
            pixelAnomaly: LookoutVisionClientTypes.PixelAnomaly? = nil
        )
        {
            self.name = name
            self.pixelAnomaly = pixelAnomaly
        }
    }
}

extension LookoutVisionClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dataset
        case model
        case modelPackageJob
        case project
        case trial
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .dataset,
                .model,
                .modelPackageJob,
                .project,
                .trial
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dataset: return "DATASET"
            case .model: return "MODEL"
            case .modelPackageJob: return "MODEL_PACKAGE_JOB"
            case .project: return "PROJECT"
            case .trial: return "TRIAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The update or deletion of a resource caused an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource.
        /// This member is required.
        public internal(set) var resourceType: LookoutVisionClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: LookoutVisionClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Amazon Lookout for Vision experienced a service issue. Try your call again.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The period of time, in seconds, before the operation can be retried.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource.
        /// This member is required.
        public internal(set) var resourceType: LookoutVisionClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: LookoutVisionClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// A service quota was exceeded the allowed limit. For more information, see Limits in Amazon Lookout for Vision in the Amazon Lookout for Vision Developer Guide.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource.
        public internal(set) var resourceType: LookoutVisionClientTypes.ResourceType? = nil
        /// The service code.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: LookoutVisionClientTypes.ResourceType? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// Amazon Lookout for Vision is temporarily unable to process the request. Try your call again.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The period of time, in seconds, before the operation can be retried.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The service code.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

/// An input validation error occured. For example, invalid characters in a project name, or if a pagination token is invalid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LookoutVisionClientTypes {

    /// Amazon S3 Location information for an input manifest file.
    public struct InputS3Object: Swift.Sendable {
        /// The Amazon S3 bucket that contains the manifest.
        /// This member is required.
        public var bucket: Swift.String?
        /// The name and location of the manifest file withiin the bucket.
        /// This member is required.
        public var key: Swift.String?
        /// The version ID of the bucket.
        public var versionId: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.versionId = versionId
        }
    }
}

extension LookoutVisionClientTypes {

    /// Location information about a manifest file. You can use a manifest file to create a dataset.
    public struct DatasetGroundTruthManifest: Swift.Sendable {
        /// The S3 bucket location for the manifest file.
        public var s3Object: LookoutVisionClientTypes.InputS3Object?

        public init(
            s3Object: LookoutVisionClientTypes.InputS3Object? = nil
        )
        {
            self.s3Object = s3Object
        }
    }
}

extension LookoutVisionClientTypes {

    /// Information about the location of a manifest file that Amazon Lookout for Vision uses to to create a dataset.
    public struct DatasetSource: Swift.Sendable {
        /// Location information for the manifest file.
        public var groundTruthManifest: LookoutVisionClientTypes.DatasetGroundTruthManifest?

        public init(
            groundTruthManifest: LookoutVisionClientTypes.DatasetGroundTruthManifest? = nil
        )
        {
            self.groundTruthManifest = groundTruthManifest
        }
    }
}

public struct CreateDatasetInput: Swift.Sendable {
    /// ClientToken is an idempotency token that ensures a call to CreateDataset completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from CreateDataset. In this case, safely retry your call to CreateDataset by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple dataset creation requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to CreateDataset. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The location of the manifest file that Amazon Lookout for Vision uses to create the dataset. If you don't specify DatasetSource, an empty dataset is created and the operation synchronously returns. Later, you can add JSON Lines by calling [UpdateDatasetEntries]. If you specify a value for DataSource, the manifest at the S3 location is validated and used to create the dataset. The call to CreateDataset is asynchronous and might take a while to complete. To find out the current status, Check the value of Status returned in a call to [DescribeDataset].
    public var datasetSource: LookoutVisionClientTypes.DatasetSource?
    /// The type of the dataset. Specify train for a training dataset. Specify test for a test dataset.
    /// This member is required.
    public var datasetType: Swift.String?
    /// The name of the project in which you want to create a dataset.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        datasetSource: LookoutVisionClientTypes.DatasetSource? = nil,
        datasetType: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.datasetSource = datasetSource
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

extension LookoutVisionClientTypes {

    public enum DatasetStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createComplete
        case createFailed
        case createInProgress
        case deleteComplete
        case deleteFailed
        case deleteInProgress
        case updateComplete
        case updateFailedRollbackComplete
        case updateFailedRollbackInProgress
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetStatus] {
            return [
                .createComplete,
                .createFailed,
                .createInProgress,
                .deleteComplete,
                .deleteFailed,
                .deleteInProgress,
                .updateComplete,
                .updateFailedRollbackComplete,
                .updateFailedRollbackInProgress,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createComplete: return "CREATE_COMPLETE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteComplete: return "DELETE_COMPLETE"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateComplete: return "UPDATE_COMPLETE"
            case .updateFailedRollbackComplete: return "UPDATE_FAILED_ROLLBACK_COMPLETE"
            case .updateFailedRollbackInProgress: return "UPDATE_FAILED_ROLLBACK_IN_PROGRESS"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutVisionClientTypes {

    /// Summary information for an Amazon Lookout for Vision dataset. For more information, see [DescribeDataset] and [ProjectDescription].
    public struct DatasetMetadata: Swift.Sendable {
        /// The Unix timestamp for the date and time that the dataset was created.
        public var creationTimestamp: Foundation.Date?
        /// The type of the dataset.
        public var datasetType: Swift.String?
        /// The status for the dataset.
        public var status: LookoutVisionClientTypes.DatasetStatus?
        /// The status message for the dataset.
        public var statusMessage: Swift.String?

        public init(
            creationTimestamp: Foundation.Date? = nil,
            datasetType: Swift.String? = nil,
            status: LookoutVisionClientTypes.DatasetStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.datasetType = datasetType
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct CreateDatasetOutput: Swift.Sendable {
    /// Information about the dataset.
    public var datasetMetadata: LookoutVisionClientTypes.DatasetMetadata?

    public init(
        datasetMetadata: LookoutVisionClientTypes.DatasetMetadata? = nil
    )
    {
        self.datasetMetadata = datasetMetadata
    }
}

extension LookoutVisionClientTypes {

    /// Information about the location of training output or the output of a model packaging job.
    public struct S3Location: Swift.Sendable {
        /// The S3 bucket that contains the training or model packaging job output. If you are training a model, the bucket must in your AWS account. If you use an S3 bucket for a model packaging job, the S3 bucket must be in the same AWS Region and AWS account in which you use AWS IoT Greengrass.
        /// This member is required.
        public var bucket: Swift.String?
        /// The path of the folder, within the S3 bucket, that contains the output.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }
}

extension LookoutVisionClientTypes {

    /// The S3 location where Amazon Lookout for Vision saves model training files.
    public struct OutputConfig: Swift.Sendable {
        /// The S3 location for the output.
        /// This member is required.
        public var s3Location: LookoutVisionClientTypes.S3Location?

        public init(
            s3Location: LookoutVisionClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }
}

extension LookoutVisionClientTypes {

    /// A key and value pair that is attached to the specified Amazon Lookout for Vision model.
    public struct Tag: Swift.Sendable {
        /// The key of the tag that is attached to the specified model.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag that is attached to the specified model.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateModelInput: Swift.Sendable {
    /// ClientToken is an idempotency token that ensures a call to CreateModel completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from CreateModel. In this case, safely retry your call to CreateModel by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from starting multiple training jobs. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to CreateModel. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// A description for the version of the model.
    public var description: Swift.String?
    /// The identifier for your AWS KMS key. The key is used to encrypt training and test images copied into the service for model training. Your source images are unaffected. If this parameter is not specified, the copied images are encrypted by a key that AWS owns and manages.
    public var kmsKeyId: Swift.String?
    /// The location where Amazon Lookout for Vision saves the training results.
    /// This member is required.
    public var outputConfig: LookoutVisionClientTypes.OutputConfig?
    /// The name of the project in which you want to create a model version.
    /// This member is required.
    public var projectName: Swift.String?
    /// A set of tags (key-value pairs) that you want to attach to the model.
    public var tags: [LookoutVisionClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        outputConfig: LookoutVisionClientTypes.OutputConfig? = nil,
        projectName: Swift.String? = nil,
        tags: [LookoutVisionClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.outputConfig = outputConfig
        self.projectName = projectName
        self.tags = tags
    }
}

extension LookoutVisionClientTypes {

    /// Information about the evaluation performance of a trained model.
    public struct ModelPerformance: Swift.Sendable {
        /// The overall F1 score metric for the trained model.
        public var f1Score: Swift.Float?
        /// The overall precision metric value for the trained model.
        public var precision: Swift.Float?
        /// The overall recall metric value for the trained model.
        public var recall: Swift.Float?

        public init(
            f1Score: Swift.Float? = nil,
            precision: Swift.Float? = nil,
            recall: Swift.Float? = nil
        )
        {
            self.f1Score = f1Score
            self.precision = precision
            self.recall = recall
        }
    }
}

extension LookoutVisionClientTypes {

    public enum ModelStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleting
        case hosted
        case hostingFailed
        case startingHosting
        case stoppingHosting
        case systemUpdating
        case trained
        case training
        case trainingFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelStatus] {
            return [
                .deleting,
                .hosted,
                .hostingFailed,
                .startingHosting,
                .stoppingHosting,
                .systemUpdating,
                .trained,
                .training,
                .trainingFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .hosted: return "HOSTED"
            case .hostingFailed: return "HOSTING_FAILED"
            case .startingHosting: return "STARTING_HOSTING"
            case .stoppingHosting: return "STOPPING_HOSTING"
            case .systemUpdating: return "SYSTEM_UPDATING"
            case .trained: return "TRAINED"
            case .training: return "TRAINING"
            case .trainingFailed: return "TRAINING_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutVisionClientTypes {

    /// Describes an Amazon Lookout for Vision model.
    public struct ModelMetadata: Swift.Sendable {
        /// The unix timestamp for the date and time that the model was created.
        public var creationTimestamp: Foundation.Date?
        /// The description for the model.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the model.
        public var modelArn: Swift.String?
        /// The version of the model.
        public var modelVersion: Swift.String?
        /// Performance metrics for the model. Not available until training has successfully completed.
        public var performance: LookoutVisionClientTypes.ModelPerformance?
        /// The status of the model.
        public var status: LookoutVisionClientTypes.ModelStatus?
        /// The status message for the model.
        public var statusMessage: Swift.String?

        public init(
            creationTimestamp: Foundation.Date? = nil,
            description: Swift.String? = nil,
            modelArn: Swift.String? = nil,
            modelVersion: Swift.String? = nil,
            performance: LookoutVisionClientTypes.ModelPerformance? = nil,
            status: LookoutVisionClientTypes.ModelStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.description = description
            self.modelArn = modelArn
            self.modelVersion = modelVersion
            self.performance = performance
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct CreateModelOutput: Swift.Sendable {
    /// The response from a call to CreateModel.
    public var modelMetadata: LookoutVisionClientTypes.ModelMetadata?

    public init(
        modelMetadata: LookoutVisionClientTypes.ModelMetadata? = nil
    )
    {
        self.modelMetadata = modelMetadata
    }
}

public struct CreateProjectInput: Swift.Sendable {
    /// ClientToken is an idempotency token that ensures a call to CreateProject completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from CreateProject. In this case, safely retry your call to CreateProject by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple project creation requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to CreateProject. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The name for the project.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectName = projectName
    }
}

extension LookoutVisionClientTypes {

    /// Metadata about an Amazon Lookout for Vision project.
    public struct ProjectMetadata: Swift.Sendable {
        /// The unix timestamp for the date and time that the project was created.
        public var creationTimestamp: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the project.
        public var projectArn: Swift.String?
        /// The name of the project.
        public var projectName: Swift.String?

        public init(
            creationTimestamp: Foundation.Date? = nil,
            projectArn: Swift.String? = nil,
            projectName: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.projectArn = projectArn
            self.projectName = projectName
        }
    }
}

public struct CreateProjectOutput: Swift.Sendable {
    /// Information about the project.
    public var projectMetadata: LookoutVisionClientTypes.ProjectMetadata?

    public init(
        projectMetadata: LookoutVisionClientTypes.ProjectMetadata? = nil
    )
    {
        self.projectMetadata = projectMetadata
    }
}

extension LookoutVisionClientTypes {

    /// Statistics about the images in a dataset.
    public struct DatasetImageStats: Swift.Sendable {
        /// the total number of images labeled as an anomaly.
        public var anomaly: Swift.Int?
        /// The total number of labeled images.
        public var labeled: Swift.Int?
        /// The total number of images labeled as normal.
        public var normal: Swift.Int?
        /// The total number of images in the dataset.
        public var total: Swift.Int?

        public init(
            anomaly: Swift.Int? = nil,
            labeled: Swift.Int? = nil,
            normal: Swift.Int? = nil,
            total: Swift.Int? = nil
        )
        {
            self.anomaly = anomaly
            self.labeled = labeled
            self.normal = normal
            self.total = total
        }
    }
}

extension LookoutVisionClientTypes {

    /// The description for a dataset. For more information, see [DescribeDataset].
    public struct DatasetDescription: Swift.Sendable {
        /// The Unix timestamp for the time and date that the dataset was created.
        public var creationTimestamp: Foundation.Date?
        /// The type of the dataset. The value train represents a training dataset or single dataset project. The value test represents a test dataset.
        public var datasetType: Swift.String?
        /// Statistics about the images in a dataset.
        public var imageStats: LookoutVisionClientTypes.DatasetImageStats?
        /// The Unix timestamp for the date and time that the dataset was last updated.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The name of the project that contains the dataset.
        public var projectName: Swift.String?
        /// The status of the dataset.
        public var status: LookoutVisionClientTypes.DatasetStatus?
        /// The status message for the dataset.
        public var statusMessage: Swift.String?

        public init(
            creationTimestamp: Foundation.Date? = nil,
            datasetType: Swift.String? = nil,
            imageStats: LookoutVisionClientTypes.DatasetImageStats? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            projectName: Swift.String? = nil,
            status: LookoutVisionClientTypes.DatasetStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.datasetType = datasetType
            self.imageStats = imageStats
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.projectName = projectName
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct DeleteDatasetInput: Swift.Sendable {
    /// ClientToken is an idempotency token that ensures a call to DeleteDataset completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from DeleteDataset. In this case, safely retry your call to DeleteDataset by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple deletetion requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to DeleteDataset. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The type of the dataset to delete. Specify train to delete the training dataset. Specify test to delete the test dataset. To delete the dataset in a single dataset project, specify train.
    /// This member is required.
    public var datasetType: Swift.String?
    /// The name of the project that contains the dataset that you want to delete.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        datasetType: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

public struct DeleteDatasetOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteModelInput: Swift.Sendable {
    /// ClientToken is an idempotency token that ensures a call to DeleteModel completes only once. You choose the value to pass. For example, an issue might prevent you from getting a response from DeleteModel. In this case, safely retry your call to DeleteModel by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple model deletion requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to DeleteModel. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The version of the model that you want to delete.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// The name of the project that contains the model that you want to delete.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

public struct DeleteModelOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the model that was deleted.
    public var modelArn: Swift.String?

    public init(
        modelArn: Swift.String? = nil
    )
    {
        self.modelArn = modelArn
    }
}

public struct DeleteProjectInput: Swift.Sendable {
    /// ClientToken is an idempotency token that ensures a call to DeleteProject completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from DeleteProject. In this case, safely retry your call to DeleteProject by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple project deletion requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to DeleteProject. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The name of the project to delete.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectName = projectName
    }
}

public struct DeleteProjectOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the project that was deleted.
    public var projectArn: Swift.String?

    public init(
        projectArn: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
    }
}

public struct DescribeDatasetInput: Swift.Sendable {
    /// The type of the dataset to describe. Specify train to describe the training dataset. Specify test to describe the test dataset. If you have a single dataset project, specify train
    /// This member is required.
    public var datasetType: Swift.String?
    /// The name of the project that contains the dataset that you want to describe.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        datasetType: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

public struct DescribeDatasetOutput: Swift.Sendable {
    /// The description of the requested dataset.
    public var datasetDescription: LookoutVisionClientTypes.DatasetDescription?

    public init(
        datasetDescription: LookoutVisionClientTypes.DatasetDescription? = nil
    )
    {
        self.datasetDescription = datasetDescription
    }
}

public struct DescribeModelInput: Swift.Sendable {
    /// The version of the model that you want to describe.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// The project that contains the version of a model that you want to describe.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

extension LookoutVisionClientTypes {

    /// The S3 location where Amazon Lookout for Vision saves training output.
    public struct OutputS3Object: Swift.Sendable {
        /// The bucket that contains the training output.
        /// This member is required.
        public var bucket: Swift.String?
        /// The location of the training output in the bucket.
        /// This member is required.
        public var key: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }
}

extension LookoutVisionClientTypes {

    /// Describes an Amazon Lookout for Vision model.
    public struct ModelDescription: Swift.Sendable {
        /// The unix timestamp for the date and time that the model was created.
        public var creationTimestamp: Foundation.Date?
        /// The description for the model.
        public var description: Swift.String?
        /// The unix timestamp for the date and time that the evaluation ended.
        public var evaluationEndTimestamp: Foundation.Date?
        /// The S3 location where Amazon Lookout for Vision saves the manifest file that was used to test the trained model and generate the performance scores.
        public var evaluationManifest: LookoutVisionClientTypes.OutputS3Object?
        /// The S3 location where Amazon Lookout for Vision saves the performance metrics.
        public var evaluationResult: LookoutVisionClientTypes.OutputS3Object?
        /// The identifer for the AWS Key Management Service (AWS KMS) key that was used to encrypt the model during training.
        public var kmsKeyId: Swift.String?
        /// The maximum number of inference units Amazon Lookout for Vision uses to auto-scale the model. For more information, see [StartModel].
        public var maxInferenceUnits: Swift.Int?
        /// The minimum number of inference units used by the model. For more information, see [StartModel]
        public var minInferenceUnits: Swift.Int?
        /// The Amazon Resource Name (ARN) of the model.
        public var modelArn: Swift.String?
        /// The version of the model
        public var modelVersion: Swift.String?
        /// The S3 location where Amazon Lookout for Vision saves model training files.
        public var outputConfig: LookoutVisionClientTypes.OutputConfig?
        /// Performance metrics for the model. Created during training.
        public var performance: LookoutVisionClientTypes.ModelPerformance?
        /// The status of the model.
        public var status: LookoutVisionClientTypes.ModelStatus?
        /// The status message for the model.
        public var statusMessage: Swift.String?

        public init(
            creationTimestamp: Foundation.Date? = nil,
            description: Swift.String? = nil,
            evaluationEndTimestamp: Foundation.Date? = nil,
            evaluationManifest: LookoutVisionClientTypes.OutputS3Object? = nil,
            evaluationResult: LookoutVisionClientTypes.OutputS3Object? = nil,
            kmsKeyId: Swift.String? = nil,
            maxInferenceUnits: Swift.Int? = nil,
            minInferenceUnits: Swift.Int? = nil,
            modelArn: Swift.String? = nil,
            modelVersion: Swift.String? = nil,
            outputConfig: LookoutVisionClientTypes.OutputConfig? = nil,
            performance: LookoutVisionClientTypes.ModelPerformance? = nil,
            status: LookoutVisionClientTypes.ModelStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.description = description
            self.evaluationEndTimestamp = evaluationEndTimestamp
            self.evaluationManifest = evaluationManifest
            self.evaluationResult = evaluationResult
            self.kmsKeyId = kmsKeyId
            self.maxInferenceUnits = maxInferenceUnits
            self.minInferenceUnits = minInferenceUnits
            self.modelArn = modelArn
            self.modelVersion = modelVersion
            self.outputConfig = outputConfig
            self.performance = performance
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct DescribeModelOutput: Swift.Sendable {
    /// Contains the description of the model.
    public var modelDescription: LookoutVisionClientTypes.ModelDescription?

    public init(
        modelDescription: LookoutVisionClientTypes.ModelDescription? = nil
    )
    {
        self.modelDescription = modelDescription
    }
}

public struct DescribeModelPackagingJobInput: Swift.Sendable {
    /// The job name for the model packaging job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The name of the project that contains the model packaging job that you want to describe.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        jobName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.jobName = jobName
        self.projectName = projectName
    }
}

extension LookoutVisionClientTypes {

    public enum TargetDevice: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jetsonXavier
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetDevice] {
            return [
                .jetsonXavier
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jetsonXavier: return "jetson_xavier"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutVisionClientTypes {

    public enum TargetPlatformAccelerator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nvidia
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetPlatformAccelerator] {
            return [
                .nvidia
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nvidia: return "NVIDIA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutVisionClientTypes {

    public enum TargetPlatformArch: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arm64
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetPlatformArch] {
            return [
                .arm64,
                .x8664
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "ARM64"
            case .x8664: return "X86_64"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutVisionClientTypes {

    public enum TargetPlatformOs: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linux
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetPlatformOs] {
            return [
                .linux
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutVisionClientTypes {

    /// The platform on which a model runs on an AWS IoT Greengrass core device.
    public struct TargetPlatform: Swift.Sendable {
        /// The target accelerator for the model. Currently, Amazon Lookout for Vision only supports NVIDIA (Nvidia graphics processing unit) and CPU accelerators. If you specify NVIDIA as an accelerator, you must also specify the gpu-code, trt-ver, and cuda-ver compiler options. If you don't specify an accelerator, Lookout for Vision uses the CPU for compilation and we highly recommend that you use the [GreengrassConfiguration$CompilerOptions] field. For example, you can use the following compiler options for CPU:
        ///
        /// * mcpu: CPU micro-architecture. For example, {'mcpu': 'skylake-avx512'}
        ///
        /// * mattr: CPU flags. For example, {'mattr': ['+neon', '+vfpv4']}
        public var accelerator: LookoutVisionClientTypes.TargetPlatformAccelerator?
        /// The target architecture for the model. The currently supported architectures are X86_64 (64-bit version of the x86 instruction set) and ARM_64 (ARMv8 64-bit CPU).
        /// This member is required.
        public var arch: LookoutVisionClientTypes.TargetPlatformArch?
        /// The target operating system for the model. Linux is the only operating system that is currently supported.
        /// This member is required.
        public var os: LookoutVisionClientTypes.TargetPlatformOs?

        public init(
            accelerator: LookoutVisionClientTypes.TargetPlatformAccelerator? = nil,
            arch: LookoutVisionClientTypes.TargetPlatformArch? = nil,
            os: LookoutVisionClientTypes.TargetPlatformOs? = nil
        )
        {
            self.accelerator = accelerator
            self.arch = arch
            self.os = os
        }
    }
}

extension LookoutVisionClientTypes {

    /// Configuration information for the AWS IoT Greengrass component created in a model packaging job. For more information, see [StartModelPackagingJob]. You can't specify a component with the same ComponentName and Componentversion as an existing component with the same component name and component version.
    public struct GreengrassConfiguration: Swift.Sendable {
        /// Additional compiler options for the Greengrass component. Currently, only NVIDIA Graphics Processing Units (GPU) and CPU accelerators are supported. If you specify TargetDevice, don't specify CompilerOptions. For more information, see Compiler options in the Amazon Lookout for Vision Developer Guide.
        public var compilerOptions: Swift.String?
        /// A description for the AWS IoT Greengrass component.
        public var componentDescription: Swift.String?
        /// A name for the AWS IoT Greengrass component.
        /// This member is required.
        public var componentName: Swift.String?
        /// A Version for the AWS IoT Greengrass component. If you don't provide a value, a default value of  Model Version.0.0 is used.
        public var componentVersion: Swift.String?
        /// An S3 location in which Lookout for Vision stores the component artifacts.
        /// This member is required.
        public var s3OutputLocation: LookoutVisionClientTypes.S3Location?
        /// A set of tags (key-value pairs) that you want to attach to the AWS IoT Greengrass component.
        public var tags: [LookoutVisionClientTypes.Tag]?
        /// The target device for the model. Currently the only supported value is jetson_xavier. If you specify TargetDevice, you can't specify TargetPlatform.
        public var targetDevice: LookoutVisionClientTypes.TargetDevice?
        /// The target platform for the model. If you specify TargetPlatform, you can't specify TargetDevice.
        public var targetPlatform: LookoutVisionClientTypes.TargetPlatform?

        public init(
            compilerOptions: Swift.String? = nil,
            componentDescription: Swift.String? = nil,
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            s3OutputLocation: LookoutVisionClientTypes.S3Location? = nil,
            tags: [LookoutVisionClientTypes.Tag]? = nil,
            targetDevice: LookoutVisionClientTypes.TargetDevice? = nil,
            targetPlatform: LookoutVisionClientTypes.TargetPlatform? = nil
        )
        {
            self.compilerOptions = compilerOptions
            self.componentDescription = componentDescription
            self.componentName = componentName
            self.componentVersion = componentVersion
            self.s3OutputLocation = s3OutputLocation
            self.tags = tags
            self.targetDevice = targetDevice
            self.targetPlatform = targetPlatform
        }
    }
}

extension LookoutVisionClientTypes {

    /// Configuration information for a Amazon Lookout for Vision model packaging job. For more information, see [StartModelPackagingJob].
    public struct ModelPackagingConfiguration: Swift.Sendable {
        /// Configuration information for the AWS IoT Greengrass component in a model packaging job.
        /// This member is required.
        public var greengrass: LookoutVisionClientTypes.GreengrassConfiguration?

        public init(
            greengrass: LookoutVisionClientTypes.GreengrassConfiguration? = nil
        )
        {
            self.greengrass = greengrass
        }
    }
}

extension LookoutVisionClientTypes {

    /// Information about the AWS IoT Greengrass component created by a model packaging job.
    public struct GreengrassOutputDetails: Swift.Sendable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of the component.
        public var componentVersionArn: Swift.String?

        public init(
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            componentVersionArn: Swift.String? = nil
        )
        {
            self.componentName = componentName
            self.componentVersion = componentVersion
            self.componentVersionArn = componentVersionArn
        }
    }
}

extension LookoutVisionClientTypes {

    /// Information about the output from a model packaging job.
    public struct ModelPackagingOutputDetails: Swift.Sendable {
        /// Information about the AWS IoT Greengrass component in a model packaging job.
        public var greengrass: LookoutVisionClientTypes.GreengrassOutputDetails?

        public init(
            greengrass: LookoutVisionClientTypes.GreengrassOutputDetails? = nil
        )
        {
            self.greengrass = greengrass
        }
    }
}

extension LookoutVisionClientTypes {

    public enum ModelPackagingJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelPackagingJobStatus] {
            return [
                .created,
                .failed,
                .running,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutVisionClientTypes {

    /// Information about a model packaging job. For more information, see [DescribeModelPackagingJob].
    public struct ModelPackagingDescription: Swift.Sendable {
        /// The Unix timestamp for the time and date that the model packaging job was created.
        public var creationTimestamp: Foundation.Date?
        /// The name of the model packaging job.
        public var jobName: Swift.String?
        /// The Unix timestamp for the time and date that the model packaging job was last updated.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The configuration information used in the model packaging job.
        public var modelPackagingConfiguration: LookoutVisionClientTypes.ModelPackagingConfiguration?
        /// The description for the model packaging job.
        public var modelPackagingJobDescription: Swift.String?
        /// The AWS service used to package the job. Currently Lookout for Vision can package jobs with AWS IoT Greengrass.
        public var modelPackagingMethod: Swift.String?
        /// Information about the output of the model packaging job. For more information, see [DescribeModelPackagingJob].
        public var modelPackagingOutputDetails: LookoutVisionClientTypes.ModelPackagingOutputDetails?
        /// The version of the model used in the model packaging job.
        public var modelVersion: Swift.String?
        /// The name of the project that's associated with a model that's in the model package.
        public var projectName: Swift.String?
        /// The status of the model packaging job.
        public var status: LookoutVisionClientTypes.ModelPackagingJobStatus?
        /// The status message for the model packaging job.
        public var statusMessage: Swift.String?

        public init(
            creationTimestamp: Foundation.Date? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            modelPackagingConfiguration: LookoutVisionClientTypes.ModelPackagingConfiguration? = nil,
            modelPackagingJobDescription: Swift.String? = nil,
            modelPackagingMethod: Swift.String? = nil,
            modelPackagingOutputDetails: LookoutVisionClientTypes.ModelPackagingOutputDetails? = nil,
            modelVersion: Swift.String? = nil,
            projectName: Swift.String? = nil,
            status: LookoutVisionClientTypes.ModelPackagingJobStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.jobName = jobName
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.modelPackagingConfiguration = modelPackagingConfiguration
            self.modelPackagingJobDescription = modelPackagingJobDescription
            self.modelPackagingMethod = modelPackagingMethod
            self.modelPackagingOutputDetails = modelPackagingOutputDetails
            self.modelVersion = modelVersion
            self.projectName = projectName
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct DescribeModelPackagingJobOutput: Swift.Sendable {
    /// The description of the model packaging job.
    public var modelPackagingDescription: LookoutVisionClientTypes.ModelPackagingDescription?

    public init(
        modelPackagingDescription: LookoutVisionClientTypes.ModelPackagingDescription? = nil
    )
    {
        self.modelPackagingDescription = modelPackagingDescription
    }
}

public struct DescribeProjectInput: Swift.Sendable {
    /// The name of the project that you want to describe.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        projectName: Swift.String? = nil
    )
    {
        self.projectName = projectName
    }
}

extension LookoutVisionClientTypes {

    /// Describe an Amazon Lookout for Vision project. For more information, see [DescribeProject].
    public struct ProjectDescription: Swift.Sendable {
        /// The unix timestamp for the date and time that the project was created.
        public var creationTimestamp: Foundation.Date?
        /// A list of datasets in the project.
        public var datasets: [LookoutVisionClientTypes.DatasetMetadata]?
        /// The Amazon Resource Name (ARN) of the project.
        public var projectArn: Swift.String?
        /// The name of the project.
        public var projectName: Swift.String?

        public init(
            creationTimestamp: Foundation.Date? = nil,
            datasets: [LookoutVisionClientTypes.DatasetMetadata]? = nil,
            projectArn: Swift.String? = nil,
            projectName: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.datasets = datasets
            self.projectArn = projectArn
            self.projectName = projectName
        }
    }
}

public struct DescribeProjectOutput: Swift.Sendable {
    /// The description of the project.
    public var projectDescription: LookoutVisionClientTypes.ProjectDescription?

    public init(
        projectDescription: LookoutVisionClientTypes.ProjectDescription? = nil
    )
    {
        self.projectDescription = projectDescription
    }
}

public struct DetectAnomaliesInput: Swift.Sendable {
    /// The unencrypted image bytes that you want to analyze.
    /// This member is required.
    public var body: Smithy.ByteStream?
    /// The type of the image passed in Body. Valid values are image/png (PNG format images) and image/jpeg (JPG format images).
    /// This member is required.
    public var contentType: Swift.String?
    /// The version of the model that you want to use.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// The name of the project that contains the model version that you want to use.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        body: Smithy.ByteStream? = nil,
        contentType: Swift.String? = nil,
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.body = body
        self.contentType = contentType
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

extension LookoutVisionClientTypes {

    /// The source for an image.
    public struct ImageSource: Swift.Sendable {
        /// The type of the image.
        public var type: Swift.String?

        public init(
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }
}

extension LookoutVisionClientTypes {

    /// The prediction results from a call to [DetectAnomalies]. DetectAnomalyResult includes classification information for the prediction (IsAnomalous and Confidence). If the model you use is an image segementation model, DetectAnomalyResult also includes segmentation information (Anomalies and AnomalyMask). Classification information is calculated separately from segmentation information and you shouldn't assume a relationship between them.
    public struct DetectAnomalyResult: Swift.Sendable {
        /// If the model is an image segmentation model, Anomalies contains a list of anomaly types found in the image. There is one entry for each type of anomaly found (even if multiple instances of an anomaly type exist on the image). The first element in the list is always an anomaly type representing the image background ('background') and shouldn't be considered an anomaly. Amazon Lookout for Vision automatically add the background anomaly type to the response, and you don't need to declare a background anomaly type in your dataset. If the list has one entry ('background'), no anomalies were found on the image. An image classification model doesn't return an Anomalies list.
        public var anomalies: [LookoutVisionClientTypes.Anomaly]?
        /// If the model is an image segmentation model, AnomalyMask contains pixel masks that covers all anomaly types found on the image. Each anomaly type has a different mask color. To map a color to an anomaly type, see the color field of the [PixelAnomaly] object. An image classification model doesn't return an Anomalies list.
        public var anomalyMask: Foundation.Data?
        /// The confidence that Lookout for Vision has in the accuracy of the classification in IsAnomalous.
        public var confidence: Swift.Float?
        /// True if Amazon Lookout for Vision classifies the image as containing an anomaly, otherwise false.
        public var isAnomalous: Swift.Bool?
        /// The source of the image that was analyzed. direct means that the images was supplied from the local computer. No other values are supported.
        public var source: LookoutVisionClientTypes.ImageSource?

        public init(
            anomalies: [LookoutVisionClientTypes.Anomaly]? = nil,
            anomalyMask: Foundation.Data? = nil,
            confidence: Swift.Float? = nil,
            isAnomalous: Swift.Bool? = nil,
            source: LookoutVisionClientTypes.ImageSource? = nil
        )
        {
            self.anomalies = anomalies
            self.anomalyMask = anomalyMask
            self.confidence = confidence
            self.isAnomalous = isAnomalous
            self.source = source
        }
    }
}

public struct DetectAnomaliesOutput: Swift.Sendable {
    /// The results of the DetectAnomalies operation.
    public var detectAnomalyResult: LookoutVisionClientTypes.DetectAnomalyResult?

    public init(
        detectAnomalyResult: LookoutVisionClientTypes.DetectAnomalyResult? = nil
    )
    {
        self.detectAnomalyResult = detectAnomalyResult
    }
}

public struct ListDatasetEntriesInput: Swift.Sendable {
    /// Only includes entries after the specified date in the response. For example, 2020-06-23T00:00:00.
    public var afterCreationDate: Foundation.Date?
    /// Specify normal to include only normal images. Specify anomaly to only include anomalous entries. If you don't specify a value, Amazon Lookout for Vision returns normal and anomalous images.
    public var anomalyClass: Swift.String?
    /// Only includes entries before the specified date in the response. For example, 2020-06-23T00:00:00.
    public var beforeCreationDate: Foundation.Date?
    /// The type of the dataset that you want to list. Specify train to list the training dataset. Specify test to list the test dataset. If you have a single dataset project, specify train.
    /// This member is required.
    public var datasetType: Swift.String?
    /// Specify true to include labeled entries, otherwise specify false. If you don't specify a value, Lookout for Vision returns all entries.
    public var labeled: Swift.Bool?
    /// The maximum number of results to return per paginated call. The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
    public var maxResults: Swift.Int?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of dataset entries.
    public var nextToken: Swift.String?
    /// The name of the project that contains the dataset that you want to list.
    /// This member is required.
    public var projectName: Swift.String?
    /// Perform a "contains" search on the values of the source-ref key within the dataset. For example a value of "IMG_17" returns all JSON Lines where the source-ref key value matches *IMG_17*.
    public var sourceRefContains: Swift.String?

    public init(
        afterCreationDate: Foundation.Date? = nil,
        anomalyClass: Swift.String? = nil,
        beforeCreationDate: Foundation.Date? = nil,
        datasetType: Swift.String? = nil,
        labeled: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sourceRefContains: Swift.String? = nil
    )
    {
        self.afterCreationDate = afterCreationDate
        self.anomalyClass = anomalyClass
        self.beforeCreationDate = beforeCreationDate
        self.datasetType = datasetType
        self.labeled = labeled
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
        self.sourceRefContains = sourceRefContains
    }
}

public struct ListDatasetEntriesOutput: Swift.Sendable {
    /// A list of the entries (JSON Lines) within the dataset.
    public var datasetEntries: [Swift.String]?
    /// If the response is truncated, Amazon Lookout for Vision returns this token that you can use in the subsequent request to retrieve the next set ofdataset entries.
    public var nextToken: Swift.String?

    public init(
        datasetEntries: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetEntries = datasetEntries
        self.nextToken = nextToken
    }
}

public struct ListModelPackagingJobsInput: Swift.Sendable {
    /// The maximum number of results to return per paginated call. The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
    public var maxResults: Swift.Int?
    /// If the previous response was incomplete (because there is more results to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The name of the project for which you want to list the model packaging jobs.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
    }
}

extension LookoutVisionClientTypes {

    /// Metadata for a model packaging job. For more information, see [ListModelPackagingJobs].
    public struct ModelPackagingJobMetadata: Swift.Sendable {
        /// The Unix timestamp for the time and date that the model packaging job was created.
        public var creationTimestamp: Foundation.Date?
        /// The name of the model packaging job.
        public var jobName: Swift.String?
        /// The Unix timestamp for the time and date that the model packaging job was last updated.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The description for the model packaging job.
        public var modelPackagingJobDescription: Swift.String?
        /// The AWS service used to package the job. Currently Lookout for Vision can package jobs with AWS IoT Greengrass.
        public var modelPackagingMethod: Swift.String?
        /// The version of the model that is in the model package.
        public var modelVersion: Swift.String?
        /// The project that contains the model that is in the model package.
        public var projectName: Swift.String?
        /// The status of the model packaging job.
        public var status: LookoutVisionClientTypes.ModelPackagingJobStatus?
        /// The status message for the model packaging job.
        public var statusMessage: Swift.String?

        public init(
            creationTimestamp: Foundation.Date? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            modelPackagingJobDescription: Swift.String? = nil,
            modelPackagingMethod: Swift.String? = nil,
            modelVersion: Swift.String? = nil,
            projectName: Swift.String? = nil,
            status: LookoutVisionClientTypes.ModelPackagingJobStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.jobName = jobName
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.modelPackagingJobDescription = modelPackagingJobDescription
            self.modelPackagingMethod = modelPackagingMethod
            self.modelVersion = modelVersion
            self.projectName = projectName
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct ListModelPackagingJobsOutput: Swift.Sendable {
    /// A list of the model packaging jobs created for the specified Amazon Lookout for Vision project.
    public var modelPackagingJobs: [LookoutVisionClientTypes.ModelPackagingJobMetadata]?
    /// If the previous response was incomplete (because there is more results to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        modelPackagingJobs: [LookoutVisionClientTypes.ModelPackagingJobMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelPackagingJobs = modelPackagingJobs
        self.nextToken = nextToken
    }
}

public struct ListModelsInput: Swift.Sendable {
    /// The maximum number of results to return per paginated call. The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
    public var maxResults: Swift.Int?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of models.
    public var nextToken: Swift.String?
    /// The name of the project that contains the model versions that you want to list.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
    }
}

public struct ListModelsOutput: Swift.Sendable {
    /// A list of model versions in the specified project.
    public var models: [LookoutVisionClientTypes.ModelMetadata]?
    /// If the response is truncated, Amazon Lookout for Vision returns this token that you can use in the subsequent request to retrieve the next set of models.
    public var nextToken: Swift.String?

    public init(
        models: [LookoutVisionClientTypes.ModelMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.models = models
        self.nextToken = nextToken
    }
}

public struct ListProjectsInput: Swift.Sendable {
    /// The maximum number of results to return per paginated call. The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
    public var maxResults: Swift.Int?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of projects.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListProjectsOutput: Swift.Sendable {
    /// If the response is truncated, Amazon Lookout for Vision returns this token that you can use in the subsequent request to retrieve the next set of projects.
    public var nextToken: Swift.String?
    /// A list of projects in your AWS account.
    public var projects: [LookoutVisionClientTypes.ProjectMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        projects: [LookoutVisionClientTypes.ProjectMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the model for which you want to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A map of tag keys and values attached to the specified model.
    public var tags: [LookoutVisionClientTypes.Tag]?

    public init(
        tags: [LookoutVisionClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct StartModelInput: Swift.Sendable {
    /// ClientToken is an idempotency token that ensures a call to StartModel completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from StartModel. In this case, safely retry your call to StartModel by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple start requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to StartModel. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The maximum number of inference units to use for auto-scaling the model. If you don't specify a value, Amazon Lookout for Vision doesn't auto-scale the model.
    public var maxInferenceUnits: Swift.Int?
    /// The minimum number of inference units to use. A single inference unit represents 1 hour of processing. Use a higher number to increase the TPS throughput of your model. You are charged for the number of inference units that you use.
    /// This member is required.
    public var minInferenceUnits: Swift.Int?
    /// The version of the model that you want to start.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// The name of the project that contains the model that you want to start.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        maxInferenceUnits: Swift.Int? = nil,
        minInferenceUnits: Swift.Int? = nil,
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.maxInferenceUnits = maxInferenceUnits
        self.minInferenceUnits = minInferenceUnits
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

extension LookoutVisionClientTypes {

    public enum ModelHostingStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hosted
        case hostingFailed
        case startingHosting
        case stoppingHosting
        case systemUpdating
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelHostingStatus] {
            return [
                .hosted,
                .hostingFailed,
                .startingHosting,
                .stoppingHosting,
                .systemUpdating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hosted: return "HOSTED"
            case .hostingFailed: return "HOSTING_FAILED"
            case .startingHosting: return "STARTING_HOSTING"
            case .stoppingHosting: return "STOPPING_HOSTING"
            case .systemUpdating: return "SYSTEM_UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartModelOutput: Swift.Sendable {
    /// The current running status of the model.
    public var status: LookoutVisionClientTypes.ModelHostingStatus?

    public init(
        status: LookoutVisionClientTypes.ModelHostingStatus? = nil
    )
    {
        self.status = status
    }
}

public struct StartModelPackagingJobInput: Swift.Sendable {
    /// ClientToken is an idempotency token that ensures a call to StartModelPackagingJob completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from StartModelPackagingJob. In this case, safely retry your call to StartModelPackagingJob by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple dataset creation requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to StartModelPackagingJob. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The configuration for the model packaging job.
    /// This member is required.
    public var configuration: LookoutVisionClientTypes.ModelPackagingConfiguration?
    /// A description for the model packaging job.
    public var description: Swift.String?
    /// A name for the model packaging job. If you don't supply a value, the service creates a job name for you.
    public var jobName: Swift.String?
    /// The version of the model within the project that you want to package.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// The name of the project which contains the version of the model that you want to package.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        configuration: LookoutVisionClientTypes.ModelPackagingConfiguration? = nil,
        description: Swift.String? = nil,
        jobName: Swift.String? = nil,
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.jobName = jobName
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

public struct StartModelPackagingJobOutput: Swift.Sendable {
    /// The job name for the model packaging job. If you don't supply a job name in the JobName input parameter, the service creates a job name for you.
    public var jobName: Swift.String?

    public init(
        jobName: Swift.String? = nil
    )
    {
        self.jobName = jobName
    }
}

public struct StopModelInput: Swift.Sendable {
    /// ClientToken is an idempotency token that ensures a call to StopModel completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from StopModel. In this case, safely retry your call to StopModel by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple stop requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to StopModel. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The version of the model that you want to stop.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// The name of the project that contains the model that you want to stop.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

public struct StopModelOutput: Swift.Sendable {
    /// The status of the model.
    public var status: LookoutVisionClientTypes.ModelHostingStatus?

    public init(
        status: LookoutVisionClientTypes.ModelHostingStatus? = nil
    )
    {
        self.status = status
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the model to assign the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value tags to assign to the model.
    /// This member is required.
    public var tags: [LookoutVisionClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [LookoutVisionClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the model from which you want to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys of the tags that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDatasetEntriesInput: Swift.Sendable {
    /// The entries to add to the dataset.
    /// This member is required.
    public var changes: Foundation.Data?
    /// ClientToken is an idempotency token that ensures a call to UpdateDatasetEntries completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from UpdateDatasetEntries. In this case, safely retry your call to UpdateDatasetEntries by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple updates with the same dataset entries. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to UpdateDatasetEntries. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The type of the dataset that you want to update. Specify train to update the training dataset. Specify test to update the test dataset. If you have a single dataset project, specify train.
    /// This member is required.
    public var datasetType: Swift.String?
    /// The name of the project that contains the dataset that you want to update.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        changes: Foundation.Data? = nil,
        clientToken: Swift.String? = nil,
        datasetType: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.changes = changes
        self.clientToken = clientToken
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

public struct UpdateDatasetEntriesOutput: Swift.Sendable {
    /// The status of the dataset update.
    public var status: LookoutVisionClientTypes.DatasetStatus?

    public init(
        status: LookoutVisionClientTypes.DatasetStatus? = nil
    )
    {
        self.status = status
    }
}

extension CreateDatasetInput {

    static func urlPathProvider(_ value: CreateDatasetInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/datasets"
    }
}

extension CreateDatasetInput {

    static func headerProvider(_ value: CreateDatasetInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateModelInput {

    static func urlPathProvider(_ value: CreateModelInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/models"
    }
}

extension CreateModelInput {

    static func headerProvider(_ value: CreateModelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateProjectInput {

    static func urlPathProvider(_ value: CreateProjectInput) -> Swift.String? {
        return "/2020-11-20/projects"
    }
}

extension CreateProjectInput {

    static func headerProvider(_ value: CreateProjectInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteDatasetInput {

    static func urlPathProvider(_ value: DeleteDatasetInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let datasetType = value.datasetType else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/datasets/\(datasetType.urlPercentEncoding())"
    }
}

extension DeleteDatasetInput {

    static func headerProvider(_ value: DeleteDatasetInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteModelInput {

    static func urlPathProvider(_ value: DeleteModelInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let modelVersion = value.modelVersion else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/models/\(modelVersion.urlPercentEncoding())"
    }
}

extension DeleteModelInput {

    static func headerProvider(_ value: DeleteModelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteProjectInput {

    static func urlPathProvider(_ value: DeleteProjectInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())"
    }
}

extension DeleteProjectInput {

    static func headerProvider(_ value: DeleteProjectInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DescribeDatasetInput {

    static func urlPathProvider(_ value: DescribeDatasetInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let datasetType = value.datasetType else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/datasets/\(datasetType.urlPercentEncoding())"
    }
}

extension DescribeModelInput {

    static func urlPathProvider(_ value: DescribeModelInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let modelVersion = value.modelVersion else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/models/\(modelVersion.urlPercentEncoding())"
    }
}

extension DescribeModelPackagingJobInput {

    static func urlPathProvider(_ value: DescribeModelPackagingJobInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let jobName = value.jobName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/modelpackagingjobs/\(jobName.urlPercentEncoding())"
    }
}

extension DescribeProjectInput {

    static func urlPathProvider(_ value: DescribeProjectInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())"
    }
}

extension DetectAnomaliesInput {

    static func urlPathProvider(_ value: DetectAnomaliesInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let modelVersion = value.modelVersion else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/models/\(modelVersion.urlPercentEncoding())/detect"
    }
}

extension DetectAnomaliesInput {

    static func headerProvider(_ value: DetectAnomaliesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let contentType = value.contentType {
            items.add(SmithyHTTPAPI.Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        return items
    }
}

extension ListDatasetEntriesInput {

    static func urlPathProvider(_ value: ListDatasetEntriesInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let datasetType = value.datasetType else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/datasets/\(datasetType.urlPercentEncoding())/entries"
    }
}

extension ListDatasetEntriesInput {

    static func queryItemProvider(_ value: ListDatasetEntriesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sourceRefContains = value.sourceRefContains {
            let sourceRefContainsQueryItem = Smithy.URIQueryItem(name: "sourceRefContains".urlPercentEncoding(), value: Swift.String(sourceRefContains).urlPercentEncoding())
            items.append(sourceRefContainsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let labeled = value.labeled {
            let labeledQueryItem = Smithy.URIQueryItem(name: "labeled".urlPercentEncoding(), value: Swift.String(labeled).urlPercentEncoding())
            items.append(labeledQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let beforeCreationDate = value.beforeCreationDate {
            let beforeCreationDateQueryItem = Smithy.URIQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: beforeCreationDate)).urlPercentEncoding())
            items.append(beforeCreationDateQueryItem)
        }
        if let afterCreationDate = value.afterCreationDate {
            let afterCreationDateQueryItem = Smithy.URIQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: afterCreationDate)).urlPercentEncoding())
            items.append(afterCreationDateQueryItem)
        }
        if let anomalyClass = value.anomalyClass {
            let anomalyClassQueryItem = Smithy.URIQueryItem(name: "anomalyClass".urlPercentEncoding(), value: Swift.String(anomalyClass).urlPercentEncoding())
            items.append(anomalyClassQueryItem)
        }
        return items
    }
}

extension ListModelPackagingJobsInput {

    static func urlPathProvider(_ value: ListModelPackagingJobsInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/modelpackagingjobs"
    }
}

extension ListModelPackagingJobsInput {

    static func queryItemProvider(_ value: ListModelPackagingJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListModelsInput {

    static func urlPathProvider(_ value: ListModelsInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/models"
    }
}

extension ListModelsInput {

    static func queryItemProvider(_ value: ListModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProjectsInput {

    static func urlPathProvider(_ value: ListProjectsInput) -> Swift.String? {
        return "/2020-11-20/projects"
    }
}

extension ListProjectsInput {

    static func queryItemProvider(_ value: ListProjectsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/2020-11-20/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension StartModelInput {

    static func urlPathProvider(_ value: StartModelInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let modelVersion = value.modelVersion else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/models/\(modelVersion.urlPercentEncoding())/start"
    }
}

extension StartModelInput {

    static func headerProvider(_ value: StartModelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension StartModelPackagingJobInput {

    static func urlPathProvider(_ value: StartModelPackagingJobInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/modelpackagingjobs"
    }
}

extension StartModelPackagingJobInput {

    static func headerProvider(_ value: StartModelPackagingJobInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension StopModelInput {

    static func urlPathProvider(_ value: StopModelInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let modelVersion = value.modelVersion else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/models/\(modelVersion.urlPercentEncoding())/stop"
    }
}

extension StopModelInput {

    static func headerProvider(_ value: StopModelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/2020-11-20/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/2020-11-20/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateDatasetEntriesInput {

    static func urlPathProvider(_ value: UpdateDatasetEntriesInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let datasetType = value.datasetType else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/datasets/\(datasetType.urlPercentEncoding())/entries"
    }
}

extension UpdateDatasetEntriesInput {

    static func headerProvider(_ value: UpdateDatasetEntriesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateDatasetInput {

    static func write(value: CreateDatasetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatasetSource"].write(value.datasetSource, with: LookoutVisionClientTypes.DatasetSource.write(value:to:))
        try writer["DatasetType"].write(value.datasetType)
    }
}

extension CreateModelInput {

    static func write(value: CreateModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["OutputConfig"].write(value.outputConfig, with: LookoutVisionClientTypes.OutputConfig.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: LookoutVisionClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateProjectInput {

    static func write(value: CreateProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProjectName"].write(value.projectName)
    }
}

extension DetectAnomaliesInput {

    static func write(value: DetectAnomaliesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Body"].write(value.body)
    }
}

extension StartModelInput {

    static func write(value: StartModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxInferenceUnits"].write(value.maxInferenceUnits)
        try writer["MinInferenceUnits"].write(value.minInferenceUnits)
    }
}

extension StartModelPackagingJobInput {

    static func write(value: StartModelPackagingJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configuration"].write(value.configuration, with: LookoutVisionClientTypes.ModelPackagingConfiguration.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["JobName"].write(value.jobName)
        try writer["ModelVersion"].write(value.modelVersion)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: LookoutVisionClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDatasetEntriesInput {

    static func write(value: UpdateDatasetEntriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Changes"].write(value.changes)
    }
}

extension CreateDatasetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDatasetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDatasetOutput()
        value.datasetMetadata = try reader["DatasetMetadata"].readIfPresent(with: LookoutVisionClientTypes.DatasetMetadata.read(from:))
        return value
    }
}

extension CreateModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelOutput()
        value.modelMetadata = try reader["ModelMetadata"].readIfPresent(with: LookoutVisionClientTypes.ModelMetadata.read(from:))
        return value
    }
}

extension CreateProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProjectOutput()
        value.projectMetadata = try reader["ProjectMetadata"].readIfPresent(with: LookoutVisionClientTypes.ProjectMetadata.read(from:))
        return value
    }
}

extension DeleteDatasetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDatasetOutput {
        return DeleteDatasetOutput()
    }
}

extension DeleteModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteModelOutput()
        value.modelArn = try reader["ModelArn"].readIfPresent()
        return value
    }
}

extension DeleteProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteProjectOutput()
        value.projectArn = try reader["ProjectArn"].readIfPresent()
        return value
    }
}

extension DescribeDatasetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDatasetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDatasetOutput()
        value.datasetDescription = try reader["DatasetDescription"].readIfPresent(with: LookoutVisionClientTypes.DatasetDescription.read(from:))
        return value
    }
}

extension DescribeModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeModelOutput()
        value.modelDescription = try reader["ModelDescription"].readIfPresent(with: LookoutVisionClientTypes.ModelDescription.read(from:))
        return value
    }
}

extension DescribeModelPackagingJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeModelPackagingJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeModelPackagingJobOutput()
        value.modelPackagingDescription = try reader["ModelPackagingDescription"].readIfPresent(with: LookoutVisionClientTypes.ModelPackagingDescription.read(from:))
        return value
    }
}

extension DescribeProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProjectOutput()
        value.projectDescription = try reader["ProjectDescription"].readIfPresent(with: LookoutVisionClientTypes.ProjectDescription.read(from:))
        return value
    }
}

extension DetectAnomaliesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetectAnomaliesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DetectAnomaliesOutput()
        value.detectAnomalyResult = try reader["DetectAnomalyResult"].readIfPresent(with: LookoutVisionClientTypes.DetectAnomalyResult.read(from:))
        return value
    }
}

extension ListDatasetEntriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDatasetEntriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDatasetEntriesOutput()
        value.datasetEntries = try reader["DatasetEntries"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListModelPackagingJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelPackagingJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelPackagingJobsOutput()
        value.modelPackagingJobs = try reader["ModelPackagingJobs"].readListIfPresent(memberReadingClosure: LookoutVisionClientTypes.ModelPackagingJobMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelsOutput()
        value.models = try reader["Models"].readListIfPresent(memberReadingClosure: LookoutVisionClientTypes.ModelMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListProjectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProjectsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.projects = try reader["Projects"].readListIfPresent(memberReadingClosure: LookoutVisionClientTypes.ProjectMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: LookoutVisionClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartModelOutput()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension StartModelPackagingJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartModelPackagingJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartModelPackagingJobOutput()
        value.jobName = try reader["JobName"].readIfPresent()
        return value
    }
}

extension StopModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopModelOutput()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDatasetEntriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDatasetEntriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDatasetEntriesOutput()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

enum CreateDatasetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDatasetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDatasetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeModelPackagingJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetectAnomaliesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDatasetEntriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelPackagingJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProjectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartModelPackagingJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDatasetEntriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LookoutVisionClientTypes.DatasetMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.DatasetMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.DatasetMetadata()
        value.datasetType = try reader["DatasetType"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension LookoutVisionClientTypes.ModelMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.ModelMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.ModelMetadata()
        value.creationTimestamp = try reader["CreationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modelVersion = try reader["ModelVersion"].readIfPresent()
        value.modelArn = try reader["ModelArn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.performance = try reader["Performance"].readIfPresent(with: LookoutVisionClientTypes.ModelPerformance.read(from:))
        return value
    }
}

extension LookoutVisionClientTypes.ModelPerformance {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.ModelPerformance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.ModelPerformance()
        value.f1Score = try reader["F1Score"].readIfPresent()
        value.recall = try reader["Recall"].readIfPresent()
        value.precision = try reader["Precision"].readIfPresent()
        return value
    }
}

extension LookoutVisionClientTypes.ProjectMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.ProjectMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.ProjectMetadata()
        value.projectArn = try reader["ProjectArn"].readIfPresent()
        value.projectName = try reader["ProjectName"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension LookoutVisionClientTypes.DatasetDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.DatasetDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.DatasetDescription()
        value.projectName = try reader["ProjectName"].readIfPresent()
        value.datasetType = try reader["DatasetType"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.imageStats = try reader["ImageStats"].readIfPresent(with: LookoutVisionClientTypes.DatasetImageStats.read(from:))
        return value
    }
}

extension LookoutVisionClientTypes.DatasetImageStats {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.DatasetImageStats {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.DatasetImageStats()
        value.total = try reader["Total"].readIfPresent()
        value.labeled = try reader["Labeled"].readIfPresent()
        value.normal = try reader["Normal"].readIfPresent()
        value.anomaly = try reader["Anomaly"].readIfPresent()
        return value
    }
}

extension LookoutVisionClientTypes.ModelDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.ModelDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.ModelDescription()
        value.modelVersion = try reader["ModelVersion"].readIfPresent()
        value.modelArn = try reader["ModelArn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.performance = try reader["Performance"].readIfPresent(with: LookoutVisionClientTypes.ModelPerformance.read(from:))
        value.outputConfig = try reader["OutputConfig"].readIfPresent(with: LookoutVisionClientTypes.OutputConfig.read(from:))
        value.evaluationManifest = try reader["EvaluationManifest"].readIfPresent(with: LookoutVisionClientTypes.OutputS3Object.read(from:))
        value.evaluationResult = try reader["EvaluationResult"].readIfPresent(with: LookoutVisionClientTypes.OutputS3Object.read(from:))
        value.evaluationEndTimestamp = try reader["EvaluationEndTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.minInferenceUnits = try reader["MinInferenceUnits"].readIfPresent()
        value.maxInferenceUnits = try reader["MaxInferenceUnits"].readIfPresent()
        return value
    }
}

extension LookoutVisionClientTypes.OutputS3Object {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.OutputS3Object {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.OutputS3Object()
        value.bucket = try reader["Bucket"].readIfPresent() ?? ""
        value.key = try reader["Key"].readIfPresent() ?? ""
        return value
    }
}

extension LookoutVisionClientTypes.OutputConfig {

    static func write(value: LookoutVisionClientTypes.OutputConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Location"].write(value.s3Location, with: LookoutVisionClientTypes.S3Location.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.OutputConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.OutputConfig()
        value.s3Location = try reader["S3Location"].readIfPresent(with: LookoutVisionClientTypes.S3Location.read(from:))
        return value
    }
}

extension LookoutVisionClientTypes.S3Location {

    static func write(value: LookoutVisionClientTypes.S3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bucket"].write(value.bucket)
        try writer["Prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.S3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.S3Location()
        value.bucket = try reader["Bucket"].readIfPresent() ?? ""
        value.`prefix` = try reader["Prefix"].readIfPresent()
        return value
    }
}

extension LookoutVisionClientTypes.ModelPackagingDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.ModelPackagingDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.ModelPackagingDescription()
        value.jobName = try reader["JobName"].readIfPresent()
        value.projectName = try reader["ProjectName"].readIfPresent()
        value.modelVersion = try reader["ModelVersion"].readIfPresent()
        value.modelPackagingConfiguration = try reader["ModelPackagingConfiguration"].readIfPresent(with: LookoutVisionClientTypes.ModelPackagingConfiguration.read(from:))
        value.modelPackagingJobDescription = try reader["ModelPackagingJobDescription"].readIfPresent()
        value.modelPackagingMethod = try reader["ModelPackagingMethod"].readIfPresent()
        value.modelPackagingOutputDetails = try reader["ModelPackagingOutputDetails"].readIfPresent(with: LookoutVisionClientTypes.ModelPackagingOutputDetails.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension LookoutVisionClientTypes.ModelPackagingOutputDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.ModelPackagingOutputDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.ModelPackagingOutputDetails()
        value.greengrass = try reader["Greengrass"].readIfPresent(with: LookoutVisionClientTypes.GreengrassOutputDetails.read(from:))
        return value
    }
}

extension LookoutVisionClientTypes.GreengrassOutputDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.GreengrassOutputDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.GreengrassOutputDetails()
        value.componentVersionArn = try reader["ComponentVersionArn"].readIfPresent()
        value.componentName = try reader["ComponentName"].readIfPresent()
        value.componentVersion = try reader["ComponentVersion"].readIfPresent()
        return value
    }
}

extension LookoutVisionClientTypes.ModelPackagingConfiguration {

    static func write(value: LookoutVisionClientTypes.ModelPackagingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Greengrass"].write(value.greengrass, with: LookoutVisionClientTypes.GreengrassConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.ModelPackagingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.ModelPackagingConfiguration()
        value.greengrass = try reader["Greengrass"].readIfPresent(with: LookoutVisionClientTypes.GreengrassConfiguration.read(from:))
        return value
    }
}

extension LookoutVisionClientTypes.GreengrassConfiguration {

    static func write(value: LookoutVisionClientTypes.GreengrassConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CompilerOptions"].write(value.compilerOptions)
        try writer["ComponentDescription"].write(value.componentDescription)
        try writer["ComponentName"].write(value.componentName)
        try writer["ComponentVersion"].write(value.componentVersion)
        try writer["S3OutputLocation"].write(value.s3OutputLocation, with: LookoutVisionClientTypes.S3Location.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: LookoutVisionClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetDevice"].write(value.targetDevice)
        try writer["TargetPlatform"].write(value.targetPlatform, with: LookoutVisionClientTypes.TargetPlatform.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.GreengrassConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.GreengrassConfiguration()
        value.compilerOptions = try reader["CompilerOptions"].readIfPresent()
        value.targetDevice = try reader["TargetDevice"].readIfPresent()
        value.targetPlatform = try reader["TargetPlatform"].readIfPresent(with: LookoutVisionClientTypes.TargetPlatform.read(from:))
        value.s3OutputLocation = try reader["S3OutputLocation"].readIfPresent(with: LookoutVisionClientTypes.S3Location.read(from:))
        value.componentName = try reader["ComponentName"].readIfPresent() ?? ""
        value.componentVersion = try reader["ComponentVersion"].readIfPresent()
        value.componentDescription = try reader["ComponentDescription"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: LookoutVisionClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LookoutVisionClientTypes.Tag {

    static func write(value: LookoutVisionClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension LookoutVisionClientTypes.TargetPlatform {

    static func write(value: LookoutVisionClientTypes.TargetPlatform?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Accelerator"].write(value.accelerator)
        try writer["Arch"].write(value.arch)
        try writer["Os"].write(value.os)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.TargetPlatform {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.TargetPlatform()
        value.os = try reader["Os"].readIfPresent() ?? .sdkUnknown("")
        value.arch = try reader["Arch"].readIfPresent() ?? .sdkUnknown("")
        value.accelerator = try reader["Accelerator"].readIfPresent()
        return value
    }
}

extension LookoutVisionClientTypes.ProjectDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.ProjectDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.ProjectDescription()
        value.projectArn = try reader["ProjectArn"].readIfPresent()
        value.projectName = try reader["ProjectName"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.datasets = try reader["Datasets"].readListIfPresent(memberReadingClosure: LookoutVisionClientTypes.DatasetMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LookoutVisionClientTypes.DetectAnomalyResult {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.DetectAnomalyResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.DetectAnomalyResult()
        value.source = try reader["Source"].readIfPresent(with: LookoutVisionClientTypes.ImageSource.read(from:))
        value.isAnomalous = try reader["IsAnomalous"].readIfPresent()
        value.confidence = try reader["Confidence"].readIfPresent()
        value.anomalies = try reader["Anomalies"].readListIfPresent(memberReadingClosure: LookoutVisionClientTypes.Anomaly.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.anomalyMask = try reader["AnomalyMask"].readIfPresent()
        return value
    }
}

extension LookoutVisionClientTypes.Anomaly {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.Anomaly {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.Anomaly()
        value.name = try reader["Name"].readIfPresent()
        value.pixelAnomaly = try reader["PixelAnomaly"].readIfPresent(with: LookoutVisionClientTypes.PixelAnomaly.read(from:))
        return value
    }
}

extension LookoutVisionClientTypes.PixelAnomaly {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.PixelAnomaly {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.PixelAnomaly()
        value.totalPercentageArea = try reader["TotalPercentageArea"].readIfPresent()
        value.color = try reader["Color"].readIfPresent()
        return value
    }
}

extension LookoutVisionClientTypes.ImageSource {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.ImageSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.ImageSource()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension LookoutVisionClientTypes.ModelPackagingJobMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutVisionClientTypes.ModelPackagingJobMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutVisionClientTypes.ModelPackagingJobMetadata()
        value.jobName = try reader["JobName"].readIfPresent()
        value.projectName = try reader["ProjectName"].readIfPresent()
        value.modelVersion = try reader["ModelVersion"].readIfPresent()
        value.modelPackagingJobDescription = try reader["ModelPackagingJobDescription"].readIfPresent()
        value.modelPackagingMethod = try reader["ModelPackagingMethod"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension LookoutVisionClientTypes.DatasetSource {

    static func write(value: LookoutVisionClientTypes.DatasetSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroundTruthManifest"].write(value.groundTruthManifest, with: LookoutVisionClientTypes.DatasetGroundTruthManifest.write(value:to:))
    }
}

extension LookoutVisionClientTypes.DatasetGroundTruthManifest {

    static func write(value: LookoutVisionClientTypes.DatasetGroundTruthManifest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Object"].write(value.s3Object, with: LookoutVisionClientTypes.InputS3Object.write(value:to:))
    }
}

extension LookoutVisionClientTypes.InputS3Object {

    static func write(value: LookoutVisionClientTypes.InputS3Object?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bucket"].write(value.bucket)
        try writer["Key"].write(value.key)
        try writer["VersionId"].write(value.versionId)
    }
}

public enum LookoutVisionClientTypes {}
