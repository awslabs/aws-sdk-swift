// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are not authorized to perform the action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LookoutVisionClientTypes.Anomaly: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case pixelAnomaly = "PixelAnomaly"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pixelAnomaly = self.pixelAnomaly {
            try encodeContainer.encode(pixelAnomaly, forKey: .pixelAnomaly)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pixelAnomalyDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.PixelAnomaly.self, forKey: .pixelAnomaly)
        pixelAnomaly = pixelAnomalyDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Information about an anomaly type found on an image by an image segmentation model. For more information, see [DetectAnomalies].
    public struct Anomaly: Swift.Equatable {
        /// The name of an anomaly type found in an image. Name maps to an anomaly type in the training dataset, apart from the anomaly type background. The service automatically inserts the background anomaly type into the response from DetectAnomalies.
        public var name: Swift.String?
        /// Information about the pixel mask that covers an anomaly type.
        public var pixelAnomaly: LookoutVisionClientTypes.PixelAnomaly?

        public init (
            name: Swift.String? = nil,
            pixelAnomaly: LookoutVisionClientTypes.PixelAnomaly? = nil
        )
        {
            self.name = name
            self.pixelAnomaly = pixelAnomaly
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The update or deletion of a resource caused an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the resource.
    /// This member is required.
    public var resourceType: LookoutVisionClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: LookoutVisionClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: LookoutVisionClientTypes.ResourceType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetSource = "DatasetSource"
        case datasetType = "DatasetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetSource = self.datasetSource {
            try encodeContainer.encode(datasetSource, forKey: .datasetSource)
        }
        if let datasetType = self.datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
    }
}

extension CreateDatasetInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/datasets"
    }
}

public struct CreateDatasetInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to CreateDataset completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from CreateDataset. In this case, safely retry your call to CreateDataset by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple dataset creation requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to CreateDataset. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The location of the manifest file that Amazon Lookout for Vision uses to create the dataset. If you don't specify DatasetSource, an empty dataset is created and the operation synchronously returns. Later, you can add JSON Lines by calling [UpdateDatasetEntries]. If you specify a value for DataSource, the manifest at the S3 location is validated and used to create the dataset. The call to CreateDataset is asynchronous and might take a while to complete. To find out the current status, Check the value of Status returned in a call to [DescribeDataset].
    public var datasetSource: LookoutVisionClientTypes.DatasetSource?
    /// The type of the dataset. Specify train for a training dataset. Specify test for a test dataset.
    /// This member is required.
    public var datasetType: Swift.String?
    /// The name of the project in which you want to create a dataset.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        datasetSource: LookoutVisionClientTypes.DatasetSource? = nil,
        datasetType: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.datasetSource = datasetSource
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

struct CreateDatasetInputBody: Swift.Equatable {
    let datasetType: Swift.String?
    let datasetSource: LookoutVisionClientTypes.DatasetSource?
}

extension CreateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetSource = "DatasetSource"
        case datasetType = "DatasetType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let datasetSourceDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetSource.self, forKey: .datasetSource)
        datasetSource = datasetSourceDecoded
    }
}

extension CreateDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDatasetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetMetadata = output.datasetMetadata
        } else {
            self.datasetMetadata = nil
        }
    }
}

public struct CreateDatasetOutputResponse: Swift.Equatable {
    /// Information about the dataset.
    public var datasetMetadata: LookoutVisionClientTypes.DatasetMetadata?

    public init (
        datasetMetadata: LookoutVisionClientTypes.DatasetMetadata? = nil
    )
    {
        self.datasetMetadata = datasetMetadata
    }
}

struct CreateDatasetOutputResponseBody: Swift.Equatable {
    let datasetMetadata: LookoutVisionClientTypes.DatasetMetadata?
}

extension CreateDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetMetadata = "DatasetMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetMetadataDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetMetadata.self, forKey: .datasetMetadata)
        datasetMetadata = datasetMetadataDecoded
    }
}

extension CreateModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case outputConfig = "OutputConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let outputConfig = self.outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateModelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/models"
    }
}

public struct CreateModelInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to CreateModel completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from CreateModel. In this case, safely retry your call to CreateModel by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from starting multiple training jobs. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to CreateModel. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// A description for the version of the model.
    public var description: Swift.String?
    /// The identifier for your AWS KMS key. The key is used to encrypt training and test images copied into the service for model training. Your source images are unaffected. If this parameter is not specified, the copied images are encrypted by a key that AWS owns and manages.
    public var kmsKeyId: Swift.String?
    /// The location where Amazon Lookout for Vision saves the training results.
    /// This member is required.
    public var outputConfig: LookoutVisionClientTypes.OutputConfig?
    /// The name of the project in which you want to create a model version.
    /// This member is required.
    public var projectName: Swift.String?
    /// A set of tags (key-value pairs) that you want to attach to the model.
    public var tags: [LookoutVisionClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        outputConfig: LookoutVisionClientTypes.OutputConfig? = nil,
        projectName: Swift.String? = nil,
        tags: [LookoutVisionClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.outputConfig = outputConfig
        self.projectName = projectName
        self.tags = tags
    }
}

struct CreateModelInputBody: Swift.Equatable {
    let description: Swift.String?
    let outputConfig: LookoutVisionClientTypes.OutputConfig?
    let kmsKeyId: Swift.String?
    let tags: [LookoutVisionClientTypes.Tag]?
}

extension CreateModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case outputConfig = "OutputConfig"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.OutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([LookoutVisionClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LookoutVisionClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LookoutVisionClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateModelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelMetadata = output.modelMetadata
        } else {
            self.modelMetadata = nil
        }
    }
}

public struct CreateModelOutputResponse: Swift.Equatable {
    /// The response from a call to CreateModel.
    public var modelMetadata: LookoutVisionClientTypes.ModelMetadata?

    public init (
        modelMetadata: LookoutVisionClientTypes.ModelMetadata? = nil
    )
    {
        self.modelMetadata = modelMetadata
    }
}

struct CreateModelOutputResponseBody: Swift.Equatable {
    let modelMetadata: LookoutVisionClientTypes.ModelMetadata?
}

extension CreateModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelMetadata = "ModelMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelMetadataDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelMetadata.self, forKey: .modelMetadata)
        modelMetadata = modelMetadataDecoded
    }
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectName = "ProjectName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }
}

extension CreateProjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-11-20/projects"
    }
}

public struct CreateProjectInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to CreateProject completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from CreateProject. In this case, safely retry your call to CreateProject by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple project creation requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to CreateProject. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The name for the project.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectName = projectName
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let projectName: Swift.String?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectName = "ProjectName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
    }
}

extension CreateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateProjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.projectMetadata = output.projectMetadata
        } else {
            self.projectMetadata = nil
        }
    }
}

public struct CreateProjectOutputResponse: Swift.Equatable {
    /// Information about the project.
    public var projectMetadata: LookoutVisionClientTypes.ProjectMetadata?

    public init (
        projectMetadata: LookoutVisionClientTypes.ProjectMetadata? = nil
    )
    {
        self.projectMetadata = projectMetadata
    }
}

struct CreateProjectOutputResponseBody: Swift.Equatable {
    let projectMetadata: LookoutVisionClientTypes.ProjectMetadata?
}

extension CreateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectMetadata = "ProjectMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectMetadataDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ProjectMetadata.self, forKey: .projectMetadata)
        projectMetadata = projectMetadataDecoded
    }
}

extension LookoutVisionClientTypes.DatasetDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case datasetType = "DatasetType"
        case imageStats = "ImageStats"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case projectName = "ProjectName"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encodeTimestamp(creationTimestamp, format: .epochSeconds, forKey: .creationTimestamp)
        }
        if let datasetType = self.datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let imageStats = self.imageStats {
            try encodeContainer.encode(imageStats, forKey: .imageStats)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let imageStatsDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetImageStats.self, forKey: .imageStats)
        imageStats = imageStatsDecoded
    }
}

extension LookoutVisionClientTypes {
    /// The description for a dataset. For more information, see [DescribeDataset].
    public struct DatasetDescription: Swift.Equatable {
        /// The Unix timestamp for the time and date that the dataset was created.
        public var creationTimestamp: ClientRuntime.Date?
        /// The type of the dataset. The value train represents a training dataset or single dataset project. The value test represents a test dataset.
        public var datasetType: Swift.String?
        /// Statistics about the images in a dataset.
        public var imageStats: LookoutVisionClientTypes.DatasetImageStats?
        /// The Unix timestamp for the date and time that the dataset was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The name of the project that contains the dataset.
        public var projectName: Swift.String?
        /// The status of the dataset.
        public var status: LookoutVisionClientTypes.DatasetStatus?
        /// The status message for the dataset.
        public var statusMessage: Swift.String?

        public init (
            creationTimestamp: ClientRuntime.Date? = nil,
            datasetType: Swift.String? = nil,
            imageStats: LookoutVisionClientTypes.DatasetImageStats? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            projectName: Swift.String? = nil,
            status: LookoutVisionClientTypes.DatasetStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.datasetType = datasetType
            self.imageStats = imageStats
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.projectName = projectName
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension LookoutVisionClientTypes.DatasetGroundTruthManifest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Object = "S3Object"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Object = self.s3Object {
            try encodeContainer.encode(s3Object, forKey: .s3Object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ObjectDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.InputS3Object.self, forKey: .s3Object)
        s3Object = s3ObjectDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Location information about a manifest file. You can use a manifest file to create a dataset.
    public struct DatasetGroundTruthManifest: Swift.Equatable {
        /// The S3 bucket location for the manifest file.
        public var s3Object: LookoutVisionClientTypes.InputS3Object?

        public init (
            s3Object: LookoutVisionClientTypes.InputS3Object? = nil
        )
        {
            self.s3Object = s3Object
        }
    }

}

extension LookoutVisionClientTypes.DatasetImageStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomaly = "Anomaly"
        case labeled = "Labeled"
        case normal = "Normal"
        case total = "Total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomaly = self.anomaly {
            try encodeContainer.encode(anomaly, forKey: .anomaly)
        }
        if let labeled = self.labeled {
            try encodeContainer.encode(labeled, forKey: .labeled)
        }
        if let normal = self.normal {
            try encodeContainer.encode(normal, forKey: .normal)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .total)
        total = totalDecoded
        let labeledDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .labeled)
        labeled = labeledDecoded
        let normalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .normal)
        normal = normalDecoded
        let anomalyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .anomaly)
        anomaly = anomalyDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Statistics about the images in a dataset.
    public struct DatasetImageStats: Swift.Equatable {
        /// the total number of images labeled as an anomaly.
        public var anomaly: Swift.Int?
        /// The total number of labeled images.
        public var labeled: Swift.Int?
        /// The total number of images labeled as normal.
        public var normal: Swift.Int?
        /// The total number of images in the dataset.
        public var total: Swift.Int?

        public init (
            anomaly: Swift.Int? = nil,
            labeled: Swift.Int? = nil,
            normal: Swift.Int? = nil,
            total: Swift.Int? = nil
        )
        {
            self.anomaly = anomaly
            self.labeled = labeled
            self.normal = normal
            self.total = total
        }
    }

}

extension LookoutVisionClientTypes.DatasetMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case datasetType = "DatasetType"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encodeTimestamp(creationTimestamp, format: .epochSeconds, forKey: .creationTimestamp)
        }
        if let datasetType = self.datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Summary information for an Amazon Lookout for Vision dataset. For more information, see [DescribeDataset] and [ProjectDescription].
    public struct DatasetMetadata: Swift.Equatable {
        /// The Unix timestamp for the date and time that the dataset was created.
        public var creationTimestamp: ClientRuntime.Date?
        /// The type of the dataset.
        public var datasetType: Swift.String?
        /// The status for the dataset.
        public var status: LookoutVisionClientTypes.DatasetStatus?
        /// The status message for the dataset.
        public var statusMessage: Swift.String?

        public init (
            creationTimestamp: ClientRuntime.Date? = nil,
            datasetType: Swift.String? = nil,
            status: LookoutVisionClientTypes.DatasetStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.datasetType = datasetType
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension LookoutVisionClientTypes.DatasetSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groundTruthManifest = "GroundTruthManifest"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groundTruthManifest = self.groundTruthManifest {
            try encodeContainer.encode(groundTruthManifest, forKey: .groundTruthManifest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groundTruthManifestDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetGroundTruthManifest.self, forKey: .groundTruthManifest)
        groundTruthManifest = groundTruthManifestDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Information about the location of a manifest file that Amazon Lookout for Vision uses to to create a dataset.
    public struct DatasetSource: Swift.Equatable {
        /// Location information for the manifest file.
        public var groundTruthManifest: LookoutVisionClientTypes.DatasetGroundTruthManifest?

        public init (
            groundTruthManifest: LookoutVisionClientTypes.DatasetGroundTruthManifest? = nil
        )
        {
            self.groundTruthManifest = groundTruthManifest
        }
    }

}

extension LookoutVisionClientTypes {
    public enum DatasetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createComplete
        case createFailed
        case createInProgress
        case deleteComplete
        case deleteFailed
        case deleteInProgress
        case updateComplete
        case updateFailedRollbackComplete
        case updateFailedRollbackInProgress
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetStatus] {
            return [
                .createComplete,
                .createFailed,
                .createInProgress,
                .deleteComplete,
                .deleteFailed,
                .deleteInProgress,
                .updateComplete,
                .updateFailedRollbackComplete,
                .updateFailedRollbackInProgress,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createComplete: return "CREATE_COMPLETE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteComplete: return "DELETE_COMPLETE"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateComplete: return "UPDATE_COMPLETE"
            case .updateFailedRollbackComplete: return "UPDATE_FAILED_ROLLBACK_COMPLETE"
            case .updateFailedRollbackInProgress: return "UPDATE_FAILED_ROLLBACK_IN_PROGRESS"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetStatus(rawValue: rawValue) ?? DatasetStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeleteDatasetInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let datasetType = datasetType else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/datasets/\(datasetType.urlPercentEncoding())"
    }
}

public struct DeleteDatasetInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to DeleteDataset completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from DeleteDataset. In this case, safely retry your call to DeleteDataset by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple deletetion requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to DeleteDataset. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The type of the dataset to delete. Specify train to delete the training dataset. Specify test to delete the test dataset. To delete the dataset in a single dataset project, specify train.
    /// This member is required.
    public var datasetType: Swift.String?
    /// The name of the project that contains the dataset that you want to delete.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        datasetType: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
}

extension DeleteDatasetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDatasetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteModelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let modelVersion = modelVersion else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/models/\(modelVersion.urlPercentEncoding())"
    }
}

public struct DeleteModelInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to DeleteModel completes only once. You choose the value to pass. For example, an issue might prevent you from getting a response from DeleteModel. In this case, safely retry your call to DeleteModel by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple model deletion requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different
    ///
    ///
    /// value for ClientToken is considered a new call to DeleteModel. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The version of the model that you want to delete.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// The name of the project that contains the model that you want to delete.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct DeleteModelInputBody: Swift.Equatable {
}

extension DeleteModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteModelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelArn = output.modelArn
        } else {
            self.modelArn = nil
        }
    }
}

public struct DeleteModelOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the model that was deleted.
    public var modelArn: Swift.String?

    public init (
        modelArn: Swift.String? = nil
    )
    {
        self.modelArn = modelArn
    }
}

struct DeleteModelOutputResponseBody: Swift.Equatable {
    let modelArn: Swift.String?
}

extension DeleteModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelArn = "ModelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
    }
}

extension DeleteProjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())"
    }
}

public struct DeleteProjectInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to DeleteProject completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from DeleteProject. In this case, safely retry your call to DeleteProject by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple project deletion requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to DeleteProject. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The name of the project to delete.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectName = projectName
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
}

extension DeleteProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteProjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.projectArn = output.projectArn
        } else {
            self.projectArn = nil
        }
    }
}

public struct DeleteProjectOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project that was deleted.
    public var projectArn: Swift.String?

    public init (
        projectArn: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
    }
}

struct DeleteProjectOutputResponseBody: Swift.Equatable {
    let projectArn: Swift.String?
}

extension DeleteProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn = "ProjectArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension DescribeDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let datasetType = datasetType else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/datasets/\(datasetType.urlPercentEncoding())"
    }
}

public struct DescribeDatasetInput: Swift.Equatable {
    /// The type of the dataset to describe. Specify train to describe the training dataset. Specify test to describe the test dataset. If you have a single dataset project, specify train
    /// This member is required.
    public var datasetType: Swift.String?
    /// The name of the project that contains the dataset that you want to describe.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        datasetType: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

struct DescribeDatasetInputBody: Swift.Equatable {
}

extension DescribeDatasetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDatasetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetDescription = output.datasetDescription
        } else {
            self.datasetDescription = nil
        }
    }
}

public struct DescribeDatasetOutputResponse: Swift.Equatable {
    /// The description of the requested dataset.
    public var datasetDescription: LookoutVisionClientTypes.DatasetDescription?

    public init (
        datasetDescription: LookoutVisionClientTypes.DatasetDescription? = nil
    )
    {
        self.datasetDescription = datasetDescription
    }
}

struct DescribeDatasetOutputResponseBody: Swift.Equatable {
    let datasetDescription: LookoutVisionClientTypes.DatasetDescription?
}

extension DescribeDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetDescription = "DatasetDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetDescriptionDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetDescription.self, forKey: .datasetDescription)
        datasetDescription = datasetDescriptionDecoded
    }
}

extension DescribeModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let modelVersion = modelVersion else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/models/\(modelVersion.urlPercentEncoding())"
    }
}

public struct DescribeModelInput: Swift.Equatable {
    /// The version of the model that you want to describe.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// The project that contains the version of a model that you want to describe.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct DescribeModelInputBody: Swift.Equatable {
}

extension DescribeModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeModelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelDescription = output.modelDescription
        } else {
            self.modelDescription = nil
        }
    }
}

public struct DescribeModelOutputResponse: Swift.Equatable {
    /// Contains the description of the model.
    public var modelDescription: LookoutVisionClientTypes.ModelDescription?

    public init (
        modelDescription: LookoutVisionClientTypes.ModelDescription? = nil
    )
    {
        self.modelDescription = modelDescription
    }
}

struct DescribeModelOutputResponseBody: Swift.Equatable {
    let modelDescription: LookoutVisionClientTypes.ModelDescription?
}

extension DescribeModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelDescription = "ModelDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelDescriptionDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelDescription.self, forKey: .modelDescription)
        modelDescription = modelDescriptionDecoded
    }
}

extension DescribeModelPackagingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let jobName = jobName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/modelpackagingjobs/\(jobName.urlPercentEncoding())"
    }
}

public struct DescribeModelPackagingJobInput: Swift.Equatable {
    /// The job name for the model packaging job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The name of the project that contains the model packaging job that you want to describe.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        jobName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.jobName = jobName
        self.projectName = projectName
    }
}

struct DescribeModelPackagingJobInputBody: Swift.Equatable {
}

extension DescribeModelPackagingJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeModelPackagingJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeModelPackagingJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeModelPackagingJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeModelPackagingJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeModelPackagingJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelPackagingDescription = output.modelPackagingDescription
        } else {
            self.modelPackagingDescription = nil
        }
    }
}

public struct DescribeModelPackagingJobOutputResponse: Swift.Equatable {
    /// The description of the model packaging job.
    public var modelPackagingDescription: LookoutVisionClientTypes.ModelPackagingDescription?

    public init (
        modelPackagingDescription: LookoutVisionClientTypes.ModelPackagingDescription? = nil
    )
    {
        self.modelPackagingDescription = modelPackagingDescription
    }
}

struct DescribeModelPackagingJobOutputResponseBody: Swift.Equatable {
    let modelPackagingDescription: LookoutVisionClientTypes.ModelPackagingDescription?
}

extension DescribeModelPackagingJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelPackagingDescription = "ModelPackagingDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelPackagingDescriptionDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelPackagingDescription.self, forKey: .modelPackagingDescription)
        modelPackagingDescription = modelPackagingDescriptionDecoded
    }
}

extension DescribeProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())"
    }
}

public struct DescribeProjectInput: Swift.Equatable {
    /// The name of the project that you want to describe.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        projectName: Swift.String? = nil
    )
    {
        self.projectName = projectName
    }
}

struct DescribeProjectInputBody: Swift.Equatable {
}

extension DescribeProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeProjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.projectDescription = output.projectDescription
        } else {
            self.projectDescription = nil
        }
    }
}

public struct DescribeProjectOutputResponse: Swift.Equatable {
    /// The description of the project.
    public var projectDescription: LookoutVisionClientTypes.ProjectDescription?

    public init (
        projectDescription: LookoutVisionClientTypes.ProjectDescription? = nil
    )
    {
        self.projectDescription = projectDescription
    }
}

struct DescribeProjectOutputResponseBody: Swift.Equatable {
    let projectDescription: LookoutVisionClientTypes.ProjectDescription?
}

extension DescribeProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectDescription = "ProjectDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDescriptionDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ProjectDescription.self, forKey: .projectDescription)
        projectDescription = projectDescriptionDecoded
    }
}

public struct DetectAnomaliesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetectAnomaliesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetectAnomaliesInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<DetectAnomaliesOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodydata = body
            let bodybody = ClientRuntime.HttpBody.stream(bodydata)
            input.builder.withBody(bodybody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetectAnomaliesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetectAnomaliesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension DetectAnomaliesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body.toBytes().getData(), forKey: .body)
        }
    }
}

extension DetectAnomaliesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        return items
    }
}

extension DetectAnomaliesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let modelVersion = modelVersion else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/models/\(modelVersion.urlPercentEncoding())/detect"
    }
}

public struct DetectAnomaliesInput: Swift.Equatable {
    /// The unencrypted image bytes that you want to analyze.
    /// This member is required.
    public var body: ClientRuntime.ByteStream?
    /// The type of the image passed in Body. Valid values are image/png (PNG format images) and image/jpeg (JPG format images).
    /// This member is required.
    public var contentType: Swift.String?
    /// The version of the model that you want to use.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// The name of the project that contains the model version that you want to use.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        body: ClientRuntime.ByteStream? = nil,
        contentType: Swift.String? = nil,
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.body = body
        self.contentType = contentType
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct DetectAnomaliesInputBody: Swift.Equatable {
    let body: ClientRuntime.ByteStream?
}

extension DetectAnomaliesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
        body = bodyDecoded
    }
}

extension DetectAnomaliesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectAnomaliesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DetectAnomaliesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectAnomaliesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DetectAnomaliesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectAnomalyResult = output.detectAnomalyResult
        } else {
            self.detectAnomalyResult = nil
        }
    }
}

public struct DetectAnomaliesOutputResponse: Swift.Equatable {
    /// The results of the DetectAnomalies operation.
    public var detectAnomalyResult: LookoutVisionClientTypes.DetectAnomalyResult?

    public init (
        detectAnomalyResult: LookoutVisionClientTypes.DetectAnomalyResult? = nil
    )
    {
        self.detectAnomalyResult = detectAnomalyResult
    }
}

struct DetectAnomaliesOutputResponseBody: Swift.Equatable {
    let detectAnomalyResult: LookoutVisionClientTypes.DetectAnomalyResult?
}

extension DetectAnomaliesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectAnomalyResult = "DetectAnomalyResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectAnomalyResultDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DetectAnomalyResult.self, forKey: .detectAnomalyResult)
        detectAnomalyResult = detectAnomalyResultDecoded
    }
}

extension LookoutVisionClientTypes.DetectAnomalyResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalies = "Anomalies"
        case anomalyMask = "AnomalyMask"
        case confidence = "Confidence"
        case isAnomalous = "IsAnomalous"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalies = anomalies {
            var anomaliesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .anomalies)
            for anomaly0 in anomalies {
                try anomaliesContainer.encode(anomaly0)
            }
        }
        if let anomalyMask = self.anomalyMask {
            try encodeContainer.encode(anomalyMask.base64EncodedString(), forKey: .anomalyMask)
        }
        if let confidence = self.confidence {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if isAnomalous != false {
            try encodeContainer.encode(isAnomalous, forKey: .isAnomalous)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ImageSource.self, forKey: .source)
        source = sourceDecoded
        let isAnomalousDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAnomalous) ?? false
        isAnomalous = isAnomalousDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .confidence)
        confidence = confidenceDecoded
        let anomaliesContainer = try containerValues.decodeIfPresent([LookoutVisionClientTypes.Anomaly?].self, forKey: .anomalies)
        var anomaliesDecoded0:[LookoutVisionClientTypes.Anomaly]? = nil
        if let anomaliesContainer = anomaliesContainer {
            anomaliesDecoded0 = [LookoutVisionClientTypes.Anomaly]()
            for structure0 in anomaliesContainer {
                if let structure0 = structure0 {
                    anomaliesDecoded0?.append(structure0)
                }
            }
        }
        anomalies = anomaliesDecoded0
        let anomalyMaskDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .anomalyMask)
        anomalyMask = anomalyMaskDecoded
    }
}

extension LookoutVisionClientTypes {
    /// The prediction results from a call to [DetectAnomalies]. DetectAnomalyResult includes classification information for the prediction (IsAnomalous and Confidence). If the model you use is an image segementation model, DetectAnomalyResult also includes segmentation information (Anomalies and AnomalyMask). Classification information is calculated separately from segmentation information and you shouldn't assume a relationship between them.
    public struct DetectAnomalyResult: Swift.Equatable {
        /// If the model is an image segmentation model, Anomalies contains a list of anomaly types found in the image. There is one entry for each type of anomaly found (even if multiple instances of an anomaly type exist on the image). The first element in the list is always an anomaly type representing the image background ('background') and shouldn't be considered an anomaly. Amazon Lookout for Vision automatically add the background anomaly type to the response, and you don't need to declare a background anomaly type in your dataset. If the list has one entry ('background'), no anomalies were found on the image. An image classification model doesn't return an Anomalies list.
        public var anomalies: [LookoutVisionClientTypes.Anomaly]?
        /// If the model is an image segmentation model, AnomalyMask contains pixel masks that covers all anomaly types found on the image. Each anomaly type has a different mask color. To map a color to an anomaly type, see the color field of the [PixelAnomaly] object. An image classification model doesn't return an Anomalies list.
        public var anomalyMask: ClientRuntime.Data?
        /// The confidence that Lookout for Vision has in the accuracy of the classification in IsAnomalous.
        public var confidence: Swift.Float?
        /// True if Amazon Lookout for Vision classifies the image as containing an anomaly, otherwise false.
        public var isAnomalous: Swift.Bool
        /// The source of the image that was analyzed. direct means that the images was supplied from the local computer. No other values are supported.
        public var source: LookoutVisionClientTypes.ImageSource?

        public init (
            anomalies: [LookoutVisionClientTypes.Anomaly]? = nil,
            anomalyMask: ClientRuntime.Data? = nil,
            confidence: Swift.Float? = nil,
            isAnomalous: Swift.Bool = false,
            source: LookoutVisionClientTypes.ImageSource? = nil
        )
        {
            self.anomalies = anomalies
            self.anomalyMask = anomalyMask
            self.confidence = confidence
            self.isAnomalous = isAnomalous
            self.source = source
        }
    }

}

extension LookoutVisionClientTypes.GreengrassConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compilerOptions = "CompilerOptions"
        case componentDescription = "ComponentDescription"
        case componentName = "ComponentName"
        case componentVersion = "ComponentVersion"
        case s3OutputLocation = "S3OutputLocation"
        case tags = "Tags"
        case targetDevice = "TargetDevice"
        case targetPlatform = "TargetPlatform"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compilerOptions = self.compilerOptions {
            try encodeContainer.encode(compilerOptions, forKey: .compilerOptions)
        }
        if let componentDescription = self.componentDescription {
            try encodeContainer.encode(componentDescription, forKey: .componentDescription)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentVersion = self.componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let s3OutputLocation = self.s3OutputLocation {
            try encodeContainer.encode(s3OutputLocation, forKey: .s3OutputLocation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetDevice = self.targetDevice {
            try encodeContainer.encode(targetDevice.rawValue, forKey: .targetDevice)
        }
        if let targetPlatform = self.targetPlatform {
            try encodeContainer.encode(targetPlatform, forKey: .targetPlatform)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compilerOptionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .compilerOptions)
        compilerOptions = compilerOptionsDecoded
        let targetDeviceDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.TargetDevice.self, forKey: .targetDevice)
        targetDevice = targetDeviceDecoded
        let targetPlatformDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.TargetPlatform.self, forKey: .targetPlatform)
        targetPlatform = targetPlatformDecoded
        let s3OutputLocationDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.S3Location.self, forKey: .s3OutputLocation)
        s3OutputLocation = s3OutputLocationDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let componentDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentDescription)
        componentDescription = componentDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([LookoutVisionClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LookoutVisionClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LookoutVisionClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LookoutVisionClientTypes {
    /// Configuration information for the AWS IoT Greengrass component created in a model packaging job. For more information, see [StartModelPackagingJob]. You can't specify a component with the same ComponentName and Componentversion as an existing component with the same component name and component version.
    public struct GreengrassConfiguration: Swift.Equatable {
        /// Additional compiler options for the Greengrass component. Currently, only NVIDIA Graphics Processing Units (GPU) and CPU accelerators are supported. If you specify TargetDevice, don't specify CompilerOptions. For more information, see Compiler options in the Amazon Lookout for Vision Developer Guide.
        public var compilerOptions: Swift.String?
        /// A description for the AWS IoT Greengrass component.
        public var componentDescription: Swift.String?
        /// A name for the AWS IoT Greengrass component.
        /// This member is required.
        public var componentName: Swift.String?
        /// A Version for the AWS IoT Greengrass component. If you don't provide a value, a default value of  Model Version.0.0 is used.
        public var componentVersion: Swift.String?
        /// An S3 location in which Lookout for Vision stores the component artifacts.
        /// This member is required.
        public var s3OutputLocation: LookoutVisionClientTypes.S3Location?
        /// A set of tags (key-value pairs) that you want to attach to the AWS IoT Greengrass component.
        public var tags: [LookoutVisionClientTypes.Tag]?
        /// The target device for the model. Currently the only supported value is jetson_xavier. If you specify TargetDevice, you can't specify TargetPlatform.
        public var targetDevice: LookoutVisionClientTypes.TargetDevice?
        /// The target platform for the model. If you specify TargetPlatform, you can't specify TargetDevice.
        public var targetPlatform: LookoutVisionClientTypes.TargetPlatform?

        public init (
            compilerOptions: Swift.String? = nil,
            componentDescription: Swift.String? = nil,
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            s3OutputLocation: LookoutVisionClientTypes.S3Location? = nil,
            tags: [LookoutVisionClientTypes.Tag]? = nil,
            targetDevice: LookoutVisionClientTypes.TargetDevice? = nil,
            targetPlatform: LookoutVisionClientTypes.TargetPlatform? = nil
        )
        {
            self.compilerOptions = compilerOptions
            self.componentDescription = componentDescription
            self.componentName = componentName
            self.componentVersion = componentVersion
            self.s3OutputLocation = s3OutputLocation
            self.tags = tags
            self.targetDevice = targetDevice
            self.targetPlatform = targetPlatform
        }
    }

}

extension LookoutVisionClientTypes.GreengrassOutputDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case componentVersion = "ComponentVersion"
        case componentVersionArn = "ComponentVersionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentVersion = self.componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let componentVersionArn = self.componentVersionArn {
            try encodeContainer.encode(componentVersionArn, forKey: .componentVersionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersionArn)
        componentVersionArn = componentVersionArnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Information about the AWS IoT Greengrass component created by a model packaging job.
    public struct GreengrassOutputDetails: Swift.Equatable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of the component.
        public var componentVersionArn: Swift.String?

        public init (
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            componentVersionArn: Swift.String? = nil
        )
        {
            self.componentName = componentName
            self.componentVersion = componentVersion
            self.componentVersionArn = componentVersionArn
        }
    }

}

extension LookoutVisionClientTypes.ImageSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension LookoutVisionClientTypes {
    /// The source for an image.
    public struct ImageSource: Swift.Equatable {
        /// The type of the image.
        public var type: Swift.String?

        public init (
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension LookoutVisionClientTypes.InputS3Object: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case key = "Key"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Amazon S3 Location information for an input manifest file.
    public struct InputS3Object: Swift.Equatable {
        /// The Amazon S3 bucket that contains the manifest.
        /// This member is required.
        public var bucket: Swift.String?
        /// The name and location of the manifest file withiin the bucket.
        /// This member is required.
        public var key: Swift.String?
        /// The version ID of the bucket.
        public var versionId: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.versionId = versionId
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Lookout for Vision experienced a service issue. Try your call again.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// The period of time, in seconds, before the operation can be retried.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDatasetEntriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let sourceRefContains = sourceRefContains {
                let sourceRefContainsQueryItem = ClientRuntime.URLQueryItem(name: "sourceRefContains".urlPercentEncoding(), value: Swift.String(sourceRefContains).urlPercentEncoding())
                items.append(sourceRefContainsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let labeled = labeled {
                let labeledQueryItem = ClientRuntime.URLQueryItem(name: "labeled".urlPercentEncoding(), value: Swift.String(labeled).urlPercentEncoding())
                items.append(labeledQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let beforeCreationDate = beforeCreationDate {
                let beforeCreationDateQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: beforeCreationDate)).urlPercentEncoding())
                items.append(beforeCreationDateQueryItem)
            }
            if let afterCreationDate = afterCreationDate {
                let afterCreationDateQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: afterCreationDate)).urlPercentEncoding())
                items.append(afterCreationDateQueryItem)
            }
            if let anomalyClass = anomalyClass {
                let anomalyClassQueryItem = ClientRuntime.URLQueryItem(name: "anomalyClass".urlPercentEncoding(), value: Swift.String(anomalyClass).urlPercentEncoding())
                items.append(anomalyClassQueryItem)
            }
            return items
        }
    }
}

extension ListDatasetEntriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let datasetType = datasetType else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/datasets/\(datasetType.urlPercentEncoding())/entries"
    }
}

public struct ListDatasetEntriesInput: Swift.Equatable {
    /// Only includes entries after the specified date in the response. For example, 2020-06-23T00:00:00.
    public var afterCreationDate: ClientRuntime.Date?
    /// Specify normal to include only normal images. Specify anomaly to only include anomalous entries. If you don't specify a value, Amazon Lookout for Vision returns normal and anomalous images.
    public var anomalyClass: Swift.String?
    /// Only includes entries before the specified date in the response. For example, 2020-06-23T00:00:00.
    public var beforeCreationDate: ClientRuntime.Date?
    /// The type of the dataset that you want to list. Specify train to list the training dataset. Specify test to list the test dataset. If you have a single dataset project, specify train.
    /// This member is required.
    public var datasetType: Swift.String?
    /// Specify true to include labeled entries, otherwise specify false. If you don't specify a value, Lookout for Vision returns all entries.
    public var labeled: Swift.Bool?
    /// The maximum number of results to return per paginated call. The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
    public var maxResults: Swift.Int?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of dataset entries.
    public var nextToken: Swift.String?
    /// The name of the project that contains the dataset that you want to list.
    /// This member is required.
    public var projectName: Swift.String?
    /// Perform a "contains" search on the values of the source-ref key within the dataset. For example a value of "IMG_17" returns all JSON Lines where the source-ref key value matches *IMG_17*.
    public var sourceRefContains: Swift.String?

    public init (
        afterCreationDate: ClientRuntime.Date? = nil,
        anomalyClass: Swift.String? = nil,
        beforeCreationDate: ClientRuntime.Date? = nil,
        datasetType: Swift.String? = nil,
        labeled: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sourceRefContains: Swift.String? = nil
    )
    {
        self.afterCreationDate = afterCreationDate
        self.anomalyClass = anomalyClass
        self.beforeCreationDate = beforeCreationDate
        self.datasetType = datasetType
        self.labeled = labeled
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
        self.sourceRefContains = sourceRefContains
    }
}

struct ListDatasetEntriesInputBody: Swift.Equatable {
}

extension ListDatasetEntriesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDatasetEntriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetEntriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDatasetEntriesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetEntriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDatasetEntriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetEntries = output.datasetEntries
            self.nextToken = output.nextToken
        } else {
            self.datasetEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetEntriesOutputResponse: Swift.Equatable {
    /// A list of the entries (JSON Lines) within the dataset.
    public var datasetEntries: [Swift.String]?
    /// If the response is truncated, Amazon Lookout for Vision returns this token that you can use in the subsequent request to retrieve the next set ofdataset entries.
    public var nextToken: Swift.String?

    public init (
        datasetEntries: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetEntries = datasetEntries
        self.nextToken = nextToken
    }
}

struct ListDatasetEntriesOutputResponseBody: Swift.Equatable {
    let datasetEntries: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListDatasetEntriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetEntries = "DatasetEntries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetEntriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetEntries)
        var datasetEntriesDecoded0:[Swift.String]? = nil
        if let datasetEntriesContainer = datasetEntriesContainer {
            datasetEntriesDecoded0 = [Swift.String]()
            for string0 in datasetEntriesContainer {
                if let string0 = string0 {
                    datasetEntriesDecoded0?.append(string0)
                }
            }
        }
        datasetEntries = datasetEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListModelPackagingJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListModelPackagingJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/modelpackagingjobs"
    }
}

public struct ListModelPackagingJobsInput: Swift.Equatable {
    /// The maximum number of results to return per paginated call. The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
    public var maxResults: Swift.Int?
    /// If the previous response was incomplete (because there is more results to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The name of the project for which you want to list the model packaging jobs.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
    }
}

struct ListModelPackagingJobsInputBody: Swift.Equatable {
}

extension ListModelPackagingJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListModelPackagingJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListModelPackagingJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListModelPackagingJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListModelPackagingJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListModelPackagingJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelPackagingJobs = output.modelPackagingJobs
            self.nextToken = output.nextToken
        } else {
            self.modelPackagingJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListModelPackagingJobsOutputResponse: Swift.Equatable {
    /// A list of the model packaging jobs created for the specified Amazon Lookout for Vision project.
    public var modelPackagingJobs: [LookoutVisionClientTypes.ModelPackagingJobMetadata]?
    /// If the previous response was incomplete (because there is more results to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        modelPackagingJobs: [LookoutVisionClientTypes.ModelPackagingJobMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelPackagingJobs = modelPackagingJobs
        self.nextToken = nextToken
    }
}

struct ListModelPackagingJobsOutputResponseBody: Swift.Equatable {
    let modelPackagingJobs: [LookoutVisionClientTypes.ModelPackagingJobMetadata]?
    let nextToken: Swift.String?
}

extension ListModelPackagingJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelPackagingJobs = "ModelPackagingJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelPackagingJobsContainer = try containerValues.decodeIfPresent([LookoutVisionClientTypes.ModelPackagingJobMetadata?].self, forKey: .modelPackagingJobs)
        var modelPackagingJobsDecoded0:[LookoutVisionClientTypes.ModelPackagingJobMetadata]? = nil
        if let modelPackagingJobsContainer = modelPackagingJobsContainer {
            modelPackagingJobsDecoded0 = [LookoutVisionClientTypes.ModelPackagingJobMetadata]()
            for structure0 in modelPackagingJobsContainer {
                if let structure0 = structure0 {
                    modelPackagingJobsDecoded0?.append(structure0)
                }
            }
        }
        modelPackagingJobs = modelPackagingJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListModelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/models"
    }
}

public struct ListModelsInput: Swift.Equatable {
    /// The maximum number of results to return per paginated call. The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
    public var maxResults: Swift.Int?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of models.
    public var nextToken: Swift.String?
    /// The name of the project that contains the model versions that you want to list.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
    }
}

struct ListModelsInputBody: Swift.Equatable {
}

extension ListModelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListModelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.models = output.models
            self.nextToken = output.nextToken
        } else {
            self.models = nil
            self.nextToken = nil
        }
    }
}

public struct ListModelsOutputResponse: Swift.Equatable {
    /// A list of model versions in the specified project.
    public var models: [LookoutVisionClientTypes.ModelMetadata]?
    /// If the response is truncated, Amazon Lookout for Vision returns this token that you can use in the subsequent request to retrieve the next set of models.
    public var nextToken: Swift.String?

    public init (
        models: [LookoutVisionClientTypes.ModelMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.models = models
        self.nextToken = nextToken
    }
}

struct ListModelsOutputResponseBody: Swift.Equatable {
    let models: [LookoutVisionClientTypes.ModelMetadata]?
    let nextToken: Swift.String?
}

extension ListModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case models = "Models"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelsContainer = try containerValues.decodeIfPresent([LookoutVisionClientTypes.ModelMetadata?].self, forKey: .models)
        var modelsDecoded0:[LookoutVisionClientTypes.ModelMetadata]? = nil
        if let modelsContainer = modelsContainer {
            modelsDecoded0 = [LookoutVisionClientTypes.ModelMetadata]()
            for structure0 in modelsContainer {
                if let structure0 = structure0 {
                    modelsDecoded0?.append(structure0)
                }
            }
        }
        models = modelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-11-20/projects"
    }
}

public struct ListProjectsInput: Swift.Equatable {
    /// The maximum number of results to return per paginated call. The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
    public var maxResults: Swift.Int?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of projects.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Swift.Equatable {
}

extension ListProjectsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProjectsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutputResponse: Swift.Equatable {
    /// If the response is truncated, Amazon Lookout for Vision returns this token that you can use in the subsequent request to retrieve the next set of projects.
    public var nextToken: Swift.String?
    /// A list of projects in your AWS account.
    public var projects: [LookoutVisionClientTypes.ProjectMetadata]?

    public init (
        nextToken: Swift.String? = nil,
        projects: [LookoutVisionClientTypes.ProjectMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Swift.Equatable {
    let projects: [LookoutVisionClientTypes.ProjectMetadata]?
    let nextToken: Swift.String?
}

extension ListProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case projects = "Projects"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([LookoutVisionClientTypes.ProjectMetadata?].self, forKey: .projects)
        var projectsDecoded0:[LookoutVisionClientTypes.ProjectMetadata]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [LookoutVisionClientTypes.ProjectMetadata]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/2020-11-20/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the model for which you want to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A map of tag keys and values attached to the specified model.
    public var tags: [LookoutVisionClientTypes.Tag]?

    public init (
        tags: [LookoutVisionClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [LookoutVisionClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([LookoutVisionClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LookoutVisionClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LookoutVisionClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LookoutVisionClientTypes.ModelDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case description = "Description"
        case evaluationEndTimestamp = "EvaluationEndTimestamp"
        case evaluationManifest = "EvaluationManifest"
        case evaluationResult = "EvaluationResult"
        case kmsKeyId = "KmsKeyId"
        case maxInferenceUnits = "MaxInferenceUnits"
        case minInferenceUnits = "MinInferenceUnits"
        case modelArn = "ModelArn"
        case modelVersion = "ModelVersion"
        case outputConfig = "OutputConfig"
        case performance = "Performance"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encodeTimestamp(creationTimestamp, format: .epochSeconds, forKey: .creationTimestamp)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let evaluationEndTimestamp = self.evaluationEndTimestamp {
            try encodeContainer.encodeTimestamp(evaluationEndTimestamp, format: .epochSeconds, forKey: .evaluationEndTimestamp)
        }
        if let evaluationManifest = self.evaluationManifest {
            try encodeContainer.encode(evaluationManifest, forKey: .evaluationManifest)
        }
        if let evaluationResult = self.evaluationResult {
            try encodeContainer.encode(evaluationResult, forKey: .evaluationResult)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let maxInferenceUnits = self.maxInferenceUnits {
            try encodeContainer.encode(maxInferenceUnits, forKey: .maxInferenceUnits)
        }
        if let minInferenceUnits = self.minInferenceUnits {
            try encodeContainer.encode(minInferenceUnits, forKey: .minInferenceUnits)
        }
        if let modelArn = self.modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let modelVersion = self.modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let outputConfig = self.outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
        if let performance = self.performance {
            try encodeContainer.encode(performance, forKey: .performance)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let performanceDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelPerformance.self, forKey: .performance)
        performance = performanceDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.OutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let evaluationManifestDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.OutputS3Object.self, forKey: .evaluationManifest)
        evaluationManifest = evaluationManifestDecoded
        let evaluationResultDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.OutputS3Object.self, forKey: .evaluationResult)
        evaluationResult = evaluationResultDecoded
        let evaluationEndTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .evaluationEndTimestamp)
        evaluationEndTimestamp = evaluationEndTimestampDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let minInferenceUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minInferenceUnits)
        minInferenceUnits = minInferenceUnitsDecoded
        let maxInferenceUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxInferenceUnits)
        maxInferenceUnits = maxInferenceUnitsDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Describes an Amazon Lookout for Vision model.
    public struct ModelDescription: Swift.Equatable {
        /// The unix timestamp for the date and time that the model was created.
        public var creationTimestamp: ClientRuntime.Date?
        /// The description for the model.
        public var description: Swift.String?
        /// The unix timestamp for the date and time that the evaluation ended.
        public var evaluationEndTimestamp: ClientRuntime.Date?
        /// The S3 location where Amazon Lookout for Vision saves the manifest file that was used to test the trained model and generate the performance scores.
        public var evaluationManifest: LookoutVisionClientTypes.OutputS3Object?
        /// The S3 location where Amazon Lookout for Vision saves the performance metrics.
        public var evaluationResult: LookoutVisionClientTypes.OutputS3Object?
        /// The identifer for the AWS Key Management Service (AWS KMS) key that was used to encrypt the model during training.
        public var kmsKeyId: Swift.String?
        /// The maximum number of inference units Amazon Lookout for Vision uses to auto-scale the model. For more information, see [StartModel].
        public var maxInferenceUnits: Swift.Int?
        /// The minimum number of inference units used by the model. For more information, see [StartModel]
        public var minInferenceUnits: Swift.Int?
        /// The Amazon Resource Name (ARN) of the model.
        public var modelArn: Swift.String?
        /// The version of the model
        public var modelVersion: Swift.String?
        /// The S3 location where Amazon Lookout for Vision saves model training files.
        public var outputConfig: LookoutVisionClientTypes.OutputConfig?
        /// Performance metrics for the model. Created during training.
        public var performance: LookoutVisionClientTypes.ModelPerformance?
        /// The status of the model.
        public var status: LookoutVisionClientTypes.ModelStatus?
        /// The status message for the model.
        public var statusMessage: Swift.String?

        public init (
            creationTimestamp: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            evaluationEndTimestamp: ClientRuntime.Date? = nil,
            evaluationManifest: LookoutVisionClientTypes.OutputS3Object? = nil,
            evaluationResult: LookoutVisionClientTypes.OutputS3Object? = nil,
            kmsKeyId: Swift.String? = nil,
            maxInferenceUnits: Swift.Int? = nil,
            minInferenceUnits: Swift.Int? = nil,
            modelArn: Swift.String? = nil,
            modelVersion: Swift.String? = nil,
            outputConfig: LookoutVisionClientTypes.OutputConfig? = nil,
            performance: LookoutVisionClientTypes.ModelPerformance? = nil,
            status: LookoutVisionClientTypes.ModelStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.description = description
            self.evaluationEndTimestamp = evaluationEndTimestamp
            self.evaluationManifest = evaluationManifest
            self.evaluationResult = evaluationResult
            self.kmsKeyId = kmsKeyId
            self.maxInferenceUnits = maxInferenceUnits
            self.minInferenceUnits = minInferenceUnits
            self.modelArn = modelArn
            self.modelVersion = modelVersion
            self.outputConfig = outputConfig
            self.performance = performance
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension LookoutVisionClientTypes {
    public enum ModelHostingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hosted
        case hostingFailed
        case startingHosting
        case stoppingHosting
        case systemUpdating
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelHostingStatus] {
            return [
                .hosted,
                .hostingFailed,
                .startingHosting,
                .stoppingHosting,
                .systemUpdating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hosted: return "HOSTED"
            case .hostingFailed: return "HOSTING_FAILED"
            case .startingHosting: return "STARTING_HOSTING"
            case .stoppingHosting: return "STOPPING_HOSTING"
            case .systemUpdating: return "SYSTEM_UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelHostingStatus(rawValue: rawValue) ?? ModelHostingStatus.sdkUnknown(rawValue)
        }
    }
}

extension LookoutVisionClientTypes.ModelMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case description = "Description"
        case modelArn = "ModelArn"
        case modelVersion = "ModelVersion"
        case performance = "Performance"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encodeTimestamp(creationTimestamp, format: .epochSeconds, forKey: .creationTimestamp)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modelArn = self.modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let modelVersion = self.modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let performance = self.performance {
            try encodeContainer.encode(performance, forKey: .performance)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let performanceDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelPerformance.self, forKey: .performance)
        performance = performanceDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Describes an Amazon Lookout for Vision model.
    public struct ModelMetadata: Swift.Equatable {
        /// The unix timestamp for the date and time that the model was created.
        public var creationTimestamp: ClientRuntime.Date?
        /// The description for the model.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the model.
        public var modelArn: Swift.String?
        /// The version of the model.
        public var modelVersion: Swift.String?
        /// Performance metrics for the model. Not available until training has successfully completed.
        public var performance: LookoutVisionClientTypes.ModelPerformance?
        /// The status of the model.
        public var status: LookoutVisionClientTypes.ModelStatus?
        /// The status message for the model.
        public var statusMessage: Swift.String?

        public init (
            creationTimestamp: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            modelArn: Swift.String? = nil,
            modelVersion: Swift.String? = nil,
            performance: LookoutVisionClientTypes.ModelPerformance? = nil,
            status: LookoutVisionClientTypes.ModelStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.description = description
            self.modelArn = modelArn
            self.modelVersion = modelVersion
            self.performance = performance
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension LookoutVisionClientTypes.ModelPackagingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case greengrass = "Greengrass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let greengrass = self.greengrass {
            try encodeContainer.encode(greengrass, forKey: .greengrass)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let greengrassDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.GreengrassConfiguration.self, forKey: .greengrass)
        greengrass = greengrassDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Configuration information for a Amazon Lookout for Vision model packaging job. For more information, see [StartModelPackagingJob].
    public struct ModelPackagingConfiguration: Swift.Equatable {
        /// Configuration information for the AWS IoT Greengrass component in a model packaging job.
        /// This member is required.
        public var greengrass: LookoutVisionClientTypes.GreengrassConfiguration?

        public init (
            greengrass: LookoutVisionClientTypes.GreengrassConfiguration? = nil
        )
        {
            self.greengrass = greengrass
        }
    }

}

extension LookoutVisionClientTypes.ModelPackagingDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case jobName = "JobName"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case modelPackagingConfiguration = "ModelPackagingConfiguration"
        case modelPackagingJobDescription = "ModelPackagingJobDescription"
        case modelPackagingMethod = "ModelPackagingMethod"
        case modelPackagingOutputDetails = "ModelPackagingOutputDetails"
        case modelVersion = "ModelVersion"
        case projectName = "ProjectName"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encodeTimestamp(creationTimestamp, format: .epochSeconds, forKey: .creationTimestamp)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let modelPackagingConfiguration = self.modelPackagingConfiguration {
            try encodeContainer.encode(modelPackagingConfiguration, forKey: .modelPackagingConfiguration)
        }
        if let modelPackagingJobDescription = self.modelPackagingJobDescription {
            try encodeContainer.encode(modelPackagingJobDescription, forKey: .modelPackagingJobDescription)
        }
        if let modelPackagingMethod = self.modelPackagingMethod {
            try encodeContainer.encode(modelPackagingMethod, forKey: .modelPackagingMethod)
        }
        if let modelPackagingOutputDetails = self.modelPackagingOutputDetails {
            try encodeContainer.encode(modelPackagingOutputDetails, forKey: .modelPackagingOutputDetails)
        }
        if let modelVersion = self.modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let modelPackagingConfigurationDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelPackagingConfiguration.self, forKey: .modelPackagingConfiguration)
        modelPackagingConfiguration = modelPackagingConfigurationDecoded
        let modelPackagingJobDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelPackagingJobDescription)
        modelPackagingJobDescription = modelPackagingJobDescriptionDecoded
        let modelPackagingMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelPackagingMethod)
        modelPackagingMethod = modelPackagingMethodDecoded
        let modelPackagingOutputDetailsDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelPackagingOutputDetails.self, forKey: .modelPackagingOutputDetails)
        modelPackagingOutputDetails = modelPackagingOutputDetailsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelPackagingJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Information about a model packaging job. For more information, see [DescribeModelPackagingJob].
    public struct ModelPackagingDescription: Swift.Equatable {
        /// The Unix timestamp for the time and date that the model packaging job was created.
        public var creationTimestamp: ClientRuntime.Date?
        /// The name of the model packaging job.
        public var jobName: Swift.String?
        /// The Unix timestamp for the time and date that the model packaging job was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The configuration information used in the model packaging job.
        public var modelPackagingConfiguration: LookoutVisionClientTypes.ModelPackagingConfiguration?
        /// The description for the model packaging job.
        public var modelPackagingJobDescription: Swift.String?
        /// The AWS service used to package the job. Currently Lookout for Vision can package jobs with AWS IoT Greengrass.
        public var modelPackagingMethod: Swift.String?
        /// Information about the output of the model packaging job. For more information, see [DescribeModelPackagingJob].
        public var modelPackagingOutputDetails: LookoutVisionClientTypes.ModelPackagingOutputDetails?
        /// The version of the model used in the model packaging job.
        public var modelVersion: Swift.String?
        /// The name of the project that's associated with a model that's in the model package.
        public var projectName: Swift.String?
        /// The status of the model packaging job.
        public var status: LookoutVisionClientTypes.ModelPackagingJobStatus?
        /// The status message for the model packaging job.
        public var statusMessage: Swift.String?

        public init (
            creationTimestamp: ClientRuntime.Date? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            modelPackagingConfiguration: LookoutVisionClientTypes.ModelPackagingConfiguration? = nil,
            modelPackagingJobDescription: Swift.String? = nil,
            modelPackagingMethod: Swift.String? = nil,
            modelPackagingOutputDetails: LookoutVisionClientTypes.ModelPackagingOutputDetails? = nil,
            modelVersion: Swift.String? = nil,
            projectName: Swift.String? = nil,
            status: LookoutVisionClientTypes.ModelPackagingJobStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.jobName = jobName
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.modelPackagingConfiguration = modelPackagingConfiguration
            self.modelPackagingJobDescription = modelPackagingJobDescription
            self.modelPackagingMethod = modelPackagingMethod
            self.modelPackagingOutputDetails = modelPackagingOutputDetails
            self.modelVersion = modelVersion
            self.projectName = projectName
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension LookoutVisionClientTypes.ModelPackagingJobMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case jobName = "JobName"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case modelPackagingJobDescription = "ModelPackagingJobDescription"
        case modelPackagingMethod = "ModelPackagingMethod"
        case modelVersion = "ModelVersion"
        case projectName = "ProjectName"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encodeTimestamp(creationTimestamp, format: .epochSeconds, forKey: .creationTimestamp)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let modelPackagingJobDescription = self.modelPackagingJobDescription {
            try encodeContainer.encode(modelPackagingJobDescription, forKey: .modelPackagingJobDescription)
        }
        if let modelPackagingMethod = self.modelPackagingMethod {
            try encodeContainer.encode(modelPackagingMethod, forKey: .modelPackagingMethod)
        }
        if let modelVersion = self.modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let modelPackagingJobDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelPackagingJobDescription)
        modelPackagingJobDescription = modelPackagingJobDescriptionDecoded
        let modelPackagingMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelPackagingMethod)
        modelPackagingMethod = modelPackagingMethodDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelPackagingJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Metadata for a model packaging job. For more information, see [ListModelPackagingJobs].
    public struct ModelPackagingJobMetadata: Swift.Equatable {
        /// The Unix timestamp for the time and date that the model packaging job was created.
        public var creationTimestamp: ClientRuntime.Date?
        /// The name of the model packaging job.
        public var jobName: Swift.String?
        /// The Unix timestamp for the time and date that the model packaging job was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The description for the model packaging job.
        public var modelPackagingJobDescription: Swift.String?
        /// The AWS service used to package the job. Currently Lookout for Vision can package jobs with AWS IoT Greengrass.
        public var modelPackagingMethod: Swift.String?
        /// The version of the model that is in the model package.
        public var modelVersion: Swift.String?
        /// The project that contains the model that is in the model package.
        public var projectName: Swift.String?
        /// The status of the model packaging job.
        public var status: LookoutVisionClientTypes.ModelPackagingJobStatus?
        /// The status message for the model packaging job.
        public var statusMessage: Swift.String?

        public init (
            creationTimestamp: ClientRuntime.Date? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            modelPackagingJobDescription: Swift.String? = nil,
            modelPackagingMethod: Swift.String? = nil,
            modelVersion: Swift.String? = nil,
            projectName: Swift.String? = nil,
            status: LookoutVisionClientTypes.ModelPackagingJobStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.jobName = jobName
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.modelPackagingJobDescription = modelPackagingJobDescription
            self.modelPackagingMethod = modelPackagingMethod
            self.modelVersion = modelVersion
            self.projectName = projectName
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension LookoutVisionClientTypes {
    public enum ModelPackagingJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelPackagingJobStatus] {
            return [
                .created,
                .failed,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelPackagingJobStatus(rawValue: rawValue) ?? ModelPackagingJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension LookoutVisionClientTypes.ModelPackagingOutputDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case greengrass = "Greengrass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let greengrass = self.greengrass {
            try encodeContainer.encode(greengrass, forKey: .greengrass)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let greengrassDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.GreengrassOutputDetails.self, forKey: .greengrass)
        greengrass = greengrassDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Information about the output from a model packaging job.
    public struct ModelPackagingOutputDetails: Swift.Equatable {
        /// Information about the AWS IoT Greengrass component in a model packaging job.
        public var greengrass: LookoutVisionClientTypes.GreengrassOutputDetails?

        public init (
            greengrass: LookoutVisionClientTypes.GreengrassOutputDetails? = nil
        )
        {
            self.greengrass = greengrass
        }
    }

}

extension LookoutVisionClientTypes.ModelPerformance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case f1Score = "F1Score"
        case precision = "Precision"
        case recall = "Recall"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let f1Score = self.f1Score {
            try encodeContainer.encode(f1Score, forKey: .f1Score)
        }
        if let precision = self.precision {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if let recall = self.recall {
            try encodeContainer.encode(recall, forKey: .recall)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let f1ScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .f1Score)
        f1Score = f1ScoreDecoded
        let recallDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .recall)
        recall = recallDecoded
        let precisionDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .precision)
        precision = precisionDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Information about the evaluation performance of a trained model.
    public struct ModelPerformance: Swift.Equatable {
        /// The overall F1 score metric for the trained model.
        public var f1Score: Swift.Float?
        /// The overall precision metric value for the trained model.
        public var precision: Swift.Float?
        /// The overall recall metric value for the trained model.
        public var recall: Swift.Float?

        public init (
            f1Score: Swift.Float? = nil,
            precision: Swift.Float? = nil,
            recall: Swift.Float? = nil
        )
        {
            self.f1Score = f1Score
            self.precision = precision
            self.recall = recall
        }
    }

}

extension LookoutVisionClientTypes {
    public enum ModelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case hosted
        case hostingFailed
        case startingHosting
        case stoppingHosting
        case systemUpdating
        case trained
        case training
        case trainingFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelStatus] {
            return [
                .deleting,
                .hosted,
                .hostingFailed,
                .startingHosting,
                .stoppingHosting,
                .systemUpdating,
                .trained,
                .training,
                .trainingFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .hosted: return "HOSTED"
            case .hostingFailed: return "HOSTING_FAILED"
            case .startingHosting: return "STARTING_HOSTING"
            case .stoppingHosting: return "STOPPING_HOSTING"
            case .systemUpdating: return "SYSTEM_UPDATING"
            case .trained: return "TRAINED"
            case .training: return "TRAINING"
            case .trainingFailed: return "TRAINING_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelStatus(rawValue: rawValue) ?? ModelStatus.sdkUnknown(rawValue)
        }
    }
}

extension LookoutVisionClientTypes.OutputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location = "S3Location"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = self.s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension LookoutVisionClientTypes {
    /// The S3 location where Amazon Lookout for Vision saves model training files.
    public struct OutputConfig: Swift.Equatable {
        /// The S3 location for the output.
        /// This member is required.
        public var s3Location: LookoutVisionClientTypes.S3Location?

        public init (
            s3Location: LookoutVisionClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

extension LookoutVisionClientTypes.OutputS3Object: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension LookoutVisionClientTypes {
    /// The S3 location where Amazon Lookout for Vision saves training output.
    public struct OutputS3Object: Swift.Equatable {
        /// The bucket that contains the training output.
        /// This member is required.
        public var bucket: Swift.String?
        /// The location of the training output in the bucket.
        /// This member is required.
        public var key: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension LookoutVisionClientTypes.PixelAnomaly: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case color = "Color"
        case totalPercentageArea = "TotalPercentageArea"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let color = self.color {
            try encodeContainer.encode(color, forKey: .color)
        }
        if let totalPercentageArea = self.totalPercentageArea {
            try encodeContainer.encode(totalPercentageArea, forKey: .totalPercentageArea)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalPercentageAreaDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .totalPercentageArea)
        totalPercentageArea = totalPercentageAreaDecoded
        let colorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .color)
        color = colorDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Information about the pixels in an anomaly mask. For more information, see [Anomaly]. PixelAnomaly is only returned by image segmentation models.
    public struct PixelAnomaly: Swift.Equatable {
        /// A hex color value for the mask that covers an anomaly type. Each anomaly type has a different mask color. The color maps to the color of the anomaly type used in the training dataset.
        public var color: Swift.String?
        /// The percentage area of the image that the anomaly type covers.
        public var totalPercentageArea: Swift.Float?

        public init (
            color: Swift.String? = nil,
            totalPercentageArea: Swift.Float? = nil
        )
        {
            self.color = color
            self.totalPercentageArea = totalPercentageArea
        }
    }

}

extension LookoutVisionClientTypes.ProjectDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case datasets = "Datasets"
        case projectArn = "ProjectArn"
        case projectName = "ProjectName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encodeTimestamp(creationTimestamp, format: .epochSeconds, forKey: .creationTimestamp)
        }
        if let datasets = datasets {
            var datasetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasets)
            for datasetmetadata0 in datasets {
                try datasetsContainer.encode(datasetmetadata0)
            }
        }
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let datasetsContainer = try containerValues.decodeIfPresent([LookoutVisionClientTypes.DatasetMetadata?].self, forKey: .datasets)
        var datasetsDecoded0:[LookoutVisionClientTypes.DatasetMetadata]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [LookoutVisionClientTypes.DatasetMetadata]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
    }
}

extension LookoutVisionClientTypes {
    /// Describe an Amazon Lookout for Vision project. For more information, see [DescribeProject].
    public struct ProjectDescription: Swift.Equatable {
        /// The unix timestamp for the date and time that the project was created.
        public var creationTimestamp: ClientRuntime.Date?
        /// A list of datasets in the project.
        public var datasets: [LookoutVisionClientTypes.DatasetMetadata]?
        /// The Amazon Resource Name (ARN) of the project.
        public var projectArn: Swift.String?
        /// The name of the project.
        public var projectName: Swift.String?

        public init (
            creationTimestamp: ClientRuntime.Date? = nil,
            datasets: [LookoutVisionClientTypes.DatasetMetadata]? = nil,
            projectArn: Swift.String? = nil,
            projectName: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.datasets = datasets
            self.projectArn = projectArn
            self.projectName = projectName
        }
    }

}

extension LookoutVisionClientTypes.ProjectMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case projectArn = "ProjectArn"
        case projectName = "ProjectName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encodeTimestamp(creationTimestamp, format: .epochSeconds, forKey: .creationTimestamp)
        }
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Metadata about an Amazon Lookout for Vision project.
    public struct ProjectMetadata: Swift.Equatable {
        /// The unix timestamp for the date and time that the project was created.
        public var creationTimestamp: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the project.
        public var projectArn: Swift.String?
        /// The name of the project.
        public var projectName: Swift.String?

        public init (
            creationTimestamp: ClientRuntime.Date? = nil,
            projectArn: Swift.String? = nil,
            projectName: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.projectArn = projectArn
            self.projectName = projectName
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the resource.
    /// This member is required.
    public var resourceType: LookoutVisionClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: LookoutVisionClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: LookoutVisionClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension LookoutVisionClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dataset
        case model
        case modelPackageJob
        case project
        case trial
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .dataset,
                .model,
                .modelPackageJob,
                .project,
                .trial,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dataset: return "DATASET"
            case .model: return "MODEL"
            case .modelPackageJob: return "MODEL_PACKAGE_JOB"
            case .project: return "PROJECT"
            case .trial: return "TRIAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension LookoutVisionClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case `prefix` = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension LookoutVisionClientTypes {
    /// Information about the location of training output or the output of a model packaging job.
    public struct S3Location: Swift.Equatable {
        /// The S3 bucket that contains the training or model packaging job output. If you are training a model, the bucket must in your AWS account. If you use an S3 bucket for a model packaging job, the S3 bucket must be in the same AWS Region and AWS account in which you use AWS IoT Greengrass.
        /// This member is required.
        public var bucket: Swift.String?
        /// The path of the folder, within the S3 bucket, that contains the output.
        public var `prefix`: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A service quota was exceeded the allowed limit. For more information, see Limits in Amazon Lookout for Vision in the Amazon Lookout for Vision Developer Guide.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The quota code.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The type of the resource.
    public var resourceType: LookoutVisionClientTypes.ResourceType?
    /// The service code.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: LookoutVisionClientTypes.ResourceType? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: LookoutVisionClientTypes.ResourceType?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension StartModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxInferenceUnits = "MaxInferenceUnits"
        case minInferenceUnits = "MinInferenceUnits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxInferenceUnits = self.maxInferenceUnits {
            try encodeContainer.encode(maxInferenceUnits, forKey: .maxInferenceUnits)
        }
        if let minInferenceUnits = self.minInferenceUnits {
            try encodeContainer.encode(minInferenceUnits, forKey: .minInferenceUnits)
        }
    }
}

extension StartModelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension StartModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let modelVersion = modelVersion else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/models/\(modelVersion.urlPercentEncoding())/start"
    }
}

public struct StartModelInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to StartModel completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from StartModel. In this case, safely retry your call to StartModel by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple start requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different
    ///
    ///
    /// value for ClientToken is considered a new call to StartModel. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The maximum number of inference units to use for auto-scaling the model. If you don't specify a value, Amazon Lookout for Vision doesn't auto-scale the model.
    public var maxInferenceUnits: Swift.Int?
    /// The minimum number of inference units to use. A single inference unit represents 1 hour of processing. Use a higher number to increase the TPS throughput of your model. You are charged for the number of inference units that you use.
    /// This member is required.
    public var minInferenceUnits: Swift.Int?
    /// The version of the model that you want to start.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// The name of the project that contains the model that you want to start.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        maxInferenceUnits: Swift.Int? = nil,
        minInferenceUnits: Swift.Int? = nil,
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.maxInferenceUnits = maxInferenceUnits
        self.minInferenceUnits = minInferenceUnits
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct StartModelInputBody: Swift.Equatable {
    let minInferenceUnits: Swift.Int?
    let maxInferenceUnits: Swift.Int?
}

extension StartModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxInferenceUnits = "MaxInferenceUnits"
        case minInferenceUnits = "MinInferenceUnits"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minInferenceUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minInferenceUnits)
        minInferenceUnits = minInferenceUnitsDecoded
        let maxInferenceUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxInferenceUnits)
        maxInferenceUnits = maxInferenceUnitsDecoded
    }
}

extension StartModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartModelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct StartModelOutputResponse: Swift.Equatable {
    /// The current running status of the model.
    public var status: LookoutVisionClientTypes.ModelHostingStatus?

    public init (
        status: LookoutVisionClientTypes.ModelHostingStatus? = nil
    )
    {
        self.status = status
    }
}

struct StartModelOutputResponseBody: Swift.Equatable {
    let status: LookoutVisionClientTypes.ModelHostingStatus?
}

extension StartModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelHostingStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension StartModelPackagingJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case jobName = "JobName"
        case modelVersion = "ModelVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let modelVersion = self.modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
    }
}

extension StartModelPackagingJobInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension StartModelPackagingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/modelpackagingjobs"
    }
}

public struct StartModelPackagingJobInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to StartModelPackagingJob completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from StartModelPackagingJob. In this case, safely retry your call to StartModelPackagingJob by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple dataset creation requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to StartModelPackagingJob. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The configuration for the model packaging job.
    /// This member is required.
    public var configuration: LookoutVisionClientTypes.ModelPackagingConfiguration?
    /// A description for the model packaging job.
    public var description: Swift.String?
    /// A name for the model packaging job. If you don't supply a value, the service creates a job name for you.
    public var jobName: Swift.String?
    /// The version of the model within the project that you want to package.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// The name of the project which contains the version of the model that you want to package.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        configuration: LookoutVisionClientTypes.ModelPackagingConfiguration? = nil,
        description: Swift.String? = nil,
        jobName: Swift.String? = nil,
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.jobName = jobName
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct StartModelPackagingJobInputBody: Swift.Equatable {
    let modelVersion: Swift.String?
    let jobName: Swift.String?
    let configuration: LookoutVisionClientTypes.ModelPackagingConfiguration?
    let description: Swift.String?
}

extension StartModelPackagingJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case jobName = "JobName"
        case modelVersion = "ModelVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelPackagingConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension StartModelPackagingJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartModelPackagingJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartModelPackagingJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartModelPackagingJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartModelPackagingJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobName = output.jobName
        } else {
            self.jobName = nil
        }
    }
}

public struct StartModelPackagingJobOutputResponse: Swift.Equatable {
    /// The job name for the model packaging job. If you don't supply a job name in the JobName input parameter, the service creates a job name for you.
    public var jobName: Swift.String?

    public init (
        jobName: Swift.String? = nil
    )
    {
        self.jobName = jobName
    }
}

struct StartModelPackagingJobOutputResponseBody: Swift.Equatable {
    let jobName: Swift.String?
}

extension StartModelPackagingJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobName = "JobName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
    }
}

extension StopModelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension StopModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let modelVersion = modelVersion else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/models/\(modelVersion.urlPercentEncoding())/stop"
    }
}

public struct StopModelInput: Swift.Equatable {
    /// ClientToken is an idempotency token that ensures a call to StopModel completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from StopModel. In this case, safely retry your call to StopModel by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple stop requests. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to StopModel. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The version of the model that you want to stop.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// The name of the project that contains the model that you want to stop.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        modelVersion: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct StopModelInputBody: Swift.Equatable {
}

extension StopModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopModelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct StopModelOutputResponse: Swift.Equatable {
    /// The status of the model.
    public var status: LookoutVisionClientTypes.ModelHostingStatus?

    public init (
        status: LookoutVisionClientTypes.ModelHostingStatus? = nil
    )
    {
        self.status = status
    }
}

struct StopModelOutputResponseBody: Swift.Equatable {
    let status: LookoutVisionClientTypes.ModelHostingStatus?
}

extension StopModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.ModelHostingStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension LookoutVisionClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LookoutVisionClientTypes {
    /// A key and value pair that is attached to the specified Amazon Lookout for Vision model.
    public struct Tag: Swift.Equatable {
        /// The key of the tag that is attached to the specified model.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag that is attached to the specified model.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/2020-11-20/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the model to assign the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value tags to assign to the model.
    /// This member is required.
    public var tags: [LookoutVisionClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [LookoutVisionClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [LookoutVisionClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([LookoutVisionClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LookoutVisionClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LookoutVisionClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension LookoutVisionClientTypes {
    public enum TargetDevice: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jetsonXavier
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetDevice] {
            return [
                .jetsonXavier,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jetsonXavier: return "jetson_xavier"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetDevice(rawValue: rawValue) ?? TargetDevice.sdkUnknown(rawValue)
        }
    }
}

extension LookoutVisionClientTypes.TargetPlatform: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
        case arch = "Arch"
        case os = "Os"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accelerator = self.accelerator {
            try encodeContainer.encode(accelerator.rawValue, forKey: .accelerator)
        }
        if let arch = self.arch {
            try encodeContainer.encode(arch.rawValue, forKey: .arch)
        }
        if let os = self.os {
            try encodeContainer.encode(os.rawValue, forKey: .os)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let osDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.TargetPlatformOs.self, forKey: .os)
        os = osDecoded
        let archDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.TargetPlatformArch.self, forKey: .arch)
        arch = archDecoded
        let acceleratorDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.TargetPlatformAccelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

extension LookoutVisionClientTypes {
    /// The platform on which a model runs on an AWS IoT Greengrass core device.
    public struct TargetPlatform: Swift.Equatable {
        /// The target accelerator for the model. Currently, Amazon Lookout for Vision only supports NVIDIA (Nvidia graphics processing unit) and CPU accelerators. If you specify NVIDIA as an accelerator, you must also specify the gpu-code, trt-ver, and cuda-ver compiler options. If you don't specify an accelerator, Lookout for Vision uses the CPU for compilation and we highly recommend that you use the [GreengrassConfiguration$CompilerOptions] field. For example, you can use the following compiler options for CPU:
        ///
        /// * mcpu: CPU micro-architecture. For example, {'mcpu': 'skylake-avx512'}
        ///
        /// * mattr: CPU flags. For example, {'mattr': ['+neon', '+vfpv4']}
        public var accelerator: LookoutVisionClientTypes.TargetPlatformAccelerator?
        /// The target architecture for the model. The currently supported architectures are X86_64 (64-bit version of the x86 instruction set) and ARM_64 (ARMv8 64-bit CPU).
        /// This member is required.
        public var arch: LookoutVisionClientTypes.TargetPlatformArch?
        /// The target operating system for the model. Linux is the only operating system that is currently supported.
        /// This member is required.
        public var os: LookoutVisionClientTypes.TargetPlatformOs?

        public init (
            accelerator: LookoutVisionClientTypes.TargetPlatformAccelerator? = nil,
            arch: LookoutVisionClientTypes.TargetPlatformArch? = nil,
            os: LookoutVisionClientTypes.TargetPlatformOs? = nil
        )
        {
            self.accelerator = accelerator
            self.arch = arch
            self.os = os
        }
    }

}

extension LookoutVisionClientTypes {
    public enum TargetPlatformAccelerator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nvidia
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetPlatformAccelerator] {
            return [
                .nvidia,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nvidia: return "NVIDIA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetPlatformAccelerator(rawValue: rawValue) ?? TargetPlatformAccelerator.sdkUnknown(rawValue)
        }
    }
}

extension LookoutVisionClientTypes {
    public enum TargetPlatformArch: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arm64
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetPlatformArch] {
            return [
                .arm64,
                .x8664,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "ARM64"
            case .x8664: return "X86_64"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetPlatformArch(rawValue: rawValue) ?? TargetPlatformArch.sdkUnknown(rawValue)
        }
    }
}

extension LookoutVisionClientTypes {
    public enum TargetPlatformOs: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetPlatformOs] {
            return [
                .linux,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetPlatformOs(rawValue: rawValue) ?? TargetPlatformOs.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Lookout for Vision is temporarily unable to process the request. Try your call again.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The quota code.
    public var quotaCode: Swift.String?
    /// The period of time, in seconds, before the operation can be retried.
    public var retryAfterSeconds: Swift.Int
    /// The service code.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/2020-11-20/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the model from which you want to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys of the tags that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDatasetEntriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changes = "Changes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changes = self.changes {
            try encodeContainer.encode(changes.base64EncodedString(), forKey: .changes)
        }
    }
}

extension UpdateDatasetEntriesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateDatasetEntriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let datasetType = datasetType else {
            return nil
        }
        return "/2020-11-20/projects/\(projectName.urlPercentEncoding())/datasets/\(datasetType.urlPercentEncoding())/entries"
    }
}

public struct UpdateDatasetEntriesInput: Swift.Equatable {
    /// The entries to add to the dataset.
    /// This member is required.
    public var changes: ClientRuntime.Data?
    /// ClientToken is an idempotency token that ensures a call to UpdateDatasetEntries completes only once. You choose the value to pass. For example, An issue might prevent you from getting a response from UpdateDatasetEntries. In this case, safely retry your call to UpdateDatasetEntries by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you. This prevents retries after a network error from making multiple updates with the same dataset entries. You'll need to provide your own value for other use cases. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to UpdateDatasetEntries. An idempotency token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The type of the dataset that you want to update. Specify train to update the training dataset. Specify test to update the test dataset. If you have a single dataset project, specify train.
    /// This member is required.
    public var datasetType: Swift.String?
    /// The name of the project that contains the dataset that you want to update.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        changes: ClientRuntime.Data? = nil,
        clientToken: Swift.String? = nil,
        datasetType: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.changes = changes
        self.clientToken = clientToken
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

struct UpdateDatasetEntriesInputBody: Swift.Equatable {
    let changes: ClientRuntime.Data?
}

extension UpdateDatasetEntriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changes = "Changes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .changes)
        changes = changesDecoded
    }
}

extension UpdateDatasetEntriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatasetEntriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDatasetEntriesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatasetEntriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDatasetEntriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct UpdateDatasetEntriesOutputResponse: Swift.Equatable {
    /// The status of the dataset update.
    public var status: LookoutVisionClientTypes.DatasetStatus?

    public init (
        status: LookoutVisionClientTypes.DatasetStatus? = nil
    )
    {
        self.status = status
    }
}

struct UpdateDatasetEntriesOutputResponseBody: Swift.Equatable {
    let status: LookoutVisionClientTypes.DatasetStatus?
}

extension UpdateDatasetEntriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(LookoutVisionClientTypes.DatasetStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An input validation error occured. For example, invalid characters in a project name, or if a pagination token is invalid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
