// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access to the Apache Airflow Web UI or CLI has been denied due to insufficient permissions. To learn more, see [Accessing an Amazon MWAA environment](https://docs.aws.amazon.com/mwaa/latest/userguide/access-policies.html).
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateCliTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/clitoken/\(name.urlPercentEncoding())"
    }
}

public struct CreateCliTokenInput: Swift.Equatable {
    /// The name of the Amazon MWAA environment. For example, MyMWAAEnvironment.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateCliTokenInputBody: Swift.Equatable {
}

extension CreateCliTokenInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CreateCliTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCliTokenOutput(webServerHostname: \(Swift.String(describing: webServerHostname)), cliToken: \"CONTENT_REDACTED\")"}
}

extension CreateCliTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCliTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.cliToken = output.cliToken
            self.webServerHostname = output.webServerHostname
        } else {
            self.cliToken = nil
            self.webServerHostname = nil
        }
    }
}

public struct CreateCliTokenOutput: Swift.Equatable {
    /// An Airflow CLI login token.
    public var cliToken: Swift.String?
    /// The Airflow web server hostname for the environment.
    public var webServerHostname: Swift.String?

    public init(
        cliToken: Swift.String? = nil,
        webServerHostname: Swift.String? = nil
    )
    {
        self.cliToken = cliToken
        self.webServerHostname = webServerHostname
    }
}

struct CreateCliTokenOutputBody: Swift.Equatable {
    let cliToken: Swift.String?
    let webServerHostname: Swift.String?
}

extension CreateCliTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cliToken = "CliToken"
        case webServerHostname = "WebServerHostname"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cliTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cliToken)
        cliToken = cliTokenDecoded
        let webServerHostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webServerHostname)
        webServerHostname = webServerHostnameDecoded
    }
}

enum CreateCliTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentInput(airflowVersion: \(Swift.String(describing: airflowVersion)), dagS3Path: \(Swift.String(describing: dagS3Path)), environmentClass: \(Swift.String(describing: environmentClass)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), kmsKey: \(Swift.String(describing: kmsKey)), loggingConfiguration: \(Swift.String(describing: loggingConfiguration)), maxWorkers: \(Swift.String(describing: maxWorkers)), minWorkers: \(Swift.String(describing: minWorkers)), name: \(Swift.String(describing: name)), networkConfiguration: \(Swift.String(describing: networkConfiguration)), pluginsS3ObjectVersion: \(Swift.String(describing: pluginsS3ObjectVersion)), pluginsS3Path: \(Swift.String(describing: pluginsS3Path)), requirementsS3ObjectVersion: \(Swift.String(describing: requirementsS3ObjectVersion)), requirementsS3Path: \(Swift.String(describing: requirementsS3Path)), schedulers: \(Swift.String(describing: schedulers)), sourceBucketArn: \(Swift.String(describing: sourceBucketArn)), startupScriptS3ObjectVersion: \(Swift.String(describing: startupScriptS3ObjectVersion)), startupScriptS3Path: \(Swift.String(describing: startupScriptS3Path)), tags: \(Swift.String(describing: tags)), webserverAccessMode: \(Swift.String(describing: webserverAccessMode)), weeklyMaintenanceWindowStart: \(Swift.String(describing: weeklyMaintenanceWindowStart)), airflowConfigurationOptions: \"CONTENT_REDACTED\")"}
}

extension CreateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case airflowConfigurationOptions = "AirflowConfigurationOptions"
        case airflowVersion = "AirflowVersion"
        case dagS3Path = "DagS3Path"
        case environmentClass = "EnvironmentClass"
        case executionRoleArn = "ExecutionRoleArn"
        case kmsKey = "KmsKey"
        case loggingConfiguration = "LoggingConfiguration"
        case maxWorkers = "MaxWorkers"
        case minWorkers = "MinWorkers"
        case networkConfiguration = "NetworkConfiguration"
        case pluginsS3ObjectVersion = "PluginsS3ObjectVersion"
        case pluginsS3Path = "PluginsS3Path"
        case requirementsS3ObjectVersion = "RequirementsS3ObjectVersion"
        case requirementsS3Path = "RequirementsS3Path"
        case schedulers = "Schedulers"
        case sourceBucketArn = "SourceBucketArn"
        case startupScriptS3ObjectVersion = "StartupScriptS3ObjectVersion"
        case startupScriptS3Path = "StartupScriptS3Path"
        case tags = "Tags"
        case webserverAccessMode = "WebserverAccessMode"
        case weeklyMaintenanceWindowStart = "WeeklyMaintenanceWindowStart"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let airflowConfigurationOptions = airflowConfigurationOptions {
            var airflowConfigurationOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .airflowConfigurationOptions)
            for (dictKey0, airflowConfigurationOptions0) in airflowConfigurationOptions {
                try airflowConfigurationOptionsContainer.encode(airflowConfigurationOptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let airflowVersion = self.airflowVersion {
            try encodeContainer.encode(airflowVersion, forKey: .airflowVersion)
        }
        if let dagS3Path = self.dagS3Path {
            try encodeContainer.encode(dagS3Path, forKey: .dagS3Path)
        }
        if let environmentClass = self.environmentClass {
            try encodeContainer.encode(environmentClass, forKey: .environmentClass)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let loggingConfiguration = self.loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
        if let maxWorkers = self.maxWorkers {
            try encodeContainer.encode(maxWorkers, forKey: .maxWorkers)
        }
        if let minWorkers = self.minWorkers {
            try encodeContainer.encode(minWorkers, forKey: .minWorkers)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let pluginsS3ObjectVersion = self.pluginsS3ObjectVersion {
            try encodeContainer.encode(pluginsS3ObjectVersion, forKey: .pluginsS3ObjectVersion)
        }
        if let pluginsS3Path = self.pluginsS3Path {
            try encodeContainer.encode(pluginsS3Path, forKey: .pluginsS3Path)
        }
        if let requirementsS3ObjectVersion = self.requirementsS3ObjectVersion {
            try encodeContainer.encode(requirementsS3ObjectVersion, forKey: .requirementsS3ObjectVersion)
        }
        if let requirementsS3Path = self.requirementsS3Path {
            try encodeContainer.encode(requirementsS3Path, forKey: .requirementsS3Path)
        }
        if let schedulers = self.schedulers {
            try encodeContainer.encode(schedulers, forKey: .schedulers)
        }
        if let sourceBucketArn = self.sourceBucketArn {
            try encodeContainer.encode(sourceBucketArn, forKey: .sourceBucketArn)
        }
        if let startupScriptS3ObjectVersion = self.startupScriptS3ObjectVersion {
            try encodeContainer.encode(startupScriptS3ObjectVersion, forKey: .startupScriptS3ObjectVersion)
        }
        if let startupScriptS3Path = self.startupScriptS3Path {
            try encodeContainer.encode(startupScriptS3Path, forKey: .startupScriptS3Path)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let webserverAccessMode = self.webserverAccessMode {
            try encodeContainer.encode(webserverAccessMode.rawValue, forKey: .webserverAccessMode)
        }
        if let weeklyMaintenanceWindowStart = self.weeklyMaintenanceWindowStart {
            try encodeContainer.encode(weeklyMaintenanceWindowStart, forKey: .weeklyMaintenanceWindowStart)
        }
    }
}

extension CreateEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/environments/\(name.urlPercentEncoding())"
    }
}

/// This section contains the Amazon Managed Workflows for Apache Airflow (MWAA) API reference documentation to create an environment. For more information, see [Get started with Amazon Managed Workflows for Apache Airflow](https://docs.aws.amazon.com/mwaa/latest/userguide/get-started.html).
public struct CreateEnvironmentInput: Swift.Equatable {
    /// A list of key-value pairs containing the Apache Airflow configuration options you want to attach to your environment. For more information, see [Apache Airflow configuration options](https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-env-variables.html).
    public var airflowConfigurationOptions: [Swift.String:Swift.String]?
    /// The Apache Airflow version for your environment. If no value is specified, it defaults to the latest version. Valid values: 1.10.12, 2.0.2, 2.2.2, 2.4.3, and 2.5.1. For more information, see [Apache Airflow versions on Amazon Managed Workflows for Apache Airflow (MWAA)](https://docs.aws.amazon.com/mwaa/latest/userguide/airflow-versions.html).
    public var airflowVersion: Swift.String?
    /// The relative path to the DAGs folder on your Amazon S3 bucket. For example, dags. For more information, see [Adding or updating DAGs](https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-folder.html).
    /// This member is required.
    public var dagS3Path: Swift.String?
    /// The environment class type. Valid values: mw1.small, mw1.medium, mw1.large. For more information, see [Amazon MWAA environment class](https://docs.aws.amazon.com/mwaa/latest/userguide/environment-class.html).
    public var environmentClass: Swift.String?
    /// The Amazon Resource Name (ARN) of the execution role for your environment. An execution role is an Amazon Web Services Identity and Access Management (IAM) role that grants MWAA permission to access Amazon Web Services services and resources used by your environment. For example, arn:aws:iam::123456789:role/my-execution-role. For more information, see [Amazon MWAA Execution role](https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-create-role.html).
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The Amazon Web Services Key Management Service (KMS) key to encrypt the data in your environment. You can use an Amazon Web Services owned CMK, or a Customer managed CMK (advanced). For more information, see [Create an Amazon MWAA environment](https://docs.aws.amazon.com/mwaa/latest/userguide/create-environment.html).
    public var kmsKey: Swift.String?
    /// Defines the Apache Airflow logs to send to CloudWatch Logs.
    public var loggingConfiguration: MWAAClientTypes.LoggingConfigurationInput?
    /// The maximum number of workers that you want to run in your environment. MWAA scales the number of Apache Airflow workers up to the number you specify in the MaxWorkers field. For example, 20. When there are no more tasks running, and no more in the queue, MWAA disposes of the extra workers leaving the one worker that is included with your environment, or the number you specify in MinWorkers.
    public var maxWorkers: Swift.Int?
    /// The minimum number of workers that you want to run in your environment. MWAA scales the number of Apache Airflow workers up to the number you specify in the MaxWorkers field. When there are no more tasks running, and no more in the queue, MWAA disposes of the extra workers leaving the worker count you specify in the MinWorkers field. For example, 2.
    public var minWorkers: Swift.Int?
    /// The name of the Amazon MWAA environment. For example, MyMWAAEnvironment.
    /// This member is required.
    public var name: Swift.String?
    /// The VPC networking components used to secure and enable network traffic between the Amazon Web Services resources for your environment. For more information, see [About networking on Amazon MWAA](https://docs.aws.amazon.com/mwaa/latest/userguide/networking-about.html).
    /// This member is required.
    public var networkConfiguration: MWAAClientTypes.NetworkConfiguration?
    /// The version of the plugins.zip file on your Amazon S3 bucket. You must specify a version each time a plugins.zip file is updated. For more information, see [How S3 Versioning works](https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html).
    public var pluginsS3ObjectVersion: Swift.String?
    /// The relative path to the plugins.zip file on your Amazon S3 bucket. For example, plugins.zip. If specified, then the plugins.zip version is required. For more information, see [Installing custom plugins](https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-import-plugins.html).
    public var pluginsS3Path: Swift.String?
    /// The version of the requirements.txt file on your Amazon S3 bucket. You must specify a version each time a requirements.txt file is updated. For more information, see [How S3 Versioning works](https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html).
    public var requirementsS3ObjectVersion: Swift.String?
    /// The relative path to the requirements.txt file on your Amazon S3 bucket. For example, requirements.txt. If specified, then a version is required. For more information, see [Installing Python dependencies](https://docs.aws.amazon.com/mwaa/latest/userguide/working-dags-dependencies.html).
    public var requirementsS3Path: Swift.String?
    /// The number of Apache Airflow schedulers to run in your environment. Valid values:
    ///
    /// * v2 - Accepts between 2 to 5. Defaults to 2.
    ///
    /// * v1 - Accepts 1.
    public var schedulers: Swift.Int?
    /// The Amazon Resource Name (ARN) of the Amazon S3 bucket where your DAG code and supporting files are stored. For example, arn:aws:s3:::my-airflow-bucket-unique-name. For more information, see [Create an Amazon S3 bucket for Amazon MWAA](https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-s3-bucket.html).
    /// This member is required.
    public var sourceBucketArn: Swift.String?
    /// The version of the startup shell script in your Amazon S3 bucket. You must specify the [version ID](https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html) that Amazon S3 assigns to the file every time you update the script. Version IDs are Unicode, UTF-8 encoded, URL-ready, opaque strings that are no more than 1,024 bytes long. The following is an example: 3sL4kqtJlcpXroDTDmJ+rmSpXd3dIbrHY+MTRCxf3vjVBH40Nr8X8gdRQBpUMLUo For more information, see [Using a startup script](https://docs.aws.amazon.com/mwaa/latest/userguide/using-startup-script.html).
    public var startupScriptS3ObjectVersion: Swift.String?
    /// The relative path to the startup shell script in your Amazon S3 bucket. For example, s3://mwaa-environment/startup.sh. Amazon MWAA runs the script as your environment starts, and before running the Apache Airflow process. You can use this script to install dependencies, modify Apache Airflow configuration options, and set environment variables. For more information, see [Using a startup script](https://docs.aws.amazon.com/mwaa/latest/userguide/using-startup-script.html).
    public var startupScriptS3Path: Swift.String?
    /// The key-value tag pairs you want to associate to your environment. For example, "Environment": "Staging". For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// The Apache Airflow Web server access mode. For more information, see [Apache Airflow access modes](https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-networking.html).
    public var webserverAccessMode: MWAAClientTypes.WebserverAccessMode?
    /// The day and time of the week in Coordinated Universal Time (UTC) 24-hour standard time to start weekly maintenance updates of your environment in the following format: DAY:HH:MM. For example: TUE:03:30. You can specify a start time in 30 minute increments only.
    public var weeklyMaintenanceWindowStart: Swift.String?

    public init(
        airflowConfigurationOptions: [Swift.String:Swift.String]? = nil,
        airflowVersion: Swift.String? = nil,
        dagS3Path: Swift.String? = nil,
        environmentClass: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        kmsKey: Swift.String? = nil,
        loggingConfiguration: MWAAClientTypes.LoggingConfigurationInput? = nil,
        maxWorkers: Swift.Int? = nil,
        minWorkers: Swift.Int? = nil,
        name: Swift.String? = nil,
        networkConfiguration: MWAAClientTypes.NetworkConfiguration? = nil,
        pluginsS3ObjectVersion: Swift.String? = nil,
        pluginsS3Path: Swift.String? = nil,
        requirementsS3ObjectVersion: Swift.String? = nil,
        requirementsS3Path: Swift.String? = nil,
        schedulers: Swift.Int? = nil,
        sourceBucketArn: Swift.String? = nil,
        startupScriptS3ObjectVersion: Swift.String? = nil,
        startupScriptS3Path: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        webserverAccessMode: MWAAClientTypes.WebserverAccessMode? = nil,
        weeklyMaintenanceWindowStart: Swift.String? = nil
    )
    {
        self.airflowConfigurationOptions = airflowConfigurationOptions
        self.airflowVersion = airflowVersion
        self.dagS3Path = dagS3Path
        self.environmentClass = environmentClass
        self.executionRoleArn = executionRoleArn
        self.kmsKey = kmsKey
        self.loggingConfiguration = loggingConfiguration
        self.maxWorkers = maxWorkers
        self.minWorkers = minWorkers
        self.name = name
        self.networkConfiguration = networkConfiguration
        self.pluginsS3ObjectVersion = pluginsS3ObjectVersion
        self.pluginsS3Path = pluginsS3Path
        self.requirementsS3ObjectVersion = requirementsS3ObjectVersion
        self.requirementsS3Path = requirementsS3Path
        self.schedulers = schedulers
        self.sourceBucketArn = sourceBucketArn
        self.startupScriptS3ObjectVersion = startupScriptS3ObjectVersion
        self.startupScriptS3Path = startupScriptS3Path
        self.tags = tags
        self.webserverAccessMode = webserverAccessMode
        self.weeklyMaintenanceWindowStart = weeklyMaintenanceWindowStart
    }
}

struct CreateEnvironmentInputBody: Swift.Equatable {
    let executionRoleArn: Swift.String?
    let sourceBucketArn: Swift.String?
    let dagS3Path: Swift.String?
    let networkConfiguration: MWAAClientTypes.NetworkConfiguration?
    let pluginsS3Path: Swift.String?
    let pluginsS3ObjectVersion: Swift.String?
    let requirementsS3Path: Swift.String?
    let requirementsS3ObjectVersion: Swift.String?
    let startupScriptS3Path: Swift.String?
    let startupScriptS3ObjectVersion: Swift.String?
    let airflowConfigurationOptions: [Swift.String:Swift.String]?
    let environmentClass: Swift.String?
    let maxWorkers: Swift.Int?
    let kmsKey: Swift.String?
    let airflowVersion: Swift.String?
    let loggingConfiguration: MWAAClientTypes.LoggingConfigurationInput?
    let weeklyMaintenanceWindowStart: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let webserverAccessMode: MWAAClientTypes.WebserverAccessMode?
    let minWorkers: Swift.Int?
    let schedulers: Swift.Int?
}

extension CreateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case airflowConfigurationOptions = "AirflowConfigurationOptions"
        case airflowVersion = "AirflowVersion"
        case dagS3Path = "DagS3Path"
        case environmentClass = "EnvironmentClass"
        case executionRoleArn = "ExecutionRoleArn"
        case kmsKey = "KmsKey"
        case loggingConfiguration = "LoggingConfiguration"
        case maxWorkers = "MaxWorkers"
        case minWorkers = "MinWorkers"
        case networkConfiguration = "NetworkConfiguration"
        case pluginsS3ObjectVersion = "PluginsS3ObjectVersion"
        case pluginsS3Path = "PluginsS3Path"
        case requirementsS3ObjectVersion = "RequirementsS3ObjectVersion"
        case requirementsS3Path = "RequirementsS3Path"
        case schedulers = "Schedulers"
        case sourceBucketArn = "SourceBucketArn"
        case startupScriptS3ObjectVersion = "StartupScriptS3ObjectVersion"
        case startupScriptS3Path = "StartupScriptS3Path"
        case tags = "Tags"
        case webserverAccessMode = "WebserverAccessMode"
        case weeklyMaintenanceWindowStart = "WeeklyMaintenanceWindowStart"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let sourceBucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBucketArn)
        sourceBucketArn = sourceBucketArnDecoded
        let dagS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dagS3Path)
        dagS3Path = dagS3PathDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let pluginsS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginsS3Path)
        pluginsS3Path = pluginsS3PathDecoded
        let pluginsS3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginsS3ObjectVersion)
        pluginsS3ObjectVersion = pluginsS3ObjectVersionDecoded
        let requirementsS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requirementsS3Path)
        requirementsS3Path = requirementsS3PathDecoded
        let requirementsS3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requirementsS3ObjectVersion)
        requirementsS3ObjectVersion = requirementsS3ObjectVersionDecoded
        let startupScriptS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startupScriptS3Path)
        startupScriptS3Path = startupScriptS3PathDecoded
        let startupScriptS3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startupScriptS3ObjectVersion)
        startupScriptS3ObjectVersion = startupScriptS3ObjectVersionDecoded
        let airflowConfigurationOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .airflowConfigurationOptions)
        var airflowConfigurationOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let airflowConfigurationOptionsContainer = airflowConfigurationOptionsContainer {
            airflowConfigurationOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, configvalue0) in airflowConfigurationOptionsContainer {
                if let configvalue0 = configvalue0 {
                    airflowConfigurationOptionsDecoded0?[key0] = configvalue0
                }
            }
        }
        airflowConfigurationOptions = airflowConfigurationOptionsDecoded0
        let environmentClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentClass)
        environmentClass = environmentClassDecoded
        let maxWorkersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxWorkers)
        maxWorkers = maxWorkersDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let airflowVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .airflowVersion)
        airflowVersion = airflowVersionDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.LoggingConfigurationInput.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let weeklyMaintenanceWindowStartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .weeklyMaintenanceWindowStart)
        weeklyMaintenanceWindowStart = weeklyMaintenanceWindowStartDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let webserverAccessModeDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.WebserverAccessMode.self, forKey: .webserverAccessMode)
        webserverAccessMode = webserverAccessModeDecoded
        let minWorkersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minWorkers)
        minWorkers = minWorkersDecoded
        let schedulersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .schedulers)
        schedulers = schedulersDecoded
    }
}

extension CreateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateEnvironmentOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) returned in the response for the environment.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateEnvironmentOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreateEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWebLoginTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/webtoken/\(name.urlPercentEncoding())"
    }
}

public struct CreateWebLoginTokenInput: Swift.Equatable {
    /// The name of the Amazon MWAA environment. For example, MyMWAAEnvironment.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateWebLoginTokenInputBody: Swift.Equatable {
}

extension CreateWebLoginTokenInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CreateWebLoginTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWebLoginTokenOutput(webServerHostname: \(Swift.String(describing: webServerHostname)), webToken: \"CONTENT_REDACTED\")"}
}

extension CreateWebLoginTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWebLoginTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.webServerHostname = output.webServerHostname
            self.webToken = output.webToken
        } else {
            self.webServerHostname = nil
            self.webToken = nil
        }
    }
}

public struct CreateWebLoginTokenOutput: Swift.Equatable {
    /// The Airflow web server hostname for the environment.
    public var webServerHostname: Swift.String?
    /// An Airflow web server login token.
    public var webToken: Swift.String?

    public init(
        webServerHostname: Swift.String? = nil,
        webToken: Swift.String? = nil
    )
    {
        self.webServerHostname = webServerHostname
        self.webToken = webToken
    }
}

struct CreateWebLoginTokenOutputBody: Swift.Equatable {
    let webToken: Swift.String?
    let webServerHostname: Swift.String?
}

extension CreateWebLoginTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case webServerHostname = "WebServerHostname"
        case webToken = "WebToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webToken)
        webToken = webTokenDecoded
        let webServerHostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webServerHostname)
        webServerHostname = webServerHostnameDecoded
    }
}

enum CreateWebLoginTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/environments/\(name.urlPercentEncoding())"
    }
}

public struct DeleteEnvironmentInput: Swift.Equatable {
    /// The name of the Amazon MWAA environment. For example, MyMWAAEnvironment.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEnvironmentInputBody: Swift.Equatable {
}

extension DeleteEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEnvironmentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MWAAClientTypes.Dimension: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MWAAClientTypes {
    /// Internal only. Represents the dimensions of a metric. To learn more about the metrics published to Amazon CloudWatch, see [Amazon MWAA performance metrics in Amazon CloudWatch](https://docs.aws.amazon.com/mwaa/latest/userguide/cw-metrics.html).
    public struct Dimension: Swift.Equatable {
        /// Internal only. The name of the dimension.
        /// This member is required.
        public var name: Swift.String?
        /// Internal only. The value of the dimension.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension MWAAClientTypes.Environment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case airflowConfigurationOptions = "AirflowConfigurationOptions"
        case airflowVersion = "AirflowVersion"
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case dagS3Path = "DagS3Path"
        case environmentClass = "EnvironmentClass"
        case executionRoleArn = "ExecutionRoleArn"
        case kmsKey = "KmsKey"
        case lastUpdate = "LastUpdate"
        case loggingConfiguration = "LoggingConfiguration"
        case maxWorkers = "MaxWorkers"
        case minWorkers = "MinWorkers"
        case name = "Name"
        case networkConfiguration = "NetworkConfiguration"
        case pluginsS3ObjectVersion = "PluginsS3ObjectVersion"
        case pluginsS3Path = "PluginsS3Path"
        case requirementsS3ObjectVersion = "RequirementsS3ObjectVersion"
        case requirementsS3Path = "RequirementsS3Path"
        case schedulers = "Schedulers"
        case serviceRoleArn = "ServiceRoleArn"
        case sourceBucketArn = "SourceBucketArn"
        case startupScriptS3ObjectVersion = "StartupScriptS3ObjectVersion"
        case startupScriptS3Path = "StartupScriptS3Path"
        case status = "Status"
        case tags = "Tags"
        case webserverAccessMode = "WebserverAccessMode"
        case webserverUrl = "WebserverUrl"
        case weeklyMaintenanceWindowStart = "WeeklyMaintenanceWindowStart"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let airflowConfigurationOptions = airflowConfigurationOptions {
            var airflowConfigurationOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .airflowConfigurationOptions)
            for (dictKey0, airflowConfigurationOptions0) in airflowConfigurationOptions {
                try airflowConfigurationOptionsContainer.encode(airflowConfigurationOptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let airflowVersion = self.airflowVersion {
            try encodeContainer.encode(airflowVersion, forKey: .airflowVersion)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let dagS3Path = self.dagS3Path {
            try encodeContainer.encode(dagS3Path, forKey: .dagS3Path)
        }
        if let environmentClass = self.environmentClass {
            try encodeContainer.encode(environmentClass, forKey: .environmentClass)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let lastUpdate = self.lastUpdate {
            try encodeContainer.encode(lastUpdate, forKey: .lastUpdate)
        }
        if let loggingConfiguration = self.loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
        if let maxWorkers = self.maxWorkers {
            try encodeContainer.encode(maxWorkers, forKey: .maxWorkers)
        }
        if let minWorkers = self.minWorkers {
            try encodeContainer.encode(minWorkers, forKey: .minWorkers)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let pluginsS3ObjectVersion = self.pluginsS3ObjectVersion {
            try encodeContainer.encode(pluginsS3ObjectVersion, forKey: .pluginsS3ObjectVersion)
        }
        if let pluginsS3Path = self.pluginsS3Path {
            try encodeContainer.encode(pluginsS3Path, forKey: .pluginsS3Path)
        }
        if let requirementsS3ObjectVersion = self.requirementsS3ObjectVersion {
            try encodeContainer.encode(requirementsS3ObjectVersion, forKey: .requirementsS3ObjectVersion)
        }
        if let requirementsS3Path = self.requirementsS3Path {
            try encodeContainer.encode(requirementsS3Path, forKey: .requirementsS3Path)
        }
        if let schedulers = self.schedulers {
            try encodeContainer.encode(schedulers, forKey: .schedulers)
        }
        if let serviceRoleArn = self.serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let sourceBucketArn = self.sourceBucketArn {
            try encodeContainer.encode(sourceBucketArn, forKey: .sourceBucketArn)
        }
        if let startupScriptS3ObjectVersion = self.startupScriptS3ObjectVersion {
            try encodeContainer.encode(startupScriptS3ObjectVersion, forKey: .startupScriptS3ObjectVersion)
        }
        if let startupScriptS3Path = self.startupScriptS3Path {
            try encodeContainer.encode(startupScriptS3Path, forKey: .startupScriptS3Path)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let webserverAccessMode = self.webserverAccessMode {
            try encodeContainer.encode(webserverAccessMode.rawValue, forKey: .webserverAccessMode)
        }
        if let webserverUrl = self.webserverUrl {
            try encodeContainer.encode(webserverUrl, forKey: .webserverUrl)
        }
        if let weeklyMaintenanceWindowStart = self.weeklyMaintenanceWindowStart {
            try encodeContainer.encode(weeklyMaintenanceWindowStart, forKey: .weeklyMaintenanceWindowStart)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let webserverUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webserverUrl)
        webserverUrl = webserverUrlDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let airflowVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .airflowVersion)
        airflowVersion = airflowVersionDecoded
        let sourceBucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBucketArn)
        sourceBucketArn = sourceBucketArnDecoded
        let dagS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dagS3Path)
        dagS3Path = dagS3PathDecoded
        let pluginsS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginsS3Path)
        pluginsS3Path = pluginsS3PathDecoded
        let pluginsS3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginsS3ObjectVersion)
        pluginsS3ObjectVersion = pluginsS3ObjectVersionDecoded
        let requirementsS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requirementsS3Path)
        requirementsS3Path = requirementsS3PathDecoded
        let requirementsS3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requirementsS3ObjectVersion)
        requirementsS3ObjectVersion = requirementsS3ObjectVersionDecoded
        let startupScriptS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startupScriptS3Path)
        startupScriptS3Path = startupScriptS3PathDecoded
        let startupScriptS3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startupScriptS3ObjectVersion)
        startupScriptS3ObjectVersion = startupScriptS3ObjectVersionDecoded
        let airflowConfigurationOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .airflowConfigurationOptions)
        var airflowConfigurationOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let airflowConfigurationOptionsContainer = airflowConfigurationOptionsContainer {
            airflowConfigurationOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, configvalue0) in airflowConfigurationOptionsContainer {
                if let configvalue0 = configvalue0 {
                    airflowConfigurationOptionsDecoded0?[key0] = configvalue0
                }
            }
        }
        airflowConfigurationOptions = airflowConfigurationOptionsDecoded0
        let environmentClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentClass)
        environmentClass = environmentClassDecoded
        let maxWorkersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxWorkers)
        maxWorkers = maxWorkersDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let lastUpdateDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.LastUpdate.self, forKey: .lastUpdate)
        lastUpdate = lastUpdateDecoded
        let weeklyMaintenanceWindowStartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .weeklyMaintenanceWindowStart)
        weeklyMaintenanceWindowStart = weeklyMaintenanceWindowStartDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let webserverAccessModeDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.WebserverAccessMode.self, forKey: .webserverAccessMode)
        webserverAccessMode = webserverAccessModeDecoded
        let minWorkersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minWorkers)
        minWorkers = minWorkersDecoded
        let schedulersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .schedulers)
        schedulers = schedulersDecoded
    }
}

extension MWAAClientTypes.Environment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Environment(airflowVersion: \(Swift.String(describing: airflowVersion)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), dagS3Path: \(Swift.String(describing: dagS3Path)), environmentClass: \(Swift.String(describing: environmentClass)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), kmsKey: \(Swift.String(describing: kmsKey)), lastUpdate: \(Swift.String(describing: lastUpdate)), loggingConfiguration: \(Swift.String(describing: loggingConfiguration)), maxWorkers: \(Swift.String(describing: maxWorkers)), minWorkers: \(Swift.String(describing: minWorkers)), name: \(Swift.String(describing: name)), networkConfiguration: \(Swift.String(describing: networkConfiguration)), pluginsS3ObjectVersion: \(Swift.String(describing: pluginsS3ObjectVersion)), pluginsS3Path: \(Swift.String(describing: pluginsS3Path)), requirementsS3ObjectVersion: \(Swift.String(describing: requirementsS3ObjectVersion)), requirementsS3Path: \(Swift.String(describing: requirementsS3Path)), schedulers: \(Swift.String(describing: schedulers)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), sourceBucketArn: \(Swift.String(describing: sourceBucketArn)), startupScriptS3ObjectVersion: \(Swift.String(describing: startupScriptS3ObjectVersion)), startupScriptS3Path: \(Swift.String(describing: startupScriptS3Path)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), webserverAccessMode: \(Swift.String(describing: webserverAccessMode)), webserverUrl: \(Swift.String(describing: webserverUrl)), weeklyMaintenanceWindowStart: \(Swift.String(describing: weeklyMaintenanceWindowStart)), airflowConfigurationOptions: \"CONTENT_REDACTED\")"}
}

extension MWAAClientTypes {
    /// Describes an Amazon Managed Workflows for Apache Airflow (MWAA) environment.
    public struct Environment: Swift.Equatable {
        /// A list of key-value pairs containing the Apache Airflow configuration options attached to your environment. For more information, see [Apache Airflow configuration options](https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-env-variables.html).
        public var airflowConfigurationOptions: [Swift.String:Swift.String]?
        /// The Apache Airflow version on your environment. Valid values: 1.10.12, 2.0.2, 2.2.2, 2.4.3, and 2.5.1.
        public var airflowVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon MWAA environment.
        public var arn: Swift.String?
        /// The day and time the environment was created.
        public var createdAt: ClientRuntime.Date?
        /// The relative path to the DAGs folder in your Amazon S3 bucket. For example, s3://mwaa-environment/dags. For more information, see [Adding or updating DAGs](https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-folder.html).
        public var dagS3Path: Swift.String?
        /// The environment class type. Valid values: mw1.small, mw1.medium, mw1.large. For more information, see [Amazon MWAA environment class](https://docs.aws.amazon.com/mwaa/latest/userguide/environment-class.html).
        public var environmentClass: Swift.String?
        /// The Amazon Resource Name (ARN) of the execution role in IAM that allows MWAA to access Amazon Web Services resources in your environment. For example, arn:aws:iam::123456789:role/my-execution-role. For more information, see [Amazon MWAA Execution role](https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-create-role.html).
        public var executionRoleArn: Swift.String?
        /// The Amazon Web Services Key Management Service (KMS) encryption key used to encrypt the data in your environment.
        public var kmsKey: Swift.String?
        /// The status of the last update on the environment.
        public var lastUpdate: MWAAClientTypes.LastUpdate?
        /// The Apache Airflow logs published to CloudWatch Logs.
        public var loggingConfiguration: MWAAClientTypes.LoggingConfiguration?
        /// The maximum number of workers that run in your environment. For example, 20.
        public var maxWorkers: Swift.Int?
        /// The minimum number of workers that run in your environment. For example, 2.
        public var minWorkers: Swift.Int?
        /// The name of the Amazon MWAA environment. For example, MyMWAAEnvironment.
        public var name: Swift.String?
        /// Describes the VPC networking components used to secure and enable network traffic between the Amazon Web Services resources for your environment. For more information, see [About networking on Amazon MWAA](https://docs.aws.amazon.com/mwaa/latest/userguide/networking-about.html).
        public var networkConfiguration: MWAAClientTypes.NetworkConfiguration?
        /// The version of the plugins.zip file in your Amazon S3 bucket. You must specify the [version ID](https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html) that Amazon S3 assigns to the file. Version IDs are Unicode, UTF-8 encoded, URL-ready, opaque strings that are no more than 1,024 bytes long. The following is an example: 3sL4kqtJlcpXroDTDmJ+rmSpXd3dIbrHY+MTRCxf3vjVBH40Nr8X8gdRQBpUMLUo For more information, see [Installing custom plugins](https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-import-plugins.html).
        public var pluginsS3ObjectVersion: Swift.String?
        /// The relative path to the file in your Amazon S3 bucket. For example, s3://mwaa-environment/plugins.zip. For more information, see [Installing custom plugins](https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-import-plugins.html).
        public var pluginsS3Path: Swift.String?
        /// The version of the requirements.txt  file on your Amazon S3 bucket. You must specify the [version ID](https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html) that Amazon S3 assigns to the file. Version IDs are Unicode, UTF-8 encoded, URL-ready, opaque strings that are no more than 1,024 bytes long. The following is an example: 3sL4kqtJlcpXroDTDmJ+rmSpXd3dIbrHY+MTRCxf3vjVBH40Nr8X8gdRQBpUMLUo For more information, see [Installing Python dependencies](https://docs.aws.amazon.com/mwaa/latest/userguide/working-dags-dependencies.html).
        public var requirementsS3ObjectVersion: Swift.String?
        /// The relative path to the requirements.txt file in your Amazon S3 bucket. For example, s3://mwaa-environment/requirements.txt. For more information, see [Installing Python dependencies](https://docs.aws.amazon.com/mwaa/latest/userguide/working-dags-dependencies.html).
        public var requirementsS3Path: Swift.String?
        /// The number of Apache Airflow schedulers that run in your Amazon MWAA environment.
        public var schedulers: Swift.Int?
        /// The Amazon Resource Name (ARN) for the service-linked role of the environment. For more information, see [Amazon MWAA Service-linked role](https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-slr.html).
        public var serviceRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon S3 bucket where your DAG code and supporting files are stored. For example, arn:aws:s3:::my-airflow-bucket-unique-name. For more information, see [Create an Amazon S3 bucket for Amazon MWAA](https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-s3-bucket.html).
        public var sourceBucketArn: Swift.String?
        /// The version of the startup shell script in your Amazon S3 bucket. You must specify the [version ID](https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html) that Amazon S3 assigns to the file. Version IDs are Unicode, UTF-8 encoded, URL-ready, opaque strings that are no more than 1,024 bytes long. The following is an example: 3sL4kqtJlcpXroDTDmJ+rmSpXd3dIbrHY+MTRCxf3vjVBH40Nr8X8gdRQBpUMLUo For more information, see [Using a startup script](https://docs.aws.amazon.com/mwaa/latest/userguide/using-startup-script.html).
        public var startupScriptS3ObjectVersion: Swift.String?
        /// The relative path to the startup shell script in your Amazon S3 bucket. For example, s3://mwaa-environment/startup.sh. Amazon MWAA runs the script as your environment starts, and before running the Apache Airflow process. You can use this script to install dependencies, modify Apache Airflow configuration options, and set environment variables. For more information, see [Using a startup script](https://docs.aws.amazon.com/mwaa/latest/userguide/using-startup-script.html).
        public var startupScriptS3Path: Swift.String?
        /// The status of the Amazon MWAA environment. Valid values:
        ///
        /// * CREATING - Indicates the request to create the environment is in progress.
        ///
        /// * CREATING_SNAPSHOT - Indicates the request to update environment details, or upgrade the environment version, is in progress and Amazon MWAA is creating a storage volume snapshot of the Amazon RDS database cluster associated with the environment. A database snapshot is a backup created at a specific point in time. Amazon MWAA uses snapshots to recover environment metadata if the process to update or upgrade an environment fails.
        ///
        /// * CREATE_FAILED - Indicates the request to create the environment failed, and the environment could not be created.
        ///
        /// * AVAILABLE - Indicates the request was successful and the environment is ready to use.
        ///
        /// * UPDATING - Indicates the request to update the environment is in progress.
        ///
        /// * ROLLING_BACK - Indicates the request to update environment details, or upgrade the environment version, failed and Amazon MWAA is restoring the environment using the latest storage volume snapshot.
        ///
        /// * DELETING - Indicates the request to delete the environment is in progress.
        ///
        /// * DELETED - Indicates the request to delete the environment is complete, and the environment has been deleted.
        ///
        /// * UNAVAILABLE - Indicates the request failed, but the environment was unable to rollback and is not in a stable state.
        ///
        /// * UPDATE_FAILED - Indicates the request to update the environment failed, and the environment has rolled back successfully and is ready to use.
        ///
        ///
        /// We recommend reviewing our troubleshooting guide for a list of common errors and their solutions. For more information, see [Amazon MWAA troubleshooting](https://docs.aws.amazon.com/mwaa/latest/userguide/troubleshooting.html).
        public var status: MWAAClientTypes.EnvironmentStatus?
        /// The key-value tag pairs associated to your environment. For example, "Environment": "Staging". For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
        public var tags: [Swift.String:Swift.String]?
        /// The Apache Airflow Web server access mode. For more information, see [Apache Airflow access modes](https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-networking.html).
        public var webserverAccessMode: MWAAClientTypes.WebserverAccessMode?
        /// The Apache Airflow Web server host name for the Amazon MWAA environment. For more information, see [Accessing the Apache Airflow UI](https://docs.aws.amazon.com/mwaa/latest/userguide/access-airflow-ui.html).
        public var webserverUrl: Swift.String?
        /// The day and time of the week in Coordinated Universal Time (UTC) 24-hour standard time that weekly maintenance updates are scheduled. For example: TUE:03:30.
        public var weeklyMaintenanceWindowStart: Swift.String?

        public init(
            airflowConfigurationOptions: [Swift.String:Swift.String]? = nil,
            airflowVersion: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            dagS3Path: Swift.String? = nil,
            environmentClass: Swift.String? = nil,
            executionRoleArn: Swift.String? = nil,
            kmsKey: Swift.String? = nil,
            lastUpdate: MWAAClientTypes.LastUpdate? = nil,
            loggingConfiguration: MWAAClientTypes.LoggingConfiguration? = nil,
            maxWorkers: Swift.Int? = nil,
            minWorkers: Swift.Int? = nil,
            name: Swift.String? = nil,
            networkConfiguration: MWAAClientTypes.NetworkConfiguration? = nil,
            pluginsS3ObjectVersion: Swift.String? = nil,
            pluginsS3Path: Swift.String? = nil,
            requirementsS3ObjectVersion: Swift.String? = nil,
            requirementsS3Path: Swift.String? = nil,
            schedulers: Swift.Int? = nil,
            serviceRoleArn: Swift.String? = nil,
            sourceBucketArn: Swift.String? = nil,
            startupScriptS3ObjectVersion: Swift.String? = nil,
            startupScriptS3Path: Swift.String? = nil,
            status: MWAAClientTypes.EnvironmentStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            webserverAccessMode: MWAAClientTypes.WebserverAccessMode? = nil,
            webserverUrl: Swift.String? = nil,
            weeklyMaintenanceWindowStart: Swift.String? = nil
        )
        {
            self.airflowConfigurationOptions = airflowConfigurationOptions
            self.airflowVersion = airflowVersion
            self.arn = arn
            self.createdAt = createdAt
            self.dagS3Path = dagS3Path
            self.environmentClass = environmentClass
            self.executionRoleArn = executionRoleArn
            self.kmsKey = kmsKey
            self.lastUpdate = lastUpdate
            self.loggingConfiguration = loggingConfiguration
            self.maxWorkers = maxWorkers
            self.minWorkers = minWorkers
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.pluginsS3ObjectVersion = pluginsS3ObjectVersion
            self.pluginsS3Path = pluginsS3Path
            self.requirementsS3ObjectVersion = requirementsS3ObjectVersion
            self.requirementsS3Path = requirementsS3Path
            self.schedulers = schedulers
            self.serviceRoleArn = serviceRoleArn
            self.sourceBucketArn = sourceBucketArn
            self.startupScriptS3ObjectVersion = startupScriptS3ObjectVersion
            self.startupScriptS3Path = startupScriptS3Path
            self.status = status
            self.tags = tags
            self.webserverAccessMode = webserverAccessMode
            self.webserverUrl = webserverUrl
            self.weeklyMaintenanceWindowStart = weeklyMaintenanceWindowStart
        }
    }

}

extension MWAAClientTypes {
    public enum EnvironmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case createFailed
        case creating
        case creatingSnapshot
        case deleted
        case deleting
        case rollingBack
        case unavailable
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentStatus] {
            return [
                .available,
                .createFailed,
                .creating,
                .creatingSnapshot,
                .deleted,
                .deleting,
                .rollingBack,
                .unavailable,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .creatingSnapshot: return "CREATING_SNAPSHOT"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .rollingBack: return "ROLLING_BACK"
            case .unavailable: return "UNAVAILABLE"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentStatus(rawValue: rawValue) ?? EnvironmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/environments/\(name.urlPercentEncoding())"
    }
}

public struct GetEnvironmentInput: Swift.Equatable {
    /// The name of the Amazon MWAA environment. For example, MyMWAAEnvironment.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetEnvironmentInputBody: Swift.Equatable {
}

extension GetEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct GetEnvironmentOutput: Swift.Equatable {
    /// An object containing all available details about the environment.
    public var environment: MWAAClientTypes.Environment?

    public init(
        environment: MWAAClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct GetEnvironmentOutputBody: Swift.Equatable {
    let environment: MWAAClientTypes.Environment?
}

extension GetEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment = "Environment"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum GetEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// InternalServerException: An internal error has occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MWAAClientTypes.LastUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case error = "Error"
        case source = "Source"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.UpdateStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let errorDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.UpdateError.self, forKey: .error)
        error = errorDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension MWAAClientTypes {
    /// Describes the status of the last update on the environment, and any errors that were encountered.
    public struct LastUpdate: Swift.Equatable {
        /// The day and time of the last update on the environment.
        public var createdAt: ClientRuntime.Date?
        /// The error that was encountered during the last update of the environment.
        public var error: MWAAClientTypes.UpdateError?
        /// The source of the last update to the environment. Includes internal processes by Amazon MWAA, such as an environment maintenance update.
        public var source: Swift.String?
        /// The status of the last update on the environment.
        public var status: MWAAClientTypes.UpdateStatus?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            error: MWAAClientTypes.UpdateError? = nil,
            source: Swift.String? = nil,
            status: MWAAClientTypes.UpdateStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.error = error
            self.source = source
            self.status = status
        }
    }

}

extension ListEnvironmentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListEnvironmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/environments"
    }
}

public struct ListEnvironmentsInput: Swift.Equatable {
    /// The maximum number of results to retrieve per page. For example, 5 environments per page.
    public var maxResults: Swift.Int?
    /// Retrieves the next page of the results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Swift.Equatable {
}

extension ListEnvironmentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.environments = output.environments
            self.nextToken = output.nextToken
        } else {
            self.environments = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutput: Swift.Equatable {
    /// Returns a list of Amazon MWAA environments.
    /// This member is required.
    public var environments: [Swift.String]?
    /// Retrieves the next page of the results.
    public var nextToken: Swift.String?

    public init(
        environments: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputBody: Swift.Equatable {
    let environments: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListEnvironmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environments = "Environments"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .environments)
        var environmentsDecoded0:[Swift.String]? = nil
        if let environmentsContainer = environmentsContainer {
            environmentsDecoded0 = [Swift.String]()
            for string0 in environmentsContainer {
                if let string0 = string0 {
                    environmentsDecoded0?.append(string0)
                }
            }
        }
        environments = environmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnvironmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon MWAA environment. For example, arn:aws:airflow:us-east-1:123456789012:environment/MyMWAAEnvironment.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The key-value tag pairs associated to your environment. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MWAAClientTypes.LoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dagProcessingLogs = "DagProcessingLogs"
        case schedulerLogs = "SchedulerLogs"
        case taskLogs = "TaskLogs"
        case webserverLogs = "WebserverLogs"
        case workerLogs = "WorkerLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dagProcessingLogs = self.dagProcessingLogs {
            try encodeContainer.encode(dagProcessingLogs, forKey: .dagProcessingLogs)
        }
        if let schedulerLogs = self.schedulerLogs {
            try encodeContainer.encode(schedulerLogs, forKey: .schedulerLogs)
        }
        if let taskLogs = self.taskLogs {
            try encodeContainer.encode(taskLogs, forKey: .taskLogs)
        }
        if let webserverLogs = self.webserverLogs {
            try encodeContainer.encode(webserverLogs, forKey: .webserverLogs)
        }
        if let workerLogs = self.workerLogs {
            try encodeContainer.encode(workerLogs, forKey: .workerLogs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dagProcessingLogsDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.ModuleLoggingConfiguration.self, forKey: .dagProcessingLogs)
        dagProcessingLogs = dagProcessingLogsDecoded
        let schedulerLogsDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.ModuleLoggingConfiguration.self, forKey: .schedulerLogs)
        schedulerLogs = schedulerLogsDecoded
        let webserverLogsDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.ModuleLoggingConfiguration.self, forKey: .webserverLogs)
        webserverLogs = webserverLogsDecoded
        let workerLogsDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.ModuleLoggingConfiguration.self, forKey: .workerLogs)
        workerLogs = workerLogsDecoded
        let taskLogsDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.ModuleLoggingConfiguration.self, forKey: .taskLogs)
        taskLogs = taskLogsDecoded
    }
}

extension MWAAClientTypes {
    /// Describes the Apache Airflow log types that are published to CloudWatch Logs.
    public struct LoggingConfiguration: Swift.Equatable {
        /// The Airflow DAG processing logs published to CloudWatch Logs and the log level.
        public var dagProcessingLogs: MWAAClientTypes.ModuleLoggingConfiguration?
        /// The Airflow scheduler logs published to CloudWatch Logs and the log level.
        public var schedulerLogs: MWAAClientTypes.ModuleLoggingConfiguration?
        /// The Airflow task logs published to CloudWatch Logs and the log level.
        public var taskLogs: MWAAClientTypes.ModuleLoggingConfiguration?
        /// The Airflow web server logs published to CloudWatch Logs and the log level.
        public var webserverLogs: MWAAClientTypes.ModuleLoggingConfiguration?
        /// The Airflow worker logs published to CloudWatch Logs and the log level.
        public var workerLogs: MWAAClientTypes.ModuleLoggingConfiguration?

        public init(
            dagProcessingLogs: MWAAClientTypes.ModuleLoggingConfiguration? = nil,
            schedulerLogs: MWAAClientTypes.ModuleLoggingConfiguration? = nil,
            taskLogs: MWAAClientTypes.ModuleLoggingConfiguration? = nil,
            webserverLogs: MWAAClientTypes.ModuleLoggingConfiguration? = nil,
            workerLogs: MWAAClientTypes.ModuleLoggingConfiguration? = nil
        )
        {
            self.dagProcessingLogs = dagProcessingLogs
            self.schedulerLogs = schedulerLogs
            self.taskLogs = taskLogs
            self.webserverLogs = webserverLogs
            self.workerLogs = workerLogs
        }
    }

}

extension MWAAClientTypes.LoggingConfigurationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dagProcessingLogs = "DagProcessingLogs"
        case schedulerLogs = "SchedulerLogs"
        case taskLogs = "TaskLogs"
        case webserverLogs = "WebserverLogs"
        case workerLogs = "WorkerLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dagProcessingLogs = self.dagProcessingLogs {
            try encodeContainer.encode(dagProcessingLogs, forKey: .dagProcessingLogs)
        }
        if let schedulerLogs = self.schedulerLogs {
            try encodeContainer.encode(schedulerLogs, forKey: .schedulerLogs)
        }
        if let taskLogs = self.taskLogs {
            try encodeContainer.encode(taskLogs, forKey: .taskLogs)
        }
        if let webserverLogs = self.webserverLogs {
            try encodeContainer.encode(webserverLogs, forKey: .webserverLogs)
        }
        if let workerLogs = self.workerLogs {
            try encodeContainer.encode(workerLogs, forKey: .workerLogs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dagProcessingLogsDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.ModuleLoggingConfigurationInput.self, forKey: .dagProcessingLogs)
        dagProcessingLogs = dagProcessingLogsDecoded
        let schedulerLogsDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.ModuleLoggingConfigurationInput.self, forKey: .schedulerLogs)
        schedulerLogs = schedulerLogsDecoded
        let webserverLogsDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.ModuleLoggingConfigurationInput.self, forKey: .webserverLogs)
        webserverLogs = webserverLogsDecoded
        let workerLogsDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.ModuleLoggingConfigurationInput.self, forKey: .workerLogs)
        workerLogs = workerLogsDecoded
        let taskLogsDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.ModuleLoggingConfigurationInput.self, forKey: .taskLogs)
        taskLogs = taskLogsDecoded
    }
}

extension MWAAClientTypes {
    /// Defines the Apache Airflow log types to send to CloudWatch Logs.
    public struct LoggingConfigurationInput: Swift.Equatable {
        /// Publishes Airflow DAG processing logs to CloudWatch Logs.
        public var dagProcessingLogs: MWAAClientTypes.ModuleLoggingConfigurationInput?
        /// Publishes Airflow scheduler logs to CloudWatch Logs.
        public var schedulerLogs: MWAAClientTypes.ModuleLoggingConfigurationInput?
        /// Publishes Airflow task logs to CloudWatch Logs.
        public var taskLogs: MWAAClientTypes.ModuleLoggingConfigurationInput?
        /// Publishes Airflow web server logs to CloudWatch Logs.
        public var webserverLogs: MWAAClientTypes.ModuleLoggingConfigurationInput?
        /// Publishes Airflow worker logs to CloudWatch Logs.
        public var workerLogs: MWAAClientTypes.ModuleLoggingConfigurationInput?

        public init(
            dagProcessingLogs: MWAAClientTypes.ModuleLoggingConfigurationInput? = nil,
            schedulerLogs: MWAAClientTypes.ModuleLoggingConfigurationInput? = nil,
            taskLogs: MWAAClientTypes.ModuleLoggingConfigurationInput? = nil,
            webserverLogs: MWAAClientTypes.ModuleLoggingConfigurationInput? = nil,
            workerLogs: MWAAClientTypes.ModuleLoggingConfigurationInput? = nil
        )
        {
            self.dagProcessingLogs = dagProcessingLogs
            self.schedulerLogs = schedulerLogs
            self.taskLogs = taskLogs
            self.webserverLogs = webserverLogs
            self.workerLogs = workerLogs
        }
    }

}

extension MWAAClientTypes {
    public enum LoggingLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case debug
        case error
        case info
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingLevel] {
            return [
                .critical,
                .debug,
                .error,
                .info,
                .warning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggingLevel(rawValue: rawValue) ?? LoggingLevel.sdkUnknown(rawValue)
        }
    }
}

extension MWAAClientTypes.MetricDatum: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case metricName = "MetricName"
        case statisticValues = "StatisticValues"
        case timestamp = "Timestamp"
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for dimension0 in dimensions {
                try dimensionsContainer.encode(dimension0)
            }
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let statisticValues = self.statisticValues {
            try encodeContainer.encode(statisticValues, forKey: .statisticValues)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([MWAAClientTypes.Dimension?].self, forKey: .dimensions)
        var dimensionsDecoded0:[MWAAClientTypes.Dimension]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [MWAAClientTypes.Dimension]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.Unit.self, forKey: .unit)
        unit = unitDecoded
        let statisticValuesDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.StatisticSet.self, forKey: .statisticValues)
        statisticValues = statisticValuesDecoded
    }
}

extension MWAAClientTypes {
    /// Internal only. Collects Apache Airflow metrics. To learn more about the metrics published to Amazon CloudWatch, see [Amazon MWAA performance metrics in Amazon CloudWatch](https://docs.aws.amazon.com/mwaa/latest/userguide/cw-metrics.html).
    public struct MetricDatum: Swift.Equatable {
        /// Internal only. The dimensions associated with the metric.
        public var dimensions: [MWAAClientTypes.Dimension]?
        /// Internal only. The name of the metric.
        /// This member is required.
        public var metricName: Swift.String?
        /// Internal only. The statistical values for the metric.
        public var statisticValues: MWAAClientTypes.StatisticSet?
        /// Internal only. The time the metric data was received.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// Internal only. The unit used to store the metric.
        public var unit: MWAAClientTypes.Unit?
        /// Internal only. The value for the metric.
        public var value: Swift.Double?

        public init(
            dimensions: [MWAAClientTypes.Dimension]? = nil,
            metricName: Swift.String? = nil,
            statisticValues: MWAAClientTypes.StatisticSet? = nil,
            timestamp: ClientRuntime.Date? = nil,
            unit: MWAAClientTypes.Unit? = nil,
            value: Swift.Double? = nil
        )
        {
            self.dimensions = dimensions
            self.metricName = metricName
            self.statisticValues = statisticValues
            self.timestamp = timestamp
            self.unit = unit
            self.value = value
        }
    }

}

extension MWAAClientTypes.ModuleLoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogGroupArn = "CloudWatchLogGroupArn"
        case enabled = "Enabled"
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogGroupArn = self.cloudWatchLogGroupArn {
            try encodeContainer.encode(cloudWatchLogGroupArn, forKey: .cloudWatchLogGroupArn)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.LoggingLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let cloudWatchLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogGroupArn)
        cloudWatchLogGroupArn = cloudWatchLogGroupArnDecoded
    }
}

extension MWAAClientTypes {
    /// Describes the Apache Airflow log details for the log type (e.g. DagProcessingLogs).
    public struct ModuleLoggingConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the CloudWatch Logs group where the Apache Airflow log type (e.g. DagProcessingLogs) is published. For example, arn:aws:logs:us-east-1:123456789012:log-group:airflow-MyMWAAEnvironment-MwaaEnvironment-DAGProcessing:*.
        public var cloudWatchLogGroupArn: Swift.String?
        /// Indicates whether the Apache Airflow log type (e.g. DagProcessingLogs) is enabled.
        public var enabled: Swift.Bool?
        /// The Apache Airflow log level for the log type (e.g. DagProcessingLogs).
        public var logLevel: MWAAClientTypes.LoggingLevel?

        public init(
            cloudWatchLogGroupArn: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            logLevel: MWAAClientTypes.LoggingLevel? = nil
        )
        {
            self.cloudWatchLogGroupArn = cloudWatchLogGroupArn
            self.enabled = enabled
            self.logLevel = logLevel
        }
    }

}

extension MWAAClientTypes.ModuleLoggingConfigurationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.LoggingLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension MWAAClientTypes {
    /// Enables the Apache Airflow log type (e.g. DagProcessingLogs) and defines the log level to send to CloudWatch Logs (e.g. INFO).
    public struct ModuleLoggingConfigurationInput: Swift.Equatable {
        /// Indicates whether to enable the Apache Airflow log type (e.g. DagProcessingLogs).
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Defines the Apache Airflow log level (e.g. INFO) to send to CloudWatch Logs.
        /// This member is required.
        public var logLevel: MWAAClientTypes.LoggingLevel?

        public init(
            enabled: Swift.Bool? = nil,
            logLevel: MWAAClientTypes.LoggingLevel? = nil
        )
        {
            self.enabled = enabled
            self.logLevel = logLevel
        }
    }

}

extension MWAAClientTypes.NetworkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension MWAAClientTypes {
    /// Describes the VPC networking components used to secure and enable network traffic between the Amazon Web Services resources for your environment. For more information, see [About networking on Amazon MWAA](https://docs.aws.amazon.com/mwaa/latest/userguide/networking-about.html).
    public struct NetworkConfiguration: Swift.Equatable {
        /// A list of security group IDs. For more information, see [Security in your VPC on Amazon MWAA](https://docs.aws.amazon.com/mwaa/latest/userguide/vpc-security.html).
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs. For more information, see [About networking on Amazon MWAA](https://docs.aws.amazon.com/mwaa/latest/userguide/networking-about.html).
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension PublishMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricData = "MetricData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricData = metricData {
            var metricDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricData)
            for metricdatum0 in metricData {
                try metricDataContainer.encode(metricdatum0)
            }
        }
    }
}

extension PublishMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentName = environmentName else {
            return nil
        }
        return "/metrics/environments/\(environmentName.urlPercentEncoding())"
    }
}

public struct PublishMetricsInput: Swift.Equatable {
    /// Internal only. The name of the environment.
    /// This member is required.
    public var environmentName: Swift.String?
    /// Internal only. Publishes metrics to Amazon CloudWatch. To learn more about the metrics published to Amazon CloudWatch, see [Amazon MWAA performance metrics in Amazon CloudWatch](https://docs.aws.amazon.com/mwaa/latest/userguide/cw-metrics.html).
    /// This member is required.
    public var metricData: [MWAAClientTypes.MetricDatum]?

    public init(
        environmentName: Swift.String? = nil,
        metricData: [MWAAClientTypes.MetricDatum]? = nil
    )
    {
        self.environmentName = environmentName
        self.metricData = metricData
    }
}

struct PublishMetricsInputBody: Swift.Equatable {
    let metricData: [MWAAClientTypes.MetricDatum]?
}

extension PublishMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricData = "MetricData"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDataContainer = try containerValues.decodeIfPresent([MWAAClientTypes.MetricDatum?].self, forKey: .metricData)
        var metricDataDecoded0:[MWAAClientTypes.MetricDatum]? = nil
        if let metricDataContainer = metricDataContainer {
            metricDataDecoded0 = [MWAAClientTypes.MetricDatum]()
            for structure0 in metricDataContainer {
                if let structure0 = structure0 {
                    metricDataDecoded0?.append(structure0)
                }
            }
        }
        metricData = metricDataDecoded0
    }
}

extension PublishMetricsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PublishMetricsOutput: Swift.Equatable {

    public init() { }
}

enum PublishMetricsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// ResourceNotFoundException: The resource is not available.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MWAAClientTypes.StatisticSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximum = "Maximum"
        case minimum = "Minimum"
        case sampleCount = "SampleCount"
        case sum = "Sum"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximum = self.maximum {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if let minimum = self.minimum {
            try encodeContainer.encode(minimum, forKey: .minimum)
        }
        if let sampleCount = self.sampleCount {
            try encodeContainer.encode(sampleCount, forKey: .sampleCount)
        }
        if let sum = self.sum {
            try encodeContainer.encode(sum, forKey: .sum)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sampleCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sampleCount)
        sampleCount = sampleCountDecoded
        let sumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .sum)
        sum = sumDecoded
        let minimumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minimum)
        minimum = minimumDecoded
        let maximumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maximum)
        maximum = maximumDecoded
    }
}

extension MWAAClientTypes {
    /// Internal only. Represents a set of statistics that describe a specific metric. To learn more about the metrics published to Amazon CloudWatch, see [Amazon MWAA performance metrics in Amazon CloudWatch](https://docs.aws.amazon.com/mwaa/latest/userguide/cw-metrics.html).
    public struct StatisticSet: Swift.Equatable {
        /// Internal only. The maximum value of the sample set.
        public var maximum: Swift.Double?
        /// Internal only. The minimum value of the sample set.
        public var minimum: Swift.Double?
        /// Internal only. The number of samples used for the statistic set.
        public var sampleCount: Swift.Int?
        /// Internal only. The sum of values for the sample set.
        public var sum: Swift.Double?

        public init(
            maximum: Swift.Double? = nil,
            minimum: Swift.Double? = nil,
            sampleCount: Swift.Int? = nil,
            sum: Swift.Double? = nil
        )
        {
            self.maximum = maximum
            self.minimum = minimum
            self.sampleCount = sampleCount
            self.sum = sum
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon MWAA environment. For example, arn:aws:airflow:us-east-1:123456789012:environment/MyMWAAEnvironment.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value tag pairs you want to associate to your environment. For example, "Environment": "Staging". For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MWAAClientTypes {
    public enum Unit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bits
        case bitsPerSecond
        case bytes
        case bytesPerSecond
        case count
        case countPerSecond
        case gigabits
        case gigabitsPerSecond
        case gigabytes
        case gigabytesPerSecond
        case kilobits
        case kilobitsPerSecond
        case kilobytes
        case kilobytesPerSecond
        case megabits
        case megabitsPerSecond
        case megabytes
        case megabytesPerSecond
        case microseconds
        case milliseconds
        case `none`
        case percent
        case seconds
        case terabits
        case terabitsPerSecond
        case terabytes
        case terabytesPerSecond
        case sdkUnknown(Swift.String)

        public static var allCases: [Unit] {
            return [
                .bits,
                .bitsPerSecond,
                .bytes,
                .bytesPerSecond,
                .count,
                .countPerSecond,
                .gigabits,
                .gigabitsPerSecond,
                .gigabytes,
                .gigabytesPerSecond,
                .kilobits,
                .kilobitsPerSecond,
                .kilobytes,
                .kilobytesPerSecond,
                .megabits,
                .megabitsPerSecond,
                .megabytes,
                .megabytesPerSecond,
                .microseconds,
                .milliseconds,
                .none,
                .percent,
                .seconds,
                .terabits,
                .terabitsPerSecond,
                .terabytes,
                .terabytesPerSecond,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bits: return "Bits"
            case .bitsPerSecond: return "Bits/Second"
            case .bytes: return "Bytes"
            case .bytesPerSecond: return "Bytes/Second"
            case .count: return "Count"
            case .countPerSecond: return "Count/Second"
            case .gigabits: return "Gigabits"
            case .gigabitsPerSecond: return "Gigabits/Second"
            case .gigabytes: return "Gigabytes"
            case .gigabytesPerSecond: return "Gigabytes/Second"
            case .kilobits: return "Kilobits"
            case .kilobitsPerSecond: return "Kilobits/Second"
            case .kilobytes: return "Kilobytes"
            case .kilobytesPerSecond: return "Kilobytes/Second"
            case .megabits: return "Megabits"
            case .megabitsPerSecond: return "Megabits/Second"
            case .megabytes: return "Megabytes"
            case .megabytesPerSecond: return "Megabytes/Second"
            case .microseconds: return "Microseconds"
            case .milliseconds: return "Milliseconds"
            case .none: return "None"
            case .percent: return "Percent"
            case .seconds: return "Seconds"
            case .terabits: return "Terabits"
            case .terabitsPerSecond: return "Terabits/Second"
            case .terabytes: return "Terabytes"
            case .terabytesPerSecond: return "Terabytes/Second"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Unit(rawValue: rawValue) ?? Unit.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon MWAA environment. For example, arn:aws:airflow:us-east-1:123456789012:environment/MyMWAAEnvironment.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value tag pair you want to remove. For example, "Environment": "Staging".
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentInput(airflowVersion: \(Swift.String(describing: airflowVersion)), dagS3Path: \(Swift.String(describing: dagS3Path)), environmentClass: \(Swift.String(describing: environmentClass)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), loggingConfiguration: \(Swift.String(describing: loggingConfiguration)), maxWorkers: \(Swift.String(describing: maxWorkers)), minWorkers: \(Swift.String(describing: minWorkers)), name: \(Swift.String(describing: name)), networkConfiguration: \(Swift.String(describing: networkConfiguration)), pluginsS3ObjectVersion: \(Swift.String(describing: pluginsS3ObjectVersion)), pluginsS3Path: \(Swift.String(describing: pluginsS3Path)), requirementsS3ObjectVersion: \(Swift.String(describing: requirementsS3ObjectVersion)), requirementsS3Path: \(Swift.String(describing: requirementsS3Path)), schedulers: \(Swift.String(describing: schedulers)), sourceBucketArn: \(Swift.String(describing: sourceBucketArn)), startupScriptS3ObjectVersion: \(Swift.String(describing: startupScriptS3ObjectVersion)), startupScriptS3Path: \(Swift.String(describing: startupScriptS3Path)), webserverAccessMode: \(Swift.String(describing: webserverAccessMode)), weeklyMaintenanceWindowStart: \(Swift.String(describing: weeklyMaintenanceWindowStart)), airflowConfigurationOptions: \"CONTENT_REDACTED\")"}
}

extension UpdateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case airflowConfigurationOptions = "AirflowConfigurationOptions"
        case airflowVersion = "AirflowVersion"
        case dagS3Path = "DagS3Path"
        case environmentClass = "EnvironmentClass"
        case executionRoleArn = "ExecutionRoleArn"
        case loggingConfiguration = "LoggingConfiguration"
        case maxWorkers = "MaxWorkers"
        case minWorkers = "MinWorkers"
        case networkConfiguration = "NetworkConfiguration"
        case pluginsS3ObjectVersion = "PluginsS3ObjectVersion"
        case pluginsS3Path = "PluginsS3Path"
        case requirementsS3ObjectVersion = "RequirementsS3ObjectVersion"
        case requirementsS3Path = "RequirementsS3Path"
        case schedulers = "Schedulers"
        case sourceBucketArn = "SourceBucketArn"
        case startupScriptS3ObjectVersion = "StartupScriptS3ObjectVersion"
        case startupScriptS3Path = "StartupScriptS3Path"
        case webserverAccessMode = "WebserverAccessMode"
        case weeklyMaintenanceWindowStart = "WeeklyMaintenanceWindowStart"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let airflowConfigurationOptions = airflowConfigurationOptions {
            var airflowConfigurationOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .airflowConfigurationOptions)
            for (dictKey0, airflowConfigurationOptions0) in airflowConfigurationOptions {
                try airflowConfigurationOptionsContainer.encode(airflowConfigurationOptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let airflowVersion = self.airflowVersion {
            try encodeContainer.encode(airflowVersion, forKey: .airflowVersion)
        }
        if let dagS3Path = self.dagS3Path {
            try encodeContainer.encode(dagS3Path, forKey: .dagS3Path)
        }
        if let environmentClass = self.environmentClass {
            try encodeContainer.encode(environmentClass, forKey: .environmentClass)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let loggingConfiguration = self.loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
        if let maxWorkers = self.maxWorkers {
            try encodeContainer.encode(maxWorkers, forKey: .maxWorkers)
        }
        if let minWorkers = self.minWorkers {
            try encodeContainer.encode(minWorkers, forKey: .minWorkers)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let pluginsS3ObjectVersion = self.pluginsS3ObjectVersion {
            try encodeContainer.encode(pluginsS3ObjectVersion, forKey: .pluginsS3ObjectVersion)
        }
        if let pluginsS3Path = self.pluginsS3Path {
            try encodeContainer.encode(pluginsS3Path, forKey: .pluginsS3Path)
        }
        if let requirementsS3ObjectVersion = self.requirementsS3ObjectVersion {
            try encodeContainer.encode(requirementsS3ObjectVersion, forKey: .requirementsS3ObjectVersion)
        }
        if let requirementsS3Path = self.requirementsS3Path {
            try encodeContainer.encode(requirementsS3Path, forKey: .requirementsS3Path)
        }
        if let schedulers = self.schedulers {
            try encodeContainer.encode(schedulers, forKey: .schedulers)
        }
        if let sourceBucketArn = self.sourceBucketArn {
            try encodeContainer.encode(sourceBucketArn, forKey: .sourceBucketArn)
        }
        if let startupScriptS3ObjectVersion = self.startupScriptS3ObjectVersion {
            try encodeContainer.encode(startupScriptS3ObjectVersion, forKey: .startupScriptS3ObjectVersion)
        }
        if let startupScriptS3Path = self.startupScriptS3Path {
            try encodeContainer.encode(startupScriptS3Path, forKey: .startupScriptS3Path)
        }
        if let webserverAccessMode = self.webserverAccessMode {
            try encodeContainer.encode(webserverAccessMode.rawValue, forKey: .webserverAccessMode)
        }
        if let weeklyMaintenanceWindowStart = self.weeklyMaintenanceWindowStart {
            try encodeContainer.encode(weeklyMaintenanceWindowStart, forKey: .weeklyMaintenanceWindowStart)
        }
    }
}

extension UpdateEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/environments/\(name.urlPercentEncoding())"
    }
}

public struct UpdateEnvironmentInput: Swift.Equatable {
    /// A list of key-value pairs containing the Apache Airflow configuration options you want to attach to your environment. For more information, see [Apache Airflow configuration options](https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-env-variables.html).
    public var airflowConfigurationOptions: [Swift.String:Swift.String]?
    /// The Apache Airflow version for your environment. To upgrade your environment, specify a newer version of Apache Airflow supported by Amazon MWAA. Before you upgrade an environment, make sure your requirements, DAGs, plugins, and other resources used in your workflows are compatible with the new Apache Airflow version. For more information about updating your resources, see [Upgrading an Amazon MWAA environment](https://docs.aws.amazon.com/mwaa/latest/userguide/upgrading-environment.html). Valid values: 1.10.12, 2.0.2, 2.2.2, 2.4.3, and 2.5.1.
    public var airflowVersion: Swift.String?
    /// The relative path to the DAGs folder on your Amazon S3 bucket. For example, dags. For more information, see [Adding or updating DAGs](https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-folder.html).
    public var dagS3Path: Swift.String?
    /// The environment class type. Valid values: mw1.small, mw1.medium, mw1.large. For more information, see [Amazon MWAA environment class](https://docs.aws.amazon.com/mwaa/latest/userguide/environment-class.html).
    public var environmentClass: Swift.String?
    /// The Amazon Resource Name (ARN) of the execution role in IAM that allows MWAA to access Amazon Web Services resources in your environment. For example, arn:aws:iam::123456789:role/my-execution-role. For more information, see [Amazon MWAA Execution role](https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-create-role.html).
    public var executionRoleArn: Swift.String?
    /// The Apache Airflow log types to send to CloudWatch Logs.
    public var loggingConfiguration: MWAAClientTypes.LoggingConfigurationInput?
    /// The maximum number of workers that you want to run in your environment. MWAA scales the number of Apache Airflow workers up to the number you specify in the MaxWorkers field. For example, 20. When there are no more tasks running, and no more in the queue, MWAA disposes of the extra workers leaving the one worker that is included with your environment, or the number you specify in MinWorkers.
    public var maxWorkers: Swift.Int?
    /// The minimum number of workers that you want to run in your environment. MWAA scales the number of Apache Airflow workers up to the number you specify in the MaxWorkers field. When there are no more tasks running, and no more in the queue, MWAA disposes of the extra workers leaving the worker count you specify in the MinWorkers field. For example, 2.
    public var minWorkers: Swift.Int?
    /// The name of your Amazon MWAA environment. For example, MyMWAAEnvironment.
    /// This member is required.
    public var name: Swift.String?
    /// The VPC networking components used to secure and enable network traffic between the Amazon Web Services resources for your environment. For more information, see [About networking on Amazon MWAA](https://docs.aws.amazon.com/mwaa/latest/userguide/networking-about.html).
    public var networkConfiguration: MWAAClientTypes.UpdateNetworkConfigurationInput?
    /// The version of the plugins.zip file on your Amazon S3 bucket. You must specify a version each time a plugins.zip file is updated. For more information, see [How S3 Versioning works](https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html).
    public var pluginsS3ObjectVersion: Swift.String?
    /// The relative path to the plugins.zip file on your Amazon S3 bucket. For example, plugins.zip. If specified, then the plugins.zip version is required. For more information, see [Installing custom plugins](https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-import-plugins.html).
    public var pluginsS3Path: Swift.String?
    /// The version of the requirements.txt file on your Amazon S3 bucket. You must specify a version each time a requirements.txt file is updated. For more information, see [How S3 Versioning works](https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html).
    public var requirementsS3ObjectVersion: Swift.String?
    /// The relative path to the requirements.txt file on your Amazon S3 bucket. For example, requirements.txt. If specified, then a file version is required. For more information, see [Installing Python dependencies](https://docs.aws.amazon.com/mwaa/latest/userguide/working-dags-dependencies.html).
    public var requirementsS3Path: Swift.String?
    /// The number of Apache Airflow schedulers to run in your Amazon MWAA environment.
    public var schedulers: Swift.Int?
    /// The Amazon Resource Name (ARN) of the Amazon S3 bucket where your DAG code and supporting files are stored. For example, arn:aws:s3:::my-airflow-bucket-unique-name. For more information, see [Create an Amazon S3 bucket for Amazon MWAA](https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-s3-bucket.html).
    public var sourceBucketArn: Swift.String?
    /// The version of the startup shell script in your Amazon S3 bucket. You must specify the [version ID](https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html) that Amazon S3 assigns to the file every time you update the script. Version IDs are Unicode, UTF-8 encoded, URL-ready, opaque strings that are no more than 1,024 bytes long. The following is an example: 3sL4kqtJlcpXroDTDmJ+rmSpXd3dIbrHY+MTRCxf3vjVBH40Nr8X8gdRQBpUMLUo For more information, see [Using a startup script](https://docs.aws.amazon.com/mwaa/latest/userguide/using-startup-script.html).
    public var startupScriptS3ObjectVersion: Swift.String?
    /// The relative path to the startup shell script in your Amazon S3 bucket. For example, s3://mwaa-environment/startup.sh. Amazon MWAA runs the script as your environment starts, and before running the Apache Airflow process. You can use this script to install dependencies, modify Apache Airflow configuration options, and set environment variables. For more information, see [Using a startup script](https://docs.aws.amazon.com/mwaa/latest/userguide/using-startup-script.html).
    public var startupScriptS3Path: Swift.String?
    /// The Apache Airflow Web server access mode. For more information, see [Apache Airflow access modes](https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-networking.html).
    public var webserverAccessMode: MWAAClientTypes.WebserverAccessMode?
    /// The day and time of the week in Coordinated Universal Time (UTC) 24-hour standard time to start weekly maintenance updates of your environment in the following format: DAY:HH:MM. For example: TUE:03:30. You can specify a start time in 30 minute increments only.
    public var weeklyMaintenanceWindowStart: Swift.String?

    public init(
        airflowConfigurationOptions: [Swift.String:Swift.String]? = nil,
        airflowVersion: Swift.String? = nil,
        dagS3Path: Swift.String? = nil,
        environmentClass: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        loggingConfiguration: MWAAClientTypes.LoggingConfigurationInput? = nil,
        maxWorkers: Swift.Int? = nil,
        minWorkers: Swift.Int? = nil,
        name: Swift.String? = nil,
        networkConfiguration: MWAAClientTypes.UpdateNetworkConfigurationInput? = nil,
        pluginsS3ObjectVersion: Swift.String? = nil,
        pluginsS3Path: Swift.String? = nil,
        requirementsS3ObjectVersion: Swift.String? = nil,
        requirementsS3Path: Swift.String? = nil,
        schedulers: Swift.Int? = nil,
        sourceBucketArn: Swift.String? = nil,
        startupScriptS3ObjectVersion: Swift.String? = nil,
        startupScriptS3Path: Swift.String? = nil,
        webserverAccessMode: MWAAClientTypes.WebserverAccessMode? = nil,
        weeklyMaintenanceWindowStart: Swift.String? = nil
    )
    {
        self.airflowConfigurationOptions = airflowConfigurationOptions
        self.airflowVersion = airflowVersion
        self.dagS3Path = dagS3Path
        self.environmentClass = environmentClass
        self.executionRoleArn = executionRoleArn
        self.loggingConfiguration = loggingConfiguration
        self.maxWorkers = maxWorkers
        self.minWorkers = minWorkers
        self.name = name
        self.networkConfiguration = networkConfiguration
        self.pluginsS3ObjectVersion = pluginsS3ObjectVersion
        self.pluginsS3Path = pluginsS3Path
        self.requirementsS3ObjectVersion = requirementsS3ObjectVersion
        self.requirementsS3Path = requirementsS3Path
        self.schedulers = schedulers
        self.sourceBucketArn = sourceBucketArn
        self.startupScriptS3ObjectVersion = startupScriptS3ObjectVersion
        self.startupScriptS3Path = startupScriptS3Path
        self.webserverAccessMode = webserverAccessMode
        self.weeklyMaintenanceWindowStart = weeklyMaintenanceWindowStart
    }
}

struct UpdateEnvironmentInputBody: Swift.Equatable {
    let executionRoleArn: Swift.String?
    let airflowVersion: Swift.String?
    let sourceBucketArn: Swift.String?
    let dagS3Path: Swift.String?
    let pluginsS3Path: Swift.String?
    let pluginsS3ObjectVersion: Swift.String?
    let requirementsS3Path: Swift.String?
    let requirementsS3ObjectVersion: Swift.String?
    let startupScriptS3Path: Swift.String?
    let startupScriptS3ObjectVersion: Swift.String?
    let airflowConfigurationOptions: [Swift.String:Swift.String]?
    let environmentClass: Swift.String?
    let maxWorkers: Swift.Int?
    let networkConfiguration: MWAAClientTypes.UpdateNetworkConfigurationInput?
    let loggingConfiguration: MWAAClientTypes.LoggingConfigurationInput?
    let weeklyMaintenanceWindowStart: Swift.String?
    let webserverAccessMode: MWAAClientTypes.WebserverAccessMode?
    let minWorkers: Swift.Int?
    let schedulers: Swift.Int?
}

extension UpdateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case airflowConfigurationOptions = "AirflowConfigurationOptions"
        case airflowVersion = "AirflowVersion"
        case dagS3Path = "DagS3Path"
        case environmentClass = "EnvironmentClass"
        case executionRoleArn = "ExecutionRoleArn"
        case loggingConfiguration = "LoggingConfiguration"
        case maxWorkers = "MaxWorkers"
        case minWorkers = "MinWorkers"
        case networkConfiguration = "NetworkConfiguration"
        case pluginsS3ObjectVersion = "PluginsS3ObjectVersion"
        case pluginsS3Path = "PluginsS3Path"
        case requirementsS3ObjectVersion = "RequirementsS3ObjectVersion"
        case requirementsS3Path = "RequirementsS3Path"
        case schedulers = "Schedulers"
        case sourceBucketArn = "SourceBucketArn"
        case startupScriptS3ObjectVersion = "StartupScriptS3ObjectVersion"
        case startupScriptS3Path = "StartupScriptS3Path"
        case webserverAccessMode = "WebserverAccessMode"
        case weeklyMaintenanceWindowStart = "WeeklyMaintenanceWindowStart"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let airflowVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .airflowVersion)
        airflowVersion = airflowVersionDecoded
        let sourceBucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBucketArn)
        sourceBucketArn = sourceBucketArnDecoded
        let dagS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dagS3Path)
        dagS3Path = dagS3PathDecoded
        let pluginsS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginsS3Path)
        pluginsS3Path = pluginsS3PathDecoded
        let pluginsS3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginsS3ObjectVersion)
        pluginsS3ObjectVersion = pluginsS3ObjectVersionDecoded
        let requirementsS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requirementsS3Path)
        requirementsS3Path = requirementsS3PathDecoded
        let requirementsS3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requirementsS3ObjectVersion)
        requirementsS3ObjectVersion = requirementsS3ObjectVersionDecoded
        let startupScriptS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startupScriptS3Path)
        startupScriptS3Path = startupScriptS3PathDecoded
        let startupScriptS3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startupScriptS3ObjectVersion)
        startupScriptS3ObjectVersion = startupScriptS3ObjectVersionDecoded
        let airflowConfigurationOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .airflowConfigurationOptions)
        var airflowConfigurationOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let airflowConfigurationOptionsContainer = airflowConfigurationOptionsContainer {
            airflowConfigurationOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, configvalue0) in airflowConfigurationOptionsContainer {
                if let configvalue0 = configvalue0 {
                    airflowConfigurationOptionsDecoded0?[key0] = configvalue0
                }
            }
        }
        airflowConfigurationOptions = airflowConfigurationOptionsDecoded0
        let environmentClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentClass)
        environmentClass = environmentClassDecoded
        let maxWorkersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxWorkers)
        maxWorkers = maxWorkersDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.UpdateNetworkConfigurationInput.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.LoggingConfigurationInput.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let weeklyMaintenanceWindowStartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .weeklyMaintenanceWindowStart)
        weeklyMaintenanceWindowStart = weeklyMaintenanceWindowStartDecoded
        let webserverAccessModeDecoded = try containerValues.decodeIfPresent(MWAAClientTypes.WebserverAccessMode.self, forKey: .webserverAccessMode)
        webserverAccessMode = webserverAccessModeDecoded
        let minWorkersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minWorkers)
        minWorkers = minWorkersDecoded
        let schedulersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .schedulers)
        schedulers = schedulersDecoded
    }
}

extension UpdateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct UpdateEnvironmentOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon MWAA environment. For example, arn:aws:airflow:us-east-1:123456789012:environment/MyMWAAEnvironment.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct UpdateEnvironmentOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension UpdateEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum UpdateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MWAAClientTypes.UpdateError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension MWAAClientTypes {
    /// Describes the error(s) encountered with the last update of the environment.
    public struct UpdateError: Swift.Equatable {
        /// The error code that corresponds to the error with the last update.
        public var errorCode: Swift.String?
        /// The error message that corresponds to the error code.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension MWAAClientTypes.UpdateNetworkConfigurationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension MWAAClientTypes {
    /// Defines the VPC networking components used to secure and enable network traffic between the Amazon Web Services resources for your environment. For more information, see [About networking on Amazon MWAA](https://docs.aws.amazon.com/mwaa/latest/userguide/networking-about.html).
    public struct UpdateNetworkConfigurationInput: Swift.Equatable {
        /// A list of security group IDs. A security group must be attached to the same VPC as the subnets. For more information, see [Security in your VPC on Amazon MWAA](https://docs.aws.amazon.com/mwaa/latest/userguide/vpc-security.html).
        /// This member is required.
        public var securityGroupIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
        }
    }

}

extension MWAAClientTypes {
    public enum UpdateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateStatus] {
            return [
                .failed,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateStatus(rawValue: rawValue) ?? UpdateStatus.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// ValidationException: The provided input is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MWAAClientTypes {
    public enum WebserverAccessMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case privateOnly
        case publicOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [WebserverAccessMode] {
            return [
                .privateOnly,
                .publicOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .privateOnly: return "PRIVATE_ONLY"
            case .publicOnly: return "PUBLIC_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WebserverAccessMode(rawValue: rawValue) ?? WebserverAccessMode.sdkUnknown(rawValue)
        }
    }
}
