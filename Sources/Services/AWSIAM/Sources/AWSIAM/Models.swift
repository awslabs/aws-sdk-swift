//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
@_spi(SmithyReadWrite) import class SmithyFormURL.Writer
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyXML.Reader
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSQueryError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

public struct AddClientIDToOpenIDConnectProviderOutput {

    public init() { }
}

public struct AddRoleToInstanceProfileOutput {

    public init() { }
}

public struct AddUserToGroupOutput {

    public init() { }
}

public struct AttachGroupPolicyOutput {

    public init() { }
}

public struct AttachRolePolicyOutput {

    public init() { }
}

public struct AttachUserPolicyOutput {

    public init() { }
}

public struct ChangePasswordOutput {

    public init() { }
}

public struct CreateAccountAliasOutput {

    public init() { }
}

public struct DeactivateMFADeviceOutput {

    public init() { }
}

public struct DeleteAccessKeyOutput {

    public init() { }
}

public struct DeleteAccountAliasOutput {

    public init() { }
}

public struct DeleteAccountPasswordPolicyInput {

    public init() { }
}

public struct DeleteAccountPasswordPolicyOutput {

    public init() { }
}

public struct DeleteGroupOutput {

    public init() { }
}

public struct DeleteGroupPolicyOutput {

    public init() { }
}

public struct DeleteInstanceProfileOutput {

    public init() { }
}

public struct DeleteLoginProfileOutput {

    public init() { }
}

public struct DeleteOpenIDConnectProviderOutput {

    public init() { }
}

public struct DeletePolicyOutput {

    public init() { }
}

public struct DeletePolicyVersionOutput {

    public init() { }
}

public struct DeleteRoleOutput {

    public init() { }
}

public struct DeleteRolePermissionsBoundaryOutput {

    public init() { }
}

public struct DeleteRolePolicyOutput {

    public init() { }
}

public struct DeleteSAMLProviderOutput {

    public init() { }
}

public struct DeleteServerCertificateOutput {

    public init() { }
}

public struct DeleteServiceSpecificCredentialOutput {

    public init() { }
}

public struct DeleteSigningCertificateOutput {

    public init() { }
}

public struct DeleteSSHPublicKeyOutput {

    public init() { }
}

public struct DeleteUserOutput {

    public init() { }
}

public struct DeleteUserPermissionsBoundaryOutput {

    public init() { }
}

public struct DeleteUserPolicyOutput {

    public init() { }
}

public struct DeleteVirtualMFADeviceOutput {

    public init() { }
}

public struct DetachGroupPolicyOutput {

    public init() { }
}

public struct DetachRolePolicyOutput {

    public init() { }
}

public struct DetachUserPolicyOutput {

    public init() { }
}

public struct EnableMFADeviceOutput {

    public init() { }
}

public struct GenerateCredentialReportInput {

    public init() { }
}

public struct GetAccountPasswordPolicyInput {

    public init() { }
}

public struct GetAccountSummaryInput {

    public init() { }
}

public struct GetCredentialReportInput {

    public init() { }
}

public struct PutGroupPolicyOutput {

    public init() { }
}

public struct PutRolePermissionsBoundaryOutput {

    public init() { }
}

public struct PutRolePolicyOutput {

    public init() { }
}

public struct PutUserPermissionsBoundaryOutput {

    public init() { }
}

public struct PutUserPolicyOutput {

    public init() { }
}

public struct RemoveClientIDFromOpenIDConnectProviderOutput {

    public init() { }
}

public struct RemoveRoleFromInstanceProfileOutput {

    public init() { }
}

public struct RemoveUserFromGroupOutput {

    public init() { }
}

public struct ResyncMFADeviceOutput {

    public init() { }
}

public struct SetDefaultPolicyVersionOutput {

    public init() { }
}

public struct SetSecurityTokenServicePreferencesOutput {

    public init() { }
}

public struct TagInstanceProfileOutput {

    public init() { }
}

public struct TagMFADeviceOutput {

    public init() { }
}

public struct TagOpenIDConnectProviderOutput {

    public init() { }
}

public struct TagPolicyOutput {

    public init() { }
}

public struct TagRoleOutput {

    public init() { }
}

public struct TagSAMLProviderOutput {

    public init() { }
}

public struct TagServerCertificateOutput {

    public init() { }
}

public struct TagUserOutput {

    public init() { }
}

public struct UntagInstanceProfileOutput {

    public init() { }
}

public struct UntagMFADeviceOutput {

    public init() { }
}

public struct UntagOpenIDConnectProviderOutput {

    public init() { }
}

public struct UntagPolicyOutput {

    public init() { }
}

public struct UntagRoleOutput {

    public init() { }
}

public struct UntagSAMLProviderOutput {

    public init() { }
}

public struct UntagServerCertificateOutput {

    public init() { }
}

public struct UntagUserOutput {

    public init() { }
}

public struct UpdateAccessKeyOutput {

    public init() { }
}

public struct UpdateAccountPasswordPolicyOutput {

    public init() { }
}

public struct UpdateAssumeRolePolicyOutput {

    public init() { }
}

public struct UpdateGroupOutput {

    public init() { }
}

public struct UpdateLoginProfileOutput {

    public init() { }
}

public struct UpdateOpenIDConnectProviderThumbprintOutput {

    public init() { }
}

public struct UpdateServerCertificateOutput {

    public init() { }
}

public struct UpdateServiceSpecificCredentialOutput {

    public init() { }
}

public struct UpdateSigningCertificateOutput {

    public init() { }
}

public struct UpdateSSHPublicKeyOutput {

    public init() { }
}

public struct UpdateUserOutput {

    public init() { }
}

extension IAMClientTypes {

    public enum AccessAdvisorUsageGranularityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionLevel
        case serviceLevel
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessAdvisorUsageGranularityType] {
            return [
                .actionLevel,
                .serviceLevel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionLevel: return "ACTION_LEVEL"
            case .serviceLevel: return "SERVICE_LEVEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IAMClientTypes {
    /// An object that contains details about when a principal in the reported Organizations entity last attempted to access an Amazon Web Services service. A principal can be an IAM user, an IAM role, or the Amazon Web Services account root user within the reported Organizations entity. This data type is a response element in the [GetOrganizationsAccessReport] operation.
    public struct AccessDetail {
        /// The path of the Organizations entity (root, organizational unit, or account) from which an authenticated principal last attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no principals (IAM users, IAM roles, or root user) in the reported Organizations entity attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var entityPath: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when an authenticated principal most recently attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no principals in the reported Organizations entity attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticatedTime: Foundation.Date?
        /// The Region where the last service access attempt occurred. This field is null if no principals in the reported Organizations entity attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var region: Swift.String?
        /// The name of the service in which access was attempted.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The namespace of the service in which access was attempted. To learn the service namespace of a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the Service Authorization Reference. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
        /// This member is required.
        public var serviceNamespace: Swift.String?
        /// The number of accounts with authenticated principals (root user, IAM users, and IAM roles) that attempted to access the service in the tracking period.
        public var totalAuthenticatedEntities: Swift.Int?

        public init(
            entityPath: Swift.String? = nil,
            lastAuthenticatedTime: Foundation.Date? = nil,
            region: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceNamespace: Swift.String? = nil,
            totalAuthenticatedEntities: Swift.Int? = nil
        )
        {
            self.entityPath = entityPath
            self.lastAuthenticatedTime = lastAuthenticatedTime
            self.region = region
            self.serviceName = serviceName
            self.serviceNamespace = serviceNamespace
            self.totalAuthenticatedEntities = totalAuthenticatedEntities
        }
    }

}

extension IAMClientTypes {

    public enum StatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusType] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an Amazon Web Services access key. This data type is used as a response element in the [CreateAccessKey] and [ListAccessKeys] operations. The SecretAccessKey value is returned only in response to [CreateAccessKey]. You can get a secret access key only when you first create an access key; you cannot recover the secret access key later. If you lose a secret access key, you must create a new access key.
    public struct AccessKey {
        /// The ID for this access key.
        /// This member is required.
        public var accessKeyId: Swift.String?
        /// The date when the access key was created.
        public var createDate: Foundation.Date?
        /// The secret key used to sign requests.
        /// This member is required.
        public var secretAccessKey: Swift.String?
        /// The status of the access key. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user that the access key is associated with.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            createDate: Foundation.Date? = nil,
            secretAccessKey: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.createDate = createDate
            self.secretAccessKey = secretAccessKey
            self.status = status
            self.userName = userName
        }
    }

}

extension IAMClientTypes.AccessKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessKey(accessKeyId: \(Swift.String(describing: accessKeyId)), createDate: \(Swift.String(describing: createDate)), status: \(Swift.String(describing: status)), userName: \(Swift.String(describing: userName)), secretAccessKey: \"CONTENT_REDACTED\")"}
}

extension IAMClientTypes {
    /// Contains information about the last time an Amazon Web Services access key was used since IAM began tracking this information on April 22, 2015. This data type is used as a response element in the [GetAccessKeyLastUsed] operation.
    public struct AccessKeyLastUsed {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the access key was most recently used. This field is null in the following situations:
        ///
        /// * The user does not have an access key.
        ///
        /// * An access key exists but has not been used since IAM began tracking this information.
        ///
        /// * There is no sign-in data associated with the user.
        public var lastUsedDate: Foundation.Date?
        /// The Amazon Web Services Region where this access key was most recently used. The value for this field is "N/A" in the following situations:
        ///
        /// * The user does not have an access key.
        ///
        /// * An access key exists but has not been used since IAM began tracking this information.
        ///
        /// * There is no sign-in data associated with the user.
        ///
        ///
        /// For more information about Amazon Web Services Regions, see [Regions and endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html) in the Amazon Web Services General Reference.
        /// This member is required.
        public var region: Swift.String?
        /// The name of the Amazon Web Services service with which this access key was most recently used. The value of this field is "N/A" in the following situations:
        ///
        /// * The user does not have an access key.
        ///
        /// * An access key exists but has not been used since IAM started tracking this information.
        ///
        /// * There is no sign-in data associated with the user.
        /// This member is required.
        public var serviceName: Swift.String?

        public init(
            lastUsedDate: Foundation.Date? = nil,
            region: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.lastUsedDate = lastUsedDate
            self.region = region
            self.serviceName = serviceName
        }
    }

}

extension IAMClientTypes {
    /// Contains information about an Amazon Web Services access key, without its secret key. This data type is used as a response element in the [ListAccessKeys] operation.
    public struct AccessKeyMetadata {
        /// The ID for this access key.
        public var accessKeyId: Swift.String?
        /// The date when the access key was created.
        public var createDate: Foundation.Date?
        /// The status of the access key. Active means that the key is valid for API calls; Inactive means it is not.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user that the key is associated with.
        public var userName: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            createDate: Foundation.Date? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.createDate = createDate
            self.status = status
            self.userName = userName
        }
    }

}

/// The request was rejected because an invalid or out-of-range value was supplied for an input parameter.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInput" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because it attempted to create resources beyond the current Amazon Web Services account limits. The error message describes the limit exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because it referenced a resource entity that does not exist. The error message describes the resource.
public struct NoSuchEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchEntity" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct ServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceFailure" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AddClientIDToOpenIDConnectProviderInput {
    /// The client ID (also known as audience) to add to the IAM OpenID Connect provider resource.
    /// This member is required.
    public var clientID: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM OpenID Connect (OIDC) provider resource to add the client ID to. You can get a list of OIDC provider ARNs by using the [ListOpenIDConnectProviders] operation.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init(
        clientID: Swift.String? = nil,
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.clientID = clientID
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

/// The request was rejected because it attempted to create a resource that already exists.
public struct EntityAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because service-linked roles are protected Amazon Web Services resources. Only the service that depends on the service-linked role can modify or delete the role on your behalf. The error message includes the name of the service that depends on this service-linked role. You must request the change through that service.
public struct UnmodifiableEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnmodifiableEntity" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AddRoleToInstanceProfileInput {
    /// The name of the instance profile to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The name of the role to add. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        instanceProfileName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.roleName = roleName
    }
}

public struct AddUserToGroupInput {
    /// The name of the group to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the user to add. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.userName = userName
    }
}

extension IAMClientTypes {

    public enum AssignmentStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case any
        case assigned
        case unassigned
        case sdkUnknown(Swift.String)

        public static var allCases: [AssignmentStatusType] {
            return [
                .any,
                .assigned,
                .unassigned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .any: return "Any"
            case .assigned: return "Assigned"
            case .unassigned: return "Unassigned"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IAMClientTypes {

    public enum PermissionsBoundaryAttachmentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case policy
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionsBoundaryAttachmentType] {
            return [
                .policy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .policy: return "PermissionsBoundaryPolicy"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an attached permissions boundary. An attached permissions boundary is a managed policy that has been attached to a user or role to set the permissions boundary. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
    public struct AttachedPermissionsBoundary {
        /// The ARN of the policy used to set the permissions boundary for the user or role.
        public var permissionsBoundaryArn: Swift.String?
        /// The permissions boundary usage type that indicates what type of IAM resource is used as the permissions boundary for an entity. This data type can only have a value of Policy.
        public var permissionsBoundaryType: IAMClientTypes.PermissionsBoundaryAttachmentType?

        public init(
            permissionsBoundaryArn: Swift.String? = nil,
            permissionsBoundaryType: IAMClientTypes.PermissionsBoundaryAttachmentType? = nil
        )
        {
            self.permissionsBoundaryArn = permissionsBoundaryArn
            self.permissionsBoundaryType = permissionsBoundaryType
        }
    }

}

extension IAMClientTypes {
    /// Contains information about an attached policy. An attached policy is a managed policy that has been attached to a user, group, or role. This data type is used as a response element in the [ListAttachedGroupPolicies], [ListAttachedRolePolicies], [ListAttachedUserPolicies], and [GetAccountAuthorizationDetails] operations. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct AttachedPolicy {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var policyArn: Swift.String?
        /// The friendly name of the attached policy.
        public var policyName: Swift.String?

        public init(
            policyArn: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.policyArn = policyArn
            self.policyName = policyName
        }
    }

}

/// The request failed because Amazon Web Services service role policies can only be attached to the service-linked role for that service.
public struct PolicyNotAttachableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyNotAttachable" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AttachGroupPolicyInput {
    /// The name (friendly name, not ARN) of the group to attach the policy to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyArn = policyArn
    }
}

public struct AttachRolePolicyInput {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the role to attach the policy to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.roleName = roleName
    }
}

public struct AttachUserPolicyInput {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the IAM user to attach the policy to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.userName = userName
    }
}

/// The request was rejected because it referenced an entity that is temporarily unmodifiable, such as a user name that was deleted and then recreated. The error indicates that the request is likely to succeed if you try again after waiting several minutes. The error message describes the entity.
public struct EntityTemporarilyUnmodifiableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityTemporarilyUnmodifiable" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because the type of user for the transaction was incorrect.
public struct InvalidUserTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidUserType" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because the provided password did not meet the requirements imposed by the account password policy.
public struct PasswordPolicyViolationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PasswordPolicyViolation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ChangePasswordInput {
    /// The new password. The new password must conform to the Amazon Web Services account's password policy, if one exists. The [regex pattern](http://wikipedia.org/wiki/regex) that is used to validate this parameter is a string of characters. That string can include almost any printable ASCII character from the space (\u0020) through the end of the ASCII character range (\u00FF). You can also include the tab (\u0009), line feed (\u000A), and carriage return (\u000D) characters. Any of these characters are valid in a password. However, many tools, such as the Amazon Web Services Management Console, might restrict the ability to type certain characters because they have special meaning within that tool.
    /// This member is required.
    public var newPassword: Swift.String?
    /// The IAM user's current password.
    /// This member is required.
    public var oldPassword: Swift.String?

    public init(
        newPassword: Swift.String? = nil,
        oldPassword: Swift.String? = nil
    )
    {
        self.newPassword = newPassword
        self.oldPassword = oldPassword
    }
}

extension ChangePasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChangePasswordInput(newPassword: \"CONTENT_REDACTED\", oldPassword: \"CONTENT_REDACTED\")"}
}

public struct CreateAccessKeyInput {
    /// The name of the IAM user that the new key will belong to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

/// Contains the response to a successful [CreateAccessKey] request.
public struct CreateAccessKeyOutput {
    /// A structure with details about the access key.
    /// This member is required.
    public var accessKey: IAMClientTypes.AccessKey?

    public init(
        accessKey: IAMClientTypes.AccessKey? = nil
    )
    {
        self.accessKey = accessKey
    }
}

/// The request was rejected because multiple requests to change this object were submitted simultaneously. Wait a few minutes and submit your request again.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModification" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateAccountAliasInput {
    /// The account alias to create. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have two dashes in a row.
    /// This member is required.
    public var accountAlias: Swift.String?

    public init(
        accountAlias: Swift.String? = nil
    )
    {
        self.accountAlias = accountAlias
    }
}

public struct CreateGroupInput {
    /// The name of the group to create. Do not include the path in this value. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    /// This member is required.
    public var groupName: Swift.String?
    /// The path to the group. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        path: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.path = path
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM group entity. This data type is used as a response element in the following operations:
    ///
    /// * [CreateGroup]
    ///
    /// * [GetGroup]
    ///
    /// * [ListGroups]
    public struct Group {
        /// The Amazon Resource Name (ARN) specifying the group. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the group was created.
        /// This member is required.
        public var createDate: Foundation.Date?
        /// The stable and unique string identifying the group. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var groupId: Swift.String?
        /// The friendly name that identifies the group.
        /// This member is required.
        public var groupName: Swift.String?
        /// The path to the group. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createDate: Foundation.Date? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.groupId = groupId
            self.groupName = groupName
            self.path = path
        }
    }

}

/// Contains the response to a successful [CreateGroup] request.
public struct CreateGroupOutput {
    /// A structure containing details about the new group.
    /// This member is required.
    public var group: IAMClientTypes.Group?

    public init(
        group: IAMClientTypes.Group? = nil
    )
    {
        self.group = group
    }
}

extension IAMClientTypes {
    /// A structure that represents user-provided metadata that can be associated with an IAM resource. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public struct Tag {
        /// The key name that can be used to look up or retrieve the associated value. For example, Department or Cost Center are common choices.
        /// This member is required.
        public var key: Swift.String?
        /// The value associated with this tag. For example, tags with a key name of Department could have values such as Human Resources, Accounting, and Support. Tags with a key name of Cost Center might have values that consist of the number associated with the different cost centers in your company. Typically, many resources have tags with the same key name but with different values. Amazon Web Services always interprets the tag Value as a single string. If you need to store an array, you can store comma-separated values in the string. However, you must interpret the value in your code.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateInstanceProfileInput {
    /// The name of the instance profile to create. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The path to the instance profile. For more information about paths, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// A list of tags that you want to attach to the newly created IAM instance profile. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        instanceProfileName: Swift.String? = nil,
        path: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.path = path
        self.tags = tags
    }
}

extension IAMClientTypes {
    /// Contains information about the last time that an IAM role was used. This includes the date and time and the Region in which the role was last used. Activity is only reported for the trailing 400 days. This period can be shorter if your Region began supporting these features within the last year. The role might have been used more than 400 days ago. For more information, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM user Guide. This data type is returned as a response element in the [GetRole] and [GetAccountAuthorizationDetails] operations.
    public struct RoleLastUsed {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601) that the role was last used. This field is null if the role has not been used within the IAM tracking period. For more information about the tracking period, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM User Guide.
        public var lastUsedDate: Foundation.Date?
        /// The name of the Amazon Web Services Region in which the role was last used.
        public var region: Swift.String?

        public init(
            lastUsedDate: Foundation.Date? = nil,
            region: Swift.String? = nil
        )
        {
            self.lastUsedDate = lastUsedDate
            self.region = region
        }
    }

}

extension IAMClientTypes {
    /// Contains information about an IAM role. This structure is returned as a response element in several API operations that interact with roles.
    public struct Role {
        /// The Amazon Resource Name (ARN) specifying the role. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The policy that grants an entity permission to assume the role.
        public var assumeRolePolicyDocument: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the role was created.
        /// This member is required.
        public var createDate: Foundation.Date?
        /// A description of the role that you provide.
        public var description: Swift.String?
        /// The maximum session duration (in seconds) for the specified role. Anyone who uses the CLI, or API to assume the role can specify the duration using the optional DurationSeconds API parameter or duration-seconds CLI parameter.
        public var maxSessionDuration: Swift.Int?
        /// The path to the role. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?
        /// The ARN of the policy used to set the permissions boundary for the role. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// The stable and unique string identifying the role. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var roleId: Swift.String?
        /// Contains information about the last time that an IAM role was used. This includes the date and time and the Region in which the role was last used. Activity is only reported for the trailing 400 days. This period can be shorter if your Region began supporting these features within the last year. The role might have been used more than 400 days ago. For more information, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM user Guide.
        public var roleLastUsed: IAMClientTypes.RoleLastUsed?
        /// The friendly name that identifies the role.
        /// This member is required.
        public var roleName: Swift.String?
        /// A list of tags that are attached to the role. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init(
            arn: Swift.String? = nil,
            assumeRolePolicyDocument: Swift.String? = nil,
            createDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            maxSessionDuration: Swift.Int? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            roleId: Swift.String? = nil,
            roleLastUsed: IAMClientTypes.RoleLastUsed? = nil,
            roleName: Swift.String? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.arn = arn
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.createDate = createDate
            self.description = description
            self.maxSessionDuration = maxSessionDuration
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.roleId = roleId
            self.roleLastUsed = roleLastUsed
            self.roleName = roleName
            self.tags = tags
        }
    }

}

extension IAMClientTypes {
    /// Contains information about an instance profile. This data type is used as a response element in the following operations:
    ///
    /// * [CreateInstanceProfile]
    ///
    /// * [GetInstanceProfile]
    ///
    /// * [ListInstanceProfiles]
    ///
    /// * [ListInstanceProfilesForRole]
    public struct InstanceProfile {
        /// The Amazon Resource Name (ARN) specifying the instance profile. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date when the instance profile was created.
        /// This member is required.
        public var createDate: Foundation.Date?
        /// The stable and unique string identifying the instance profile. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var instanceProfileId: Swift.String?
        /// The name identifying the instance profile.
        /// This member is required.
        public var instanceProfileName: Swift.String?
        /// The path to the instance profile. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?
        /// The role associated with the instance profile.
        /// This member is required.
        public var roles: [IAMClientTypes.Role]?
        /// A list of tags that are attached to the instance profile. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init(
            arn: Swift.String? = nil,
            createDate: Foundation.Date? = nil,
            instanceProfileId: Swift.String? = nil,
            instanceProfileName: Swift.String? = nil,
            path: Swift.String? = nil,
            roles: [IAMClientTypes.Role]? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.instanceProfileId = instanceProfileId
            self.instanceProfileName = instanceProfileName
            self.path = path
            self.roles = roles
            self.tags = tags
        }
    }

}

/// Contains the response to a successful [CreateInstanceProfile] request.
public struct CreateInstanceProfileOutput {
    /// A structure containing details about the new instance profile.
    /// This member is required.
    public var instanceProfile: IAMClientTypes.InstanceProfile?

    public init(
        instanceProfile: IAMClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

public struct CreateLoginProfileInput {
    /// The new password for the user. The [regex pattern](http://wikipedia.org/wiki/regex) that is used to validate this parameter is a string of characters. That string can include almost any printable ASCII character from the space (\u0020) through the end of the ASCII character range (\u00FF). You can also include the tab (\u0009), line feed (\u000A), and carriage return (\u000D) characters. Any of these characters are valid in a password. However, many tools, such as the Amazon Web Services Management Console, might restrict the ability to type certain characters because they have special meaning within that tool.
    /// This member is required.
    public var password: Swift.String?
    /// Specifies whether the user is required to set a new password on next sign-in.
    public var passwordResetRequired: Swift.Bool?
    /// The name of the IAM user to create a password for. The user must already exist. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        password: Swift.String? = nil,
        passwordResetRequired: Swift.Bool? = false,
        userName: Swift.String? = nil
    )
    {
        self.password = password
        self.passwordResetRequired = passwordResetRequired
        self.userName = userName
    }
}

extension CreateLoginProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLoginProfileInput(passwordResetRequired: \(Swift.String(describing: passwordResetRequired)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

extension IAMClientTypes {
    /// Contains the user name and password create date for a user. This data type is used as a response element in the [CreateLoginProfile] and [GetLoginProfile] operations.
    public struct LoginProfile {
        /// The date when the password for the user was created.
        /// This member is required.
        public var createDate: Foundation.Date?
        /// Specifies whether the user is required to set a new password on next sign-in.
        public var passwordResetRequired: Swift.Bool
        /// The name of the user, which can be used for signing in to the Amazon Web Services Management Console.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            createDate: Foundation.Date? = nil,
            passwordResetRequired: Swift.Bool = false,
            userName: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.passwordResetRequired = passwordResetRequired
            self.userName = userName
        }
    }

}

/// Contains the response to a successful [CreateLoginProfile] request.
public struct CreateLoginProfileOutput {
    /// A structure containing the user name and password create date.
    /// This member is required.
    public var loginProfile: IAMClientTypes.LoginProfile?

    public init(
        loginProfile: IAMClientTypes.LoginProfile? = nil
    )
    {
        self.loginProfile = loginProfile
    }
}

/// The request failed because IAM cannot connect to the OpenID Connect identity provider URL.
public struct OpenIdIdpCommunicationErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OpenIdIdpCommunicationError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateOpenIDConnectProviderInput {
    /// Provides a list of client IDs, also known as audiences. When a mobile or web app registers with an OpenID Connect provider, they establish a value that identifies the application. This is the value that's sent as the client_id parameter on OAuth requests. You can register multiple client IDs with the same provider. For example, you might have multiple applications that use the same OIDC provider. You cannot register more than 100 client IDs with a single IAM OIDC provider. There is no defined format for a client ID. The CreateOpenIDConnectProviderRequest operation accepts client IDs up to 255 characters long.
    public var clientIDList: [Swift.String]?
    /// A list of tags that you want to attach to the new IAM OpenID Connect (OIDC) provider. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?
    /// A list of server certificate thumbprints for the OpenID Connect (OIDC) identity provider's server certificates. Typically this list includes only one entry. However, IAM lets you have up to five thumbprints for an OIDC provider. This lets you maintain multiple thumbprints if the identity provider is rotating certificates. This parameter is optional. If it is not included, IAM will retrieve and use the top intermediate certificate authority (CA) thumbprint of the OpenID Connect identity provider server certificate. The server certificate thumbprint is the hex-encoded SHA-1 hash value of the X.509 certificate used by the domain where the OpenID Connect provider makes its keys available. It is always a 40-character string. For example, assume that the OIDC provider is server.example.com and the provider stores its keys at https://keys.server.example.com/openid-connect. In that case, the thumbprint string would be the hex-encoded SHA-1 hash value of the certificate used by https://keys.server.example.com. For more information about obtaining the OIDC provider thumbprint, see [Obtaining the thumbprint for an OpenID Connect provider](https://docs.aws.amazon.com/IAM/latest/UserGuide/identity-providers-oidc-obtain-thumbprint.html) in the IAM user Guide.
    public var thumbprintList: [Swift.String]?
    /// The URL of the identity provider. The URL must begin with https:// and should correspond to the iss claim in the provider's OpenID Connect ID tokens. Per the OIDC standard, path components are allowed but query parameters are not. Typically the URL consists of only a hostname, like https://server.example.org or https://example.com. The URL should not contain a port number. You cannot register the same provider multiple times in a single Amazon Web Services account. If you try to submit a URL that has already been used for an OpenID Connect provider in the Amazon Web Services account, you will get an error.
    /// This member is required.
    public var url: Swift.String?

    public init(
        clientIDList: [Swift.String]? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        thumbprintList: [Swift.String]? = nil,
        url: Swift.String? = nil
    )
    {
        self.clientIDList = clientIDList
        self.tags = tags
        self.thumbprintList = thumbprintList
        self.url = url
    }
}

/// Contains the response to a successful [CreateOpenIDConnectProvider] request.
public struct CreateOpenIDConnectProviderOutput {
    /// The Amazon Resource Name (ARN) of the new IAM OpenID Connect provider that is created. For more information, see [OpenIDConnectProviderListEntry].
    public var openIDConnectProviderArn: Swift.String?
    /// A list of tags that are attached to the new IAM OIDC provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        openIDConnectProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.tags = tags
    }
}

/// The request was rejected because the policy document was malformed. The error message describes the specific error.
public struct MalformedPolicyDocumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MalformedPolicyDocument" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreatePolicyInput {
    /// A friendly description of the policy. Typically used to store information about the permissions defined in the policy. For example, "Grants access to production DynamoDB tables." The policy description is immutable. After a value is assigned, it cannot be changed.
    public var description: Swift.String?
    /// The path for the policy. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters. You cannot use an asterisk (*) in the path name.
    public var path: Swift.String?
    /// The JSON policy document that you want to use as the content for the new policy. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). To learn more about JSON policy grammar, see [Grammar of the IAM JSON policy language](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_grammar.html) in the IAM User Guide. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The friendly name of the policy. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    /// This member is required.
    public var policyName: Swift.String?
    /// A list of tags that you want to attach to the new IAM customer managed policy. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        path: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.path = path
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.tags = tags
    }
}

extension IAMClientTypes {
    /// Contains information about a managed policy. This data type is used as a response element in the [CreatePolicy], [GetPolicy], and [ListPolicies] operations. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct Policy {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The number of entities (users, groups, and roles) that the policy is attached to.
        public var attachmentCount: Swift.Int?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was created.
        public var createDate: Foundation.Date?
        /// The identifier for the version of the policy that is set as the default version.
        public var defaultVersionId: Swift.String?
        /// A friendly description of the policy. This element is included in the response to the [GetPolicy] operation. It is not included in the response to the [ListPolicies] operation.
        public var description: Swift.String?
        /// Specifies whether the policy can be attached to an IAM user, group, or role.
        public var isAttachable: Swift.Bool
        /// The path to the policy. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The number of entities (users and roles) for which the policy is used to set the permissions boundary. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundaryUsageCount: Swift.Int?
        /// The stable and unique string identifying the policy. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var policyId: Swift.String?
        /// The friendly name (not ARN) identifying the policy.
        public var policyName: Swift.String?
        /// A list of tags that are attached to the instance profile. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was last updated. When a policy has only one version, this field contains the date and time when the policy was created. When a policy has more than one version, this field contains the date and time when the most recent policy version was created.
        public var updateDate: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            attachmentCount: Swift.Int? = nil,
            createDate: Foundation.Date? = nil,
            defaultVersionId: Swift.String? = nil,
            description: Swift.String? = nil,
            isAttachable: Swift.Bool = false,
            path: Swift.String? = nil,
            permissionsBoundaryUsageCount: Swift.Int? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            updateDate: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.attachmentCount = attachmentCount
            self.createDate = createDate
            self.defaultVersionId = defaultVersionId
            self.description = description
            self.isAttachable = isAttachable
            self.path = path
            self.permissionsBoundaryUsageCount = permissionsBoundaryUsageCount
            self.policyId = policyId
            self.policyName = policyName
            self.tags = tags
            self.updateDate = updateDate
        }
    }

}

/// Contains the response to a successful [CreatePolicy] request.
public struct CreatePolicyOutput {
    /// A structure containing details about the new policy.
    public var policy: IAMClientTypes.Policy?

    public init(
        policy: IAMClientTypes.Policy? = nil
    )
    {
        self.policy = policy
    }
}

public struct CreatePolicyVersionInput {
    /// The Amazon Resource Name (ARN) of the IAM policy to which you want to add a new version. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The JSON policy document that you want to use as the content for this new version of the policy. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// Specifies whether to set this version as the policy's default version. When this parameter is true, the new policy version becomes the operative version. That is, it becomes the version that is in effect for the IAM users, groups, and roles that the policy is attached to. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    public var setAsDefault: Swift.Bool?

    public init(
        policyArn: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        setAsDefault: Swift.Bool? = false
    )
    {
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.setAsDefault = setAsDefault
    }
}

extension IAMClientTypes {
    /// Contains information about a version of a managed policy. This data type is used as a response element in the [CreatePolicyVersion], [GetPolicyVersion], [ListPolicyVersions], and [GetAccountAuthorizationDetails] operations. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyVersion {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy version was created.
        public var createDate: Foundation.Date?
        /// The policy document. The policy document is returned in the response to the [GetPolicyVersion] and [GetAccountAuthorizationDetails] operations. It is not returned in the response to the [CreatePolicyVersion] or [ListPolicyVersions] operations. The policy document returned in this structure is URL-encoded compliant with [RFC 3986](https://tools.ietf.org/html/rfc3986). You can use a URL decoding method to convert the policy back to plain JSON text. For example, if you use Java, you can use the decode method of the java.net.URLDecoder utility class in the Java SDK. Other languages and SDKs provide similar functionality.
        public var document: Swift.String?
        /// Specifies whether the policy version is set as the policy's default version.
        public var isDefaultVersion: Swift.Bool
        /// The identifier for the policy version. Policy version identifiers always begin with v (always lowercase). When a policy is created, the first policy version is v1.
        public var versionId: Swift.String?

        public init(
            createDate: Foundation.Date? = nil,
            document: Swift.String? = nil,
            isDefaultVersion: Swift.Bool = false,
            versionId: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.document = document
            self.isDefaultVersion = isDefaultVersion
            self.versionId = versionId
        }
    }

}

/// Contains the response to a successful [CreatePolicyVersion] request.
public struct CreatePolicyVersionOutput {
    /// A structure containing details about the new policy version.
    public var policyVersion: IAMClientTypes.PolicyVersion?

    public init(
        policyVersion: IAMClientTypes.PolicyVersion? = nil
    )
    {
        self.policyVersion = policyVersion
    }
}

public struct CreateRoleInput {
    /// The trust relationship policy document that grants an entity permission to assume the role. In IAM, you must provide a JSON policy that has been converted to a string. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// Upon success, the response includes the same trust policy in JSON format.
    /// This member is required.
    public var assumeRolePolicyDocument: Swift.String?
    /// A description of the role.
    public var description: Swift.String?
    /// The maximum session duration (in seconds) that you want to set for the specified role. If you do not specify a value for this setting, the default value of one hour is applied. This setting can have a value from 1 hour to 12 hours. Anyone who assumes the role from the CLI or API can use the DurationSeconds API parameter or the duration-seconds CLI parameter to request a longer session. The MaxSessionDuration setting determines the maximum duration that can be requested using the DurationSeconds parameter. If users don't specify a value for the DurationSeconds parameter, their security credentials are valid for one hour by default. This applies when you use the AssumeRole* API operations or the assume-role* CLI operations but does not apply when you use those operations to create a console URL. For more information, see [Using IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html) in the IAM User Guide.
    public var maxSessionDuration: Swift.Int?
    /// The path to the role. For more information about paths, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// The ARN of the managed policy that is used to set the permissions boundary for the role. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    public var permissionsBoundary: Swift.String?
    /// The name of the role to create. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource". This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?
    /// A list of tags that you want to attach to the new role. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        assumeRolePolicyDocument: Swift.String? = nil,
        description: Swift.String? = nil,
        maxSessionDuration: Swift.Int? = nil,
        path: Swift.String? = nil,
        permissionsBoundary: Swift.String? = nil,
        roleName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.assumeRolePolicyDocument = assumeRolePolicyDocument
        self.description = description
        self.maxSessionDuration = maxSessionDuration
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.roleName = roleName
        self.tags = tags
    }
}

/// Contains the response to a successful [CreateRole] request.
public struct CreateRoleOutput {
    /// A structure containing details about the new role.
    /// This member is required.
    public var role: IAMClientTypes.Role?

    public init(
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

public struct CreateSAMLProviderInput {
    /// The name of the provider to create. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var name: Swift.String?
    /// An XML document generated by an identity provider (IdP) that supports SAML 2.0. The document includes the issuer's name, expiration information, and keys that can be used to validate the SAML authentication response (assertions) that are received from the IdP. You must generate the metadata document using the identity management software that is used as your organization's IdP. For more information, see [About SAML 2.0-based federation](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_saml.html) in the IAM User Guide
    /// This member is required.
    public var samlMetadataDocument: Swift.String?
    /// A list of tags that you want to attach to the new IAM SAML provider. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        name: Swift.String? = nil,
        samlMetadataDocument: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.name = name
        self.samlMetadataDocument = samlMetadataDocument
        self.tags = tags
    }
}

/// Contains the response to a successful [CreateSAMLProvider] request.
public struct CreateSAMLProviderOutput {
    /// The Amazon Resource Name (ARN) of the new SAML provider resource in IAM.
    public var samlProviderArn: Swift.String?
    /// A list of tags that are attached to the new IAM SAML provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        samlProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
        self.tags = tags
    }
}

public struct CreateServiceLinkedRoleInput {
    /// The service principal for the Amazon Web Services service to which this role is attached. You use a string similar to a URL but without the http:// in front. For example: elasticbeanstalk.amazonaws.com. Service principals are unique and case-sensitive. To find the exact service principal for your service-linked role, see [Amazon Web Services services that work with IAM](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html) in the IAM User Guide. Look for the services that have Yes in the Service-Linked Role column. Choose the Yes link to view the service-linked role documentation for that service.
    /// This member is required.
    public var awsServiceName: Swift.String?
    /// A string that you provide, which is combined with the service-provided prefix to form the complete role name. If you make multiple requests for the same service, then you must supply a different CustomSuffix for each request. Otherwise the request fails with a duplicate role name error. For example, you could add -1 or -debug to the suffix. Some services do not support the CustomSuffix parameter. If you provide an optional suffix and the operation fails, try the operation again without the suffix.
    public var customSuffix: Swift.String?
    /// The description of the role.
    public var description: Swift.String?

    public init(
        awsServiceName: Swift.String? = nil,
        customSuffix: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.awsServiceName = awsServiceName
        self.customSuffix = customSuffix
        self.description = description
    }
}

public struct CreateServiceLinkedRoleOutput {
    /// A [Role] object that contains details about the newly created role.
    public var role: IAMClientTypes.Role?

    public init(
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

/// The specified service does not support service-specific credentials.
public struct ServiceNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotSupportedService" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateServiceSpecificCredentialInput {
    /// The name of the Amazon Web Services service that is to be associated with the credentials. The service you specify here is the only service that can be accessed using these credentials.
    /// This member is required.
    public var serviceName: Swift.String?
    /// The name of the IAM user that is to be associated with the credentials. The new service-specific credentials have the same permissions as the associated user except that they can be used only to access the specified service. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serviceName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceName = serviceName
        self.userName = userName
    }
}

extension IAMClientTypes {
    /// Contains the details of a service-specific credential.
    public struct ServiceSpecificCredential {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the service-specific credential were created.
        /// This member is required.
        public var createDate: Foundation.Date?
        /// The name of the service associated with the service-specific credential.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The generated password for the service-specific credential.
        /// This member is required.
        public var servicePassword: Swift.String?
        /// The unique identifier for the service-specific credential.
        /// This member is required.
        public var serviceSpecificCredentialId: Swift.String?
        /// The generated user name for the service-specific credential. This value is generated by combining the IAM user's name combined with the ID number of the Amazon Web Services account, as in jane-at-123456789012, for example. This value cannot be configured by the user.
        /// This member is required.
        public var serviceUserName: Swift.String?
        /// The status of the service-specific credential. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user associated with the service-specific credential.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            createDate: Foundation.Date? = nil,
            serviceName: Swift.String? = nil,
            servicePassword: Swift.String? = nil,
            serviceSpecificCredentialId: Swift.String? = nil,
            serviceUserName: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.serviceName = serviceName
            self.servicePassword = servicePassword
            self.serviceSpecificCredentialId = serviceSpecificCredentialId
            self.serviceUserName = serviceUserName
            self.status = status
            self.userName = userName
        }
    }

}

extension IAMClientTypes.ServiceSpecificCredential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceSpecificCredential(createDate: \(Swift.String(describing: createDate)), serviceName: \(Swift.String(describing: serviceName)), serviceSpecificCredentialId: \(Swift.String(describing: serviceSpecificCredentialId)), serviceUserName: \(Swift.String(describing: serviceUserName)), status: \(Swift.String(describing: status)), userName: \(Swift.String(describing: userName)), servicePassword: \"CONTENT_REDACTED\")"}
}

public struct CreateServiceSpecificCredentialOutput {
    /// A structure that contains information about the newly created service-specific credential. This is the only time that the password for this credential set is available. It cannot be recovered later. Instead, you must reset the password with [ResetServiceSpecificCredential].
    public var serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential?

    public init(
        serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential? = nil
    )
    {
        self.serviceSpecificCredential = serviceSpecificCredential
    }
}

public struct CreateUserInput {
    /// The path for the user name. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// The ARN of the managed policy that is used to set the permissions boundary for the user. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    public var permissionsBoundary: Swift.String?
    /// A list of tags that you want to attach to the new user. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?
    /// The name of the user to create. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    /// This member is required.
    public var userName: Swift.String?

    public init(
        path: Swift.String? = nil,
        permissionsBoundary: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.tags = tags
        self.userName = userName
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM user entity. This data type is used as a response element in the following operations:
    ///
    /// * [CreateUser]
    ///
    /// * [GetUser]
    ///
    /// * [ListUsers]
    public struct User {
        /// The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the user was created.
        /// This member is required.
        public var createDate: Foundation.Date?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the user's password was last used to sign in to an Amazon Web Services website. For a list of Amazon Web Services websites that capture a user's last sign-in time, see the [Credential reports](https://docs.aws.amazon.com/IAM/latest/UserGuide/credential-reports.html) topic in the IAM User Guide. If a password is used more than once in a five-minute span, only the first use is returned in this field. If the field is null (no value), then it indicates that they never signed in with a password. This can be because:
        ///
        /// * The user never had a password.
        ///
        /// * A password exists but has not been used since IAM started tracking this information on October 20, 2014.
        ///
        ///
        /// A null value does not mean that the user never had a password. Also, if the user does not currently have a password but had one in the past, then this field contains the date and time the most recent password was used. This value is returned only in the [GetUser] and [ListUsers] operations.
        public var passwordLastUsed: Foundation.Date?
        /// The path to the user. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. The ARN of the policy used to set the permissions boundary for the user.
        /// This member is required.
        public var path: Swift.String?
        /// For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// A list of tags that are associated with the user. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The stable and unique string identifying the user. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var userId: Swift.String?
        /// The friendly name identifying the user.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createDate: Foundation.Date? = nil,
            passwordLastUsed: Foundation.Date? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            userId: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.passwordLastUsed = passwordLastUsed
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.tags = tags
            self.userId = userId
            self.userName = userName
        }
    }

}

/// Contains the response to a successful [CreateUser] request.
public struct CreateUserOutput {
    /// A structure with details about the new IAM user.
    public var user: IAMClientTypes.User?

    public init(
        user: IAMClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

public struct CreateVirtualMFADeviceInput {
    /// The path for the virtual MFA device. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// A list of tags that you want to attach to the new IAM virtual MFA device. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?
    /// The name of the virtual MFA device, which must be unique. Use with path to uniquely identify a virtual MFA device. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var virtualMFADeviceName: Swift.String?

    public init(
        path: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        virtualMFADeviceName: Swift.String? = nil
    )
    {
        self.path = path
        self.tags = tags
        self.virtualMFADeviceName = virtualMFADeviceName
    }
}

extension IAMClientTypes {
    /// Contains information about a virtual MFA device.
    public struct VirtualMFADevice {
        /// The base32 seed defined as specified in [RFC3548](https://tools.ietf.org/html/rfc3548.txt). The Base32StringSeed is base32-encoded.
        public var base32StringSeed: Foundation.Data?
        /// The date and time on which the virtual MFA device was enabled.
        public var enableDate: Foundation.Date?
        /// A QR code PNG image that encodes otpauth://totp/$virtualMFADeviceName@$AccountName?secret=$Base32String where $virtualMFADeviceName is one of the create call arguments. AccountName is the user name if set (otherwise, the account ID otherwise), and Base32String is the seed in base32 format. The Base32String value is base64-encoded.
        public var qrCodePNG: Foundation.Data?
        /// The serial number associated with VirtualMFADevice.
        /// This member is required.
        public var serialNumber: Swift.String?
        /// A list of tags that are attached to the virtual MFA device. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The IAM user associated with this virtual MFA device.
        public var user: IAMClientTypes.User?

        public init(
            base32StringSeed: Foundation.Data? = nil,
            enableDate: Foundation.Date? = nil,
            qrCodePNG: Foundation.Data? = nil,
            serialNumber: Swift.String? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            user: IAMClientTypes.User? = nil
        )
        {
            self.base32StringSeed = base32StringSeed
            self.enableDate = enableDate
            self.qrCodePNG = qrCodePNG
            self.serialNumber = serialNumber
            self.tags = tags
            self.user = user
        }
    }

}

extension IAMClientTypes.VirtualMFADevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VirtualMFADevice(enableDate: \(Swift.String(describing: enableDate)), serialNumber: \(Swift.String(describing: serialNumber)), tags: \(Swift.String(describing: tags)), user: \(Swift.String(describing: user)), base32StringSeed: \"CONTENT_REDACTED\", qrCodePNG: \"CONTENT_REDACTED\")"}
}

/// Contains the response to a successful [CreateVirtualMFADevice] request.
public struct CreateVirtualMFADeviceOutput {
    /// A structure containing details about the new virtual MFA device.
    /// This member is required.
    public var virtualMFADevice: IAMClientTypes.VirtualMFADevice?

    public init(
        virtualMFADevice: IAMClientTypes.VirtualMFADevice? = nil
    )
    {
        self.virtualMFADevice = virtualMFADevice
    }
}

public struct DeactivateMFADeviceInput {
    /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: =,.@:/-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The name of the user whose MFA device you want to deactivate. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

public struct DeleteAccessKeyInput {
    /// The access key ID for the access key ID and secret access key you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var accessKeyId: Swift.String?
    /// The name of the user whose access key pair you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        accessKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.userName = userName
    }
}

public struct DeleteAccountAliasInput {
    /// The name of the account alias to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have two dashes in a row.
    /// This member is required.
    public var accountAlias: Swift.String?

    public init(
        accountAlias: Swift.String? = nil
    )
    {
        self.accountAlias = accountAlias
    }
}

/// The request was rejected because it attempted to delete a resource that has attached subordinate entities. The error message describes these entities.
public struct DeleteConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeleteConflict" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteGroupInput {
    /// The name of the IAM group to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?

    public init(
        groupName: Swift.String? = nil
    )
    {
        self.groupName = groupName
    }
}

public struct DeleteGroupPolicyInput {
    /// The name (friendly name, not ARN) identifying the group that the policy is embedded in. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name identifying the policy document to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyName = policyName
    }
}

public struct DeleteInstanceProfileInput {
    /// The name of the instance profile to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?

    public init(
        instanceProfileName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
    }
}

public struct DeleteLoginProfileInput {
    /// The name of the user whose password you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

public struct DeleteOpenIDConnectProviderInput {
    /// The Amazon Resource Name (ARN) of the IAM OpenID Connect provider resource object to delete. You can get a list of OpenID Connect provider resource ARNs by using the [ListOpenIDConnectProviders] operation.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init(
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

public struct DeletePolicyInput {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to delete. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        policyArn: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

public struct DeletePolicyVersionInput {
    /// The Amazon Resource Name (ARN) of the IAM policy from which you want to delete a version. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The policy version to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consists of the lowercase letter 'v' followed by one or two digits, and optionally followed by a period '.' and a string of letters and digits. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.versionId = versionId
    }
}

public struct DeleteRoleInput {
    /// The name of the role to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

public struct DeleteRolePermissionsBoundaryInput {
    /// The name (friendly name, not ARN) of the IAM role from which you want to remove the permissions boundary.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

public struct DeleteRolePolicyInput {
    /// The name of the inline policy to delete from the specified IAM role. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name (friendly name, not ARN) identifying the role that the policy is embedded in. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.roleName = roleName
    }
}

public struct DeleteSAMLProviderInput {
    /// The Amazon Resource Name (ARN) of the SAML provider to delete.
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init(
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
    }
}

public struct DeleteServerCertificateInput {
    /// The name of the server certificate you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init(
        serverCertificateName: Swift.String? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
    }
}

public struct DeleteServiceLinkedRoleInput {
    /// The name of the service-linked role to be deleted.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

public struct DeleteServiceLinkedRoleOutput {
    /// The deletion task identifier that you can use to check the status of the deletion. This identifier is returned in the format task/aws-service-role///.
    /// This member is required.
    public var deletionTaskId: Swift.String?

    public init(
        deletionTaskId: Swift.String? = nil
    )
    {
        self.deletionTaskId = deletionTaskId
    }
}

public struct DeleteServiceSpecificCredentialInput {
    /// The unique identifier of the service-specific credential. You can get this value by calling [ListServiceSpecificCredentials]. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var serviceSpecificCredentialId: Swift.String?
    /// The name of the IAM user associated with the service-specific credential. If this value is not specified, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        serviceSpecificCredentialId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.userName = userName
    }
}

public struct DeleteSigningCertificateInput {
    /// The ID of the signing certificate to delete. The format of this parameter, as described by its [regex](http://wikipedia.org/wiki/regex) pattern, is a string of characters that can be upper- or lower-cased letters or digits.
    /// This member is required.
    public var certificateId: Swift.String?
    /// The name of the user the signing certificate belongs to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        certificateId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
        self.userName = userName
    }
}

public struct DeleteSSHPublicKeyInput {
    /// The unique identifier for the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// The name of the IAM user associated with the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

public struct DeleteUserInput {
    /// The name of the user to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

public struct DeleteUserPermissionsBoundaryInput {
    /// The name (friendly name, not ARN) of the IAM user from which you want to remove the permissions boundary.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

public struct DeleteUserPolicyInput {
    /// The name identifying the policy document to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name (friendly name, not ARN) identifying the user that the policy is embedded in. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.userName = userName
    }
}

public struct DeleteVirtualMFADeviceInput {
    /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: =,.@:/-
    /// This member is required.
    public var serialNumber: Swift.String?

    public init(
        serialNumber: Swift.String? = nil
    )
    {
        self.serialNumber = serialNumber
    }
}

public struct DetachGroupPolicyInput {
    /// The name (friendly name, not ARN) of the IAM group to detach the policy from. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM policy you want to detach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyArn = policyArn
    }
}

public struct DetachRolePolicyInput {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to detach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the IAM role to detach the policy from. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.roleName = roleName
    }
}

public struct DetachUserPolicyInput {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to detach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the IAM user to detach the policy from. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.userName = userName
    }
}

/// The request was rejected because the authentication code was not recognized. The error message describes the specific error.
public struct InvalidAuthenticationCodeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAuthenticationCode" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct EnableMFADeviceInput {
    /// An authentication code emitted by the device. The format for this parameter is a string of six digits. Submit your request immediately after generating the authentication codes. If you generate the codes and then wait too long to submit the request, the MFA device successfully associates with the user but the MFA device becomes out of sync. This happens because time-based one-time passwords (TOTP) expire after a short period of time. If this happens, you can [resync the device](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html).
    /// This member is required.
    public var authenticationCode1: Swift.String?
    /// A subsequent authentication code emitted by the device. The format for this parameter is a string of six digits. Submit your request immediately after generating the authentication codes. If you generate the codes and then wait too long to submit the request, the MFA device successfully associates with the user but the MFA device becomes out of sync. This happens because time-based one-time passwords (TOTP) expire after a short period of time. If this happens, you can [resync the device](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html).
    /// This member is required.
    public var authenticationCode2: Swift.String?
    /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: =,.@:/-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The name of the IAM user for whom you want to enable the MFA device. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        authenticationCode1: Swift.String? = nil,
        authenticationCode2: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationCode1 = authenticationCode1
        self.authenticationCode2 = authenticationCode2
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

extension IAMClientTypes {

    public enum ReportStateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case inprogress
        case started
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportStateType] {
            return [
                .complete,
                .inprogress,
                .started
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .inprogress: return "INPROGRESS"
            case .started: return "STARTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Contains the response to a successful [GenerateCredentialReport] request.
public struct GenerateCredentialReportOutput {
    /// Information about the credential report.
    public var description: Swift.String?
    /// Information about the state of the credential report.
    public var state: IAMClientTypes.ReportStateType?

    public init(
        description: Swift.String? = nil,
        state: IAMClientTypes.ReportStateType? = nil
    )
    {
        self.description = description
        self.state = state
    }
}

/// The request failed because the maximum number of concurrent requests for this account are already running.
public struct ReportGenerationLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReportGenerationLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GenerateOrganizationsAccessReportInput {
    /// The path of the Organizations entity (root, OU, or account). You can build an entity path using the known structure of your organization. For example, assume that your account ID is 123456789012 and its parent OU ID is ou-rge0-awsabcde. The organization root ID is r-f6g7h8i9j0example and your organization ID is o-a1b2c3d4e5. Your entity path is o-a1b2c3d4e5/r-f6g7h8i9j0example/ou-rge0-awsabcde/123456789012.
    /// This member is required.
    public var entityPath: Swift.String?
    /// The identifier of the Organizations service control policy (SCP). This parameter is optional. This ID is used to generate information about when an account principal that is limited by the SCP attempted to access an Amazon Web Services service.
    public var organizationsPolicyId: Swift.String?

    public init(
        entityPath: Swift.String? = nil,
        organizationsPolicyId: Swift.String? = nil
    )
    {
        self.entityPath = entityPath
        self.organizationsPolicyId = organizationsPolicyId
    }
}

public struct GenerateOrganizationsAccessReportOutput {
    /// The job identifier that you can use in the [GetOrganizationsAccessReport] operation.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct GenerateServiceLastAccessedDetailsInput {
    /// The ARN of the IAM resource (user, group, role, or managed policy) used to generate information about when the resource was last used in an attempt to access an Amazon Web Services service.
    /// This member is required.
    public var arn: Swift.String?
    /// The level of detail that you want to generate. You can specify whether you want to generate information about the last attempt to access services or actions. If you specify service-level granularity, this operation generates only service data. If you specify action-level granularity, it generates service and action data. If you don't include this optional parameter, the operation generates service data.
    public var granularity: IAMClientTypes.AccessAdvisorUsageGranularityType?

    public init(
        arn: Swift.String? = nil,
        granularity: IAMClientTypes.AccessAdvisorUsageGranularityType? = nil
    )
    {
        self.arn = arn
        self.granularity = granularity
    }
}

public struct GenerateServiceLastAccessedDetailsOutput {
    /// The JobId that you can use in the [GetServiceLastAccessedDetails] or [GetServiceLastAccessedDetailsWithEntities] operations. The JobId returned by GenerateServiceLastAccessedDetail must be used by the same role within a session, or by the same user when used to call GetServiceLastAccessedDetail.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct GetAccessKeyLastUsedInput {
    /// The identifier of an access key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var accessKeyId: Swift.String?

    public init(
        accessKeyId: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
    }
}

/// Contains the response to a successful [GetAccessKeyLastUsed] request. It is also returned as a member of the [AccessKeyMetaData] structure returned by the [ListAccessKeys] action.
public struct GetAccessKeyLastUsedOutput {
    /// Contains information about the last time the access key was used.
    public var accessKeyLastUsed: IAMClientTypes.AccessKeyLastUsed?
    /// The name of the IAM user that owns this access key.
    public var userName: Swift.String?

    public init(
        accessKeyLastUsed: IAMClientTypes.AccessKeyLastUsed? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessKeyLastUsed = accessKeyLastUsed
        self.userName = userName
    }
}

extension IAMClientTypes {

    public enum EntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsmanagedpolicy
        case group
        case localmanagedpolicy
        case role
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .awsmanagedpolicy,
                .group,
                .localmanagedpolicy,
                .role,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsmanagedpolicy: return "AWSManagedPolicy"
            case .group: return "Group"
            case .localmanagedpolicy: return "LocalManagedPolicy"
            case .role: return "Role"
            case .user: return "User"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetAccountAuthorizationDetailsInput {
    /// A list of entity types used to filter the results. Only the entities that match the types you specify are included in the output. Use the value LocalManagedPolicy to include customer managed policies. The format for this parameter is a comma-separated (if more than one) list of strings. Each string value in the list must be one of the valid values listed below.
    public var filter: [IAMClientTypes.EntityType]?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        filter: [IAMClientTypes.EntityType]? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.filter = filter
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM policy, including the policy document. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct PolicyDetail {
        /// The policy document.
        public var policyDocument: Swift.String?
        /// The name of the policy.
        public var policyName: Swift.String?

        public init(
            policyDocument: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.policyDocument = policyDocument
            self.policyName = policyName
        }
    }

}

extension IAMClientTypes {
    /// Contains information about an IAM group, including all of the group's policies. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct GroupDetail {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// A list of the managed policies attached to the group.
        public var attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the group was created.
        public var createDate: Foundation.Date?
        /// The stable and unique string identifying the group. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var groupId: Swift.String?
        /// The friendly name that identifies the group.
        public var groupName: Swift.String?
        /// A list of the inline policies embedded in the group.
        public var groupPolicyList: [IAMClientTypes.PolicyDetail]?
        /// The path to the group. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?

        public init(
            arn: Swift.String? = nil,
            attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
            createDate: Foundation.Date? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            groupPolicyList: [IAMClientTypes.PolicyDetail]? = nil,
            path: Swift.String? = nil
        )
        {
            self.arn = arn
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupId = groupId
            self.groupName = groupName
            self.groupPolicyList = groupPolicyList
            self.path = path
        }
    }

}

extension IAMClientTypes {
    /// Contains information about a managed policy, including the policy's ARN, versions, and the number of principal entities (users, groups, and roles) that the policy is attached to. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation. For more information about managed policies, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct ManagedPolicyDetail {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The number of principal entities (users, groups, and roles) that the policy is attached to.
        public var attachmentCount: Swift.Int?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was created.
        public var createDate: Foundation.Date?
        /// The identifier for the version of the policy that is set as the default (operative) version. For more information about policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
        public var defaultVersionId: Swift.String?
        /// A friendly description of the policy.
        public var description: Swift.String?
        /// Specifies whether the policy can be attached to an IAM user, group, or role.
        public var isAttachable: Swift.Bool
        /// The path to the policy. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The number of entities (users and roles) for which the policy is used as the permissions boundary. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundaryUsageCount: Swift.Int?
        /// The stable and unique string identifying the policy. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var policyId: Swift.String?
        /// The friendly name (not ARN) identifying the policy.
        public var policyName: Swift.String?
        /// A list containing information about the versions of the policy.
        public var policyVersionList: [IAMClientTypes.PolicyVersion]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was last updated. When a policy has only one version, this field contains the date and time when the policy was created. When a policy has more than one version, this field contains the date and time when the most recent policy version was created.
        public var updateDate: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            attachmentCount: Swift.Int? = nil,
            createDate: Foundation.Date? = nil,
            defaultVersionId: Swift.String? = nil,
            description: Swift.String? = nil,
            isAttachable: Swift.Bool = false,
            path: Swift.String? = nil,
            permissionsBoundaryUsageCount: Swift.Int? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyVersionList: [IAMClientTypes.PolicyVersion]? = nil,
            updateDate: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.attachmentCount = attachmentCount
            self.createDate = createDate
            self.defaultVersionId = defaultVersionId
            self.description = description
            self.isAttachable = isAttachable
            self.path = path
            self.permissionsBoundaryUsageCount = permissionsBoundaryUsageCount
            self.policyId = policyId
            self.policyName = policyName
            self.policyVersionList = policyVersionList
            self.updateDate = updateDate
        }
    }

}

extension IAMClientTypes {
    /// Contains information about an IAM role, including all of the role's policies. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct RoleDetail {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The trust policy that grants permission to assume the role.
        public var assumeRolePolicyDocument: Swift.String?
        /// A list of managed policies attached to the role. These policies are the role's access (permissions) policies.
        public var attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the role was created.
        public var createDate: Foundation.Date?
        /// A list of instance profiles that contain this role.
        public var instanceProfileList: [IAMClientTypes.InstanceProfile]?
        /// The path to the role. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The ARN of the policy used to set the permissions boundary for the role. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// The stable and unique string identifying the role. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var roleId: Swift.String?
        /// Contains information about the last time that an IAM role was used. This includes the date and time and the Region in which the role was last used. Activity is only reported for the trailing 400 days. This period can be shorter if your Region began supporting these features within the last year. The role might have been used more than 400 days ago. For more information, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM User Guide.
        public var roleLastUsed: IAMClientTypes.RoleLastUsed?
        /// The friendly name that identifies the role.
        public var roleName: Swift.String?
        /// A list of inline policies embedded in the role. These policies are the role's access (permissions) policies.
        public var rolePolicyList: [IAMClientTypes.PolicyDetail]?
        /// A list of tags that are attached to the role. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init(
            arn: Swift.String? = nil,
            assumeRolePolicyDocument: Swift.String? = nil,
            attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
            createDate: Foundation.Date? = nil,
            instanceProfileList: [IAMClientTypes.InstanceProfile]? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            roleId: Swift.String? = nil,
            roleLastUsed: IAMClientTypes.RoleLastUsed? = nil,
            roleName: Swift.String? = nil,
            rolePolicyList: [IAMClientTypes.PolicyDetail]? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.arn = arn
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.instanceProfileList = instanceProfileList
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.roleId = roleId
            self.roleLastUsed = roleLastUsed
            self.roleName = roleName
            self.rolePolicyList = rolePolicyList
            self.tags = tags
        }
    }

}

extension IAMClientTypes {
    /// Contains information about an IAM user, including all the user's policies and all the IAM groups the user is in. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct UserDetail {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// A list of the managed policies attached to the user.
        public var attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the user was created.
        public var createDate: Foundation.Date?
        /// A list of IAM groups that the user is in.
        public var groupList: [Swift.String]?
        /// The path to the user. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The ARN of the policy used to set the permissions boundary for the user. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// A list of tags that are associated with the user. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The stable and unique string identifying the user. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var userId: Swift.String?
        /// The friendly name identifying the user.
        public var userName: Swift.String?
        /// A list of the inline policies embedded in the user.
        public var userPolicyList: [IAMClientTypes.PolicyDetail]?

        public init(
            arn: Swift.String? = nil,
            attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
            createDate: Foundation.Date? = nil,
            groupList: [Swift.String]? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            userId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userPolicyList: [IAMClientTypes.PolicyDetail]? = nil
        )
        {
            self.arn = arn
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupList = groupList
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.tags = tags
            self.userId = userId
            self.userName = userName
            self.userPolicyList = userPolicyList
        }
    }

}

/// Contains the response to a successful [GetAccountAuthorizationDetails] request.
public struct GetAccountAuthorizationDetailsOutput {
    /// A list containing information about IAM groups.
    public var groupDetailList: [IAMClientTypes.GroupDetail]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list containing information about managed policies.
    public var policies: [IAMClientTypes.ManagedPolicyDetail]?
    /// A list containing information about IAM roles.
    public var roleDetailList: [IAMClientTypes.RoleDetail]?
    /// A list containing information about IAM users.
    public var userDetailList: [IAMClientTypes.UserDetail]?

    public init(
        groupDetailList: [IAMClientTypes.GroupDetail]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policies: [IAMClientTypes.ManagedPolicyDetail]? = nil,
        roleDetailList: [IAMClientTypes.RoleDetail]? = nil,
        userDetailList: [IAMClientTypes.UserDetail]? = nil
    )
    {
        self.groupDetailList = groupDetailList
        self.isTruncated = isTruncated
        self.marker = marker
        self.policies = policies
        self.roleDetailList = roleDetailList
        self.userDetailList = userDetailList
    }
}

extension IAMClientTypes {
    /// Contains information about the account password policy. This data type is used as a response element in the [GetAccountPasswordPolicy] operation.
    public struct PasswordPolicy {
        /// Specifies whether IAM users are allowed to change their own password. Gives IAM users permissions to iam:ChangePassword for only their user and to the iam:GetAccountPasswordPolicy action. This option does not attach a permissions policy to each user, rather the permissions are applied at the account-level for all users by IAM.
        public var allowUsersToChangePassword: Swift.Bool
        /// Indicates whether passwords in the account expire. Returns true if MaxPasswordAge contains a value greater than 0. Returns false if MaxPasswordAge is 0 or not present.
        public var expirePasswords: Swift.Bool
        /// Specifies whether IAM users are prevented from setting a new password via the Amazon Web Services Management Console after their password has expired. The IAM user cannot access the console until an administrator resets the password. IAM users with iam:ChangePassword permission and active access keys can reset their own expired console password using the CLI or API.
        public var hardExpiry: Swift.Bool?
        /// The number of days that an IAM user password is valid.
        public var maxPasswordAge: Swift.Int?
        /// Minimum length to require for IAM user passwords.
        public var minimumPasswordLength: Swift.Int?
        /// Specifies the number of previous passwords that IAM users are prevented from reusing.
        public var passwordReusePrevention: Swift.Int?
        /// Specifies whether IAM user passwords must contain at least one lowercase character (a to z).
        public var requireLowercaseCharacters: Swift.Bool
        /// Specifies whether IAM user passwords must contain at least one numeric character (0 to 9).
        public var requireNumbers: Swift.Bool
        /// Specifies whether IAM user passwords must contain at least one of the following symbols: ! @ # $ % ^ & * ( ) _ + - = [ ] { } | '
        public var requireSymbols: Swift.Bool
        /// Specifies whether IAM user passwords must contain at least one uppercase character (A to Z).
        public var requireUppercaseCharacters: Swift.Bool

        public init(
            allowUsersToChangePassword: Swift.Bool = false,
            expirePasswords: Swift.Bool = false,
            hardExpiry: Swift.Bool? = nil,
            maxPasswordAge: Swift.Int? = nil,
            minimumPasswordLength: Swift.Int? = nil,
            passwordReusePrevention: Swift.Int? = nil,
            requireLowercaseCharacters: Swift.Bool = false,
            requireNumbers: Swift.Bool = false,
            requireSymbols: Swift.Bool = false,
            requireUppercaseCharacters: Swift.Bool = false
        )
        {
            self.allowUsersToChangePassword = allowUsersToChangePassword
            self.expirePasswords = expirePasswords
            self.hardExpiry = hardExpiry
            self.maxPasswordAge = maxPasswordAge
            self.minimumPasswordLength = minimumPasswordLength
            self.passwordReusePrevention = passwordReusePrevention
            self.requireLowercaseCharacters = requireLowercaseCharacters
            self.requireNumbers = requireNumbers
            self.requireSymbols = requireSymbols
            self.requireUppercaseCharacters = requireUppercaseCharacters
        }
    }

}

/// Contains the response to a successful [GetAccountPasswordPolicy] request.
public struct GetAccountPasswordPolicyOutput {
    /// A structure that contains details about the account's password policy.
    /// This member is required.
    public var passwordPolicy: IAMClientTypes.PasswordPolicy?

    public init(
        passwordPolicy: IAMClientTypes.PasswordPolicy? = nil
    )
    {
        self.passwordPolicy = passwordPolicy
    }
}

extension IAMClientTypes {

    public enum SummaryKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accesskeysperuserquota
        case accountaccesskeyspresent
        case accountmfaenabled
        case accountsigningcertificatespresent
        case attachedpoliciespergroupquota
        case attachedpoliciesperrolequota
        case attachedpoliciesperuserquota
        case globalendpointtokenversion
        case grouppolicysizequota
        case groups
        case groupsperuserquota
        case groupsquota
        case mfadevices
        case mfadevicesinuse
        case policies
        case policiesquota
        case policysizequota
        case policyversionsinuse
        case policyversionsinusequota
        case servercertificates
        case servercertificatesquota
        case signingcertificatesperuserquota
        case userpolicysizequota
        case users
        case usersquota
        case versionsperpolicyquota
        case sdkUnknown(Swift.String)

        public static var allCases: [SummaryKeyType] {
            return [
                .accesskeysperuserquota,
                .accountaccesskeyspresent,
                .accountmfaenabled,
                .accountsigningcertificatespresent,
                .attachedpoliciespergroupquota,
                .attachedpoliciesperrolequota,
                .attachedpoliciesperuserquota,
                .globalendpointtokenversion,
                .grouppolicysizequota,
                .groups,
                .groupsperuserquota,
                .groupsquota,
                .mfadevices,
                .mfadevicesinuse,
                .policies,
                .policiesquota,
                .policysizequota,
                .policyversionsinuse,
                .policyversionsinusequota,
                .servercertificates,
                .servercertificatesquota,
                .signingcertificatesperuserquota,
                .userpolicysizequota,
                .users,
                .usersquota,
                .versionsperpolicyquota
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accesskeysperuserquota: return "AccessKeysPerUserQuota"
            case .accountaccesskeyspresent: return "AccountAccessKeysPresent"
            case .accountmfaenabled: return "AccountMFAEnabled"
            case .accountsigningcertificatespresent: return "AccountSigningCertificatesPresent"
            case .attachedpoliciespergroupquota: return "AttachedPoliciesPerGroupQuota"
            case .attachedpoliciesperrolequota: return "AttachedPoliciesPerRoleQuota"
            case .attachedpoliciesperuserquota: return "AttachedPoliciesPerUserQuota"
            case .globalendpointtokenversion: return "GlobalEndpointTokenVersion"
            case .grouppolicysizequota: return "GroupPolicySizeQuota"
            case .groups: return "Groups"
            case .groupsperuserquota: return "GroupsPerUserQuota"
            case .groupsquota: return "GroupsQuota"
            case .mfadevices: return "MFADevices"
            case .mfadevicesinuse: return "MFADevicesInUse"
            case .policies: return "Policies"
            case .policiesquota: return "PoliciesQuota"
            case .policysizequota: return "PolicySizeQuota"
            case .policyversionsinuse: return "PolicyVersionsInUse"
            case .policyversionsinusequota: return "PolicyVersionsInUseQuota"
            case .servercertificates: return "ServerCertificates"
            case .servercertificatesquota: return "ServerCertificatesQuota"
            case .signingcertificatesperuserquota: return "SigningCertificatesPerUserQuota"
            case .userpolicysizequota: return "UserPolicySizeQuota"
            case .users: return "Users"
            case .usersquota: return "UsersQuota"
            case .versionsperpolicyquota: return "VersionsPerPolicyQuota"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Contains the response to a successful [GetAccountSummary] request.
public struct GetAccountSummaryOutput {
    /// A set of key–value pairs containing information about IAM entity usage and IAM quotas.
    public var summaryMap: [Swift.String: Swift.Int]?

    public init(
        summaryMap: [Swift.String: Swift.Int]? = nil
    )
    {
        self.summaryMap = summaryMap
    }
}

public struct GetContextKeysForCustomPolicyInput {
    /// A list of policies for which you want the list of context keys referenced in those policies. Each document is specified as a string containing the complete, valid JSON text of an IAM policy. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyInputList: [Swift.String]?

    public init(
        policyInputList: [Swift.String]? = nil
    )
    {
        self.policyInputList = policyInputList
    }
}

/// Contains the response to a successful [GetContextKeysForPrincipalPolicy] or [GetContextKeysForCustomPolicy] request.
public struct GetContextKeysForCustomPolicyOutput {
    /// The list of context keys that are referenced in the input policies.
    public var contextKeyNames: [Swift.String]?

    public init(
        contextKeyNames: [Swift.String]? = nil
    )
    {
        self.contextKeyNames = contextKeyNames
    }
}

public struct GetContextKeysForPrincipalPolicyInput {
    /// An optional list of additional policies for which you want the list of context keys that are referenced. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var policyInputList: [Swift.String]?
    /// The ARN of a user, group, or role whose policies contain the context keys that you want listed. If you specify a user, the list includes context keys that are found in all policies that are attached to the user. The list also includes all groups that the user is a member of. If you pick a group or a role, then it includes only those context keys that are found in policies attached to that entity. Note that all parameters are shown in unencoded form here for clarity, but must be URL encoded to be included as a part of a real HTML request. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policySourceArn: Swift.String?

    public init(
        policyInputList: [Swift.String]? = nil,
        policySourceArn: Swift.String? = nil
    )
    {
        self.policyInputList = policyInputList
        self.policySourceArn = policySourceArn
    }
}

/// Contains the response to a successful [GetContextKeysForPrincipalPolicy] or [GetContextKeysForCustomPolicy] request.
public struct GetContextKeysForPrincipalPolicyOutput {
    /// The list of context keys that are referenced in the input policies.
    public var contextKeyNames: [Swift.String]?

    public init(
        contextKeyNames: [Swift.String]? = nil
    )
    {
        self.contextKeyNames = contextKeyNames
    }
}

/// The request was rejected because the most recent credential report has expired. To generate a new credential report, use [GenerateCredentialReport]. For more information about credential report expiration, see [Getting credential reports](https://docs.aws.amazon.com/IAM/latest/UserGuide/credential-reports.html) in the IAM User Guide.
public struct CredentialReportExpiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReportExpired" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because the credential report does not exist. To generate a credential report, use [GenerateCredentialReport].
public struct CredentialReportNotPresentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReportNotPresent" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because the credential report is still being generated.
public struct CredentialReportNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReportInProgress" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IAMClientTypes {

    public enum ReportFormatType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case textCsv
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFormatType] {
            return [
                .textCsv
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .textCsv: return "text/csv"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Contains the response to a successful [GetCredentialReport] request.
public struct GetCredentialReportOutput {
    /// Contains the credential report. The report is Base64-encoded.
    public var content: Foundation.Data?
    /// The date and time when the credential report was created, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601).
    public var generatedTime: Foundation.Date?
    /// The format (MIME type) of the credential report.
    public var reportFormat: IAMClientTypes.ReportFormatType?

    public init(
        content: Foundation.Data? = nil,
        generatedTime: Foundation.Date? = nil,
        reportFormat: IAMClientTypes.ReportFormatType? = nil
    )
    {
        self.content = content
        self.generatedTime = generatedTime
        self.reportFormat = reportFormat
    }
}

public struct GetGroupInput {
    /// The name of the group. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        groupName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.groupName = groupName
        self.marker = marker
        self.maxItems = maxItems
    }
}

/// Contains the response to a successful [GetGroup] request.
public struct GetGroupOutput {
    /// A structure that contains details about the group.
    /// This member is required.
    public var group: IAMClientTypes.Group?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of users in the group.
    /// This member is required.
    public var users: [IAMClientTypes.User]?

    public init(
        group: IAMClientTypes.Group? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        users: [IAMClientTypes.User]? = nil
    )
    {
        self.group = group
        self.isTruncated = isTruncated
        self.marker = marker
        self.users = users
    }
}

public struct GetGroupPolicyInput {
    /// The name of the group the policy is associated with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the policy document to get. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyName = policyName
    }
}

/// Contains the response to a successful [GetGroupPolicy] request.
public struct GetGroupPolicyOutput {
    /// The group the policy is associated with.
    /// This member is required.
    public var groupName: Swift.String?
    /// The policy document. IAM stores policies in JSON format. However, resources that were created using CloudFormation templates can be formatted in YAML. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyDocument = policyDocument
        self.policyName = policyName
    }
}

public struct GetInstanceProfileInput {
    /// The name of the instance profile to get information about. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?

    public init(
        instanceProfileName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
    }
}

/// Contains the response to a successful [GetInstanceProfile] request.
public struct GetInstanceProfileOutput {
    /// A structure containing details about the instance profile.
    /// This member is required.
    public var instanceProfile: IAMClientTypes.InstanceProfile?

    public init(
        instanceProfile: IAMClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

public struct GetLoginProfileInput {
    /// The name of the user whose login profile you want to retrieve. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

/// Contains the response to a successful [GetLoginProfile] request.
public struct GetLoginProfileOutput {
    /// A structure containing the user name and the profile creation date for the user.
    /// This member is required.
    public var loginProfile: IAMClientTypes.LoginProfile?

    public init(
        loginProfile: IAMClientTypes.LoginProfile? = nil
    )
    {
        self.loginProfile = loginProfile
    }
}

public struct GetMFADeviceInput {
    /// Serial number that uniquely identifies the MFA device. For this API, we only accept FIDO security key [ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html).
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The friendly name identifying the user.
    public var userName: Swift.String?

    public init(
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

public struct GetMFADeviceOutput {
    /// The certifications of a specified user's MFA device. We currently provide FIPS-140-2, FIPS-140-3, and FIDO certification levels obtained from [ FIDO Alliance Metadata Service (MDS)](https://fidoalliance.org/metadata/).
    public var certifications: [Swift.String: Swift.String]?
    /// The date that a specified user's MFA device was first enabled.
    public var enableDate: Foundation.Date?
    /// Serial number that uniquely identifies the MFA device. For this API, we only accept FIDO security key [ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html).
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The friendly name identifying the user.
    public var userName: Swift.String?

    public init(
        certifications: [Swift.String: Swift.String]? = nil,
        enableDate: Foundation.Date? = nil,
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.certifications = certifications
        self.enableDate = enableDate
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

public struct GetOpenIDConnectProviderInput {
    /// The Amazon Resource Name (ARN) of the OIDC provider resource object in IAM to get information for. You can get a list of OIDC provider resource ARNs by using the [ListOpenIDConnectProviders] operation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init(
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

/// Contains the response to a successful [GetOpenIDConnectProvider] request.
public struct GetOpenIDConnectProviderOutput {
    /// A list of client IDs (also known as audiences) that are associated with the specified IAM OIDC provider resource object. For more information, see [CreateOpenIDConnectProvider].
    public var clientIDList: [Swift.String]?
    /// The date and time when the IAM OIDC provider resource object was created in the Amazon Web Services account.
    public var createDate: Foundation.Date?
    /// A list of tags that are attached to the specified IAM OIDC provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?
    /// A list of certificate thumbprints that are associated with the specified IAM OIDC provider resource object. For more information, see [CreateOpenIDConnectProvider].
    public var thumbprintList: [Swift.String]?
    /// The URL that the IAM OIDC provider resource object is associated with. For more information, see [CreateOpenIDConnectProvider].
    public var url: Swift.String?

    public init(
        clientIDList: [Swift.String]? = nil,
        createDate: Foundation.Date? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        thumbprintList: [Swift.String]? = nil,
        url: Swift.String? = nil
    )
    {
        self.clientIDList = clientIDList
        self.createDate = createDate
        self.tags = tags
        self.thumbprintList = thumbprintList
        self.url = url
    }
}

extension IAMClientTypes {

    public enum SortKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lastAuthenticatedTimeAscending
        case lastAuthenticatedTimeDescending
        case serviceNamespaceAscending
        case serviceNamespaceDescending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortKeyType] {
            return [
                .lastAuthenticatedTimeAscending,
                .lastAuthenticatedTimeDescending,
                .serviceNamespaceAscending,
                .serviceNamespaceDescending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lastAuthenticatedTimeAscending: return "LAST_AUTHENTICATED_TIME_ASCENDING"
            case .lastAuthenticatedTimeDescending: return "LAST_AUTHENTICATED_TIME_DESCENDING"
            case .serviceNamespaceAscending: return "SERVICE_NAMESPACE_ASCENDING"
            case .serviceNamespaceDescending: return "SERVICE_NAMESPACE_DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetOrganizationsAccessReportInput {
    /// The identifier of the request generated by the [GenerateOrganizationsAccessReport] operation.
    /// This member is required.
    public var jobId: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The key that is used to sort the results. If you choose the namespace key, the results are returned in alphabetical order. If you choose the time key, the results are sorted numerically by the date and time.
    public var sortKey: IAMClientTypes.SortKeyType?

    public init(
        jobId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        sortKey: IAMClientTypes.SortKeyType? = nil
    )
    {
        self.jobId = jobId
        self.marker = marker
        self.maxItems = maxItems
        self.sortKey = sortKey
    }
}

extension IAMClientTypes {
    /// Contains information about the reason that the operation failed. This data type is used as a response element in the [GetOrganizationsAccessReport], [GetServiceLastAccessedDetails], and [GetServiceLastAccessedDetailsWithEntities] operations.
    public struct ErrorDetails {
        /// The error code associated with the operation failure.
        /// This member is required.
        public var code: Swift.String?
        /// Detailed information about the reason that the operation failed.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IAMClientTypes {

    public enum JobStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatusType] {
            return [
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetOrganizationsAccessReportOutput {
    /// An object that contains details about the most recent attempt to access the service.
    public var accessDetails: [IAMClientTypes.AccessDetail]?
    /// Contains information about the reason that the operation failed. This data type is used as a response element in the [GetOrganizationsAccessReport], [GetServiceLastAccessedDetails], and [GetServiceLastAccessedDetailsWithEntities] operations.
    public var errorDetails: IAMClientTypes.ErrorDetails?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the generated report job was completed or failed. This field is null if the job is still in progress, as indicated by a job status value of IN_PROGRESS.
    public var jobCompletionDate: Foundation.Date?
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the report job was created.
    /// This member is required.
    public var jobCreationDate: Foundation.Date?
    /// The status of the job.
    /// This member is required.
    public var jobStatus: IAMClientTypes.JobStatusType?
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The number of services that the applicable SCPs allow account principals to access.
    public var numberOfServicesAccessible: Swift.Int?
    /// The number of services that account principals are allowed but did not attempt to access.
    public var numberOfServicesNotAccessed: Swift.Int?

    public init(
        accessDetails: [IAMClientTypes.AccessDetail]? = nil,
        errorDetails: IAMClientTypes.ErrorDetails? = nil,
        isTruncated: Swift.Bool = false,
        jobCompletionDate: Foundation.Date? = nil,
        jobCreationDate: Foundation.Date? = nil,
        jobStatus: IAMClientTypes.JobStatusType? = nil,
        marker: Swift.String? = nil,
        numberOfServicesAccessible: Swift.Int? = nil,
        numberOfServicesNotAccessed: Swift.Int? = nil
    )
    {
        self.accessDetails = accessDetails
        self.errorDetails = errorDetails
        self.isTruncated = isTruncated
        self.jobCompletionDate = jobCompletionDate
        self.jobCreationDate = jobCreationDate
        self.jobStatus = jobStatus
        self.marker = marker
        self.numberOfServicesAccessible = numberOfServicesAccessible
        self.numberOfServicesNotAccessed = numberOfServicesNotAccessed
    }
}

public struct GetPolicyInput {
    /// The Amazon Resource Name (ARN) of the managed policy that you want information about. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        policyArn: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

/// Contains the response to a successful [GetPolicy] request.
public struct GetPolicyOutput {
    /// A structure containing details about the policy.
    public var policy: IAMClientTypes.Policy?

    public init(
        policy: IAMClientTypes.Policy? = nil
    )
    {
        self.policy = policy
    }
}

public struct GetPolicyVersionInput {
    /// The Amazon Resource Name (ARN) of the managed policy that you want information about. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// Identifies the policy version to retrieve. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consists of the lowercase letter 'v' followed by one or two digits, and optionally followed by a period '.' and a string of letters and digits.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.versionId = versionId
    }
}

/// Contains the response to a successful [GetPolicyVersion] request.
public struct GetPolicyVersionOutput {
    /// A structure containing details about the policy version.
    public var policyVersion: IAMClientTypes.PolicyVersion?

    public init(
        policyVersion: IAMClientTypes.PolicyVersion? = nil
    )
    {
        self.policyVersion = policyVersion
    }
}

public struct GetRoleInput {
    /// The name of the IAM role to get information about. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

/// Contains the response to a successful [GetRole] request.
public struct GetRoleOutput {
    /// A structure containing details about the IAM role.
    /// This member is required.
    public var role: IAMClientTypes.Role?

    public init(
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

public struct GetRolePolicyInput {
    /// The name of the policy document to get. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the role associated with the policy. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.roleName = roleName
    }
}

/// Contains the response to a successful [GetRolePolicy] request.
public struct GetRolePolicyOutput {
    /// The policy document. IAM stores policies in JSON format. However, resources that were created using CloudFormation templates can be formatted in YAML. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?
    /// The role the policy is associated with.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.roleName = roleName
    }
}

public struct GetSAMLProviderInput {
    /// The Amazon Resource Name (ARN) of the SAML provider resource object in IAM to get information about. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init(
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
    }
}

/// Contains the response to a successful [GetSAMLProvider] request.
public struct GetSAMLProviderOutput {
    /// The date and time when the SAML provider was created.
    public var createDate: Foundation.Date?
    /// The XML metadata document that includes information about an identity provider.
    public var samlMetadataDocument: Swift.String?
    /// A list of tags that are attached to the specified IAM SAML provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?
    /// The expiration date and time for the SAML provider.
    public var validUntil: Foundation.Date?

    public init(
        createDate: Foundation.Date? = nil,
        samlMetadataDocument: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        validUntil: Foundation.Date? = nil
    )
    {
        self.createDate = createDate
        self.samlMetadataDocument = samlMetadataDocument
        self.tags = tags
        self.validUntil = validUntil
    }
}

public struct GetServerCertificateInput {
    /// The name of the server certificate you want to retrieve information about. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init(
        serverCertificateName: Swift.String? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
    }
}

extension IAMClientTypes {
    /// Contains information about a server certificate without its certificate body, certificate chain, and private key. This data type is used as a response element in the [UploadServerCertificate] and [ListServerCertificates] operations.
    public struct ServerCertificateMetadata {
        /// The Amazon Resource Name (ARN) specifying the server certificate. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date on which the certificate is set to expire.
        public var expiration: Foundation.Date?
        /// The path to the server certificate. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?
        /// The stable and unique string identifying the server certificate. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var serverCertificateId: Swift.String?
        /// The name that identifies the server certificate.
        /// This member is required.
        public var serverCertificateName: Swift.String?
        /// The date when the server certificate was uploaded.
        public var uploadDate: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            expiration: Foundation.Date? = nil,
            path: Swift.String? = nil,
            serverCertificateId: Swift.String? = nil,
            serverCertificateName: Swift.String? = nil,
            uploadDate: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.expiration = expiration
            self.path = path
            self.serverCertificateId = serverCertificateId
            self.serverCertificateName = serverCertificateName
            self.uploadDate = uploadDate
        }
    }

}

extension IAMClientTypes {
    /// Contains information about a server certificate. This data type is used as a response element in the [GetServerCertificate] operation.
    public struct ServerCertificate {
        /// The contents of the public key certificate.
        /// This member is required.
        public var certificateBody: Swift.String?
        /// The contents of the public key certificate chain.
        public var certificateChain: Swift.String?
        /// The meta information of the server certificate, such as its name, path, ID, and ARN.
        /// This member is required.
        public var serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata?
        /// A list of tags that are attached to the server certificate. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init(
            certificateBody: Swift.String? = nil,
            certificateChain: Swift.String? = nil,
            serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.certificateBody = certificateBody
            self.certificateChain = certificateChain
            self.serverCertificateMetadata = serverCertificateMetadata
            self.tags = tags
        }
    }

}

/// Contains the response to a successful [GetServerCertificate] request.
public struct GetServerCertificateOutput {
    /// A structure containing details about the server certificate.
    /// This member is required.
    public var serverCertificate: IAMClientTypes.ServerCertificate?

    public init(
        serverCertificate: IAMClientTypes.ServerCertificate? = nil
    )
    {
        self.serverCertificate = serverCertificate
    }
}

public struct GetServiceLastAccessedDetailsInput {
    /// The ID of the request generated by the [GenerateServiceLastAccessedDetails] operation. The JobId returned by GenerateServiceLastAccessedDetail must be used by the same role within a session, or by the same user when used to call GetServiceLastAccessedDetail.
    /// This member is required.
    public var jobId: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        jobId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.jobId = jobId
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension IAMClientTypes {
    /// Contains details about the most recent attempt to access an action within the service. This data type is used as a response element in the [GetServiceLastAccessedDetails] operation.
    public struct TrackedActionLastAccessed {
        /// The name of the tracked action to which access was attempted. Tracked actions are actions that report activity to IAM.
        public var actionName: Swift.String?
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var lastAccessedEntity: Swift.String?
        /// The Region from which the authenticated entity (user or role) last attempted to access the tracked action. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAccessedRegion: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when an authenticated entity most recently attempted to access the tracked service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAccessedTime: Foundation.Date?

        public init(
            actionName: Swift.String? = nil,
            lastAccessedEntity: Swift.String? = nil,
            lastAccessedRegion: Swift.String? = nil,
            lastAccessedTime: Foundation.Date? = nil
        )
        {
            self.actionName = actionName
            self.lastAccessedEntity = lastAccessedEntity
            self.lastAccessedRegion = lastAccessedRegion
            self.lastAccessedTime = lastAccessedTime
        }
    }

}

extension IAMClientTypes {
    /// Contains details about the most recent attempt to access the service. This data type is used as a response element in the [GetServiceLastAccessedDetails] operation.
    public struct ServiceLastAccessed {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when an authenticated entity most recently attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticated: Foundation.Date?
        /// The ARN of the authenticated entity (user or role) that last attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticatedEntity: Swift.String?
        /// The Region from which the authenticated entity (user or role) last attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticatedRegion: Swift.String?
        /// The name of the service in which access was attempted.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The namespace of the service in which access was attempted. To learn the service namespace of a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the Service Authorization Reference. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services Service Namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
        /// This member is required.
        public var serviceNamespace: Swift.String?
        /// The total number of authenticated principals (root user, IAM users, or IAM roles) that have attempted to access the service. This field is null if no principals attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var totalAuthenticatedEntities: Swift.Int?
        /// An object that contains details about the most recent attempt to access a tracked action within the service. This field is null if there no tracked actions or if the principal did not use the tracked actions within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period). This field is also null if the report was generated at the service level and not the action level. For more information, see the Granularity field in [GenerateServiceLastAccessedDetails].
        public var trackedActionsLastAccessed: [IAMClientTypes.TrackedActionLastAccessed]?

        public init(
            lastAuthenticated: Foundation.Date? = nil,
            lastAuthenticatedEntity: Swift.String? = nil,
            lastAuthenticatedRegion: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceNamespace: Swift.String? = nil,
            totalAuthenticatedEntities: Swift.Int? = nil,
            trackedActionsLastAccessed: [IAMClientTypes.TrackedActionLastAccessed]? = nil
        )
        {
            self.lastAuthenticated = lastAuthenticated
            self.lastAuthenticatedEntity = lastAuthenticatedEntity
            self.lastAuthenticatedRegion = lastAuthenticatedRegion
            self.serviceName = serviceName
            self.serviceNamespace = serviceNamespace
            self.totalAuthenticatedEntities = totalAuthenticatedEntities
            self.trackedActionsLastAccessed = trackedActionsLastAccessed
        }
    }

}

public struct GetServiceLastAccessedDetailsOutput {
    /// An object that contains details about the reason the operation failed.
    public var error: IAMClientTypes.ErrorDetails?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the generated report job was completed or failed. This field is null if the job is still in progress, as indicated by a job status value of IN_PROGRESS.
    /// This member is required.
    public var jobCompletionDate: Foundation.Date?
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the report job was created.
    /// This member is required.
    public var jobCreationDate: Foundation.Date?
    /// The status of the job.
    /// This member is required.
    public var jobStatus: IAMClientTypes.JobStatusType?
    /// The type of job. Service jobs return information about when each service was last accessed. Action jobs also include information about when tracked actions within the service were last accessed.
    public var jobType: IAMClientTypes.AccessAdvisorUsageGranularityType?
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A ServiceLastAccessed object that contains details about the most recent attempt to access the service.
    /// This member is required.
    public var servicesLastAccessed: [IAMClientTypes.ServiceLastAccessed]?

    public init(
        error: IAMClientTypes.ErrorDetails? = nil,
        isTruncated: Swift.Bool = false,
        jobCompletionDate: Foundation.Date? = nil,
        jobCreationDate: Foundation.Date? = nil,
        jobStatus: IAMClientTypes.JobStatusType? = nil,
        jobType: IAMClientTypes.AccessAdvisorUsageGranularityType? = nil,
        marker: Swift.String? = nil,
        servicesLastAccessed: [IAMClientTypes.ServiceLastAccessed]? = nil
    )
    {
        self.error = error
        self.isTruncated = isTruncated
        self.jobCompletionDate = jobCompletionDate
        self.jobCreationDate = jobCreationDate
        self.jobStatus = jobStatus
        self.jobType = jobType
        self.marker = marker
        self.servicesLastAccessed = servicesLastAccessed
    }
}

public struct GetServiceLastAccessedDetailsWithEntitiesInput {
    /// The ID of the request generated by the GenerateServiceLastAccessedDetails operation.
    /// This member is required.
    public var jobId: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The service namespace for an Amazon Web Services service. Provide the service namespace to learn when the IAM entity last attempted to access the specified service. To learn the service namespace for a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the IAM User Guide. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
    /// This member is required.
    public var serviceNamespace: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        serviceNamespace: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.marker = marker
        self.maxItems = maxItems
        self.serviceNamespace = serviceNamespace
    }
}

extension IAMClientTypes {

    public enum PolicyOwnerEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case group
        case role
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyOwnerEntityType] {
            return [
                .group,
                .role,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .role: return "ROLE"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IAMClientTypes {
    /// Contains details about the specified entity (user or role). This data type is an element of the [EntityDetails] object.
    public struct EntityInfo {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        /// This member is required.
        public var arn: Swift.String?
        /// The identifier of the entity (user or role).
        /// This member is required.
        public var id: Swift.String?
        /// The name of the entity (user or role).
        /// This member is required.
        public var name: Swift.String?
        /// The path to the entity (user or role). For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The type of entity (user or role).
        /// This member is required.
        public var type: IAMClientTypes.PolicyOwnerEntityType?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            type: IAMClientTypes.PolicyOwnerEntityType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
            self.path = path
            self.type = type
        }
    }

}

extension IAMClientTypes {
    /// An object that contains details about when the IAM entities (users or roles) were last used in an attempt to access the specified Amazon Web Services service. This data type is a response element in the [GetServiceLastAccessedDetailsWithEntities] operation.
    public struct EntityDetails {
        /// The EntityInfo object that contains details about the entity (user or role).
        /// This member is required.
        public var entityInfo: IAMClientTypes.EntityInfo?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the authenticated entity last attempted to access Amazon Web Services. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticated: Foundation.Date?

        public init(
            entityInfo: IAMClientTypes.EntityInfo? = nil,
            lastAuthenticated: Foundation.Date? = nil
        )
        {
            self.entityInfo = entityInfo
            self.lastAuthenticated = lastAuthenticated
        }
    }

}

public struct GetServiceLastAccessedDetailsWithEntitiesOutput {
    /// An EntityDetailsList object that contains details about when an IAM entity (user or role) used group or policy permissions in an attempt to access the specified Amazon Web Services service.
    /// This member is required.
    public var entityDetailsList: [IAMClientTypes.EntityDetails]?
    /// An object that contains details about the reason the operation failed.
    public var error: IAMClientTypes.ErrorDetails?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the generated report job was completed or failed. This field is null if the job is still in progress, as indicated by a job status value of IN_PROGRESS.
    /// This member is required.
    public var jobCompletionDate: Foundation.Date?
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the report job was created.
    /// This member is required.
    public var jobCreationDate: Foundation.Date?
    /// The status of the job.
    /// This member is required.
    public var jobStatus: IAMClientTypes.JobStatusType?
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        entityDetailsList: [IAMClientTypes.EntityDetails]? = nil,
        error: IAMClientTypes.ErrorDetails? = nil,
        isTruncated: Swift.Bool = false,
        jobCompletionDate: Foundation.Date? = nil,
        jobCreationDate: Foundation.Date? = nil,
        jobStatus: IAMClientTypes.JobStatusType? = nil,
        marker: Swift.String? = nil
    )
    {
        self.entityDetailsList = entityDetailsList
        self.error = error
        self.isTruncated = isTruncated
        self.jobCompletionDate = jobCompletionDate
        self.jobCreationDate = jobCreationDate
        self.jobStatus = jobStatus
        self.marker = marker
    }
}

public struct GetServiceLinkedRoleDeletionStatusInput {
    /// The deletion task identifier. This identifier is returned by the [DeleteServiceLinkedRole] operation in the format task/aws-service-role///.
    /// This member is required.
    public var deletionTaskId: Swift.String?

    public init(
        deletionTaskId: Swift.String? = nil
    )
    {
        self.deletionTaskId = deletionTaskId
    }
}

extension IAMClientTypes {
    /// An object that contains details about how a service-linked role is used, if that information is returned by the service. This data type is used as a response element in the [GetServiceLinkedRoleDeletionStatus] operation.
    public struct RoleUsageType {
        /// The name of the Region where the service-linked role is being used.
        public var region: Swift.String?
        /// The name of the resource that is using the service-linked role.
        public var resources: [Swift.String]?

        public init(
            region: Swift.String? = nil,
            resources: [Swift.String]? = nil
        )
        {
            self.region = region
            self.resources = resources
        }
    }

}

extension IAMClientTypes {
    /// The reason that the service-linked role deletion failed. This data type is used as a response element in the [GetServiceLinkedRoleDeletionStatus] operation.
    public struct DeletionTaskFailureReasonType {
        /// A short description of the reason that the service-linked role deletion failed.
        public var reason: Swift.String?
        /// A list of objects that contains details about the service-linked role deletion failure, if that information is returned by the service. If the service-linked role has active sessions or if any resources that were used by the role have not been deleted from the linked service, the role can't be deleted. This parameter includes a list of the resources that are associated with the role and the Region in which the resources are being used.
        public var roleUsageList: [IAMClientTypes.RoleUsageType]?

        public init(
            reason: Swift.String? = nil,
            roleUsageList: [IAMClientTypes.RoleUsageType]? = nil
        )
        {
            self.reason = reason
            self.roleUsageList = roleUsageList
        }
    }

}

extension IAMClientTypes {

    public enum DeletionTaskStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case notStarted
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeletionTaskStatusType] {
            return [
                .failed,
                .inProgress,
                .notStarted,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetServiceLinkedRoleDeletionStatusOutput {
    /// An object that contains details about the reason the deletion failed.
    public var reason: IAMClientTypes.DeletionTaskFailureReasonType?
    /// The status of the deletion.
    /// This member is required.
    public var status: IAMClientTypes.DeletionTaskStatusType?

    public init(
        reason: IAMClientTypes.DeletionTaskFailureReasonType? = nil,
        status: IAMClientTypes.DeletionTaskStatusType? = nil
    )
    {
        self.reason = reason
        self.status = status
    }
}

/// The request was rejected because the public key encoding format is unsupported or unrecognized.
public struct UnrecognizedPublicKeyEncodingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnrecognizedPublicKeyEncoding" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IAMClientTypes {

    public enum EncodingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pem
        case ssh
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingType] {
            return [
                .pem,
                .ssh
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pem: return "PEM"
            case .ssh: return "SSH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSSHPublicKeyInput {
    /// Specifies the public key encoding format to use in the response. To retrieve the public key in ssh-rsa format, use SSH. To retrieve the public key in PEM format, use PEM.
    /// This member is required.
    public var encoding: IAMClientTypes.EncodingType?
    /// The unique identifier for the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// The name of the IAM user associated with the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        encoding: IAMClientTypes.EncodingType? = nil,
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.encoding = encoding
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

extension IAMClientTypes {
    /// Contains information about an SSH public key. This data type is used as a response element in the [GetSSHPublicKey] and [UploadSSHPublicKey] operations.
    public struct SSHPublicKey {
        /// The MD5 message digest of the SSH public key.
        /// This member is required.
        public var fingerprint: Swift.String?
        /// The SSH public key.
        /// This member is required.
        public var sshPublicKeyBody: Swift.String?
        /// The unique identifier for the SSH public key.
        /// This member is required.
        public var sshPublicKeyId: Swift.String?
        /// The status of the SSH public key. Active means that the key can be used for authentication with an CodeCommit repository. Inactive means that the key cannot be used.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the SSH public key was uploaded.
        public var uploadDate: Foundation.Date?
        /// The name of the IAM user associated with the SSH public key.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            fingerprint: Swift.String? = nil,
            sshPublicKeyBody: Swift.String? = nil,
            sshPublicKeyId: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            uploadDate: Foundation.Date? = nil,
            userName: Swift.String? = nil
        )
        {
            self.fingerprint = fingerprint
            self.sshPublicKeyBody = sshPublicKeyBody
            self.sshPublicKeyId = sshPublicKeyId
            self.status = status
            self.uploadDate = uploadDate
            self.userName = userName
        }
    }

}

/// Contains the response to a successful [GetSSHPublicKey] request.
public struct GetSSHPublicKeyOutput {
    /// A structure containing details about the SSH public key.
    public var sshPublicKey: IAMClientTypes.SSHPublicKey?

    public init(
        sshPublicKey: IAMClientTypes.SSHPublicKey? = nil
    )
    {
        self.sshPublicKey = sshPublicKey
    }
}

public struct GetUserInput {
    /// The name of the user to get information about. This parameter is optional. If it is not included, it defaults to the user making the request. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

/// Contains the response to a successful [GetUser] request.
public struct GetUserOutput {
    /// A structure containing details about the IAM user. Due to a service issue, password last used data does not include password use from May 3, 2018 22:50 PDT to May 23, 2018 14:08 PDT. This affects [last sign-in](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_finding-unused.html) dates shown in the IAM console and password last used dates in the [IAM credential report](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_getting-report.html), and returned by this operation. If users signed in during the affected time, the password last used date that is returned is the date the user last signed in before May 3, 2018. For users that signed in after May 23, 2018 14:08 PDT, the returned password last used date is accurate. You can use password last used information to identify unused credentials for deletion. For example, you might delete users who did not sign in to Amazon Web Services in the last 90 days. In cases like this, we recommend that you adjust your evaluation window to include dates after May 23, 2018. Alternatively, if your users use access keys to access Amazon Web Services programmatically you can refer to access key last used information because it is accurate for all dates.
    /// This member is required.
    public var user: IAMClientTypes.User?

    public init(
        user: IAMClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

public struct GetUserPolicyInput {
    /// The name of the policy document to get. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the user who the policy is associated with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.userName = userName
    }
}

/// Contains the response to a successful [GetUserPolicy] request.
public struct GetUserPolicyOutput {
    /// The policy document. IAM stores policies in JSON format. However, resources that were created using CloudFormation templates can be formatted in YAML. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?
    /// The user the policy is associated with.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.userName = userName
    }
}

public struct ListAccessKeysInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

/// Contains the response to a successful [ListAccessKeys] request.
public struct ListAccessKeysOutput {
    /// A list of objects containing metadata about the access keys.
    /// This member is required.
    public var accessKeyMetadata: [IAMClientTypes.AccessKeyMetadata]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        accessKeyMetadata: [IAMClientTypes.AccessKeyMetadata]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.accessKeyMetadata = accessKeyMetadata
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

public struct ListAccountAliasesInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

/// Contains the response to a successful [ListAccountAliases] request.
public struct ListAccountAliasesOutput {
    /// A list of aliases associated with the account. Amazon Web Services supports only one alias per account.
    /// This member is required.
    public var accountAliases: [Swift.String]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        accountAliases: [Swift.String]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.accountAliases = accountAliases
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

public struct ListAttachedGroupPoliciesInput {
    /// The name (friendly name, not ARN) of the group to list attached policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

/// Contains the response to a successful [ListAttachedGroupPolicies] request.
public struct ListAttachedGroupPoliciesOutput {
    /// A list of the attached policies.
    public var attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        attachedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.attachedPolicies = attachedPolicies
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

public struct ListAttachedRolePoliciesInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The name (friendly name, not ARN) of the role to list attached policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
        self.roleName = roleName
    }
}

/// Contains the response to a successful [ListAttachedRolePolicies] request.
public struct ListAttachedRolePoliciesOutput {
    /// A list of the attached policies.
    public var attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        attachedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.attachedPolicies = attachedPolicies
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

public struct ListAttachedUserPoliciesInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The name (friendly name, not ARN) of the user to list attached policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
        self.userName = userName
    }
}

/// Contains the response to a successful [ListAttachedUserPolicies] request.
public struct ListAttachedUserPoliciesOutput {
    /// A list of the attached policies.
    public var attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        attachedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.attachedPolicies = attachedPolicies
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

extension IAMClientTypes {

    /// The policy usage type that indicates whether the policy is used as a permissions policy or as the permissions boundary for an entity. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
    public enum PolicyUsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case permissionsboundary
        case permissionspolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyUsageType] {
            return [
                .permissionsboundary,
                .permissionspolicy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .permissionsboundary: return "PermissionsBoundary"
            case .permissionspolicy: return "PermissionsPolicy"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListEntitiesForPolicyInput {
    /// The entity type to use for filtering the results. For example, when EntityFilter is Role, only the roles that are attached to the specified policy are returned. This parameter is optional. If it is not included, all attached entities (users, groups, and roles) are returned. The argument for this parameter must be one of the valid values listed below.
    public var entityFilter: IAMClientTypes.EntityType?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all entities. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM policy for which you want the versions. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The policy usage method to use for filtering the results. To list only permissions policies, set PolicyUsageFilter to PermissionsPolicy. To list only the policies used to set permissions boundaries, set the value to PermissionsBoundary. This parameter is optional. If it is not included, all policies are returned.
    public var policyUsageFilter: IAMClientTypes.PolicyUsageType?

    public init(
        entityFilter: IAMClientTypes.EntityType? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        policyUsageFilter: IAMClientTypes.PolicyUsageType? = nil
    )
    {
        self.entityFilter = entityFilter
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
        self.policyArn = policyArn
        self.policyUsageFilter = policyUsageFilter
    }
}

extension IAMClientTypes {
    /// Contains information about a group that a managed policy is attached to. This data type is used as a response element in the [ListEntitiesForPolicy] operation. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyGroup {
        /// The stable and unique string identifying the group. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        public var groupId: Swift.String?
        /// The name (friendly name, not ARN) identifying the group.
        public var groupName: Swift.String?

        public init(
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }

}

extension IAMClientTypes {
    /// Contains information about a role that a managed policy is attached to. This data type is used as a response element in the [ListEntitiesForPolicy] operation. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyRole {
        /// The stable and unique string identifying the role. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        public var roleId: Swift.String?
        /// The name (friendly name, not ARN) identifying the role.
        public var roleName: Swift.String?

        public init(
            roleId: Swift.String? = nil,
            roleName: Swift.String? = nil
        )
        {
            self.roleId = roleId
            self.roleName = roleName
        }
    }

}

extension IAMClientTypes {
    /// Contains information about a user that a managed policy is attached to. This data type is used as a response element in the [ListEntitiesForPolicy] operation. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyUser {
        /// The stable and unique string identifying the user. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        public var userId: Swift.String?
        /// The name (friendly name, not ARN) identifying the user.
        public var userName: Swift.String?

        public init(
            userId: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.userId = userId
            self.userName = userName
        }
    }

}

/// Contains the response to a successful [ListEntitiesForPolicy] request.
public struct ListEntitiesForPolicyOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of IAM groups that the policy is attached to.
    public var policyGroups: [IAMClientTypes.PolicyGroup]?
    /// A list of IAM roles that the policy is attached to.
    public var policyRoles: [IAMClientTypes.PolicyRole]?
    /// A list of IAM users that the policy is attached to.
    public var policyUsers: [IAMClientTypes.PolicyUser]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyGroups: [IAMClientTypes.PolicyGroup]? = nil,
        policyRoles: [IAMClientTypes.PolicyRole]? = nil,
        policyUsers: [IAMClientTypes.PolicyUser]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyGroups = policyGroups
        self.policyRoles = policyRoles
        self.policyUsers = policyUsers
    }
}

public struct ListGroupPoliciesInput {
    /// The name of the group to list policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        groupName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.groupName = groupName
        self.marker = marker
        self.maxItems = maxItems
    }
}

/// Contains the response to a successful [ListGroupPolicies] request.
public struct ListGroupPoliciesOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy names. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyNames = policyNames
    }
}

public struct ListGroupsInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example, the prefix /division_abc/subdivision_xyz/ gets all groups whose path starts with /division_abc/subdivision_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all groups. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

/// Contains the response to a successful [ListGroups] request.
public struct ListGroupsOutput {
    /// A list of groups.
    /// This member is required.
    public var groups: [IAMClientTypes.Group]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        groups: [IAMClientTypes.Group]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.groups = groups
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

public struct ListGroupsForUserInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user to list groups for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

/// Contains the response to a successful [ListGroupsForUser] request.
public struct ListGroupsForUserOutput {
    /// A list of groups.
    /// This member is required.
    public var groups: [IAMClientTypes.Group]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        groups: [IAMClientTypes.Group]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.groups = groups
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

public struct ListInstanceProfilesInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example, the prefix /application_abc/component_xyz/ gets all instance profiles whose path starts with /application_abc/component_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all instance profiles. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

/// Contains the response to a successful [ListInstanceProfiles] request.
public struct ListInstanceProfilesOutput {
    /// A list of instance profiles.
    /// This member is required.
    public var instanceProfiles: [IAMClientTypes.InstanceProfile]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        instanceProfiles: [IAMClientTypes.InstanceProfile]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

public struct ListInstanceProfilesForRoleInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the role to list instance profiles for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.roleName = roleName
    }
}

/// Contains the response to a successful [ListInstanceProfilesForRole] request.
public struct ListInstanceProfilesForRoleOutput {
    /// A list of instance profiles.
    /// This member is required.
    public var instanceProfiles: [IAMClientTypes.InstanceProfile]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        instanceProfiles: [IAMClientTypes.InstanceProfile]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

public struct ListInstanceProfileTagsInput {
    /// The name of the IAM instance profile whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        instanceProfileName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.marker = marker
        self.maxItems = maxItems
    }
}

public struct ListInstanceProfileTagsOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the IAM instance profile. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

public struct ListMFADevicesInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user whose MFA devices you want to list. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension IAMClientTypes {
    /// Contains information about an MFA device. This data type is used as a response element in the [ListMFADevices] operation.
    public struct MFADevice {
        /// The date when the MFA device was enabled for the user.
        /// This member is required.
        public var enableDate: Foundation.Date?
        /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN.
        /// This member is required.
        public var serialNumber: Swift.String?
        /// The user with whom the MFA device is associated.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            enableDate: Foundation.Date? = nil,
            serialNumber: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.enableDate = enableDate
            self.serialNumber = serialNumber
            self.userName = userName
        }
    }

}

/// Contains the response to a successful [ListMFADevices] request.
public struct ListMFADevicesOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of MFA devices.
    /// This member is required.
    public var mfaDevices: [IAMClientTypes.MFADevice]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        mfaDevices: [IAMClientTypes.MFADevice]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.mfaDevices = mfaDevices
    }
}

public struct ListMFADeviceTagsInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The unique identifier for the IAM virtual MFA device whose tags you want to see. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        serialNumber: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.serialNumber = serialNumber
    }
}

public struct ListMFADeviceTagsOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the virtual MFA device. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

public struct ListOpenIDConnectProvidersInput {

    public init() { }
}

extension IAMClientTypes {
    /// Contains the Amazon Resource Name (ARN) for an IAM OpenID Connect provider.
    public struct OpenIDConnectProviderListEntry {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

/// Contains the response to a successful [ListOpenIDConnectProviders] request.
public struct ListOpenIDConnectProvidersOutput {
    /// The list of IAM OIDC provider resource objects defined in the Amazon Web Services account.
    public var openIDConnectProviderList: [IAMClientTypes.OpenIDConnectProviderListEntry]?

    public init(
        openIDConnectProviderList: [IAMClientTypes.OpenIDConnectProviderListEntry]? = nil
    )
    {
        self.openIDConnectProviderList = openIDConnectProviderList
    }
}

public struct ListOpenIDConnectProviderTagsInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The ARN of the OpenID Connect (OIDC) identity provider whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

public struct ListOpenIDConnectProviderTagsOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the OpenID Connect (OIDC) identity provider. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

extension IAMClientTypes {

    public enum PolicyScopeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aws
        case all
        case local
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyScopeType] {
            return [
                .aws,
                .all,
                .local
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .all: return "All"
            case .local: return "Local"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListPoliciesInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// A flag to filter the results to only the attached policies. When OnlyAttached is true, the returned list contains only the policies that are attached to an IAM user, group, or role. When OnlyAttached is false, or when the parameter is not included, all policies are returned.
    public var onlyAttached: Swift.Bool?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The policy usage method to use for filtering the results. To list only permissions policies, set PolicyUsageFilter to PermissionsPolicy. To list only the policies used to set permissions boundaries, set the value to PermissionsBoundary. This parameter is optional. If it is not included, all policies are returned.
    public var policyUsageFilter: IAMClientTypes.PolicyUsageType?
    /// The scope to use for filtering the results. To list only Amazon Web Services managed policies, set Scope to AWS. To list only the customer managed policies in your Amazon Web Services account, set Scope to Local. This parameter is optional. If it is not included, or if it is set to All, all policies are returned.
    public var scope: IAMClientTypes.PolicyScopeType?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        onlyAttached: Swift.Bool? = false,
        pathPrefix: Swift.String? = nil,
        policyUsageFilter: IAMClientTypes.PolicyUsageType? = nil,
        scope: IAMClientTypes.PolicyScopeType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.onlyAttached = onlyAttached
        self.pathPrefix = pathPrefix
        self.policyUsageFilter = policyUsageFilter
        self.scope = scope
    }
}

/// Contains the response to a successful [ListPolicies] request.
public struct ListPoliciesOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policies.
    public var policies: [IAMClientTypes.Policy]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policies: [IAMClientTypes.Policy]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policies = policies
    }
}

public struct ListPoliciesGrantingServiceAccessInput {
    /// The ARN of the IAM identity (user, group, or role) whose policies you want to list.
    /// This member is required.
    public var arn: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// The service namespace for the Amazon Web Services services whose policies you want to list. To learn the service namespace for a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the IAM User Guide. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
    /// This member is required.
    public var serviceNamespaces: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        marker: Swift.String? = nil,
        serviceNamespaces: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.marker = marker
        self.serviceNamespaces = serviceNamespaces
    }
}

extension IAMClientTypes {

    public enum PolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case inline
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyType] {
            return [
                .inline,
                .managed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .inline: return "INLINE"
            case .managed: return "MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IAMClientTypes {
    /// Contains details about the permissions policies that are attached to the specified identity (user, group, or role). This data type is an element of the [ListPoliciesGrantingServiceAccessEntry] object.
    public struct PolicyGrantingServiceAccess {
        /// The name of the entity (user or role) to which the inline policy is attached. This field is null for managed policies. For more information about these policy types, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html) in the IAM User Guide.
        public var entityName: Swift.String?
        /// The type of entity (user or role) that used the policy to access the service to which the inline policy is attached. This field is null for managed policies. For more information about these policy types, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html) in the IAM User Guide.
        public var entityType: IAMClientTypes.PolicyOwnerEntityType?
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var policyArn: Swift.String?
        /// The policy name.
        /// This member is required.
        public var policyName: Swift.String?
        /// The policy type. For more information about these policy types, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html) in the IAM User Guide.
        /// This member is required.
        public var policyType: IAMClientTypes.PolicyType?

        public init(
            entityName: Swift.String? = nil,
            entityType: IAMClientTypes.PolicyOwnerEntityType? = nil,
            policyArn: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyType: IAMClientTypes.PolicyType? = nil
        )
        {
            self.entityName = entityName
            self.entityType = entityType
            self.policyArn = policyArn
            self.policyName = policyName
            self.policyType = policyType
        }
    }

}

extension IAMClientTypes {
    /// Contains details about the permissions policies that are attached to the specified identity (user, group, or role). This data type is used as a response element in the [ListPoliciesGrantingServiceAccess] operation.
    public struct ListPoliciesGrantingServiceAccessEntry {
        /// The PoliciesGrantingServiceAccess object that contains details about the policy.
        public var policies: [IAMClientTypes.PolicyGrantingServiceAccess]?
        /// The namespace of the service that was accessed. To learn the service namespace of a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the Service Authorization Reference. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
        public var serviceNamespace: Swift.String?

        public init(
            policies: [IAMClientTypes.PolicyGrantingServiceAccess]? = nil,
            serviceNamespace: Swift.String? = nil
        )
        {
            self.policies = policies
            self.serviceNamespace = serviceNamespace
        }
    }

}

public struct ListPoliciesGrantingServiceAccessOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A ListPoliciesGrantingServiceAccess object that contains details about the permissions policies attached to the specified identity (user, group, or role).
    /// This member is required.
    public var policiesGrantingServiceAccess: [IAMClientTypes.ListPoliciesGrantingServiceAccessEntry]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policiesGrantingServiceAccess: [IAMClientTypes.ListPoliciesGrantingServiceAccessEntry]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policiesGrantingServiceAccess = policiesGrantingServiceAccess
    }
}

public struct ListPolicyTagsInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The ARN of the IAM customer managed policy whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.policyArn = policyArn
    }
}

public struct ListPolicyTagsOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the IAM customer managed policy. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

public struct ListPolicyVersionsInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The Amazon Resource Name (ARN) of the IAM policy for which you want the versions. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.policyArn = policyArn
    }
}

/// Contains the response to a successful [ListPolicyVersions] request.
public struct ListPolicyVersionsOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy versions. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    public var versions: [IAMClientTypes.PolicyVersion]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        versions: [IAMClientTypes.PolicyVersion]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.versions = versions
    }
}

public struct ListRolePoliciesInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the role to list policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.roleName = roleName
    }
}

/// Contains the response to a successful [ListRolePolicies] request.
public struct ListRolePoliciesOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy names.
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyNames = policyNames
    }
}

public struct ListRolesInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example, the prefix /application_abc/component_xyz/ gets all roles whose path starts with /application_abc/component_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all roles. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

/// Contains the response to a successful [ListRoles] request.
public struct ListRolesOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of roles.
    /// This member is required.
    public var roles: [IAMClientTypes.Role]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        roles: [IAMClientTypes.Role]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.roles = roles
    }
}

public struct ListRoleTagsInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM role for which you want to see the list of tags. This parameter accepts (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.roleName = roleName
    }
}

public struct ListRoleTagsOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the role. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

public struct ListSAMLProvidersInput {

    public init() { }
}

extension IAMClientTypes {
    /// Contains the list of SAML providers for this account.
    public struct SAMLProviderListEntry {
        /// The Amazon Resource Name (ARN) of the SAML provider.
        public var arn: Swift.String?
        /// The date and time when the SAML provider was created.
        public var createDate: Foundation.Date?
        /// The expiration date and time for the SAML provider.
        public var validUntil: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createDate: Foundation.Date? = nil,
            validUntil: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.validUntil = validUntil
        }
    }

}

/// Contains the response to a successful [ListSAMLProviders] request.
public struct ListSAMLProvidersOutput {
    /// The list of SAML provider resource objects defined in IAM for this Amazon Web Services account.
    public var samlProviderList: [IAMClientTypes.SAMLProviderListEntry]?

    public init(
        samlProviderList: [IAMClientTypes.SAMLProviderListEntry]? = nil
    )
    {
        self.samlProviderList = samlProviderList
    }
}

public struct ListSAMLProviderTagsInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The ARN of the Security Assertion Markup Language (SAML) identity provider whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        samlProviderArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.samlProviderArn = samlProviderArn
    }
}

public struct ListSAMLProviderTagsOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the Security Assertion Markup Language (SAML) identity provider. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

public struct ListServerCertificatesInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example: /company/servercerts would get all server certificates for which the path starts with /company/servercerts. This parameter is optional. If it is not included, it defaults to a slash (/), listing all server certificates. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

/// Contains the response to a successful [ListServerCertificates] request.
public struct ListServerCertificatesOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of server certificates.
    /// This member is required.
    public var serverCertificateMetadataList: [IAMClientTypes.ServerCertificateMetadata]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        serverCertificateMetadataList: [IAMClientTypes.ServerCertificateMetadata]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.serverCertificateMetadataList = serverCertificateMetadataList
    }
}

public struct ListServerCertificateTagsInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM server certificate whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        serverCertificateName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.serverCertificateName = serverCertificateName
    }
}

public struct ListServerCertificateTagsOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the IAM server certificate. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

public struct ListServiceSpecificCredentialsInput {
    /// Filters the returned results to only those for the specified Amazon Web Services service. If not specified, then Amazon Web Services returns service-specific credentials for all services.
    public var serviceName: Swift.String?
    /// The name of the user whose service-specific credentials you want information about. If this value is not specified, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        serviceName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceName = serviceName
        self.userName = userName
    }
}

extension IAMClientTypes {
    /// Contains additional details about a service-specific credential.
    public struct ServiceSpecificCredentialMetadata {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the service-specific credential were created.
        /// This member is required.
        public var createDate: Foundation.Date?
        /// The name of the service associated with the service-specific credential.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The unique identifier for the service-specific credential.
        /// This member is required.
        public var serviceSpecificCredentialId: Swift.String?
        /// The generated user name for the service-specific credential.
        /// This member is required.
        public var serviceUserName: Swift.String?
        /// The status of the service-specific credential. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user associated with the service-specific credential.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            createDate: Foundation.Date? = nil,
            serviceName: Swift.String? = nil,
            serviceSpecificCredentialId: Swift.String? = nil,
            serviceUserName: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.serviceName = serviceName
            self.serviceSpecificCredentialId = serviceSpecificCredentialId
            self.serviceUserName = serviceUserName
            self.status = status
            self.userName = userName
        }
    }

}

public struct ListServiceSpecificCredentialsOutput {
    /// A list of structures that each contain details about a service-specific credential.
    public var serviceSpecificCredentials: [IAMClientTypes.ServiceSpecificCredentialMetadata]?

    public init(
        serviceSpecificCredentials: [IAMClientTypes.ServiceSpecificCredentialMetadata]? = nil
    )
    {
        self.serviceSpecificCredentials = serviceSpecificCredentials
    }
}

public struct ListSigningCertificatesInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM user whose signing certificates you want to examine. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension IAMClientTypes {
    /// Contains information about an X.509 signing certificate. This data type is used as a response element in the [UploadSigningCertificate] and [ListSigningCertificates] operations.
    public struct SigningCertificate {
        /// The contents of the signing certificate.
        /// This member is required.
        public var certificateBody: Swift.String?
        /// The ID for the signing certificate.
        /// This member is required.
        public var certificateId: Swift.String?
        /// The status of the signing certificate. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The date when the signing certificate was uploaded.
        public var uploadDate: Foundation.Date?
        /// The name of the user the signing certificate is associated with.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            certificateBody: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            uploadDate: Foundation.Date? = nil,
            userName: Swift.String? = nil
        )
        {
            self.certificateBody = certificateBody
            self.certificateId = certificateId
            self.status = status
            self.uploadDate = uploadDate
            self.userName = userName
        }
    }

}

/// Contains the response to a successful [ListSigningCertificates] request.
public struct ListSigningCertificatesOutput {
    /// A list of the user's signing certificate information.
    /// This member is required.
    public var certificates: [IAMClientTypes.SigningCertificate]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        certificates: [IAMClientTypes.SigningCertificate]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

public struct ListSSHPublicKeysInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM user to list SSH public keys for. If none is specified, the UserName field is determined implicitly based on the Amazon Web Services access key used to sign the request. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension IAMClientTypes {
    /// Contains information about an SSH public key, without the key's body or fingerprint. This data type is used as a response element in the [ListSSHPublicKeys] operation.
    public struct SSHPublicKeyMetadata {
        /// The unique identifier for the SSH public key.
        /// This member is required.
        public var sshPublicKeyId: Swift.String?
        /// The status of the SSH public key. Active means that the key can be used for authentication with an CodeCommit repository. Inactive means that the key cannot be used.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the SSH public key was uploaded.
        /// This member is required.
        public var uploadDate: Foundation.Date?
        /// The name of the IAM user associated with the SSH public key.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            sshPublicKeyId: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            uploadDate: Foundation.Date? = nil,
            userName: Swift.String? = nil
        )
        {
            self.sshPublicKeyId = sshPublicKeyId
            self.status = status
            self.uploadDate = uploadDate
            self.userName = userName
        }
    }

}

/// Contains the response to a successful [ListSSHPublicKeys] request.
public struct ListSSHPublicKeysOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of the SSH public keys assigned to IAM user.
    public var sshPublicKeys: [IAMClientTypes.SSHPublicKeyMetadata]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        sshPublicKeys: [IAMClientTypes.SSHPublicKeyMetadata]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.sshPublicKeys = sshPublicKeys
    }
}

public struct ListUserPoliciesInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user to list policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

/// Contains the response to a successful [ListUserPolicies] request.
public struct ListUserPoliciesOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy names.
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyNames = policyNames
    }
}

public struct ListUsersInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example: /division_abc/subdivision_xyz/, which would get all user names whose path starts with /division_abc/subdivision_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all user names. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

/// Contains the response to a successful [ListUsers] request.
public struct ListUsersOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of users.
    /// This member is required.
    public var users: [IAMClientTypes.User]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        users: [IAMClientTypes.User]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.users = users
    }
}

public struct ListUserTagsInput {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM user whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

public struct ListUserTagsOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the user. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

public struct ListVirtualMFADevicesInput {
    /// The status (Unassigned or Assigned) of the devices to list. If you do not specify an AssignmentStatus, the operation defaults to Any, which lists both assigned and unassigned virtual MFA devices.,
    public var assignmentStatus: IAMClientTypes.AssignmentStatusType?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        assignmentStatus: IAMClientTypes.AssignmentStatusType? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.assignmentStatus = assignmentStatus
        self.marker = marker
        self.maxItems = maxItems
    }
}

/// Contains the response to a successful [ListVirtualMFADevices] request.
public struct ListVirtualMFADevicesOutput {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of virtual MFA devices in the current account that match the AssignmentStatus value that was passed in the request.
    /// This member is required.
    public var virtualMFADevices: [IAMClientTypes.VirtualMFADevice]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        virtualMFADevices: [IAMClientTypes.VirtualMFADevice]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.virtualMFADevices = virtualMFADevices
    }
}

public struct PutGroupPolicyInput {
    /// The name of the group to associate the policy with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-.
    /// This member is required.
    public var groupName: Swift.String?
    /// The policy document. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy document. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyDocument = policyDocument
        self.policyName = policyName
    }
}

public struct PutRolePermissionsBoundaryInput {
    /// The ARN of the managed policy that is used to set the permissions boundary for the role. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    /// This member is required.
    public var permissionsBoundary: Swift.String?
    /// The name (friendly name, not ARN) of the IAM role for which you want to set the permissions boundary.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        permissionsBoundary: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.permissionsBoundary = permissionsBoundary
        self.roleName = roleName
    }
}

public struct PutRolePolicyInput {
    /// The policy document. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy document. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the role to associate the policy with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.roleName = roleName
    }
}

public struct PutUserPermissionsBoundaryInput {
    /// The ARN of the managed policy that is used to set the permissions boundary for the user. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    /// This member is required.
    public var permissionsBoundary: Swift.String?
    /// The name (friendly name, not ARN) of the IAM user for which you want to set the permissions boundary.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        permissionsBoundary: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.permissionsBoundary = permissionsBoundary
        self.userName = userName
    }
}

public struct PutUserPolicyInput {
    /// The policy document. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy document. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the user to associate the policy with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.userName = userName
    }
}

public struct RemoveClientIDFromOpenIDConnectProviderInput {
    /// The client ID (also known as audience) to remove from the IAM OIDC provider resource. For more information about client IDs, see [CreateOpenIDConnectProvider].
    /// This member is required.
    public var clientID: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM OIDC provider resource to remove the client ID from. You can get a list of OIDC provider ARNs by using the [ListOpenIDConnectProviders] operation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init(
        clientID: Swift.String? = nil,
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.clientID = clientID
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

public struct RemoveRoleFromInstanceProfileInput {
    /// The name of the instance profile to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The name of the role to remove. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        instanceProfileName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.roleName = roleName
    }
}

public struct RemoveUserFromGroupInput {
    /// The name of the group to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the user to remove. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.userName = userName
    }
}

public struct ResetServiceSpecificCredentialInput {
    /// The unique identifier of the service-specific credential. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var serviceSpecificCredentialId: Swift.String?
    /// The name of the IAM user associated with the service-specific credential. If this value is not specified, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        serviceSpecificCredentialId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.userName = userName
    }
}

public struct ResetServiceSpecificCredentialOutput {
    /// A structure with details about the updated service-specific credential, including the new password. This is the only time that you can access the password. You cannot recover the password later, but you can reset it again.
    public var serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential?

    public init(
        serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential? = nil
    )
    {
        self.serviceSpecificCredential = serviceSpecificCredential
    }
}

public struct ResyncMFADeviceInput {
    /// An authentication code emitted by the device. The format for this parameter is a sequence of six digits.
    /// This member is required.
    public var authenticationCode1: Swift.String?
    /// A subsequent authentication code emitted by the device. The format for this parameter is a sequence of six digits.
    /// This member is required.
    public var authenticationCode2: Swift.String?
    /// Serial number that uniquely identifies the MFA device. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The name of the user whose MFA device you want to resynchronize. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        authenticationCode1: Swift.String? = nil,
        authenticationCode2: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationCode1 = authenticationCode1
        self.authenticationCode2 = authenticationCode2
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

public struct SetDefaultPolicyVersionInput {
    /// The Amazon Resource Name (ARN) of the IAM policy whose default version you want to set. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The version of the policy to set as the default (operative) version. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.versionId = versionId
    }
}

extension IAMClientTypes {

    public enum GlobalEndpointTokenVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case v1token
        case v2token
        case sdkUnknown(Swift.String)

        public static var allCases: [GlobalEndpointTokenVersion] {
            return [
                .v1token,
                .v2token
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .v1token: return "v1Token"
            case .v2token: return "v2Token"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SetSecurityTokenServicePreferencesInput {
    /// The version of the global endpoint token. Version 1 tokens are valid only in Amazon Web Services Regions that are available by default. These tokens do not work in manually enabled Regions, such as Asia Pacific (Hong Kong). Version 2 tokens are valid in all Regions. However, version 2 tokens are longer and might affect systems where you temporarily store tokens. For information, see [Activating and deactivating STS in an Amazon Web Services Region](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html) in the IAM User Guide.
    /// This member is required.
    public var globalEndpointTokenVersion: IAMClientTypes.GlobalEndpointTokenVersion?

    public init(
        globalEndpointTokenVersion: IAMClientTypes.GlobalEndpointTokenVersion? = nil
    )
    {
        self.globalEndpointTokenVersion = globalEndpointTokenVersion
    }
}

/// The request failed because a provided policy could not be successfully evaluated. An additional detailed message indicates the source of the failure.
public struct PolicyEvaluationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyEvaluation" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IAMClientTypes {

    public enum ContextKeyTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case binary
        case binaryList
        case boolean
        case booleanList
        case date
        case dateList
        case ip
        case ipList
        case numeric
        case numericList
        case string
        case stringList
        case sdkUnknown(Swift.String)

        public static var allCases: [ContextKeyTypeEnum] {
            return [
                .binary,
                .binaryList,
                .boolean,
                .booleanList,
                .date,
                .dateList,
                .ip,
                .ipList,
                .numeric,
                .numericList,
                .string,
                .stringList
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .binary: return "binary"
            case .binaryList: return "binaryList"
            case .boolean: return "boolean"
            case .booleanList: return "booleanList"
            case .date: return "date"
            case .dateList: return "dateList"
            case .ip: return "ip"
            case .ipList: return "ipList"
            case .numeric: return "numeric"
            case .numericList: return "numericList"
            case .string: return "string"
            case .stringList: return "stringList"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a condition context key. It includes the name of the key and specifies the value (or values, if the context key supports multiple values) to use in the simulation. This information is used when evaluating the Condition elements of the input policies. This data type is used as an input parameter to [SimulateCustomPolicy] and [SimulatePrincipalPolicy].
    public struct ContextEntry {
        /// The full name of a condition context key, including the service prefix. For example, aws:SourceIp or s3:VersionId.
        public var contextKeyName: Swift.String?
        /// The data type of the value (or values) specified in the ContextKeyValues parameter.
        public var contextKeyType: IAMClientTypes.ContextKeyTypeEnum?
        /// The value (or values, if the condition context key supports multiple values) to provide to the simulation when the key is referenced by a Condition element in an input policy.
        public var contextKeyValues: [Swift.String]?

        public init(
            contextKeyName: Swift.String? = nil,
            contextKeyType: IAMClientTypes.ContextKeyTypeEnum? = nil,
            contextKeyValues: [Swift.String]? = nil
        )
        {
            self.contextKeyName = contextKeyName
            self.contextKeyType = contextKeyType
            self.contextKeyValues = contextKeyValues
        }
    }

}

public struct SimulateCustomPolicyInput {
    /// A list of names of API operations to evaluate in the simulation. Each operation is evaluated against each resource. Each operation must include the service identifier, such as iam:CreateUser. This operation does not support using wildcards (*) in an action name.
    /// This member is required.
    public var actionNames: [Swift.String]?
    /// The ARN of the IAM user that you want to use as the simulated caller of the API operations. CallerArn is required if you include a ResourcePolicy so that the policy's Principal element has a value to use in evaluating the policy. You can specify only the ARN of an IAM user. You cannot specify the ARN of an assumed role, federated user, or a service principal.
    public var callerArn: Swift.String?
    /// A list of context keys and corresponding values for the simulation to use. Whenever a context key is evaluated in one of the simulated IAM permissions policies, the corresponding value is supplied.
    public var contextEntries: [IAMClientTypes.ContextEntry]?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The IAM permissions boundary policy to simulate. The permissions boundary sets the maximum permissions that an IAM entity can have. You can input only one permissions boundary when you pass a policy to this operation. For more information about permissions boundaries, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. The policy input is specified as a string that contains the complete, valid JSON text of a permissions boundary policy. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var permissionsBoundaryPolicyInputList: [Swift.String]?
    /// A list of policy documents to include in the simulation. Each document is specified as a string containing the complete, valid JSON text of an IAM policy. Do not include any resource-based policies in this parameter. Any resource-based policy must be submitted with the ResourcePolicy parameter. The policies cannot be "scope-down" policies, such as you could include in a call to [GetFederationToken](https://docs.aws.amazon.com/IAM/latest/APIReference/API_GetFederationToken.html) or one of the [AssumeRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_AssumeRole.html) API operations. In other words, do not use policies designed to restrict what a user can do while using the temporary credentials. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyInputList: [Swift.String]?
    /// A list of ARNs of Amazon Web Services resources to include in the simulation. If this parameter is not provided, then the value defaults to * (all resources). Each API in the ActionNames parameter is evaluated for each resource in this list. The simulation determines the access result (allowed or denied) of each combination and reports it in the response. You can simulate resources that don't exist in your account. The simulation does not automatically retrieve policies for the specified resources. If you want to include a resource policy in the simulation, then you must include the policy as a string in the ResourcePolicy parameter. If you include a ResourcePolicy, then it must be applicable to all of the resources included in the simulation or you receive an invalid input error. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. Simulation of resource-based policies isn't supported for IAM roles.
    public var resourceArns: [Swift.String]?
    /// Specifies the type of simulation to run. Different API operations that support resource-based policies require different combinations of resources. By specifying the type of simulation to run, you enable the policy simulator to enforce the presence of the required resources to ensure reliable simulation results. If your simulation does not match one of the following scenarios, then you can omit this parameter. The following list shows each of the supported scenario values and the resources that you must define to run the simulation. Each of the Amazon EC2 scenarios requires that you specify instance, image, and security group resources. If your scenario includes an EBS volume, then you must specify that volume as a resource. If the Amazon EC2 scenario includes VPC, then you must supply the network interface resource. If it includes an IP subnet, then you must specify the subnet resource. For more information on the Amazon EC2 scenario options, see [Supported platforms](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html) in the Amazon EC2 User Guide.
    ///
    /// * EC2-VPC-InstanceStore instance, image, security group, network interface
    ///
    /// * EC2-VPC-InstanceStore-Subnet instance, image, security group, network interface, subnet
    ///
    /// * EC2-VPC-EBS instance, image, security group, network interface, volume
    ///
    /// * EC2-VPC-EBS-Subnet instance, image, security group, network interface, subnet, volume
    public var resourceHandlingOption: Swift.String?
    /// An ARN representing the Amazon Web Services account ID that specifies the owner of any simulated resource that does not identify its owner in the resource ARN. Examples of resource ARNs include an S3 bucket or object. If ResourceOwner is specified, it is also used as the account owner of any ResourcePolicy included in the simulation. If the ResourceOwner parameter is not specified, then the owner of the resources and the resource policy defaults to the account of the identity provided in CallerArn. This parameter is required only if you specify a resource-based policy and account that owns the resource is different from the account that owns the simulated calling user CallerArn. The ARN for an account uses the following syntax: arn:aws:iam::AWS-account-ID:root. For example, to represent the account with the 112233445566 ID, use the following ARN: arn:aws:iam::112233445566-ID:root.
    public var resourceOwner: Swift.String?
    /// A resource-based policy to include in the simulation provided as a string. Each resource in the simulation is treated as if it had this policy attached. You can include only one resource-based policy in a simulation. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// Simulation of resource-based policies isn't supported for IAM roles.
    public var resourcePolicy: Swift.String?

    public init(
        actionNames: [Swift.String]? = nil,
        callerArn: Swift.String? = nil,
        contextEntries: [IAMClientTypes.ContextEntry]? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        permissionsBoundaryPolicyInputList: [Swift.String]? = nil,
        policyInputList: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceHandlingOption: Swift.String? = nil,
        resourceOwner: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.actionNames = actionNames
        self.callerArn = callerArn
        self.contextEntries = contextEntries
        self.marker = marker
        self.maxItems = maxItems
        self.permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList
        self.policyInputList = policyInputList
        self.resourceArns = resourceArns
        self.resourceHandlingOption = resourceHandlingOption
        self.resourceOwner = resourceOwner
        self.resourcePolicy = resourcePolicy
    }
}

extension IAMClientTypes {

    public enum PolicyEvaluationDecisionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowed
        case explicitDeny
        case implicitDeny
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyEvaluationDecisionType] {
            return [
                .allowed,
                .explicitDeny,
                .implicitDeny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowed: return "allowed"
            case .explicitDeny: return "explicitDeny"
            case .implicitDeny: return "implicitDeny"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IAMClientTypes {
    /// Contains the row and column of a location of a Statement element in a policy document. This data type is used as a member of the [Statement] type.
    public struct Position {
        /// The column in the line containing the specified position in the document.
        public var column: Swift.Int
        /// The line containing the specified position in the document.
        public var line: Swift.Int

        public init(
            column: Swift.Int = 0,
            line: Swift.Int = 0
        )
        {
            self.column = column
            self.line = line
        }
    }

}

extension IAMClientTypes {

    public enum PolicySourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsManaged
        case group
        case `none`
        case resource
        case role
        case user
        case userManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicySourceType] {
            return [
                .awsManaged,
                .group,
                .none,
                .resource,
                .role,
                .user,
                .userManaged
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsManaged: return "aws-managed"
            case .group: return "group"
            case .none: return "none"
            case .resource: return "resource"
            case .role: return "role"
            case .user: return "user"
            case .userManaged: return "user-managed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IAMClientTypes {
    /// Contains a reference to a Statement element in a policy document that determines the result of the simulation. This data type is used by the MatchedStatements member of the [EvaluationResult] type.
    public struct Statement {
        /// The row and column of the end of a Statement in an IAM policy.
        public var endPosition: IAMClientTypes.Position?
        /// The identifier of the policy that was provided as an input.
        public var sourcePolicyId: Swift.String?
        /// The type of the policy.
        public var sourcePolicyType: IAMClientTypes.PolicySourceType?
        /// The row and column of the beginning of the Statement in an IAM policy.
        public var startPosition: IAMClientTypes.Position?

        public init(
            endPosition: IAMClientTypes.Position? = nil,
            sourcePolicyId: Swift.String? = nil,
            sourcePolicyType: IAMClientTypes.PolicySourceType? = nil,
            startPosition: IAMClientTypes.Position? = nil
        )
        {
            self.endPosition = endPosition
            self.sourcePolicyId = sourcePolicyId
            self.sourcePolicyType = sourcePolicyType
            self.startPosition = startPosition
        }
    }

}

extension IAMClientTypes {
    /// Contains information about the effect that Organizations has on a policy simulation.
    public struct OrganizationsDecisionDetail {
        /// Specifies whether the simulated operation is allowed by the Organizations service control policies that impact the simulated user's account.
        public var allowedByOrganizations: Swift.Bool

        public init(
            allowedByOrganizations: Swift.Bool = false
        )
        {
            self.allowedByOrganizations = allowedByOrganizations
        }
    }

}

extension IAMClientTypes {
    /// Contains information about the effect that a permissions boundary has on a policy simulation when the boundary is applied to an IAM entity.
    public struct PermissionsBoundaryDecisionDetail {
        /// Specifies whether an action is allowed by a permissions boundary that is applied to an IAM entity (user or role). A value of true means that the permissions boundary does not deny the action. This means that the policy includes an Allow statement that matches the request. In this case, if an identity-based policy also allows the action, the request is allowed. A value of false means that either the requested action is not allowed (implicitly denied) or that the action is explicitly denied by the permissions boundary. In both of these cases, the action is not allowed, regardless of the identity-based policy.
        public var allowedByPermissionsBoundary: Swift.Bool

        public init(
            allowedByPermissionsBoundary: Swift.Bool = false
        )
        {
            self.allowedByPermissionsBoundary = allowedByPermissionsBoundary
        }
    }

}

extension IAMClientTypes {
    /// Contains the result of the simulation of a single API operation call on a single resource. This data type is used by a member of the [EvaluationResult] data type.
    public struct ResourceSpecificResult {
        /// Additional details about the results of the evaluation decision on a single resource. This parameter is returned only for cross-account simulations. This parameter explains how each policy type contributes to the resource-specific evaluation decision.
        public var evalDecisionDetails: [Swift.String: IAMClientTypes.PolicyEvaluationDecisionType]?
        /// The result of the simulation of the simulated API operation on the resource specified in EvalResourceName.
        /// This member is required.
        public var evalResourceDecision: IAMClientTypes.PolicyEvaluationDecisionType?
        /// The name of the simulated resource, in Amazon Resource Name (ARN) format.
        /// This member is required.
        public var evalResourceName: Swift.String?
        /// A list of the statements in the input policies that determine the result for this part of the simulation. Remember that even if multiple statements allow the operation on the resource, if any statement denies that operation, then the explicit deny overrides any allow. In addition, the deny statement is the only entry included in the result.
        public var matchedStatements: [IAMClientTypes.Statement]?
        /// A list of context keys that are required by the included input policies but that were not provided by one of the input parameters. This list is used when a list of ARNs is included in the ResourceArns parameter instead of "*". If you do not specify individual resources, by setting ResourceArns to "*" or by not including the ResourceArns parameter, then any missing context values are instead included under the EvaluationResults section. To discover the context keys used by a set of policies, you can call [GetContextKeysForCustomPolicy] or [GetContextKeysForPrincipalPolicy].
        public var missingContextValues: [Swift.String]?
        /// Contains information about the effect that a permissions boundary has on a policy simulation when that boundary is applied to an IAM entity.
        public var permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail?

        public init(
            evalDecisionDetails: [Swift.String: IAMClientTypes.PolicyEvaluationDecisionType]? = nil,
            evalResourceDecision: IAMClientTypes.PolicyEvaluationDecisionType? = nil,
            evalResourceName: Swift.String? = nil,
            matchedStatements: [IAMClientTypes.Statement]? = nil,
            missingContextValues: [Swift.String]? = nil,
            permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail? = nil
        )
        {
            self.evalDecisionDetails = evalDecisionDetails
            self.evalResourceDecision = evalResourceDecision
            self.evalResourceName = evalResourceName
            self.matchedStatements = matchedStatements
            self.missingContextValues = missingContextValues
            self.permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail
        }
    }

}

extension IAMClientTypes {
    /// Contains the results of a simulation. This data type is used by the return parameter of [SimulateCustomPolicy] and [SimulatePrincipalPolicy].
    public struct EvaluationResult {
        /// The name of the API operation tested on the indicated resource.
        /// This member is required.
        public var evalActionName: Swift.String?
        /// The result of the simulation.
        /// This member is required.
        public var evalDecision: IAMClientTypes.PolicyEvaluationDecisionType?
        /// Additional details about the results of the cross-account evaluation decision. This parameter is populated for only cross-account simulations. It contains a brief summary of how each policy type contributes to the final evaluation decision. If the simulation evaluates policies within the same account and includes a resource ARN, then the parameter is present but the response is empty. If the simulation evaluates policies within the same account and specifies all resources (*), then the parameter is not returned. When you make a cross-account request, Amazon Web Services evaluates the request in the trusting account and the trusted account. The request is allowed only if both evaluations return true. For more information about how policies are evaluated, see [Evaluating policies within a single account](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic.html#policy-eval-basics). If an Organizations SCP included in the evaluation denies access, the simulation ends. In this case, policy evaluation does not proceed any further and this parameter is not returned.
        public var evalDecisionDetails: [Swift.String: IAMClientTypes.PolicyEvaluationDecisionType]?
        /// The ARN of the resource that the indicated API operation was tested on.
        public var evalResourceName: Swift.String?
        /// A list of the statements in the input policies that determine the result for this scenario. Remember that even if multiple statements allow the operation on the resource, if only one statement denies that operation, then the explicit deny overrides any allow. In addition, the deny statement is the only entry included in the result.
        public var matchedStatements: [IAMClientTypes.Statement]?
        /// A list of context keys that are required by the included input policies but that were not provided by one of the input parameters. This list is used when the resource in a simulation is "*", either explicitly, or when the ResourceArns parameter blank. If you include a list of resources, then any missing context values are instead included under the ResourceSpecificResults section. To discover the context keys used by a set of policies, you can call [GetContextKeysForCustomPolicy] or [GetContextKeysForPrincipalPolicy].
        public var missingContextValues: [Swift.String]?
        /// A structure that details how Organizations and its service control policies affect the results of the simulation. Only applies if the simulated user's account is part of an organization.
        public var organizationsDecisionDetail: IAMClientTypes.OrganizationsDecisionDetail?
        /// Contains information about the effect that a permissions boundary has on a policy simulation when the boundary is applied to an IAM entity.
        public var permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail?
        /// The individual results of the simulation of the API operation specified in EvalActionName on each resource.
        public var resourceSpecificResults: [IAMClientTypes.ResourceSpecificResult]?

        public init(
            evalActionName: Swift.String? = nil,
            evalDecision: IAMClientTypes.PolicyEvaluationDecisionType? = nil,
            evalDecisionDetails: [Swift.String: IAMClientTypes.PolicyEvaluationDecisionType]? = nil,
            evalResourceName: Swift.String? = nil,
            matchedStatements: [IAMClientTypes.Statement]? = nil,
            missingContextValues: [Swift.String]? = nil,
            organizationsDecisionDetail: IAMClientTypes.OrganizationsDecisionDetail? = nil,
            permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail? = nil,
            resourceSpecificResults: [IAMClientTypes.ResourceSpecificResult]? = nil
        )
        {
            self.evalActionName = evalActionName
            self.evalDecision = evalDecision
            self.evalDecisionDetails = evalDecisionDetails
            self.evalResourceName = evalResourceName
            self.matchedStatements = matchedStatements
            self.missingContextValues = missingContextValues
            self.organizationsDecisionDetail = organizationsDecisionDetail
            self.permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail
            self.resourceSpecificResults = resourceSpecificResults
        }
    }

}

/// Contains the response to a successful [SimulatePrincipalPolicy] or [SimulateCustomPolicy] request.
public struct SimulateCustomPolicyOutput {
    /// The results of the simulation.
    public var evaluationResults: [IAMClientTypes.EvaluationResult]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        evaluationResults: [IAMClientTypes.EvaluationResult]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

public struct SimulatePrincipalPolicyInput {
    /// A list of names of API operations to evaluate in the simulation. Each operation is evaluated for each resource. Each operation must include the service identifier, such as iam:CreateUser.
    /// This member is required.
    public var actionNames: [Swift.String]?
    /// The ARN of the IAM user that you want to specify as the simulated caller of the API operations. If you do not specify a CallerArn, it defaults to the ARN of the user that you specify in PolicySourceArn, if you specified a user. If you include both a PolicySourceArn (for example, arn:aws:iam::123456789012:user/David) and a CallerArn (for example, arn:aws:iam::123456789012:user/Bob), the result is that you simulate calling the API operations as Bob, as if Bob had David's policies. You can specify only the ARN of an IAM user. You cannot specify the ARN of an assumed role, federated user, or a service principal. CallerArn is required if you include a ResourcePolicy and the PolicySourceArn is not the ARN for an IAM user. This is required so that the resource-based policy's Principal element has a value to use in evaluating the policy. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    public var callerArn: Swift.String?
    /// A list of context keys and corresponding values for the simulation to use. Whenever a context key is evaluated in one of the simulated IAM permissions policies, the corresponding value is supplied.
    public var contextEntries: [IAMClientTypes.ContextEntry]?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The IAM permissions boundary policy to simulate. The permissions boundary sets the maximum permissions that the entity can have. You can input only one permissions boundary when you pass a policy to this operation. An IAM entity can only have one permissions boundary in effect at a time. For example, if a permissions boundary is attached to an entity and you pass in a different permissions boundary policy using this parameter, then the new permissions boundary policy is used for the simulation. For more information about permissions boundaries, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. The policy input is specified as a string containing the complete, valid JSON text of a permissions boundary policy. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var permissionsBoundaryPolicyInputList: [Swift.String]?
    /// An optional list of additional policy documents to include in the simulation. Each document is specified as a string containing the complete, valid JSON text of an IAM policy. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var policyInputList: [Swift.String]?
    /// The Amazon Resource Name (ARN) of a user, group, or role whose policies you want to include in the simulation. If you specify a user, group, or role, the simulation includes all policies that are associated with that entity. If you specify a user, the simulation also includes all policies that are attached to any groups the user belongs to. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policySourceArn: Swift.String?
    /// A list of ARNs of Amazon Web Services resources to include in the simulation. If this parameter is not provided, then the value defaults to * (all resources). Each API in the ActionNames parameter is evaluated for each resource in this list. The simulation determines the access result (allowed or denied) of each combination and reports it in the response. You can simulate resources that don't exist in your account. The simulation does not automatically retrieve policies for the specified resources. If you want to include a resource policy in the simulation, then you must include the policy as a string in the ResourcePolicy parameter. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. Simulation of resource-based policies isn't supported for IAM roles.
    public var resourceArns: [Swift.String]?
    /// Specifies the type of simulation to run. Different API operations that support resource-based policies require different combinations of resources. By specifying the type of simulation to run, you enable the policy simulator to enforce the presence of the required resources to ensure reliable simulation results. If your simulation does not match one of the following scenarios, then you can omit this parameter. The following list shows each of the supported scenario values and the resources that you must define to run the simulation. Each of the Amazon EC2 scenarios requires that you specify instance, image, and security group resources. If your scenario includes an EBS volume, then you must specify that volume as a resource. If the Amazon EC2 scenario includes VPC, then you must supply the network interface resource. If it includes an IP subnet, then you must specify the subnet resource. For more information on the Amazon EC2 scenario options, see [Supported platforms](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html) in the Amazon EC2 User Guide.
    ///
    /// * EC2-VPC-InstanceStore instance, image, security group, network interface
    ///
    /// * EC2-VPC-InstanceStore-Subnet instance, image, security group, network interface, subnet
    ///
    /// * EC2-VPC-EBS instance, image, security group, network interface, volume
    ///
    /// * EC2-VPC-EBS-Subnet instance, image, security group, network interface, subnet, volume
    public var resourceHandlingOption: Swift.String?
    /// An Amazon Web Services account ID that specifies the owner of any simulated resource that does not identify its owner in the resource ARN. Examples of resource ARNs include an S3 bucket or object. If ResourceOwner is specified, it is also used as the account owner of any ResourcePolicy included in the simulation. If the ResourceOwner parameter is not specified, then the owner of the resources and the resource policy defaults to the account of the identity provided in CallerArn. This parameter is required only if you specify a resource-based policy and account that owns the resource is different from the account that owns the simulated calling user CallerArn.
    public var resourceOwner: Swift.String?
    /// A resource-based policy to include in the simulation provided as a string. Each resource in the simulation is treated as if it had this policy attached. You can include only one resource-based policy in a simulation. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// Simulation of resource-based policies isn't supported for IAM roles.
    public var resourcePolicy: Swift.String?

    public init(
        actionNames: [Swift.String]? = nil,
        callerArn: Swift.String? = nil,
        contextEntries: [IAMClientTypes.ContextEntry]? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        permissionsBoundaryPolicyInputList: [Swift.String]? = nil,
        policyInputList: [Swift.String]? = nil,
        policySourceArn: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceHandlingOption: Swift.String? = nil,
        resourceOwner: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.actionNames = actionNames
        self.callerArn = callerArn
        self.contextEntries = contextEntries
        self.marker = marker
        self.maxItems = maxItems
        self.permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList
        self.policyInputList = policyInputList
        self.policySourceArn = policySourceArn
        self.resourceArns = resourceArns
        self.resourceHandlingOption = resourceHandlingOption
        self.resourceOwner = resourceOwner
        self.resourcePolicy = resourcePolicy
    }
}

/// Contains the response to a successful [SimulatePrincipalPolicy] or [SimulateCustomPolicy] request.
public struct SimulatePrincipalPolicyOutput {
    /// The results of the simulation.
    public var evaluationResults: [IAMClientTypes.EvaluationResult]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        evaluationResults: [IAMClientTypes.EvaluationResult]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

public struct TagInstanceProfileInput {
    /// The name of the IAM instance profile to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The list of tags that you want to attach to the IAM instance profile. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        instanceProfileName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.tags = tags
    }
}

public struct TagMFADeviceInput {
    /// The unique identifier for the IAM virtual MFA device to which you want to add tags. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The list of tags that you want to attach to the IAM virtual MFA device. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        serialNumber: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.serialNumber = serialNumber
        self.tags = tags
    }
}

public struct TagOpenIDConnectProviderInput {
    /// The ARN of the OIDC identity provider in IAM to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?
    /// The list of tags that you want to attach to the OIDC identity provider in IAM. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        openIDConnectProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.tags = tags
    }
}

public struct TagPolicyInput {
    /// The ARN of the IAM customer managed policy to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyArn: Swift.String?
    /// The list of tags that you want to attach to the IAM customer managed policy. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        policyArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.policyArn = policyArn
        self.tags = tags
    }
}

public struct TagRoleInput {
    /// The name of the IAM role to which you want to add tags. This parameter accepts (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?
    /// The list of tags that you want to attach to the IAM role. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        roleName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.roleName = roleName
        self.tags = tags
    }
}

public struct TagSAMLProviderInput {
    /// The ARN of the SAML identity provider in IAM to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var samlProviderArn: Swift.String?
    /// The list of tags that you want to attach to the SAML identity provider in IAM. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        samlProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
        self.tags = tags
    }
}

public struct TagServerCertificateInput {
    /// The name of the IAM server certificate to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?
    /// The list of tags that you want to attach to the IAM server certificate. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        serverCertificateName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
        self.tags = tags
    }
}

public struct TagUserInput {
    /// The list of tags that you want to attach to the IAM user. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?
    /// The name of the IAM user to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        tags: [IAMClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.tags = tags
        self.userName = userName
    }
}

public struct UntagInstanceProfileInput {
    /// The name of the IAM instance profile from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified instance profile.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        instanceProfileName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.tagKeys = tagKeys
    }
}

public struct UntagMFADeviceInput {
    /// The unique identifier for the IAM virtual MFA device from which you want to remove tags. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified instance profile.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        serialNumber: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.serialNumber = serialNumber
        self.tagKeys = tagKeys
    }
}

public struct UntagOpenIDConnectProviderInput {
    /// The ARN of the OIDC provider in IAM from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified OIDC provider.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        openIDConnectProviderArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.tagKeys = tagKeys
    }
}

public struct UntagPolicyInput {
    /// The ARN of the IAM customer managed policy from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyArn: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified policy.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        policyArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.policyArn = policyArn
        self.tagKeys = tagKeys
    }
}

public struct UntagRoleInput {
    /// The name of the IAM role from which you want to remove tags. This parameter accepts (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified role.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        roleName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.roleName = roleName
        self.tagKeys = tagKeys
    }
}

public struct UntagSAMLProviderInput {
    /// The ARN of the SAML identity provider in IAM from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var samlProviderArn: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified SAML identity provider.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        samlProviderArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
        self.tagKeys = tagKeys
    }
}

public struct UntagServerCertificateInput {
    /// The name of the IAM server certificate from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified IAM server certificate.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        serverCertificateName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
        self.tagKeys = tagKeys
    }
}

public struct UntagUserInput {
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified user.
    /// This member is required.
    public var tagKeys: [Swift.String]?
    /// The name of the IAM user from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        tagKeys: [Swift.String]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.tagKeys = tagKeys
        self.userName = userName
    }
}

public struct UpdateAccessKeyInput {
    /// The access key ID of the secret access key you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var accessKeyId: Swift.String?
    /// The status you want to assign to the secret access key. Active means that the key can be used for programmatic calls to Amazon Web Services, while Inactive means that the key cannot be used.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the user whose key you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        accessKeyId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.status = status
        self.userName = userName
    }
}

public struct UpdateAccountPasswordPolicyInput {
    /// Allows all IAM users in your account to use the Amazon Web Services Management Console to change their own passwords. For more information, see [Permitting IAM users to change their own passwords](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_passwords_enable-user-change.html) in the IAM User Guide. If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that IAM users in the account do not automatically have permissions to change their own password.
    public var allowUsersToChangePassword: Swift.Bool?
    /// Prevents IAM users who are accessing the account via the Amazon Web Services Management Console from setting a new console password after their password has expired. The IAM user cannot access the console until an administrator resets the password. If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that IAM users can change their passwords after they expire and continue to sign in as the user. In the Amazon Web Services Management Console, the custom password policy option Allow users to change their own password gives IAM users permissions to iam:ChangePassword for only their user and to the iam:GetAccountPasswordPolicy action. This option does not attach a permissions policy to each user, rather the permissions are applied at the account-level for all users by IAM. IAM users with iam:ChangePassword permission and active access keys can reset their own expired console password using the CLI or API.
    public var hardExpiry: Swift.Bool?
    /// The number of days that an IAM user password is valid. If you do not specify a value for this parameter, then the operation uses the default value of 0. The result is that IAM user passwords never expire.
    public var maxPasswordAge: Swift.Int?
    /// The minimum number of characters allowed in an IAM user password. If you do not specify a value for this parameter, then the operation uses the default value of 6.
    public var minimumPasswordLength: Swift.Int?
    /// Specifies the number of previous passwords that IAM users are prevented from reusing. If you do not specify a value for this parameter, then the operation uses the default value of 0. The result is that IAM users are not prevented from reusing previous passwords.
    public var passwordReusePrevention: Swift.Int?
    /// Specifies whether IAM user passwords must contain at least one lowercase character from the ISO basic Latin alphabet (a to z). If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one lowercase character.
    public var requireLowercaseCharacters: Swift.Bool?
    /// Specifies whether IAM user passwords must contain at least one numeric character (0 to 9). If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one numeric character.
    public var requireNumbers: Swift.Bool?
    /// Specifies whether IAM user passwords must contain at least one of the following non-alphanumeric characters: ! @ # $ % ^ & * ( ) _ + - = [ ] { } | ' If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one symbol character.
    public var requireSymbols: Swift.Bool?
    /// Specifies whether IAM user passwords must contain at least one uppercase character from the ISO basic Latin alphabet (A to Z). If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one uppercase character.
    public var requireUppercaseCharacters: Swift.Bool?

    public init(
        allowUsersToChangePassword: Swift.Bool? = false,
        hardExpiry: Swift.Bool? = nil,
        maxPasswordAge: Swift.Int? = nil,
        minimumPasswordLength: Swift.Int? = nil,
        passwordReusePrevention: Swift.Int? = nil,
        requireLowercaseCharacters: Swift.Bool? = false,
        requireNumbers: Swift.Bool? = false,
        requireSymbols: Swift.Bool? = false,
        requireUppercaseCharacters: Swift.Bool? = false
    )
    {
        self.allowUsersToChangePassword = allowUsersToChangePassword
        self.hardExpiry = hardExpiry
        self.maxPasswordAge = maxPasswordAge
        self.minimumPasswordLength = minimumPasswordLength
        self.passwordReusePrevention = passwordReusePrevention
        self.requireLowercaseCharacters = requireLowercaseCharacters
        self.requireNumbers = requireNumbers
        self.requireSymbols = requireSymbols
        self.requireUppercaseCharacters = requireUppercaseCharacters
    }
}

public struct UpdateAssumeRolePolicyInput {
    /// The policy that grants an entity permission to assume the role. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the role to update with the new policy. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.roleName = roleName
    }
}

public struct UpdateGroupInput {
    /// Name of the IAM group to update. If you're changing the name of the group, this is the original name. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// New name for the IAM group. Only include this if changing the group's name. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    public var newGroupName: Swift.String?
    /// New path for the IAM group. Only include this if changing the group's path. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var newPath: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        newGroupName: Swift.String? = nil,
        newPath: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.newGroupName = newGroupName
        self.newPath = newPath
    }
}

public struct UpdateLoginProfileInput {
    /// The new password for the specified IAM user. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// However, the format can be further restricted by the account administrator by setting a password policy on the Amazon Web Services account. For more information, see [UpdateAccountPasswordPolicy].
    public var password: Swift.String?
    /// Allows this new password to be used only once by requiring the specified IAM user to set a new password on next sign-in.
    public var passwordResetRequired: Swift.Bool?
    /// The name of the user whose password you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        password: Swift.String? = nil,
        passwordResetRequired: Swift.Bool? = nil,
        userName: Swift.String? = nil
    )
    {
        self.password = password
        self.passwordResetRequired = passwordResetRequired
        self.userName = userName
    }
}

extension UpdateLoginProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLoginProfileInput(passwordResetRequired: \(Swift.String(describing: passwordResetRequired)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

public struct UpdateOpenIDConnectProviderThumbprintInput {
    /// The Amazon Resource Name (ARN) of the IAM OIDC provider resource object for which you want to update the thumbprint. You can get a list of OIDC provider ARNs by using the [ListOpenIDConnectProviders] operation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?
    /// A list of certificate thumbprints that are associated with the specified IAM OpenID Connect provider. For more information, see [CreateOpenIDConnectProvider].
    /// This member is required.
    public var thumbprintList: [Swift.String]?

    public init(
        openIDConnectProviderArn: Swift.String? = nil,
        thumbprintList: [Swift.String]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.thumbprintList = thumbprintList
    }
}

public struct UpdateRoleInput {
    /// The new description that you want to apply to the specified role.
    public var description: Swift.String?
    /// The maximum session duration (in seconds) that you want to set for the specified role. If you do not specify a value for this setting, the default value of one hour is applied. This setting can have a value from 1 hour to 12 hours. Anyone who assumes the role from the CLI or API can use the DurationSeconds API parameter or the duration-seconds CLI parameter to request a longer session. The MaxSessionDuration setting determines the maximum duration that can be requested using the DurationSeconds parameter. If users don't specify a value for the DurationSeconds parameter, their security credentials are valid for one hour by default. This applies when you use the AssumeRole* API operations or the assume-role* CLI operations but does not apply when you use those operations to create a console URL. For more information, see [Using IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html) in the IAM User Guide. IAM role credentials provided by Amazon EC2 instances assigned to the role are not subject to the specified maximum session duration.
    public var maxSessionDuration: Swift.Int?
    /// The name of the role that you want to modify.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        description: Swift.String? = nil,
        maxSessionDuration: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.description = description
        self.maxSessionDuration = maxSessionDuration
        self.roleName = roleName
    }
}

public struct UpdateRoleOutput {

    public init() { }
}

public struct UpdateRoleDescriptionInput {
    /// The new description that you want to apply to the specified role.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the role that you want to modify.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        description: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.description = description
        self.roleName = roleName
    }
}

public struct UpdateRoleDescriptionOutput {
    /// A structure that contains details about the modified role.
    public var role: IAMClientTypes.Role?

    public init(
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

public struct UpdateSAMLProviderInput {
    /// An XML document generated by an identity provider (IdP) that supports SAML 2.0. The document includes the issuer's name, expiration information, and keys that can be used to validate the SAML authentication response (assertions) that are received from the IdP. You must generate the metadata document using the identity management software that is used as your organization's IdP.
    /// This member is required.
    public var samlMetadataDocument: Swift.String?
    /// The Amazon Resource Name (ARN) of the SAML provider to update. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init(
        samlMetadataDocument: Swift.String? = nil,
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlMetadataDocument = samlMetadataDocument
        self.samlProviderArn = samlProviderArn
    }
}

/// Contains the response to a successful [UpdateSAMLProvider] request.
public struct UpdateSAMLProviderOutput {
    /// The Amazon Resource Name (ARN) of the SAML provider that was updated.
    public var samlProviderArn: Swift.String?

    public init(
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
    }
}

public struct UpdateServerCertificateInput {
    /// The new path for the server certificate. Include this only if you are updating the server certificate's path. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var newPath: Swift.String?
    /// The new name for the server certificate. Include this only if you are updating the server certificate's name. The name of the certificate cannot contain any spaces. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var newServerCertificateName: Swift.String?
    /// The name of the server certificate that you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init(
        newPath: Swift.String? = nil,
        newServerCertificateName: Swift.String? = nil,
        serverCertificateName: Swift.String? = nil
    )
    {
        self.newPath = newPath
        self.newServerCertificateName = newServerCertificateName
        self.serverCertificateName = serverCertificateName
    }
}

public struct UpdateServiceSpecificCredentialInput {
    /// The unique identifier of the service-specific credential. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var serviceSpecificCredentialId: Swift.String?
    /// The status to be assigned to the service-specific credential.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the IAM user associated with the service-specific credential. If you do not specify this value, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        serviceSpecificCredentialId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.status = status
        self.userName = userName
    }
}

public struct UpdateSigningCertificateInput {
    /// The ID of the signing certificate you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var certificateId: Swift.String?
    /// The status you want to assign to the certificate. Active means that the certificate can be used for programmatic calls to Amazon Web Services Inactive means that the certificate cannot be used.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the IAM user the signing certificate belongs to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        certificateId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
        self.status = status
        self.userName = userName
    }
}

public struct UpdateSSHPublicKeyInput {
    /// The unique identifier for the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// The status to assign to the SSH public key. Active means that the key can be used for authentication with an CodeCommit repository. Inactive means that the key cannot be used.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the IAM user associated with the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        sshPublicKeyId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.sshPublicKeyId = sshPublicKeyId
        self.status = status
        self.userName = userName
    }
}

public struct UpdateUserInput {
    /// New path for the IAM user. Include this parameter only if you're changing the user's path. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var newPath: Swift.String?
    /// New name for the user. Include this parameter only if you're changing the user's name. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    public var newUserName: Swift.String?
    /// Name of the user to update. If you're changing the name of the user, this is the original user name. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        newPath: Swift.String? = nil,
        newUserName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.newPath = newPath
        self.newUserName = newUserName
        self.userName = userName
    }
}

/// The request was rejected because the public key certificate and the private key do not match.
public struct KeyPairMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KeyPairMismatch" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because the certificate was malformed or expired. The error message describes the specific error.
public struct MalformedCertificateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MalformedCertificate" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UploadServerCertificateInput {
    /// The contents of the public key certificate in PEM-encoded format. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var certificateBody: Swift.String?
    /// The contents of the certificate chain. This is typically a concatenation of the PEM-encoded public key certificates of the chain. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var certificateChain: Swift.String?
    /// The path for the server certificate. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters. If you are uploading a server certificate specifically for use with Amazon CloudFront distributions, you must specify a path using the path parameter. The path must begin with /cloudfront and must include a trailing slash (for example, /cloudfront/test/).
    public var path: Swift.String?
    /// The contents of the private key in PEM-encoded format. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var privateKey: Swift.String?
    /// The name for the server certificate. Do not include the path in this value. The name of the certificate cannot contain any spaces. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?
    /// A list of tags that you want to attach to the new IAM server certificate resource. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        certificateBody: Swift.String? = nil,
        certificateChain: Swift.String? = nil,
        path: Swift.String? = nil,
        privateKey: Swift.String? = nil,
        serverCertificateName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.certificateBody = certificateBody
        self.certificateChain = certificateChain
        self.path = path
        self.privateKey = privateKey
        self.serverCertificateName = serverCertificateName
        self.tags = tags
    }
}

extension UploadServerCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadServerCertificateInput(certificateBody: \(Swift.String(describing: certificateBody)), certificateChain: \(Swift.String(describing: certificateChain)), path: \(Swift.String(describing: path)), serverCertificateName: \(Swift.String(describing: serverCertificateName)), tags: \(Swift.String(describing: tags)), privateKey: \"CONTENT_REDACTED\")"}
}

/// Contains the response to a successful [UploadServerCertificate] request.
public struct UploadServerCertificateOutput {
    /// The meta information of the uploaded server certificate without its certificate body, certificate chain, and private key.
    public var serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata?
    /// A list of tags that are attached to the new IAM server certificate. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.serverCertificateMetadata = serverCertificateMetadata
        self.tags = tags
    }
}

/// The request was rejected because the same certificate is associated with an IAM user in the account.
public struct DuplicateCertificateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateCertificate" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because the certificate is invalid.
public struct InvalidCertificateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCertificate" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UploadSigningCertificateInput {
    /// The contents of the signing certificate. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var certificateBody: Swift.String?
    /// The name of the user the signing certificate is for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        certificateBody: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.certificateBody = certificateBody
        self.userName = userName
    }
}

/// Contains the response to a successful [UploadSigningCertificate] request.
public struct UploadSigningCertificateOutput {
    /// Information about the certificate.
    /// This member is required.
    public var certificate: IAMClientTypes.SigningCertificate?

    public init(
        certificate: IAMClientTypes.SigningCertificate? = nil
    )
    {
        self.certificate = certificate
    }
}

/// The request was rejected because the SSH public key is already associated with the specified IAM user.
public struct DuplicateSSHPublicKeyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateSSHPublicKey" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because the public key is malformed or otherwise invalid.
public struct InvalidPublicKeyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPublicKey" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UploadSSHPublicKeyInput {
    /// The SSH public key. The public key must be encoded in ssh-rsa format or PEM format. The minimum bit-length of the public key is 2048 bits. For example, you can generate a 2048-bit key, and the resulting PEM file is 1679 bytes long. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var sshPublicKeyBody: Swift.String?
    /// The name of the IAM user to associate the SSH public key with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        sshPublicKeyBody: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.sshPublicKeyBody = sshPublicKeyBody
        self.userName = userName
    }
}

/// Contains the response to a successful [UploadSSHPublicKey] request.
public struct UploadSSHPublicKeyOutput {
    /// Contains information about the SSH public key.
    public var sshPublicKey: IAMClientTypes.SSHPublicKey?

    public init(
        sshPublicKey: IAMClientTypes.SSHPublicKey? = nil
    )
    {
        self.sshPublicKey = sshPublicKey
    }
}

extension AddClientIDToOpenIDConnectProviderInput {

    static func urlPathProvider(_ value: AddClientIDToOpenIDConnectProviderInput) -> Swift.String? {
        return "/"
    }
}

extension AddRoleToInstanceProfileInput {

    static func urlPathProvider(_ value: AddRoleToInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension AddUserToGroupInput {

    static func urlPathProvider(_ value: AddUserToGroupInput) -> Swift.String? {
        return "/"
    }
}

extension AttachGroupPolicyInput {

    static func urlPathProvider(_ value: AttachGroupPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension AttachRolePolicyInput {

    static func urlPathProvider(_ value: AttachRolePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension AttachUserPolicyInput {

    static func urlPathProvider(_ value: AttachUserPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension ChangePasswordInput {

    static func urlPathProvider(_ value: ChangePasswordInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAccessKeyInput {

    static func urlPathProvider(_ value: CreateAccessKeyInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAccountAliasInput {

    static func urlPathProvider(_ value: CreateAccountAliasInput) -> Swift.String? {
        return "/"
    }
}

extension CreateGroupInput {

    static func urlPathProvider(_ value: CreateGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateInstanceProfileInput {

    static func urlPathProvider(_ value: CreateInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLoginProfileInput {

    static func urlPathProvider(_ value: CreateLoginProfileInput) -> Swift.String? {
        return "/"
    }
}

extension CreateOpenIDConnectProviderInput {

    static func urlPathProvider(_ value: CreateOpenIDConnectProviderInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePolicyInput {

    static func urlPathProvider(_ value: CreatePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePolicyVersionInput {

    static func urlPathProvider(_ value: CreatePolicyVersionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRoleInput {

    static func urlPathProvider(_ value: CreateRoleInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSAMLProviderInput {

    static func urlPathProvider(_ value: CreateSAMLProviderInput) -> Swift.String? {
        return "/"
    }
}

extension CreateServiceLinkedRoleInput {

    static func urlPathProvider(_ value: CreateServiceLinkedRoleInput) -> Swift.String? {
        return "/"
    }
}

extension CreateServiceSpecificCredentialInput {

    static func urlPathProvider(_ value: CreateServiceSpecificCredentialInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUserInput {

    static func urlPathProvider(_ value: CreateUserInput) -> Swift.String? {
        return "/"
    }
}

extension CreateVirtualMFADeviceInput {

    static func urlPathProvider(_ value: CreateVirtualMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

extension DeactivateMFADeviceInput {

    static func urlPathProvider(_ value: DeactivateMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAccessKeyInput {

    static func urlPathProvider(_ value: DeleteAccessKeyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAccountAliasInput {

    static func urlPathProvider(_ value: DeleteAccountAliasInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAccountPasswordPolicyInput {

    static func urlPathProvider(_ value: DeleteAccountPasswordPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteGroupInput {

    static func urlPathProvider(_ value: DeleteGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteGroupPolicyInput {

    static func urlPathProvider(_ value: DeleteGroupPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteInstanceProfileInput {

    static func urlPathProvider(_ value: DeleteInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteLoginProfileInput {

    static func urlPathProvider(_ value: DeleteLoginProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteOpenIDConnectProviderInput {

    static func urlPathProvider(_ value: DeleteOpenIDConnectProviderInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePolicyInput {

    static func urlPathProvider(_ value: DeletePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePolicyVersionInput {

    static func urlPathProvider(_ value: DeletePolicyVersionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRoleInput {

    static func urlPathProvider(_ value: DeleteRoleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRolePermissionsBoundaryInput {

    static func urlPathProvider(_ value: DeleteRolePermissionsBoundaryInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRolePolicyInput {

    static func urlPathProvider(_ value: DeleteRolePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSAMLProviderInput {

    static func urlPathProvider(_ value: DeleteSAMLProviderInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteServerCertificateInput {

    static func urlPathProvider(_ value: DeleteServerCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteServiceLinkedRoleInput {

    static func urlPathProvider(_ value: DeleteServiceLinkedRoleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteServiceSpecificCredentialInput {

    static func urlPathProvider(_ value: DeleteServiceSpecificCredentialInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSigningCertificateInput {

    static func urlPathProvider(_ value: DeleteSigningCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSSHPublicKeyInput {

    static func urlPathProvider(_ value: DeleteSSHPublicKeyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteUserInput {

    static func urlPathProvider(_ value: DeleteUserInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteUserPermissionsBoundaryInput {

    static func urlPathProvider(_ value: DeleteUserPermissionsBoundaryInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteUserPolicyInput {

    static func urlPathProvider(_ value: DeleteUserPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteVirtualMFADeviceInput {

    static func urlPathProvider(_ value: DeleteVirtualMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

extension DetachGroupPolicyInput {

    static func urlPathProvider(_ value: DetachGroupPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DetachRolePolicyInput {

    static func urlPathProvider(_ value: DetachRolePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DetachUserPolicyInput {

    static func urlPathProvider(_ value: DetachUserPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension EnableMFADeviceInput {

    static func urlPathProvider(_ value: EnableMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

extension GenerateCredentialReportInput {

    static func urlPathProvider(_ value: GenerateCredentialReportInput) -> Swift.String? {
        return "/"
    }
}

extension GenerateOrganizationsAccessReportInput {

    static func urlPathProvider(_ value: GenerateOrganizationsAccessReportInput) -> Swift.String? {
        return "/"
    }
}

extension GenerateServiceLastAccessedDetailsInput {

    static func urlPathProvider(_ value: GenerateServiceLastAccessedDetailsInput) -> Swift.String? {
        return "/"
    }
}

extension GetAccessKeyLastUsedInput {

    static func urlPathProvider(_ value: GetAccessKeyLastUsedInput) -> Swift.String? {
        return "/"
    }
}

extension GetAccountAuthorizationDetailsInput {

    static func urlPathProvider(_ value: GetAccountAuthorizationDetailsInput) -> Swift.String? {
        return "/"
    }
}

extension GetAccountPasswordPolicyInput {

    static func urlPathProvider(_ value: GetAccountPasswordPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetAccountSummaryInput {

    static func urlPathProvider(_ value: GetAccountSummaryInput) -> Swift.String? {
        return "/"
    }
}

extension GetContextKeysForCustomPolicyInput {

    static func urlPathProvider(_ value: GetContextKeysForCustomPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetContextKeysForPrincipalPolicyInput {

    static func urlPathProvider(_ value: GetContextKeysForPrincipalPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetCredentialReportInput {

    static func urlPathProvider(_ value: GetCredentialReportInput) -> Swift.String? {
        return "/"
    }
}

extension GetGroupInput {

    static func urlPathProvider(_ value: GetGroupInput) -> Swift.String? {
        return "/"
    }
}

extension GetGroupPolicyInput {

    static func urlPathProvider(_ value: GetGroupPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetInstanceProfileInput {

    static func urlPathProvider(_ value: GetInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension GetLoginProfileInput {

    static func urlPathProvider(_ value: GetLoginProfileInput) -> Swift.String? {
        return "/"
    }
}

extension GetMFADeviceInput {

    static func urlPathProvider(_ value: GetMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

extension GetOpenIDConnectProviderInput {

    static func urlPathProvider(_ value: GetOpenIDConnectProviderInput) -> Swift.String? {
        return "/"
    }
}

extension GetOrganizationsAccessReportInput {

    static func urlPathProvider(_ value: GetOrganizationsAccessReportInput) -> Swift.String? {
        return "/"
    }
}

extension GetPolicyInput {

    static func urlPathProvider(_ value: GetPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetPolicyVersionInput {

    static func urlPathProvider(_ value: GetPolicyVersionInput) -> Swift.String? {
        return "/"
    }
}

extension GetRoleInput {

    static func urlPathProvider(_ value: GetRoleInput) -> Swift.String? {
        return "/"
    }
}

extension GetRolePolicyInput {

    static func urlPathProvider(_ value: GetRolePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetSAMLProviderInput {

    static func urlPathProvider(_ value: GetSAMLProviderInput) -> Swift.String? {
        return "/"
    }
}

extension GetServerCertificateInput {

    static func urlPathProvider(_ value: GetServerCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension GetServiceLastAccessedDetailsInput {

    static func urlPathProvider(_ value: GetServiceLastAccessedDetailsInput) -> Swift.String? {
        return "/"
    }
}

extension GetServiceLastAccessedDetailsWithEntitiesInput {

    static func urlPathProvider(_ value: GetServiceLastAccessedDetailsWithEntitiesInput) -> Swift.String? {
        return "/"
    }
}

extension GetServiceLinkedRoleDeletionStatusInput {

    static func urlPathProvider(_ value: GetServiceLinkedRoleDeletionStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetSSHPublicKeyInput {

    static func urlPathProvider(_ value: GetSSHPublicKeyInput) -> Swift.String? {
        return "/"
    }
}

extension GetUserInput {

    static func urlPathProvider(_ value: GetUserInput) -> Swift.String? {
        return "/"
    }
}

extension GetUserPolicyInput {

    static func urlPathProvider(_ value: GetUserPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension ListAccessKeysInput {

    static func urlPathProvider(_ value: ListAccessKeysInput) -> Swift.String? {
        return "/"
    }
}

extension ListAccountAliasesInput {

    static func urlPathProvider(_ value: ListAccountAliasesInput) -> Swift.String? {
        return "/"
    }
}

extension ListAttachedGroupPoliciesInput {

    static func urlPathProvider(_ value: ListAttachedGroupPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension ListAttachedRolePoliciesInput {

    static func urlPathProvider(_ value: ListAttachedRolePoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension ListAttachedUserPoliciesInput {

    static func urlPathProvider(_ value: ListAttachedUserPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension ListEntitiesForPolicyInput {

    static func urlPathProvider(_ value: ListEntitiesForPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension ListGroupPoliciesInput {

    static func urlPathProvider(_ value: ListGroupPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension ListGroupsInput {

    static func urlPathProvider(_ value: ListGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension ListGroupsForUserInput {

    static func urlPathProvider(_ value: ListGroupsForUserInput) -> Swift.String? {
        return "/"
    }
}

extension ListInstanceProfilesInput {

    static func urlPathProvider(_ value: ListInstanceProfilesInput) -> Swift.String? {
        return "/"
    }
}

extension ListInstanceProfilesForRoleInput {

    static func urlPathProvider(_ value: ListInstanceProfilesForRoleInput) -> Swift.String? {
        return "/"
    }
}

extension ListInstanceProfileTagsInput {

    static func urlPathProvider(_ value: ListInstanceProfileTagsInput) -> Swift.String? {
        return "/"
    }
}

extension ListMFADevicesInput {

    static func urlPathProvider(_ value: ListMFADevicesInput) -> Swift.String? {
        return "/"
    }
}

extension ListMFADeviceTagsInput {

    static func urlPathProvider(_ value: ListMFADeviceTagsInput) -> Swift.String? {
        return "/"
    }
}

extension ListOpenIDConnectProvidersInput {

    static func urlPathProvider(_ value: ListOpenIDConnectProvidersInput) -> Swift.String? {
        return "/"
    }
}

extension ListOpenIDConnectProviderTagsInput {

    static func urlPathProvider(_ value: ListOpenIDConnectProviderTagsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPoliciesInput {

    static func urlPathProvider(_ value: ListPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension ListPoliciesGrantingServiceAccessInput {

    static func urlPathProvider(_ value: ListPoliciesGrantingServiceAccessInput) -> Swift.String? {
        return "/"
    }
}

extension ListPolicyTagsInput {

    static func urlPathProvider(_ value: ListPolicyTagsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPolicyVersionsInput {

    static func urlPathProvider(_ value: ListPolicyVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListRolePoliciesInput {

    static func urlPathProvider(_ value: ListRolePoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension ListRolesInput {

    static func urlPathProvider(_ value: ListRolesInput) -> Swift.String? {
        return "/"
    }
}

extension ListRoleTagsInput {

    static func urlPathProvider(_ value: ListRoleTagsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSAMLProvidersInput {

    static func urlPathProvider(_ value: ListSAMLProvidersInput) -> Swift.String? {
        return "/"
    }
}

extension ListSAMLProviderTagsInput {

    static func urlPathProvider(_ value: ListSAMLProviderTagsInput) -> Swift.String? {
        return "/"
    }
}

extension ListServerCertificatesInput {

    static func urlPathProvider(_ value: ListServerCertificatesInput) -> Swift.String? {
        return "/"
    }
}

extension ListServerCertificateTagsInput {

    static func urlPathProvider(_ value: ListServerCertificateTagsInput) -> Swift.String? {
        return "/"
    }
}

extension ListServiceSpecificCredentialsInput {

    static func urlPathProvider(_ value: ListServiceSpecificCredentialsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSigningCertificatesInput {

    static func urlPathProvider(_ value: ListSigningCertificatesInput) -> Swift.String? {
        return "/"
    }
}

extension ListSSHPublicKeysInput {

    static func urlPathProvider(_ value: ListSSHPublicKeysInput) -> Swift.String? {
        return "/"
    }
}

extension ListUserPoliciesInput {

    static func urlPathProvider(_ value: ListUserPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension ListUsersInput {

    static func urlPathProvider(_ value: ListUsersInput) -> Swift.String? {
        return "/"
    }
}

extension ListUserTagsInput {

    static func urlPathProvider(_ value: ListUserTagsInput) -> Swift.String? {
        return "/"
    }
}

extension ListVirtualMFADevicesInput {

    static func urlPathProvider(_ value: ListVirtualMFADevicesInput) -> Swift.String? {
        return "/"
    }
}

extension PutGroupPolicyInput {

    static func urlPathProvider(_ value: PutGroupPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension PutRolePermissionsBoundaryInput {

    static func urlPathProvider(_ value: PutRolePermissionsBoundaryInput) -> Swift.String? {
        return "/"
    }
}

extension PutRolePolicyInput {

    static func urlPathProvider(_ value: PutRolePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension PutUserPermissionsBoundaryInput {

    static func urlPathProvider(_ value: PutUserPermissionsBoundaryInput) -> Swift.String? {
        return "/"
    }
}

extension PutUserPolicyInput {

    static func urlPathProvider(_ value: PutUserPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension RemoveClientIDFromOpenIDConnectProviderInput {

    static func urlPathProvider(_ value: RemoveClientIDFromOpenIDConnectProviderInput) -> Swift.String? {
        return "/"
    }
}

extension RemoveRoleFromInstanceProfileInput {

    static func urlPathProvider(_ value: RemoveRoleFromInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension RemoveUserFromGroupInput {

    static func urlPathProvider(_ value: RemoveUserFromGroupInput) -> Swift.String? {
        return "/"
    }
}

extension ResetServiceSpecificCredentialInput {

    static func urlPathProvider(_ value: ResetServiceSpecificCredentialInput) -> Swift.String? {
        return "/"
    }
}

extension ResyncMFADeviceInput {

    static func urlPathProvider(_ value: ResyncMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

extension SetDefaultPolicyVersionInput {

    static func urlPathProvider(_ value: SetDefaultPolicyVersionInput) -> Swift.String? {
        return "/"
    }
}

extension SetSecurityTokenServicePreferencesInput {

    static func urlPathProvider(_ value: SetSecurityTokenServicePreferencesInput) -> Swift.String? {
        return "/"
    }
}

extension SimulateCustomPolicyInput {

    static func urlPathProvider(_ value: SimulateCustomPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension SimulatePrincipalPolicyInput {

    static func urlPathProvider(_ value: SimulatePrincipalPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension TagInstanceProfileInput {

    static func urlPathProvider(_ value: TagInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension TagMFADeviceInput {

    static func urlPathProvider(_ value: TagMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

extension TagOpenIDConnectProviderInput {

    static func urlPathProvider(_ value: TagOpenIDConnectProviderInput) -> Swift.String? {
        return "/"
    }
}

extension TagPolicyInput {

    static func urlPathProvider(_ value: TagPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension TagRoleInput {

    static func urlPathProvider(_ value: TagRoleInput) -> Swift.String? {
        return "/"
    }
}

extension TagSAMLProviderInput {

    static func urlPathProvider(_ value: TagSAMLProviderInput) -> Swift.String? {
        return "/"
    }
}

extension TagServerCertificateInput {

    static func urlPathProvider(_ value: TagServerCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension TagUserInput {

    static func urlPathProvider(_ value: TagUserInput) -> Swift.String? {
        return "/"
    }
}

extension UntagInstanceProfileInput {

    static func urlPathProvider(_ value: UntagInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension UntagMFADeviceInput {

    static func urlPathProvider(_ value: UntagMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagOpenIDConnectProviderInput {

    static func urlPathProvider(_ value: UntagOpenIDConnectProviderInput) -> Swift.String? {
        return "/"
    }
}

extension UntagPolicyInput {

    static func urlPathProvider(_ value: UntagPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension UntagRoleInput {

    static func urlPathProvider(_ value: UntagRoleInput) -> Swift.String? {
        return "/"
    }
}

extension UntagSAMLProviderInput {

    static func urlPathProvider(_ value: UntagSAMLProviderInput) -> Swift.String? {
        return "/"
    }
}

extension UntagServerCertificateInput {

    static func urlPathProvider(_ value: UntagServerCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension UntagUserInput {

    static func urlPathProvider(_ value: UntagUserInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAccessKeyInput {

    static func urlPathProvider(_ value: UpdateAccessKeyInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAccountPasswordPolicyInput {

    static func urlPathProvider(_ value: UpdateAccountPasswordPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAssumeRolePolicyInput {

    static func urlPathProvider(_ value: UpdateAssumeRolePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateGroupInput {

    static func urlPathProvider(_ value: UpdateGroupInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateLoginProfileInput {

    static func urlPathProvider(_ value: UpdateLoginProfileInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateOpenIDConnectProviderThumbprintInput {

    static func urlPathProvider(_ value: UpdateOpenIDConnectProviderThumbprintInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRoleInput {

    static func urlPathProvider(_ value: UpdateRoleInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRoleDescriptionInput {

    static func urlPathProvider(_ value: UpdateRoleDescriptionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSAMLProviderInput {

    static func urlPathProvider(_ value: UpdateSAMLProviderInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateServerCertificateInput {

    static func urlPathProvider(_ value: UpdateServerCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateServiceSpecificCredentialInput {

    static func urlPathProvider(_ value: UpdateServiceSpecificCredentialInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSigningCertificateInput {

    static func urlPathProvider(_ value: UpdateSigningCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSSHPublicKeyInput {

    static func urlPathProvider(_ value: UpdateSSHPublicKeyInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateUserInput {

    static func urlPathProvider(_ value: UpdateUserInput) -> Swift.String? {
        return "/"
    }
}

extension UploadServerCertificateInput {

    static func urlPathProvider(_ value: UploadServerCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension UploadSigningCertificateInput {

    static func urlPathProvider(_ value: UploadSigningCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension UploadSSHPublicKeyInput {

    static func urlPathProvider(_ value: UploadSSHPublicKeyInput) -> Swift.String? {
        return "/"
    }
}

extension AddClientIDToOpenIDConnectProviderInput {

    static func write(value: AddClientIDToOpenIDConnectProviderInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ClientID"].write(value.clientID)
        try writer["OpenIDConnectProviderArn"].write(value.openIDConnectProviderArn)
        try writer["Action"].write("AddClientIDToOpenIDConnectProvider")
        try writer["Version"].write("2010-05-08")
    }
}

extension AddRoleToInstanceProfileInput {

    static func write(value: AddRoleToInstanceProfileInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["InstanceProfileName"].write(value.instanceProfileName)
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("AddRoleToInstanceProfile")
        try writer["Version"].write("2010-05-08")
    }
}

extension AddUserToGroupInput {

    static func write(value: AddUserToGroupInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("AddUserToGroup")
        try writer["Version"].write("2010-05-08")
    }
}

extension AttachGroupPolicyInput {

    static func write(value: AttachGroupPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
        try writer["PolicyArn"].write(value.policyArn)
        try writer["Action"].write("AttachGroupPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension AttachRolePolicyInput {

    static func write(value: AttachRolePolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyArn"].write(value.policyArn)
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("AttachRolePolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension AttachUserPolicyInput {

    static func write(value: AttachUserPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyArn"].write(value.policyArn)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("AttachUserPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension ChangePasswordInput {

    static func write(value: ChangePasswordInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["NewPassword"].write(value.newPassword)
        try writer["OldPassword"].write(value.oldPassword)
        try writer["Action"].write("ChangePassword")
        try writer["Version"].write("2010-05-08")
    }
}

extension CreateAccessKeyInput {

    static func write(value: CreateAccessKeyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("CreateAccessKey")
        try writer["Version"].write("2010-05-08")
    }
}

extension CreateAccountAliasInput {

    static func write(value: CreateAccountAliasInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AccountAlias"].write(value.accountAlias)
        try writer["Action"].write("CreateAccountAlias")
        try writer["Version"].write("2010-05-08")
    }
}

extension CreateGroupInput {

    static func write(value: CreateGroupInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
        try writer["Path"].write(value.path)
        try writer["Action"].write("CreateGroup")
        try writer["Version"].write("2010-05-08")
    }
}

extension CreateInstanceProfileInput {

    static func write(value: CreateInstanceProfileInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["InstanceProfileName"].write(value.instanceProfileName)
        try writer["Path"].write(value.path)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("CreateInstanceProfile")
        try writer["Version"].write("2010-05-08")
    }
}

extension CreateLoginProfileInput {

    static func write(value: CreateLoginProfileInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Password"].write(value.password)
        try writer["PasswordResetRequired"].write(value.passwordResetRequired)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("CreateLoginProfile")
        try writer["Version"].write("2010-05-08")
    }
}

extension CreateOpenIDConnectProviderInput {

    static func write(value: CreateOpenIDConnectProviderInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ClientIDList"].writeList(value.clientIDList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ThumbprintList"].writeList(value.thumbprintList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Url"].write(value.url)
        try writer["Action"].write("CreateOpenIDConnectProvider")
        try writer["Version"].write("2010-05-08")
    }
}

extension CreatePolicyInput {

    static func write(value: CreatePolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Path"].write(value.path)
        try writer["PolicyDocument"].write(value.policyDocument)
        try writer["PolicyName"].write(value.policyName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("CreatePolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension CreatePolicyVersionInput {

    static func write(value: CreatePolicyVersionInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyArn"].write(value.policyArn)
        try writer["PolicyDocument"].write(value.policyDocument)
        try writer["SetAsDefault"].write(value.setAsDefault)
        try writer["Action"].write("CreatePolicyVersion")
        try writer["Version"].write("2010-05-08")
    }
}

extension CreateRoleInput {

    static func write(value: CreateRoleInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AssumeRolePolicyDocument"].write(value.assumeRolePolicyDocument)
        try writer["Description"].write(value.description)
        try writer["MaxSessionDuration"].write(value.maxSessionDuration)
        try writer["Path"].write(value.path)
        try writer["PermissionsBoundary"].write(value.permissionsBoundary)
        try writer["RoleName"].write(value.roleName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("CreateRole")
        try writer["Version"].write("2010-05-08")
    }
}

extension CreateSAMLProviderInput {

    static func write(value: CreateSAMLProviderInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["SAMLMetadataDocument"].write(value.samlMetadataDocument)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("CreateSAMLProvider")
        try writer["Version"].write("2010-05-08")
    }
}

extension CreateServiceLinkedRoleInput {

    static func write(value: CreateServiceLinkedRoleInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AWSServiceName"].write(value.awsServiceName)
        try writer["CustomSuffix"].write(value.customSuffix)
        try writer["Description"].write(value.description)
        try writer["Action"].write("CreateServiceLinkedRole")
        try writer["Version"].write("2010-05-08")
    }
}

extension CreateServiceSpecificCredentialInput {

    static func write(value: CreateServiceSpecificCredentialInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ServiceName"].write(value.serviceName)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("CreateServiceSpecificCredential")
        try writer["Version"].write("2010-05-08")
    }
}

extension CreateUserInput {

    static func write(value: CreateUserInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Path"].write(value.path)
        try writer["PermissionsBoundary"].write(value.permissionsBoundary)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("CreateUser")
        try writer["Version"].write("2010-05-08")
    }
}

extension CreateVirtualMFADeviceInput {

    static func write(value: CreateVirtualMFADeviceInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Path"].write(value.path)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VirtualMFADeviceName"].write(value.virtualMFADeviceName)
        try writer["Action"].write("CreateVirtualMFADevice")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeactivateMFADeviceInput {

    static func write(value: DeactivateMFADeviceInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["SerialNumber"].write(value.serialNumber)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("DeactivateMFADevice")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteAccessKeyInput {

    static func write(value: DeleteAccessKeyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AccessKeyId"].write(value.accessKeyId)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("DeleteAccessKey")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteAccountAliasInput {

    static func write(value: DeleteAccountAliasInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AccountAlias"].write(value.accountAlias)
        try writer["Action"].write("DeleteAccountAlias")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteAccountPasswordPolicyInput {

    static func write(value: DeleteAccountPasswordPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
        try writer["Action"].write("DeleteAccountPasswordPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteGroupInput {

    static func write(value: DeleteGroupInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
        try writer["Action"].write("DeleteGroup")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteGroupPolicyInput {

    static func write(value: DeleteGroupPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
        try writer["PolicyName"].write(value.policyName)
        try writer["Action"].write("DeleteGroupPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteInstanceProfileInput {

    static func write(value: DeleteInstanceProfileInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["InstanceProfileName"].write(value.instanceProfileName)
        try writer["Action"].write("DeleteInstanceProfile")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteLoginProfileInput {

    static func write(value: DeleteLoginProfileInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("DeleteLoginProfile")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteOpenIDConnectProviderInput {

    static func write(value: DeleteOpenIDConnectProviderInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["OpenIDConnectProviderArn"].write(value.openIDConnectProviderArn)
        try writer["Action"].write("DeleteOpenIDConnectProvider")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeletePolicyInput {

    static func write(value: DeletePolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyArn"].write(value.policyArn)
        try writer["Action"].write("DeletePolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeletePolicyVersionInput {

    static func write(value: DeletePolicyVersionInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyArn"].write(value.policyArn)
        try writer["VersionId"].write(value.versionId)
        try writer["Action"].write("DeletePolicyVersion")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteRoleInput {

    static func write(value: DeleteRoleInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("DeleteRole")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteRolePermissionsBoundaryInput {

    static func write(value: DeleteRolePermissionsBoundaryInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("DeleteRolePermissionsBoundary")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteRolePolicyInput {

    static func write(value: DeleteRolePolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyName"].write(value.policyName)
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("DeleteRolePolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteSAMLProviderInput {

    static func write(value: DeleteSAMLProviderInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["SAMLProviderArn"].write(value.samlProviderArn)
        try writer["Action"].write("DeleteSAMLProvider")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteServerCertificateInput {

    static func write(value: DeleteServerCertificateInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ServerCertificateName"].write(value.serverCertificateName)
        try writer["Action"].write("DeleteServerCertificate")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteServiceLinkedRoleInput {

    static func write(value: DeleteServiceLinkedRoleInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("DeleteServiceLinkedRole")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteServiceSpecificCredentialInput {

    static func write(value: DeleteServiceSpecificCredentialInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ServiceSpecificCredentialId"].write(value.serviceSpecificCredentialId)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("DeleteServiceSpecificCredential")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteSigningCertificateInput {

    static func write(value: DeleteSigningCertificateInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["CertificateId"].write(value.certificateId)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("DeleteSigningCertificate")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteSSHPublicKeyInput {

    static func write(value: DeleteSSHPublicKeyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["SSHPublicKeyId"].write(value.sshPublicKeyId)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("DeleteSSHPublicKey")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteUserInput {

    static func write(value: DeleteUserInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("DeleteUser")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteUserPermissionsBoundaryInput {

    static func write(value: DeleteUserPermissionsBoundaryInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("DeleteUserPermissionsBoundary")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteUserPolicyInput {

    static func write(value: DeleteUserPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyName"].write(value.policyName)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("DeleteUserPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension DeleteVirtualMFADeviceInput {

    static func write(value: DeleteVirtualMFADeviceInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["SerialNumber"].write(value.serialNumber)
        try writer["Action"].write("DeleteVirtualMFADevice")
        try writer["Version"].write("2010-05-08")
    }
}

extension DetachGroupPolicyInput {

    static func write(value: DetachGroupPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
        try writer["PolicyArn"].write(value.policyArn)
        try writer["Action"].write("DetachGroupPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension DetachRolePolicyInput {

    static func write(value: DetachRolePolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyArn"].write(value.policyArn)
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("DetachRolePolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension DetachUserPolicyInput {

    static func write(value: DetachUserPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyArn"].write(value.policyArn)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("DetachUserPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension EnableMFADeviceInput {

    static func write(value: EnableMFADeviceInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationCode1"].write(value.authenticationCode1)
        try writer["AuthenticationCode2"].write(value.authenticationCode2)
        try writer["SerialNumber"].write(value.serialNumber)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("EnableMFADevice")
        try writer["Version"].write("2010-05-08")
    }
}

extension GenerateCredentialReportInput {

    static func write(value: GenerateCredentialReportInput?, to writer: SmithyFormURL.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
        try writer["Action"].write("GenerateCredentialReport")
        try writer["Version"].write("2010-05-08")
    }
}

extension GenerateOrganizationsAccessReportInput {

    static func write(value: GenerateOrganizationsAccessReportInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["EntityPath"].write(value.entityPath)
        try writer["OrganizationsPolicyId"].write(value.organizationsPolicyId)
        try writer["Action"].write("GenerateOrganizationsAccessReport")
        try writer["Version"].write("2010-05-08")
    }
}

extension GenerateServiceLastAccessedDetailsInput {

    static func write(value: GenerateServiceLastAccessedDetailsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Granularity"].write(value.granularity)
        try writer["Action"].write("GenerateServiceLastAccessedDetails")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetAccessKeyLastUsedInput {

    static func write(value: GetAccessKeyLastUsedInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AccessKeyId"].write(value.accessKeyId)
        try writer["Action"].write("GetAccessKeyLastUsed")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetAccountAuthorizationDetailsInput {

    static func write(value: GetAccountAuthorizationDetailsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Filter"].writeList(value.filter, memberWritingClosure: SmithyReadWrite.WritingClosureBox<IAMClientTypes.EntityType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["Action"].write("GetAccountAuthorizationDetails")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetAccountPasswordPolicyInput {

    static func write(value: GetAccountPasswordPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
        try writer["Action"].write("GetAccountPasswordPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetAccountSummaryInput {

    static func write(value: GetAccountSummaryInput?, to writer: SmithyFormURL.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
        try writer["Action"].write("GetAccountSummary")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetContextKeysForCustomPolicyInput {

    static func write(value: GetContextKeysForCustomPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyInputList"].writeList(value.policyInputList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("GetContextKeysForCustomPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetContextKeysForPrincipalPolicyInput {

    static func write(value: GetContextKeysForPrincipalPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyInputList"].writeList(value.policyInputList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PolicySourceArn"].write(value.policySourceArn)
        try writer["Action"].write("GetContextKeysForPrincipalPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetCredentialReportInput {

    static func write(value: GetCredentialReportInput?, to writer: SmithyFormURL.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
        try writer["Action"].write("GetCredentialReport")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetGroupInput {

    static func write(value: GetGroupInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["Action"].write("GetGroup")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetGroupPolicyInput {

    static func write(value: GetGroupPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
        try writer["PolicyName"].write(value.policyName)
        try writer["Action"].write("GetGroupPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetInstanceProfileInput {

    static func write(value: GetInstanceProfileInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["InstanceProfileName"].write(value.instanceProfileName)
        try writer["Action"].write("GetInstanceProfile")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetLoginProfileInput {

    static func write(value: GetLoginProfileInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("GetLoginProfile")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetMFADeviceInput {

    static func write(value: GetMFADeviceInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["SerialNumber"].write(value.serialNumber)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("GetMFADevice")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetOpenIDConnectProviderInput {

    static func write(value: GetOpenIDConnectProviderInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["OpenIDConnectProviderArn"].write(value.openIDConnectProviderArn)
        try writer["Action"].write("GetOpenIDConnectProvider")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetOrganizationsAccessReportInput {

    static func write(value: GetOrganizationsAccessReportInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["JobId"].write(value.jobId)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["SortKey"].write(value.sortKey)
        try writer["Action"].write("GetOrganizationsAccessReport")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetPolicyInput {

    static func write(value: GetPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyArn"].write(value.policyArn)
        try writer["Action"].write("GetPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetPolicyVersionInput {

    static func write(value: GetPolicyVersionInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyArn"].write(value.policyArn)
        try writer["VersionId"].write(value.versionId)
        try writer["Action"].write("GetPolicyVersion")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetRoleInput {

    static func write(value: GetRoleInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("GetRole")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetRolePolicyInput {

    static func write(value: GetRolePolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyName"].write(value.policyName)
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("GetRolePolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetSAMLProviderInput {

    static func write(value: GetSAMLProviderInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["SAMLProviderArn"].write(value.samlProviderArn)
        try writer["Action"].write("GetSAMLProvider")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetServerCertificateInput {

    static func write(value: GetServerCertificateInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ServerCertificateName"].write(value.serverCertificateName)
        try writer["Action"].write("GetServerCertificate")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetServiceLastAccessedDetailsInput {

    static func write(value: GetServiceLastAccessedDetailsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["JobId"].write(value.jobId)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["Action"].write("GetServiceLastAccessedDetails")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetServiceLastAccessedDetailsWithEntitiesInput {

    static func write(value: GetServiceLastAccessedDetailsWithEntitiesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["JobId"].write(value.jobId)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["ServiceNamespace"].write(value.serviceNamespace)
        try writer["Action"].write("GetServiceLastAccessedDetailsWithEntities")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetServiceLinkedRoleDeletionStatusInput {

    static func write(value: GetServiceLinkedRoleDeletionStatusInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DeletionTaskId"].write(value.deletionTaskId)
        try writer["Action"].write("GetServiceLinkedRoleDeletionStatus")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetSSHPublicKeyInput {

    static func write(value: GetSSHPublicKeyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Encoding"].write(value.encoding)
        try writer["SSHPublicKeyId"].write(value.sshPublicKeyId)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("GetSSHPublicKey")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetUserInput {

    static func write(value: GetUserInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("GetUser")
        try writer["Version"].write("2010-05-08")
    }
}

extension GetUserPolicyInput {

    static func write(value: GetUserPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyName"].write(value.policyName)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("GetUserPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListAccessKeysInput {

    static func write(value: ListAccessKeysInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("ListAccessKeys")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListAccountAliasesInput {

    static func write(value: ListAccountAliasesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["Action"].write("ListAccountAliases")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListAttachedGroupPoliciesInput {

    static func write(value: ListAttachedGroupPoliciesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["PathPrefix"].write(value.pathPrefix)
        try writer["Action"].write("ListAttachedGroupPolicies")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListAttachedRolePoliciesInput {

    static func write(value: ListAttachedRolePoliciesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["PathPrefix"].write(value.pathPrefix)
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("ListAttachedRolePolicies")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListAttachedUserPoliciesInput {

    static func write(value: ListAttachedUserPoliciesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["PathPrefix"].write(value.pathPrefix)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("ListAttachedUserPolicies")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListEntitiesForPolicyInput {

    static func write(value: ListEntitiesForPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["EntityFilter"].write(value.entityFilter)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["PathPrefix"].write(value.pathPrefix)
        try writer["PolicyArn"].write(value.policyArn)
        try writer["PolicyUsageFilter"].write(value.policyUsageFilter)
        try writer["Action"].write("ListEntitiesForPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListGroupPoliciesInput {

    static func write(value: ListGroupPoliciesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["Action"].write("ListGroupPolicies")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListGroupsInput {

    static func write(value: ListGroupsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["PathPrefix"].write(value.pathPrefix)
        try writer["Action"].write("ListGroups")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListGroupsForUserInput {

    static func write(value: ListGroupsForUserInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("ListGroupsForUser")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListInstanceProfilesInput {

    static func write(value: ListInstanceProfilesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["PathPrefix"].write(value.pathPrefix)
        try writer["Action"].write("ListInstanceProfiles")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListInstanceProfilesForRoleInput {

    static func write(value: ListInstanceProfilesForRoleInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("ListInstanceProfilesForRole")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListInstanceProfileTagsInput {

    static func write(value: ListInstanceProfileTagsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["InstanceProfileName"].write(value.instanceProfileName)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["Action"].write("ListInstanceProfileTags")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListMFADevicesInput {

    static func write(value: ListMFADevicesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("ListMFADevices")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListMFADeviceTagsInput {

    static func write(value: ListMFADeviceTagsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["SerialNumber"].write(value.serialNumber)
        try writer["Action"].write("ListMFADeviceTags")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListOpenIDConnectProvidersInput {

    static func write(value: ListOpenIDConnectProvidersInput?, to writer: SmithyFormURL.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
        try writer["Action"].write("ListOpenIDConnectProviders")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListOpenIDConnectProviderTagsInput {

    static func write(value: ListOpenIDConnectProviderTagsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["OpenIDConnectProviderArn"].write(value.openIDConnectProviderArn)
        try writer["Action"].write("ListOpenIDConnectProviderTags")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListPoliciesInput {

    static func write(value: ListPoliciesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["OnlyAttached"].write(value.onlyAttached)
        try writer["PathPrefix"].write(value.pathPrefix)
        try writer["PolicyUsageFilter"].write(value.policyUsageFilter)
        try writer["Scope"].write(value.scope)
        try writer["Action"].write("ListPolicies")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListPoliciesGrantingServiceAccessInput {

    static func write(value: ListPoliciesGrantingServiceAccessInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Marker"].write(value.marker)
        try writer["ServiceNamespaces"].writeList(value.serviceNamespaces, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("ListPoliciesGrantingServiceAccess")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListPolicyTagsInput {

    static func write(value: ListPolicyTagsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["PolicyArn"].write(value.policyArn)
        try writer["Action"].write("ListPolicyTags")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListPolicyVersionsInput {

    static func write(value: ListPolicyVersionsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["PolicyArn"].write(value.policyArn)
        try writer["Action"].write("ListPolicyVersions")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListRolePoliciesInput {

    static func write(value: ListRolePoliciesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("ListRolePolicies")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListRolesInput {

    static func write(value: ListRolesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["PathPrefix"].write(value.pathPrefix)
        try writer["Action"].write("ListRoles")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListRoleTagsInput {

    static func write(value: ListRoleTagsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("ListRoleTags")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListSAMLProvidersInput {

    static func write(value: ListSAMLProvidersInput?, to writer: SmithyFormURL.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
        try writer["Action"].write("ListSAMLProviders")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListSAMLProviderTagsInput {

    static func write(value: ListSAMLProviderTagsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["SAMLProviderArn"].write(value.samlProviderArn)
        try writer["Action"].write("ListSAMLProviderTags")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListServerCertificatesInput {

    static func write(value: ListServerCertificatesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["PathPrefix"].write(value.pathPrefix)
        try writer["Action"].write("ListServerCertificates")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListServerCertificateTagsInput {

    static func write(value: ListServerCertificateTagsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["ServerCertificateName"].write(value.serverCertificateName)
        try writer["Action"].write("ListServerCertificateTags")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListServiceSpecificCredentialsInput {

    static func write(value: ListServiceSpecificCredentialsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ServiceName"].write(value.serviceName)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("ListServiceSpecificCredentials")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListSigningCertificatesInput {

    static func write(value: ListSigningCertificatesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("ListSigningCertificates")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListSSHPublicKeysInput {

    static func write(value: ListSSHPublicKeysInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("ListSSHPublicKeys")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListUserPoliciesInput {

    static func write(value: ListUserPoliciesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("ListUserPolicies")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListUsersInput {

    static func write(value: ListUsersInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["PathPrefix"].write(value.pathPrefix)
        try writer["Action"].write("ListUsers")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListUserTagsInput {

    static func write(value: ListUserTagsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("ListUserTags")
        try writer["Version"].write("2010-05-08")
    }
}

extension ListVirtualMFADevicesInput {

    static func write(value: ListVirtualMFADevicesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AssignmentStatus"].write(value.assignmentStatus)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["Action"].write("ListVirtualMFADevices")
        try writer["Version"].write("2010-05-08")
    }
}

extension PutGroupPolicyInput {

    static func write(value: PutGroupPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
        try writer["PolicyDocument"].write(value.policyDocument)
        try writer["PolicyName"].write(value.policyName)
        try writer["Action"].write("PutGroupPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension PutRolePermissionsBoundaryInput {

    static func write(value: PutRolePermissionsBoundaryInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PermissionsBoundary"].write(value.permissionsBoundary)
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("PutRolePermissionsBoundary")
        try writer["Version"].write("2010-05-08")
    }
}

extension PutRolePolicyInput {

    static func write(value: PutRolePolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyDocument"].write(value.policyDocument)
        try writer["PolicyName"].write(value.policyName)
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("PutRolePolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension PutUserPermissionsBoundaryInput {

    static func write(value: PutUserPermissionsBoundaryInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PermissionsBoundary"].write(value.permissionsBoundary)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("PutUserPermissionsBoundary")
        try writer["Version"].write("2010-05-08")
    }
}

extension PutUserPolicyInput {

    static func write(value: PutUserPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyDocument"].write(value.policyDocument)
        try writer["PolicyName"].write(value.policyName)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("PutUserPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension RemoveClientIDFromOpenIDConnectProviderInput {

    static func write(value: RemoveClientIDFromOpenIDConnectProviderInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ClientID"].write(value.clientID)
        try writer["OpenIDConnectProviderArn"].write(value.openIDConnectProviderArn)
        try writer["Action"].write("RemoveClientIDFromOpenIDConnectProvider")
        try writer["Version"].write("2010-05-08")
    }
}

extension RemoveRoleFromInstanceProfileInput {

    static func write(value: RemoveRoleFromInstanceProfileInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["InstanceProfileName"].write(value.instanceProfileName)
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("RemoveRoleFromInstanceProfile")
        try writer["Version"].write("2010-05-08")
    }
}

extension RemoveUserFromGroupInput {

    static func write(value: RemoveUserFromGroupInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("RemoveUserFromGroup")
        try writer["Version"].write("2010-05-08")
    }
}

extension ResetServiceSpecificCredentialInput {

    static func write(value: ResetServiceSpecificCredentialInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ServiceSpecificCredentialId"].write(value.serviceSpecificCredentialId)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("ResetServiceSpecificCredential")
        try writer["Version"].write("2010-05-08")
    }
}

extension ResyncMFADeviceInput {

    static func write(value: ResyncMFADeviceInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationCode1"].write(value.authenticationCode1)
        try writer["AuthenticationCode2"].write(value.authenticationCode2)
        try writer["SerialNumber"].write(value.serialNumber)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("ResyncMFADevice")
        try writer["Version"].write("2010-05-08")
    }
}

extension SetDefaultPolicyVersionInput {

    static func write(value: SetDefaultPolicyVersionInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyArn"].write(value.policyArn)
        try writer["VersionId"].write(value.versionId)
        try writer["Action"].write("SetDefaultPolicyVersion")
        try writer["Version"].write("2010-05-08")
    }
}

extension SetSecurityTokenServicePreferencesInput {

    static func write(value: SetSecurityTokenServicePreferencesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["GlobalEndpointTokenVersion"].write(value.globalEndpointTokenVersion)
        try writer["Action"].write("SetSecurityTokenServicePreferences")
        try writer["Version"].write("2010-05-08")
    }
}

extension SimulateCustomPolicyInput {

    static func write(value: SimulateCustomPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ActionNames"].writeList(value.actionNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CallerArn"].write(value.callerArn)
        try writer["ContextEntries"].writeList(value.contextEntries, memberWritingClosure: IAMClientTypes.ContextEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["PermissionsBoundaryPolicyInputList"].writeList(value.permissionsBoundaryPolicyInputList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PolicyInputList"].writeList(value.policyInputList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceArns"].writeList(value.resourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceHandlingOption"].write(value.resourceHandlingOption)
        try writer["ResourceOwner"].write(value.resourceOwner)
        try writer["ResourcePolicy"].write(value.resourcePolicy)
        try writer["Action"].write("SimulateCustomPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension SimulatePrincipalPolicyInput {

    static func write(value: SimulatePrincipalPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ActionNames"].writeList(value.actionNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CallerArn"].write(value.callerArn)
        try writer["ContextEntries"].writeList(value.contextEntries, memberWritingClosure: IAMClientTypes.ContextEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["PermissionsBoundaryPolicyInputList"].writeList(value.permissionsBoundaryPolicyInputList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PolicyInputList"].writeList(value.policyInputList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PolicySourceArn"].write(value.policySourceArn)
        try writer["ResourceArns"].writeList(value.resourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceHandlingOption"].write(value.resourceHandlingOption)
        try writer["ResourceOwner"].write(value.resourceOwner)
        try writer["ResourcePolicy"].write(value.resourcePolicy)
        try writer["Action"].write("SimulatePrincipalPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension TagInstanceProfileInput {

    static func write(value: TagInstanceProfileInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["InstanceProfileName"].write(value.instanceProfileName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("TagInstanceProfile")
        try writer["Version"].write("2010-05-08")
    }
}

extension TagMFADeviceInput {

    static func write(value: TagMFADeviceInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["SerialNumber"].write(value.serialNumber)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("TagMFADevice")
        try writer["Version"].write("2010-05-08")
    }
}

extension TagOpenIDConnectProviderInput {

    static func write(value: TagOpenIDConnectProviderInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["OpenIDConnectProviderArn"].write(value.openIDConnectProviderArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("TagOpenIDConnectProvider")
        try writer["Version"].write("2010-05-08")
    }
}

extension TagPolicyInput {

    static func write(value: TagPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyArn"].write(value.policyArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("TagPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension TagRoleInput {

    static func write(value: TagRoleInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["RoleName"].write(value.roleName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("TagRole")
        try writer["Version"].write("2010-05-08")
    }
}

extension TagSAMLProviderInput {

    static func write(value: TagSAMLProviderInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["SAMLProviderArn"].write(value.samlProviderArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("TagSAMLProvider")
        try writer["Version"].write("2010-05-08")
    }
}

extension TagServerCertificateInput {

    static func write(value: TagServerCertificateInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ServerCertificateName"].write(value.serverCertificateName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("TagServerCertificate")
        try writer["Version"].write("2010-05-08")
    }
}

extension TagUserInput {

    static func write(value: TagUserInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("TagUser")
        try writer["Version"].write("2010-05-08")
    }
}

extension UntagInstanceProfileInput {

    static func write(value: UntagInstanceProfileInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["InstanceProfileName"].write(value.instanceProfileName)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("UntagInstanceProfile")
        try writer["Version"].write("2010-05-08")
    }
}

extension UntagMFADeviceInput {

    static func write(value: UntagMFADeviceInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["SerialNumber"].write(value.serialNumber)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("UntagMFADevice")
        try writer["Version"].write("2010-05-08")
    }
}

extension UntagOpenIDConnectProviderInput {

    static func write(value: UntagOpenIDConnectProviderInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["OpenIDConnectProviderArn"].write(value.openIDConnectProviderArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("UntagOpenIDConnectProvider")
        try writer["Version"].write("2010-05-08")
    }
}

extension UntagPolicyInput {

    static func write(value: UntagPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyArn"].write(value.policyArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("UntagPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension UntagRoleInput {

    static func write(value: UntagRoleInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["RoleName"].write(value.roleName)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("UntagRole")
        try writer["Version"].write("2010-05-08")
    }
}

extension UntagSAMLProviderInput {

    static func write(value: UntagSAMLProviderInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["SAMLProviderArn"].write(value.samlProviderArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("UntagSAMLProvider")
        try writer["Version"].write("2010-05-08")
    }
}

extension UntagServerCertificateInput {

    static func write(value: UntagServerCertificateInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ServerCertificateName"].write(value.serverCertificateName)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("UntagServerCertificate")
        try writer["Version"].write("2010-05-08")
    }
}

extension UntagUserInput {

    static func write(value: UntagUserInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("UntagUser")
        try writer["Version"].write("2010-05-08")
    }
}

extension UpdateAccessKeyInput {

    static func write(value: UpdateAccessKeyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AccessKeyId"].write(value.accessKeyId)
        try writer["Status"].write(value.status)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("UpdateAccessKey")
        try writer["Version"].write("2010-05-08")
    }
}

extension UpdateAccountPasswordPolicyInput {

    static func write(value: UpdateAccountPasswordPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AllowUsersToChangePassword"].write(value.allowUsersToChangePassword)
        try writer["HardExpiry"].write(value.hardExpiry)
        try writer["MaxPasswordAge"].write(value.maxPasswordAge)
        try writer["MinimumPasswordLength"].write(value.minimumPasswordLength)
        try writer["PasswordReusePrevention"].write(value.passwordReusePrevention)
        try writer["RequireLowercaseCharacters"].write(value.requireLowercaseCharacters)
        try writer["RequireNumbers"].write(value.requireNumbers)
        try writer["RequireSymbols"].write(value.requireSymbols)
        try writer["RequireUppercaseCharacters"].write(value.requireUppercaseCharacters)
        try writer["Action"].write("UpdateAccountPasswordPolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension UpdateAssumeRolePolicyInput {

    static func write(value: UpdateAssumeRolePolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyDocument"].write(value.policyDocument)
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("UpdateAssumeRolePolicy")
        try writer["Version"].write("2010-05-08")
    }
}

extension UpdateGroupInput {

    static func write(value: UpdateGroupInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
        try writer["NewGroupName"].write(value.newGroupName)
        try writer["NewPath"].write(value.newPath)
        try writer["Action"].write("UpdateGroup")
        try writer["Version"].write("2010-05-08")
    }
}

extension UpdateLoginProfileInput {

    static func write(value: UpdateLoginProfileInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Password"].write(value.password)
        try writer["PasswordResetRequired"].write(value.passwordResetRequired)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("UpdateLoginProfile")
        try writer["Version"].write("2010-05-08")
    }
}

extension UpdateOpenIDConnectProviderThumbprintInput {

    static func write(value: UpdateOpenIDConnectProviderThumbprintInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["OpenIDConnectProviderArn"].write(value.openIDConnectProviderArn)
        try writer["ThumbprintList"].writeList(value.thumbprintList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("UpdateOpenIDConnectProviderThumbprint")
        try writer["Version"].write("2010-05-08")
    }
}

extension UpdateRoleInput {

    static func write(value: UpdateRoleInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["MaxSessionDuration"].write(value.maxSessionDuration)
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("UpdateRole")
        try writer["Version"].write("2010-05-08")
    }
}

extension UpdateRoleDescriptionInput {

    static func write(value: UpdateRoleDescriptionInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["RoleName"].write(value.roleName)
        try writer["Action"].write("UpdateRoleDescription")
        try writer["Version"].write("2010-05-08")
    }
}

extension UpdateSAMLProviderInput {

    static func write(value: UpdateSAMLProviderInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["SAMLMetadataDocument"].write(value.samlMetadataDocument)
        try writer["SAMLProviderArn"].write(value.samlProviderArn)
        try writer["Action"].write("UpdateSAMLProvider")
        try writer["Version"].write("2010-05-08")
    }
}

extension UpdateServerCertificateInput {

    static func write(value: UpdateServerCertificateInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["NewPath"].write(value.newPath)
        try writer["NewServerCertificateName"].write(value.newServerCertificateName)
        try writer["ServerCertificateName"].write(value.serverCertificateName)
        try writer["Action"].write("UpdateServerCertificate")
        try writer["Version"].write("2010-05-08")
    }
}

extension UpdateServiceSpecificCredentialInput {

    static func write(value: UpdateServiceSpecificCredentialInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ServiceSpecificCredentialId"].write(value.serviceSpecificCredentialId)
        try writer["Status"].write(value.status)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("UpdateServiceSpecificCredential")
        try writer["Version"].write("2010-05-08")
    }
}

extension UpdateSigningCertificateInput {

    static func write(value: UpdateSigningCertificateInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["CertificateId"].write(value.certificateId)
        try writer["Status"].write(value.status)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("UpdateSigningCertificate")
        try writer["Version"].write("2010-05-08")
    }
}

extension UpdateSSHPublicKeyInput {

    static func write(value: UpdateSSHPublicKeyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["SSHPublicKeyId"].write(value.sshPublicKeyId)
        try writer["Status"].write(value.status)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("UpdateSSHPublicKey")
        try writer["Version"].write("2010-05-08")
    }
}

extension UpdateUserInput {

    static func write(value: UpdateUserInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["NewPath"].write(value.newPath)
        try writer["NewUserName"].write(value.newUserName)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("UpdateUser")
        try writer["Version"].write("2010-05-08")
    }
}

extension UploadServerCertificateInput {

    static func write(value: UploadServerCertificateInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["CertificateBody"].write(value.certificateBody)
        try writer["CertificateChain"].write(value.certificateChain)
        try writer["Path"].write(value.path)
        try writer["PrivateKey"].write(value.privateKey)
        try writer["ServerCertificateName"].write(value.serverCertificateName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IAMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("UploadServerCertificate")
        try writer["Version"].write("2010-05-08")
    }
}

extension UploadSigningCertificateInput {

    static func write(value: UploadSigningCertificateInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["CertificateBody"].write(value.certificateBody)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("UploadSigningCertificate")
        try writer["Version"].write("2010-05-08")
    }
}

extension UploadSSHPublicKeyInput {

    static func write(value: UploadSSHPublicKeyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["SSHPublicKeyBody"].write(value.sshPublicKeyBody)
        try writer["UserName"].write(value.userName)
        try writer["Action"].write("UploadSSHPublicKey")
        try writer["Version"].write("2010-05-08")
    }
}

extension AddClientIDToOpenIDConnectProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddClientIDToOpenIDConnectProviderOutput {
        return AddClientIDToOpenIDConnectProviderOutput()
    }
}

extension AddRoleToInstanceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddRoleToInstanceProfileOutput {
        return AddRoleToInstanceProfileOutput()
    }
}

extension AddUserToGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddUserToGroupOutput {
        return AddUserToGroupOutput()
    }
}

extension AttachGroupPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachGroupPolicyOutput {
        return AttachGroupPolicyOutput()
    }
}

extension AttachRolePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachRolePolicyOutput {
        return AttachRolePolicyOutput()
    }
}

extension AttachUserPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachUserPolicyOutput {
        return AttachUserPolicyOutput()
    }
}

extension ChangePasswordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ChangePasswordOutput {
        return ChangePasswordOutput()
    }
}

extension CreateAccessKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccessKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreateAccessKeyResult"]
        var value = CreateAccessKeyOutput()
        value.accessKey = try reader["AccessKey"].readIfPresent(with: IAMClientTypes.AccessKey.read(from:))
        return value
    }
}

extension CreateAccountAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccountAliasOutput {
        return CreateAccountAliasOutput()
    }
}

extension CreateGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreateGroupResult"]
        var value = CreateGroupOutput()
        value.group = try reader["Group"].readIfPresent(with: IAMClientTypes.Group.read(from:))
        return value
    }
}

extension CreateInstanceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInstanceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreateInstanceProfileResult"]
        var value = CreateInstanceProfileOutput()
        value.instanceProfile = try reader["InstanceProfile"].readIfPresent(with: IAMClientTypes.InstanceProfile.read(from:))
        return value
    }
}

extension CreateLoginProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLoginProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreateLoginProfileResult"]
        var value = CreateLoginProfileOutput()
        value.loginProfile = try reader["LoginProfile"].readIfPresent(with: IAMClientTypes.LoginProfile.read(from:))
        return value
    }
}

extension CreateOpenIDConnectProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOpenIDConnectProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreateOpenIDConnectProviderResult"]
        var value = CreateOpenIDConnectProviderOutput()
        value.openIDConnectProviderArn = try reader["OpenIDConnectProviderArn"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreatePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreatePolicyResult"]
        var value = CreatePolicyOutput()
        value.policy = try reader["Policy"].readIfPresent(with: IAMClientTypes.Policy.read(from:))
        return value
    }
}

extension CreatePolicyVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePolicyVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreatePolicyVersionResult"]
        var value = CreatePolicyVersionOutput()
        value.policyVersion = try reader["PolicyVersion"].readIfPresent(with: IAMClientTypes.PolicyVersion.read(from:))
        return value
    }
}

extension CreateRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRoleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreateRoleResult"]
        var value = CreateRoleOutput()
        value.role = try reader["Role"].readIfPresent(with: IAMClientTypes.Role.read(from:))
        return value
    }
}

extension CreateSAMLProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSAMLProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreateSAMLProviderResult"]
        var value = CreateSAMLProviderOutput()
        value.samlProviderArn = try reader["SAMLProviderArn"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateServiceLinkedRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceLinkedRoleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreateServiceLinkedRoleResult"]
        var value = CreateServiceLinkedRoleOutput()
        value.role = try reader["Role"].readIfPresent(with: IAMClientTypes.Role.read(from:))
        return value
    }
}

extension CreateServiceSpecificCredentialOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceSpecificCredentialOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreateServiceSpecificCredentialResult"]
        var value = CreateServiceSpecificCredentialOutput()
        value.serviceSpecificCredential = try reader["ServiceSpecificCredential"].readIfPresent(with: IAMClientTypes.ServiceSpecificCredential.read(from:))
        return value
    }
}

extension CreateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreateUserResult"]
        var value = CreateUserOutput()
        value.user = try reader["User"].readIfPresent(with: IAMClientTypes.User.read(from:))
        return value
    }
}

extension CreateVirtualMFADeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVirtualMFADeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreateVirtualMFADeviceResult"]
        var value = CreateVirtualMFADeviceOutput()
        value.virtualMFADevice = try reader["VirtualMFADevice"].readIfPresent(with: IAMClientTypes.VirtualMFADevice.read(from:))
        return value
    }
}

extension DeactivateMFADeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeactivateMFADeviceOutput {
        return DeactivateMFADeviceOutput()
    }
}

extension DeleteAccessKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccessKeyOutput {
        return DeleteAccessKeyOutput()
    }
}

extension DeleteAccountAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccountAliasOutput {
        return DeleteAccountAliasOutput()
    }
}

extension DeleteAccountPasswordPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccountPasswordPolicyOutput {
        return DeleteAccountPasswordPolicyOutput()
    }
}

extension DeleteGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGroupOutput {
        return DeleteGroupOutput()
    }
}

extension DeleteGroupPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGroupPolicyOutput {
        return DeleteGroupPolicyOutput()
    }
}

extension DeleteInstanceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInstanceProfileOutput {
        return DeleteInstanceProfileOutput()
    }
}

extension DeleteLoginProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLoginProfileOutput {
        return DeleteLoginProfileOutput()
    }
}

extension DeleteOpenIDConnectProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOpenIDConnectProviderOutput {
        return DeleteOpenIDConnectProviderOutput()
    }
}

extension DeletePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePolicyOutput {
        return DeletePolicyOutput()
    }
}

extension DeletePolicyVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePolicyVersionOutput {
        return DeletePolicyVersionOutput()
    }
}

extension DeleteRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRoleOutput {
        return DeleteRoleOutput()
    }
}

extension DeleteRolePermissionsBoundaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRolePermissionsBoundaryOutput {
        return DeleteRolePermissionsBoundaryOutput()
    }
}

extension DeleteRolePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRolePolicyOutput {
        return DeleteRolePolicyOutput()
    }
}

extension DeleteSAMLProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSAMLProviderOutput {
        return DeleteSAMLProviderOutput()
    }
}

extension DeleteServerCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServerCertificateOutput {
        return DeleteServerCertificateOutput()
    }
}

extension DeleteServiceLinkedRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceLinkedRoleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DeleteServiceLinkedRoleResult"]
        var value = DeleteServiceLinkedRoleOutput()
        value.deletionTaskId = try reader["DeletionTaskId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteServiceSpecificCredentialOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceSpecificCredentialOutput {
        return DeleteServiceSpecificCredentialOutput()
    }
}

extension DeleteSigningCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSigningCertificateOutput {
        return DeleteSigningCertificateOutput()
    }
}

extension DeleteSSHPublicKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSSHPublicKeyOutput {
        return DeleteSSHPublicKeyOutput()
    }
}

extension DeleteUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserOutput {
        return DeleteUserOutput()
    }
}

extension DeleteUserPermissionsBoundaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserPermissionsBoundaryOutput {
        return DeleteUserPermissionsBoundaryOutput()
    }
}

extension DeleteUserPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserPolicyOutput {
        return DeleteUserPolicyOutput()
    }
}

extension DeleteVirtualMFADeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVirtualMFADeviceOutput {
        return DeleteVirtualMFADeviceOutput()
    }
}

extension DetachGroupPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachGroupPolicyOutput {
        return DetachGroupPolicyOutput()
    }
}

extension DetachRolePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachRolePolicyOutput {
        return DetachRolePolicyOutput()
    }
}

extension DetachUserPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachUserPolicyOutput {
        return DetachUserPolicyOutput()
    }
}

extension EnableMFADeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableMFADeviceOutput {
        return EnableMFADeviceOutput()
    }
}

extension GenerateCredentialReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GenerateCredentialReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GenerateCredentialReportResult"]
        var value = GenerateCredentialReportOutput()
        value.description = try reader["Description"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension GenerateOrganizationsAccessReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GenerateOrganizationsAccessReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GenerateOrganizationsAccessReportResult"]
        var value = GenerateOrganizationsAccessReportOutput()
        value.jobId = try reader["JobId"].readIfPresent()
        return value
    }
}

extension GenerateServiceLastAccessedDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GenerateServiceLastAccessedDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GenerateServiceLastAccessedDetailsResult"]
        var value = GenerateServiceLastAccessedDetailsOutput()
        value.jobId = try reader["JobId"].readIfPresent()
        return value
    }
}

extension GetAccessKeyLastUsedOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccessKeyLastUsedOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetAccessKeyLastUsedResult"]
        var value = GetAccessKeyLastUsedOutput()
        value.accessKeyLastUsed = try reader["AccessKeyLastUsed"].readIfPresent(with: IAMClientTypes.AccessKeyLastUsed.read(from:))
        value.userName = try reader["UserName"].readIfPresent()
        return value
    }
}

extension GetAccountAuthorizationDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountAuthorizationDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetAccountAuthorizationDetailsResult"]
        var value = GetAccountAuthorizationDetailsOutput()
        value.groupDetailList = try reader["GroupDetailList"].readListIfPresent(memberReadingClosure: IAMClientTypes.GroupDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.policies = try reader["Policies"].readListIfPresent(memberReadingClosure: IAMClientTypes.ManagedPolicyDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleDetailList = try reader["RoleDetailList"].readListIfPresent(memberReadingClosure: IAMClientTypes.RoleDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.userDetailList = try reader["UserDetailList"].readListIfPresent(memberReadingClosure: IAMClientTypes.UserDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAccountPasswordPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountPasswordPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetAccountPasswordPolicyResult"]
        var value = GetAccountPasswordPolicyOutput()
        value.passwordPolicy = try reader["PasswordPolicy"].readIfPresent(with: IAMClientTypes.PasswordPolicy.read(from:))
        return value
    }
}

extension GetAccountSummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountSummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetAccountSummaryResult"]
        var value = GetAccountSummaryOutput()
        value.summaryMap = try reader["SummaryMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetContextKeysForCustomPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContextKeysForCustomPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetContextKeysForCustomPolicyResult"]
        var value = GetContextKeysForCustomPolicyOutput()
        value.contextKeyNames = try reader["ContextKeyNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetContextKeysForPrincipalPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContextKeysForPrincipalPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetContextKeysForPrincipalPolicyResult"]
        var value = GetContextKeysForPrincipalPolicyOutput()
        value.contextKeyNames = try reader["ContextKeyNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetCredentialReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCredentialReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetCredentialReportResult"]
        var value = GetCredentialReportOutput()
        value.content = try reader["Content"].readIfPresent()
        value.generatedTime = try reader["GeneratedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.reportFormat = try reader["ReportFormat"].readIfPresent()
        return value
    }
}

extension GetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetGroupResult"]
        var value = GetGroupOutput()
        value.group = try reader["Group"].readIfPresent(with: IAMClientTypes.Group.read(from:))
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.users = try reader["Users"].readListIfPresent(memberReadingClosure: IAMClientTypes.User.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetGroupPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGroupPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetGroupPolicyResult"]
        var value = GetGroupPolicyOutput()
        value.groupName = try reader["GroupName"].readIfPresent() ?? ""
        value.policyDocument = try reader["PolicyDocument"].readIfPresent() ?? ""
        value.policyName = try reader["PolicyName"].readIfPresent() ?? ""
        return value
    }
}

extension GetInstanceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInstanceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetInstanceProfileResult"]
        var value = GetInstanceProfileOutput()
        value.instanceProfile = try reader["InstanceProfile"].readIfPresent(with: IAMClientTypes.InstanceProfile.read(from:))
        return value
    }
}

extension GetLoginProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLoginProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetLoginProfileResult"]
        var value = GetLoginProfileOutput()
        value.loginProfile = try reader["LoginProfile"].readIfPresent(with: IAMClientTypes.LoginProfile.read(from:))
        return value
    }
}

extension GetMFADeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMFADeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetMFADeviceResult"]
        var value = GetMFADeviceOutput()
        value.certifications = try reader["Certifications"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.enableDate = try reader["EnableDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.serialNumber = try reader["SerialNumber"].readIfPresent() ?? ""
        value.userName = try reader["UserName"].readIfPresent()
        return value
    }
}

extension GetOpenIDConnectProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOpenIDConnectProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetOpenIDConnectProviderResult"]
        var value = GetOpenIDConnectProviderOutput()
        value.clientIDList = try reader["ClientIDList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.thumbprintList = try reader["ThumbprintList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.url = try reader["Url"].readIfPresent()
        return value
    }
}

extension GetOrganizationsAccessReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOrganizationsAccessReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetOrganizationsAccessReportResult"]
        var value = GetOrganizationsAccessReportOutput()
        value.accessDetails = try reader["AccessDetails"].readListIfPresent(memberReadingClosure: IAMClientTypes.AccessDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errorDetails = try reader["ErrorDetails"].readIfPresent(with: IAMClientTypes.ErrorDetails.read(from:))
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.jobCompletionDate = try reader["JobCompletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.jobCreationDate = try reader["JobCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.jobStatus = try reader["JobStatus"].readIfPresent() ?? .sdkUnknown("")
        value.marker = try reader["Marker"].readIfPresent()
        value.numberOfServicesAccessible = try reader["NumberOfServicesAccessible"].readIfPresent()
        value.numberOfServicesNotAccessed = try reader["NumberOfServicesNotAccessed"].readIfPresent()
        return value
    }
}

extension GetPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetPolicyResult"]
        var value = GetPolicyOutput()
        value.policy = try reader["Policy"].readIfPresent(with: IAMClientTypes.Policy.read(from:))
        return value
    }
}

extension GetPolicyVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPolicyVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetPolicyVersionResult"]
        var value = GetPolicyVersionOutput()
        value.policyVersion = try reader["PolicyVersion"].readIfPresent(with: IAMClientTypes.PolicyVersion.read(from:))
        return value
    }
}

extension GetRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRoleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetRoleResult"]
        var value = GetRoleOutput()
        value.role = try reader["Role"].readIfPresent(with: IAMClientTypes.Role.read(from:))
        return value
    }
}

extension GetRolePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRolePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetRolePolicyResult"]
        var value = GetRolePolicyOutput()
        value.policyDocument = try reader["PolicyDocument"].readIfPresent() ?? ""
        value.policyName = try reader["PolicyName"].readIfPresent() ?? ""
        value.roleName = try reader["RoleName"].readIfPresent() ?? ""
        return value
    }
}

extension GetSAMLProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSAMLProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetSAMLProviderResult"]
        var value = GetSAMLProviderOutput()
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.samlMetadataDocument = try reader["SAMLMetadataDocument"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.validUntil = try reader["ValidUntil"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GetServerCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServerCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetServerCertificateResult"]
        var value = GetServerCertificateOutput()
        value.serverCertificate = try reader["ServerCertificate"].readIfPresent(with: IAMClientTypes.ServerCertificate.read(from:))
        return value
    }
}

extension GetServiceLastAccessedDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceLastAccessedDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetServiceLastAccessedDetailsResult"]
        var value = GetServiceLastAccessedDetailsOutput()
        value.error = try reader["Error"].readIfPresent(with: IAMClientTypes.ErrorDetails.read(from:))
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.jobCompletionDate = try reader["JobCompletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.jobCreationDate = try reader["JobCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.jobStatus = try reader["JobStatus"].readIfPresent() ?? .sdkUnknown("")
        value.jobType = try reader["JobType"].readIfPresent()
        value.marker = try reader["Marker"].readIfPresent()
        value.servicesLastAccessed = try reader["ServicesLastAccessed"].readListIfPresent(memberReadingClosure: IAMClientTypes.ServiceLastAccessed.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetServiceLastAccessedDetailsWithEntitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceLastAccessedDetailsWithEntitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetServiceLastAccessedDetailsWithEntitiesResult"]
        var value = GetServiceLastAccessedDetailsWithEntitiesOutput()
        value.entityDetailsList = try reader["EntityDetailsList"].readListIfPresent(memberReadingClosure: IAMClientTypes.EntityDetails.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.error = try reader["Error"].readIfPresent(with: IAMClientTypes.ErrorDetails.read(from:))
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.jobCompletionDate = try reader["JobCompletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.jobCreationDate = try reader["JobCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.jobStatus = try reader["JobStatus"].readIfPresent() ?? .sdkUnknown("")
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension GetServiceLinkedRoleDeletionStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceLinkedRoleDeletionStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetServiceLinkedRoleDeletionStatusResult"]
        var value = GetServiceLinkedRoleDeletionStatusOutput()
        value.reason = try reader["Reason"].readIfPresent(with: IAMClientTypes.DeletionTaskFailureReasonType.read(from:))
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetSSHPublicKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSSHPublicKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetSSHPublicKeyResult"]
        var value = GetSSHPublicKeyOutput()
        value.sshPublicKey = try reader["SSHPublicKey"].readIfPresent(with: IAMClientTypes.SSHPublicKey.read(from:))
        return value
    }
}

extension GetUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetUserResult"]
        var value = GetUserOutput()
        value.user = try reader["User"].readIfPresent(with: IAMClientTypes.User.read(from:))
        return value
    }
}

extension GetUserPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUserPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetUserPolicyResult"]
        var value = GetUserPolicyOutput()
        value.policyDocument = try reader["PolicyDocument"].readIfPresent() ?? ""
        value.policyName = try reader["PolicyName"].readIfPresent() ?? ""
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        return value
    }
}

extension ListAccessKeysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccessKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListAccessKeysResult"]
        var value = ListAccessKeysOutput()
        value.accessKeyMetadata = try reader["AccessKeyMetadata"].readListIfPresent(memberReadingClosure: IAMClientTypes.AccessKeyMetadata.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension ListAccountAliasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccountAliasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListAccountAliasesResult"]
        var value = ListAccountAliasesOutput()
        value.accountAliases = try reader["AccountAliases"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension ListAttachedGroupPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAttachedGroupPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListAttachedGroupPoliciesResult"]
        var value = ListAttachedGroupPoliciesOutput()
        value.attachedPolicies = try reader["AttachedPolicies"].readListIfPresent(memberReadingClosure: IAMClientTypes.AttachedPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension ListAttachedRolePoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAttachedRolePoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListAttachedRolePoliciesResult"]
        var value = ListAttachedRolePoliciesOutput()
        value.attachedPolicies = try reader["AttachedPolicies"].readListIfPresent(memberReadingClosure: IAMClientTypes.AttachedPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension ListAttachedUserPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAttachedUserPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListAttachedUserPoliciesResult"]
        var value = ListAttachedUserPoliciesOutput()
        value.attachedPolicies = try reader["AttachedPolicies"].readListIfPresent(memberReadingClosure: IAMClientTypes.AttachedPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension ListEntitiesForPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEntitiesForPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListEntitiesForPolicyResult"]
        var value = ListEntitiesForPolicyOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.policyGroups = try reader["PolicyGroups"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.policyRoles = try reader["PolicyRoles"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyRole.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.policyUsers = try reader["PolicyUsers"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyUser.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListGroupPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGroupPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListGroupPoliciesResult"]
        var value = ListGroupPoliciesOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.policyNames = try reader["PolicyNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListGroupsResult"]
        var value = ListGroupsOutput()
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: IAMClientTypes.Group.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension ListGroupsForUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGroupsForUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListGroupsForUserResult"]
        var value = ListGroupsForUserOutput()
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: IAMClientTypes.Group.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension ListInstanceProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstanceProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListInstanceProfilesResult"]
        var value = ListInstanceProfilesOutput()
        value.instanceProfiles = try reader["InstanceProfiles"].readListIfPresent(memberReadingClosure: IAMClientTypes.InstanceProfile.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension ListInstanceProfilesForRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstanceProfilesForRoleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListInstanceProfilesForRoleResult"]
        var value = ListInstanceProfilesForRoleOutput()
        value.instanceProfiles = try reader["InstanceProfiles"].readListIfPresent(memberReadingClosure: IAMClientTypes.InstanceProfile.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension ListInstanceProfileTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstanceProfileTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListInstanceProfileTagsResult"]
        var value = ListInstanceProfileTagsOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListMFADevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMFADevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListMFADevicesResult"]
        var value = ListMFADevicesOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.mfaDevices = try reader["MFADevices"].readListIfPresent(memberReadingClosure: IAMClientTypes.MFADevice.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension ListMFADeviceTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMFADeviceTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListMFADeviceTagsResult"]
        var value = ListMFADeviceTagsOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListOpenIDConnectProvidersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOpenIDConnectProvidersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListOpenIDConnectProvidersResult"]
        var value = ListOpenIDConnectProvidersOutput()
        value.openIDConnectProviderList = try reader["OpenIDConnectProviderList"].readListIfPresent(memberReadingClosure: IAMClientTypes.OpenIDConnectProviderListEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListOpenIDConnectProviderTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOpenIDConnectProviderTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListOpenIDConnectProviderTagsResult"]
        var value = ListOpenIDConnectProviderTagsOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListPoliciesResult"]
        var value = ListPoliciesOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.policies = try reader["Policies"].readListIfPresent(memberReadingClosure: IAMClientTypes.Policy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPoliciesGrantingServiceAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPoliciesGrantingServiceAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListPoliciesGrantingServiceAccessResult"]
        var value = ListPoliciesGrantingServiceAccessOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.policiesGrantingServiceAccess = try reader["PoliciesGrantingServiceAccess"].readListIfPresent(memberReadingClosure: IAMClientTypes.ListPoliciesGrantingServiceAccessEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListPolicyTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPolicyTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListPolicyTagsResult"]
        var value = ListPolicyTagsOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListPolicyVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPolicyVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListPolicyVersionsResult"]
        var value = ListPolicyVersionsOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRolePoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRolePoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListRolePoliciesResult"]
        var value = ListRolePoliciesOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.policyNames = try reader["PolicyNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListRolesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRolesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListRolesResult"]
        var value = ListRolesOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.roles = try reader["Roles"].readListIfPresent(memberReadingClosure: IAMClientTypes.Role.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListRoleTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRoleTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListRoleTagsResult"]
        var value = ListRoleTagsOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListSAMLProvidersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSAMLProvidersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListSAMLProvidersResult"]
        var value = ListSAMLProvidersOutput()
        value.samlProviderList = try reader["SAMLProviderList"].readListIfPresent(memberReadingClosure: IAMClientTypes.SAMLProviderListEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSAMLProviderTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSAMLProviderTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListSAMLProviderTagsResult"]
        var value = ListSAMLProviderTagsOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListServerCertificatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServerCertificatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListServerCertificatesResult"]
        var value = ListServerCertificatesOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.serverCertificateMetadataList = try reader["ServerCertificateMetadataList"].readListIfPresent(memberReadingClosure: IAMClientTypes.ServerCertificateMetadata.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListServerCertificateTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServerCertificateTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListServerCertificateTagsResult"]
        var value = ListServerCertificateTagsOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListServiceSpecificCredentialsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceSpecificCredentialsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListServiceSpecificCredentialsResult"]
        var value = ListServiceSpecificCredentialsOutput()
        value.serviceSpecificCredentials = try reader["ServiceSpecificCredentials"].readListIfPresent(memberReadingClosure: IAMClientTypes.ServiceSpecificCredentialMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSigningCertificatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSigningCertificatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListSigningCertificatesResult"]
        var value = ListSigningCertificatesOutput()
        value.certificates = try reader["Certificates"].readListIfPresent(memberReadingClosure: IAMClientTypes.SigningCertificate.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension ListSSHPublicKeysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSSHPublicKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListSSHPublicKeysResult"]
        var value = ListSSHPublicKeysOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.sshPublicKeys = try reader["SSHPublicKeys"].readListIfPresent(memberReadingClosure: IAMClientTypes.SSHPublicKeyMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListUserPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUserPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListUserPoliciesResult"]
        var value = ListUserPoliciesOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.policyNames = try reader["PolicyNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListUsersResult"]
        var value = ListUsersOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.users = try reader["Users"].readListIfPresent(memberReadingClosure: IAMClientTypes.User.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListUserTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUserTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListUserTagsResult"]
        var value = ListUserTagsOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListVirtualMFADevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVirtualMFADevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListVirtualMFADevicesResult"]
        var value = ListVirtualMFADevicesOutput()
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        value.virtualMFADevices = try reader["VirtualMFADevices"].readListIfPresent(memberReadingClosure: IAMClientTypes.VirtualMFADevice.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PutGroupPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutGroupPolicyOutput {
        return PutGroupPolicyOutput()
    }
}

extension PutRolePermissionsBoundaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRolePermissionsBoundaryOutput {
        return PutRolePermissionsBoundaryOutput()
    }
}

extension PutRolePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRolePolicyOutput {
        return PutRolePolicyOutput()
    }
}

extension PutUserPermissionsBoundaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutUserPermissionsBoundaryOutput {
        return PutUserPermissionsBoundaryOutput()
    }
}

extension PutUserPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutUserPolicyOutput {
        return PutUserPolicyOutput()
    }
}

extension RemoveClientIDFromOpenIDConnectProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveClientIDFromOpenIDConnectProviderOutput {
        return RemoveClientIDFromOpenIDConnectProviderOutput()
    }
}

extension RemoveRoleFromInstanceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveRoleFromInstanceProfileOutput {
        return RemoveRoleFromInstanceProfileOutput()
    }
}

extension RemoveUserFromGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveUserFromGroupOutput {
        return RemoveUserFromGroupOutput()
    }
}

extension ResetServiceSpecificCredentialOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetServiceSpecificCredentialOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ResetServiceSpecificCredentialResult"]
        var value = ResetServiceSpecificCredentialOutput()
        value.serviceSpecificCredential = try reader["ServiceSpecificCredential"].readIfPresent(with: IAMClientTypes.ServiceSpecificCredential.read(from:))
        return value
    }
}

extension ResyncMFADeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResyncMFADeviceOutput {
        return ResyncMFADeviceOutput()
    }
}

extension SetDefaultPolicyVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetDefaultPolicyVersionOutput {
        return SetDefaultPolicyVersionOutput()
    }
}

extension SetSecurityTokenServicePreferencesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetSecurityTokenServicePreferencesOutput {
        return SetSecurityTokenServicePreferencesOutput()
    }
}

extension SimulateCustomPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SimulateCustomPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["SimulateCustomPolicyResult"]
        var value = SimulateCustomPolicyOutput()
        value.evaluationResults = try reader["EvaluationResults"].readListIfPresent(memberReadingClosure: IAMClientTypes.EvaluationResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension SimulatePrincipalPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SimulatePrincipalPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["SimulatePrincipalPolicyResult"]
        var value = SimulatePrincipalPolicyOutput()
        value.evaluationResults = try reader["EvaluationResults"].readListIfPresent(memberReadingClosure: IAMClientTypes.EvaluationResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension TagInstanceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagInstanceProfileOutput {
        return TagInstanceProfileOutput()
    }
}

extension TagMFADeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagMFADeviceOutput {
        return TagMFADeviceOutput()
    }
}

extension TagOpenIDConnectProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagOpenIDConnectProviderOutput {
        return TagOpenIDConnectProviderOutput()
    }
}

extension TagPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagPolicyOutput {
        return TagPolicyOutput()
    }
}

extension TagRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagRoleOutput {
        return TagRoleOutput()
    }
}

extension TagSAMLProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagSAMLProviderOutput {
        return TagSAMLProviderOutput()
    }
}

extension TagServerCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagServerCertificateOutput {
        return TagServerCertificateOutput()
    }
}

extension TagUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagUserOutput {
        return TagUserOutput()
    }
}

extension UntagInstanceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagInstanceProfileOutput {
        return UntagInstanceProfileOutput()
    }
}

extension UntagMFADeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagMFADeviceOutput {
        return UntagMFADeviceOutput()
    }
}

extension UntagOpenIDConnectProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagOpenIDConnectProviderOutput {
        return UntagOpenIDConnectProviderOutput()
    }
}

extension UntagPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagPolicyOutput {
        return UntagPolicyOutput()
    }
}

extension UntagRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagRoleOutput {
        return UntagRoleOutput()
    }
}

extension UntagSAMLProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagSAMLProviderOutput {
        return UntagSAMLProviderOutput()
    }
}

extension UntagServerCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagServerCertificateOutput {
        return UntagServerCertificateOutput()
    }
}

extension UntagUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagUserOutput {
        return UntagUserOutput()
    }
}

extension UpdateAccessKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccessKeyOutput {
        return UpdateAccessKeyOutput()
    }
}

extension UpdateAccountPasswordPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccountPasswordPolicyOutput {
        return UpdateAccountPasswordPolicyOutput()
    }
}

extension UpdateAssumeRolePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssumeRolePolicyOutput {
        return UpdateAssumeRolePolicyOutput()
    }
}

extension UpdateGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGroupOutput {
        return UpdateGroupOutput()
    }
}

extension UpdateLoginProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLoginProfileOutput {
        return UpdateLoginProfileOutput()
    }
}

extension UpdateOpenIDConnectProviderThumbprintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOpenIDConnectProviderThumbprintOutput {
        return UpdateOpenIDConnectProviderThumbprintOutput()
    }
}

extension UpdateRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRoleOutput {
        return UpdateRoleOutput()
    }
}

extension UpdateRoleDescriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRoleDescriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["UpdateRoleDescriptionResult"]
        var value = UpdateRoleDescriptionOutput()
        value.role = try reader["Role"].readIfPresent(with: IAMClientTypes.Role.read(from:))
        return value
    }
}

extension UpdateSAMLProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSAMLProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["UpdateSAMLProviderResult"]
        var value = UpdateSAMLProviderOutput()
        value.samlProviderArn = try reader["SAMLProviderArn"].readIfPresent()
        return value
    }
}

extension UpdateServerCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServerCertificateOutput {
        return UpdateServerCertificateOutput()
    }
}

extension UpdateServiceSpecificCredentialOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceSpecificCredentialOutput {
        return UpdateServiceSpecificCredentialOutput()
    }
}

extension UpdateSigningCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSigningCertificateOutput {
        return UpdateSigningCertificateOutput()
    }
}

extension UpdateSSHPublicKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSSHPublicKeyOutput {
        return UpdateSSHPublicKeyOutput()
    }
}

extension UpdateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserOutput {
        return UpdateUserOutput()
    }
}

extension UploadServerCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UploadServerCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["UploadServerCertificateResult"]
        var value = UploadServerCertificateOutput()
        value.serverCertificateMetadata = try reader["ServerCertificateMetadata"].readIfPresent(with: IAMClientTypes.ServerCertificateMetadata.read(from:))
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UploadSigningCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UploadSigningCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["UploadSigningCertificateResult"]
        var value = UploadSigningCertificateOutput()
        value.certificate = try reader["Certificate"].readIfPresent(with: IAMClientTypes.SigningCertificate.read(from:))
        return value
    }
}

extension UploadSSHPublicKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UploadSSHPublicKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["UploadSSHPublicKeyResult"]
        var value = UploadSSHPublicKeyOutput()
        value.sshPublicKey = try reader["SSHPublicKey"].readIfPresent(with: IAMClientTypes.SSHPublicKey.read(from:))
        return value
    }
}

enum AddClientIDToOpenIDConnectProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddRoleToInstanceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            case "UnmodifiableEntity": return try UnmodifiableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddUserToGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AttachGroupPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "PolicyNotAttachable": return try PolicyNotAttachableException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AttachRolePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "PolicyNotAttachable": return try PolicyNotAttachableException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            case "UnmodifiableEntity": return try UnmodifiableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AttachUserPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "PolicyNotAttachable": return try PolicyNotAttachableException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ChangePasswordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityTemporarilyUnmodifiable": return try EntityTemporarilyUnmodifiableException.makeError(baseError: baseError)
            case "InvalidUserType": return try InvalidUserTypeException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "PasswordPolicyViolation": return try PasswordPolicyViolationException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAccessKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAccountAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInstanceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLoginProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "PasswordPolicyViolation": return try PasswordPolicyViolationException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOpenIDConnectProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "OpenIdIdpCommunicationError": return try OpenIdIdpCommunicationErrorException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "MalformedPolicyDocument": return try MalformedPolicyDocumentException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePolicyVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "MalformedPolicyDocument": return try MalformedPolicyDocumentException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "MalformedPolicyDocument": return try MalformedPolicyDocumentException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSAMLProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceLinkedRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceSpecificCredentialOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "NotSupportedService": return try ServiceNotSupportedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVirtualMFADeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeactivateMFADeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityTemporarilyUnmodifiable": return try EntityTemporarilyUnmodifiableException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccessKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccountAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccountPasswordPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DeleteConflict": return try DeleteConflictException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGroupPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInstanceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DeleteConflict": return try DeleteConflictException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLoginProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityTemporarilyUnmodifiable": return try EntityTemporarilyUnmodifiableException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOpenIDConnectProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DeleteConflict": return try DeleteConflictException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePolicyVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DeleteConflict": return try DeleteConflictException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "DeleteConflict": return try DeleteConflictException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            case "UnmodifiableEntity": return try UnmodifiableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRolePermissionsBoundaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            case "UnmodifiableEntity": return try UnmodifiableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRolePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            case "UnmodifiableEntity": return try UnmodifiableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSAMLProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServerCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DeleteConflict": return try DeleteConflictException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceLinkedRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceSpecificCredentialOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSigningCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSSHPublicKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "DeleteConflict": return try DeleteConflictException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserPermissionsBoundaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVirtualMFADeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "DeleteConflict": return try DeleteConflictException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachGroupPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachRolePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            case "UnmodifiableEntity": return try UnmodifiableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachUserPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableMFADeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "EntityTemporarilyUnmodifiable": return try EntityTemporarilyUnmodifiableException.makeError(baseError: baseError)
            case "InvalidAuthenticationCode": return try InvalidAuthenticationCodeException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GenerateCredentialReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GenerateOrganizationsAccessReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ReportGenerationLimitExceeded": return try ReportGenerationLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GenerateServiceLastAccessedDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccessKeyLastUsedOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountAuthorizationDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountPasswordPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountSummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContextKeysForCustomPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContextKeysForPrincipalPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCredentialReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ReportExpired": return try CredentialReportExpiredException.makeError(baseError: baseError)
            case "ReportNotPresent": return try CredentialReportNotPresentException.makeError(baseError: baseError)
            case "ReportInProgress": return try CredentialReportNotReadyException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGroupPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInstanceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLoginProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMFADeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOpenIDConnectProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOrganizationsAccessReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPolicyVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRolePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSAMLProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServerCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceLastAccessedDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceLastAccessedDetailsWithEntitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceLinkedRoleDeletionStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSSHPublicKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "UnrecognizedPublicKeyEncoding": return try UnrecognizedPublicKeyEncodingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUserPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccessKeysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccountAliasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAttachedGroupPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAttachedRolePoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAttachedUserPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEntitiesForPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGroupPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGroupsForUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstanceProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstanceProfilesForRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstanceProfileTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMFADevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMFADeviceTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOpenIDConnectProvidersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOpenIDConnectProviderTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPoliciesGrantingServiceAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPolicyTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPolicyVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRolePoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRolesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRoleTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSAMLProvidersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSAMLProviderTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServerCertificatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServerCertificateTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceSpecificCredentialsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "NotSupportedService": return try ServiceNotSupportedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSigningCertificatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSSHPublicKeysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUserPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUserTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVirtualMFADevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutGroupPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "MalformedPolicyDocument": return try MalformedPolicyDocumentException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRolePermissionsBoundaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "PolicyNotAttachable": return try PolicyNotAttachableException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            case "UnmodifiableEntity": return try UnmodifiableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRolePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "MalformedPolicyDocument": return try MalformedPolicyDocumentException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            case "UnmodifiableEntity": return try UnmodifiableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutUserPermissionsBoundaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "PolicyNotAttachable": return try PolicyNotAttachableException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutUserPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "MalformedPolicyDocument": return try MalformedPolicyDocumentException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveClientIDFromOpenIDConnectProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveRoleFromInstanceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            case "UnmodifiableEntity": return try UnmodifiableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveUserFromGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetServiceSpecificCredentialOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResyncMFADeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidAuthenticationCode": return try InvalidAuthenticationCodeException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetDefaultPolicyVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetSecurityTokenServicePreferencesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SimulateCustomPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "PolicyEvaluation": return try PolicyEvaluationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SimulatePrincipalPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "PolicyEvaluation": return try PolicyEvaluationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagInstanceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagMFADeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagOpenIDConnectProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagSAMLProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagServerCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagInstanceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagMFADeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagOpenIDConnectProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagSAMLProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagServerCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccessKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccountPasswordPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "MalformedPolicyDocument": return try MalformedPolicyDocumentException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssumeRolePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "MalformedPolicyDocument": return try MalformedPolicyDocumentException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            case "UnmodifiableEntity": return try UnmodifiableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLoginProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityTemporarilyUnmodifiable": return try EntityTemporarilyUnmodifiableException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "PasswordPolicyViolation": return try PasswordPolicyViolationException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOpenIDConnectProviderThumbprintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            case "UnmodifiableEntity": return try UnmodifiableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRoleDescriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            case "UnmodifiableEntity": return try UnmodifiableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSAMLProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServerCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceSpecificCredentialOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSigningCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSSHPublicKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "EntityTemporarilyUnmodifiable": return try EntityTemporarilyUnmodifiableException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UploadServerCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInputException.makeError(baseError: baseError)
            case "KeyPairMismatch": return try KeyPairMismatchException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "MalformedCertificate": return try MalformedCertificateException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UploadSigningCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "DuplicateCertificate": return try DuplicateCertificateException.makeError(baseError: baseError)
            case "EntityAlreadyExists": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "InvalidCertificate": return try InvalidCertificateException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "MalformedCertificate": return try MalformedCertificateException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceFailure": return try ServiceFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UploadSSHPublicKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateSSHPublicKey": return try DuplicateSSHPublicKeyException.makeError(baseError: baseError)
            case "InvalidPublicKey": return try InvalidPublicKeyException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntity": return try NoSuchEntityException.makeError(baseError: baseError)
            case "UnrecognizedPublicKeyEncoding": return try UnrecognizedPublicKeyEncodingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchEntityException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> NoSuchEntityException {
        let reader = baseError.errorBodyReader
        var value = NoSuchEntityException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInputException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidInputException {
        let reader = baseError.errorBodyReader
        var value = InvalidInputException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceFailureException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> ServiceFailureException {
        let reader = baseError.errorBodyReader
        var value = ServiceFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnmodifiableEntityException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> UnmodifiableEntityException {
        let reader = baseError.errorBodyReader
        var value = UnmodifiableEntityException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntityAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> EntityAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = EntityAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PolicyNotAttachableException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> PolicyNotAttachableException {
        let reader = baseError.errorBodyReader
        var value = PolicyNotAttachableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntityTemporarilyUnmodifiableException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> EntityTemporarilyUnmodifiableException {
        let reader = baseError.errorBodyReader
        var value = EntityTemporarilyUnmodifiableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PasswordPolicyViolationException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> PasswordPolicyViolationException {
        let reader = baseError.errorBodyReader
        var value = PasswordPolicyViolationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidUserTypeException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidUserTypeException {
        let reader = baseError.errorBodyReader
        var value = InvalidUserTypeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> ConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentModificationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpenIdIdpCommunicationErrorException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> OpenIdIdpCommunicationErrorException {
        let reader = baseError.errorBodyReader
        var value = OpenIdIdpCommunicationErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MalformedPolicyDocumentException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> MalformedPolicyDocumentException {
        let reader = baseError.errorBodyReader
        var value = MalformedPolicyDocumentException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceNotSupportedException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> ServiceNotSupportedException {
        let reader = baseError.errorBodyReader
        var value = ServiceNotSupportedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DeleteConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> DeleteConflictException {
        let reader = baseError.errorBodyReader
        var value = DeleteConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidAuthenticationCodeException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidAuthenticationCodeException {
        let reader = baseError.errorBodyReader
        var value = InvalidAuthenticationCodeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReportGenerationLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> ReportGenerationLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ReportGenerationLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CredentialReportNotReadyException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> CredentialReportNotReadyException {
        let reader = baseError.errorBodyReader
        var value = CredentialReportNotReadyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CredentialReportExpiredException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> CredentialReportExpiredException {
        let reader = baseError.errorBodyReader
        var value = CredentialReportExpiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CredentialReportNotPresentException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> CredentialReportNotPresentException {
        let reader = baseError.errorBodyReader
        var value = CredentialReportNotPresentException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnrecognizedPublicKeyEncodingException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> UnrecognizedPublicKeyEncodingException {
        let reader = baseError.errorBodyReader
        var value = UnrecognizedPublicKeyEncodingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PolicyEvaluationException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> PolicyEvaluationException {
        let reader = baseError.errorBodyReader
        var value = PolicyEvaluationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KeyPairMismatchException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> KeyPairMismatchException {
        let reader = baseError.errorBodyReader
        var value = KeyPairMismatchException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MalformedCertificateException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> MalformedCertificateException {
        let reader = baseError.errorBodyReader
        var value = MalformedCertificateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidCertificateException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidCertificateException {
        let reader = baseError.errorBodyReader
        var value = InvalidCertificateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateCertificateException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> DuplicateCertificateException {
        let reader = baseError.errorBodyReader
        var value = DuplicateCertificateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPublicKeyException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidPublicKeyException {
        let reader = baseError.errorBodyReader
        var value = InvalidPublicKeyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateSSHPublicKeyException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> DuplicateSSHPublicKeyException {
        let reader = baseError.errorBodyReader
        var value = DuplicateSSHPublicKeyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IAMClientTypes.AccessKey {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.AccessKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.AccessKey()
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        value.accessKeyId = try reader["AccessKeyId"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.secretAccessKey = try reader["SecretAccessKey"].readIfPresent() ?? ""
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IAMClientTypes.Group {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.Group {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.Group()
        value.path = try reader["Path"].readIfPresent() ?? ""
        value.groupName = try reader["GroupName"].readIfPresent() ?? ""
        value.groupId = try reader["GroupId"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension IAMClientTypes.InstanceProfile {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.InstanceProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.InstanceProfile()
        value.path = try reader["Path"].readIfPresent() ?? ""
        value.instanceProfileName = try reader["InstanceProfileName"].readIfPresent() ?? ""
        value.instanceProfileId = try reader["InstanceProfileId"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.roles = try reader["Roles"].readListIfPresent(memberReadingClosure: IAMClientTypes.Role.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IAMClientTypes.Tag {

    static func write(value: IAMClientTypes.Tag?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension IAMClientTypes.Role {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.Role {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.Role()
        value.path = try reader["Path"].readIfPresent() ?? ""
        value.roleName = try reader["RoleName"].readIfPresent() ?? ""
        value.roleId = try reader["RoleId"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.assumeRolePolicyDocument = try reader["AssumeRolePolicyDocument"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.maxSessionDuration = try reader["MaxSessionDuration"].readIfPresent()
        value.permissionsBoundary = try reader["PermissionsBoundary"].readIfPresent(with: IAMClientTypes.AttachedPermissionsBoundary.read(from:))
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleLastUsed = try reader["RoleLastUsed"].readIfPresent(with: IAMClientTypes.RoleLastUsed.read(from:))
        return value
    }
}

extension IAMClientTypes.RoleLastUsed {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.RoleLastUsed {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.RoleLastUsed()
        value.lastUsedDate = try reader["LastUsedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.region = try reader["Region"].readIfPresent()
        return value
    }
}

extension IAMClientTypes.AttachedPermissionsBoundary {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.AttachedPermissionsBoundary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.AttachedPermissionsBoundary()
        value.permissionsBoundaryType = try reader["PermissionsBoundaryType"].readIfPresent()
        value.permissionsBoundaryArn = try reader["PermissionsBoundaryArn"].readIfPresent()
        return value
    }
}

extension IAMClientTypes.LoginProfile {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.LoginProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.LoginProfile()
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.passwordResetRequired = try reader["PasswordResetRequired"].readIfPresent() ?? false
        return value
    }
}

extension IAMClientTypes.Policy {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.Policy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.Policy()
        value.policyName = try reader["PolicyName"].readIfPresent()
        value.policyId = try reader["PolicyId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.defaultVersionId = try reader["DefaultVersionId"].readIfPresent()
        value.attachmentCount = try reader["AttachmentCount"].readIfPresent()
        value.permissionsBoundaryUsageCount = try reader["PermissionsBoundaryUsageCount"].readIfPresent()
        value.isAttachable = try reader["IsAttachable"].readIfPresent() ?? false
        value.description = try reader["Description"].readIfPresent()
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updateDate = try reader["UpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IAMClientTypes.PolicyVersion {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.PolicyVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.PolicyVersion()
        value.document = try reader["Document"].readIfPresent()
        value.versionId = try reader["VersionId"].readIfPresent()
        value.isDefaultVersion = try reader["IsDefaultVersion"].readIfPresent() ?? false
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IAMClientTypes.ServiceSpecificCredential {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.ServiceSpecificCredential {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.ServiceSpecificCredential()
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.serviceName = try reader["ServiceName"].readIfPresent() ?? ""
        value.serviceUserName = try reader["ServiceUserName"].readIfPresent() ?? ""
        value.servicePassword = try reader["ServicePassword"].readIfPresent() ?? ""
        value.serviceSpecificCredentialId = try reader["ServiceSpecificCredentialId"].readIfPresent() ?? ""
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IAMClientTypes.User {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.User {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.User()
        value.path = try reader["Path"].readIfPresent() ?? ""
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        value.userId = try reader["UserId"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.passwordLastUsed = try reader["PasswordLastUsed"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.permissionsBoundary = try reader["PermissionsBoundary"].readIfPresent(with: IAMClientTypes.AttachedPermissionsBoundary.read(from:))
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IAMClientTypes.VirtualMFADevice {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.VirtualMFADevice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.VirtualMFADevice()
        value.serialNumber = try reader["SerialNumber"].readIfPresent() ?? ""
        value.base32StringSeed = try reader["Base32StringSeed"].readIfPresent()
        value.qrCodePNG = try reader["QRCodePNG"].readIfPresent()
        value.user = try reader["User"].readIfPresent(with: IAMClientTypes.User.read(from:))
        value.enableDate = try reader["EnableDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IAMClientTypes.AccessKeyLastUsed {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.AccessKeyLastUsed {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.AccessKeyLastUsed()
        value.lastUsedDate = try reader["LastUsedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.serviceName = try reader["ServiceName"].readIfPresent() ?? ""
        value.region = try reader["Region"].readIfPresent() ?? ""
        return value
    }
}

extension IAMClientTypes.UserDetail {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.UserDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.UserDetail()
        value.path = try reader["Path"].readIfPresent()
        value.userName = try reader["UserName"].readIfPresent()
        value.userId = try reader["UserId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.userPolicyList = try reader["UserPolicyList"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.groupList = try reader["GroupList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.attachedManagedPolicies = try reader["AttachedManagedPolicies"].readListIfPresent(memberReadingClosure: IAMClientTypes.AttachedPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.permissionsBoundary = try reader["PermissionsBoundary"].readIfPresent(with: IAMClientTypes.AttachedPermissionsBoundary.read(from:))
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IAMClientTypes.AttachedPolicy {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.AttachedPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.AttachedPolicy()
        value.policyName = try reader["PolicyName"].readIfPresent()
        value.policyArn = try reader["PolicyArn"].readIfPresent()
        return value
    }
}

extension IAMClientTypes.PolicyDetail {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.PolicyDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.PolicyDetail()
        value.policyName = try reader["PolicyName"].readIfPresent()
        value.policyDocument = try reader["PolicyDocument"].readIfPresent()
        return value
    }
}

extension IAMClientTypes.GroupDetail {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.GroupDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.GroupDetail()
        value.path = try reader["Path"].readIfPresent()
        value.groupName = try reader["GroupName"].readIfPresent()
        value.groupId = try reader["GroupId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.groupPolicyList = try reader["GroupPolicyList"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.attachedManagedPolicies = try reader["AttachedManagedPolicies"].readListIfPresent(memberReadingClosure: IAMClientTypes.AttachedPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IAMClientTypes.RoleDetail {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.RoleDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.RoleDetail()
        value.path = try reader["Path"].readIfPresent()
        value.roleName = try reader["RoleName"].readIfPresent()
        value.roleId = try reader["RoleId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.assumeRolePolicyDocument = try reader["AssumeRolePolicyDocument"].readIfPresent()
        value.instanceProfileList = try reader["InstanceProfileList"].readListIfPresent(memberReadingClosure: IAMClientTypes.InstanceProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.rolePolicyList = try reader["RolePolicyList"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.attachedManagedPolicies = try reader["AttachedManagedPolicies"].readListIfPresent(memberReadingClosure: IAMClientTypes.AttachedPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.permissionsBoundary = try reader["PermissionsBoundary"].readIfPresent(with: IAMClientTypes.AttachedPermissionsBoundary.read(from:))
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleLastUsed = try reader["RoleLastUsed"].readIfPresent(with: IAMClientTypes.RoleLastUsed.read(from:))
        return value
    }
}

extension IAMClientTypes.ManagedPolicyDetail {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.ManagedPolicyDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.ManagedPolicyDetail()
        value.policyName = try reader["PolicyName"].readIfPresent()
        value.policyId = try reader["PolicyId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.defaultVersionId = try reader["DefaultVersionId"].readIfPresent()
        value.attachmentCount = try reader["AttachmentCount"].readIfPresent()
        value.permissionsBoundaryUsageCount = try reader["PermissionsBoundaryUsageCount"].readIfPresent()
        value.isAttachable = try reader["IsAttachable"].readIfPresent() ?? false
        value.description = try reader["Description"].readIfPresent()
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updateDate = try reader["UpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.policyVersionList = try reader["PolicyVersionList"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IAMClientTypes.PasswordPolicy {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.PasswordPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.PasswordPolicy()
        value.minimumPasswordLength = try reader["MinimumPasswordLength"].readIfPresent()
        value.requireSymbols = try reader["RequireSymbols"].readIfPresent() ?? false
        value.requireNumbers = try reader["RequireNumbers"].readIfPresent() ?? false
        value.requireUppercaseCharacters = try reader["RequireUppercaseCharacters"].readIfPresent() ?? false
        value.requireLowercaseCharacters = try reader["RequireLowercaseCharacters"].readIfPresent() ?? false
        value.allowUsersToChangePassword = try reader["AllowUsersToChangePassword"].readIfPresent() ?? false
        value.expirePasswords = try reader["ExpirePasswords"].readIfPresent() ?? false
        value.maxPasswordAge = try reader["MaxPasswordAge"].readIfPresent()
        value.passwordReusePrevention = try reader["PasswordReusePrevention"].readIfPresent()
        value.hardExpiry = try reader["HardExpiry"].readIfPresent()
        return value
    }
}

extension IAMClientTypes.AccessDetail {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.AccessDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.AccessDetail()
        value.serviceName = try reader["ServiceName"].readIfPresent() ?? ""
        value.serviceNamespace = try reader["ServiceNamespace"].readIfPresent() ?? ""
        value.region = try reader["Region"].readIfPresent()
        value.entityPath = try reader["EntityPath"].readIfPresent()
        value.lastAuthenticatedTime = try reader["LastAuthenticatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.totalAuthenticatedEntities = try reader["TotalAuthenticatedEntities"].readIfPresent()
        return value
    }
}

extension IAMClientTypes.ErrorDetails {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.ErrorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.ErrorDetails()
        value.message = try reader["Message"].readIfPresent() ?? ""
        value.code = try reader["Code"].readIfPresent() ?? ""
        return value
    }
}

extension IAMClientTypes.ServerCertificate {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.ServerCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.ServerCertificate()
        value.serverCertificateMetadata = try reader["ServerCertificateMetadata"].readIfPresent(with: IAMClientTypes.ServerCertificateMetadata.read(from:))
        value.certificateBody = try reader["CertificateBody"].readIfPresent() ?? ""
        value.certificateChain = try reader["CertificateChain"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IAMClientTypes.ServerCertificateMetadata {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.ServerCertificateMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.ServerCertificateMetadata()
        value.path = try reader["Path"].readIfPresent() ?? ""
        value.serverCertificateName = try reader["ServerCertificateName"].readIfPresent() ?? ""
        value.serverCertificateId = try reader["ServerCertificateId"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.uploadDate = try reader["UploadDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.expiration = try reader["Expiration"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IAMClientTypes.ServiceLastAccessed {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.ServiceLastAccessed {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.ServiceLastAccessed()
        value.serviceName = try reader["ServiceName"].readIfPresent() ?? ""
        value.lastAuthenticated = try reader["LastAuthenticated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.serviceNamespace = try reader["ServiceNamespace"].readIfPresent() ?? ""
        value.lastAuthenticatedEntity = try reader["LastAuthenticatedEntity"].readIfPresent()
        value.lastAuthenticatedRegion = try reader["LastAuthenticatedRegion"].readIfPresent()
        value.totalAuthenticatedEntities = try reader["TotalAuthenticatedEntities"].readIfPresent()
        value.trackedActionsLastAccessed = try reader["TrackedActionsLastAccessed"].readListIfPresent(memberReadingClosure: IAMClientTypes.TrackedActionLastAccessed.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IAMClientTypes.TrackedActionLastAccessed {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.TrackedActionLastAccessed {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.TrackedActionLastAccessed()
        value.actionName = try reader["ActionName"].readIfPresent()
        value.lastAccessedEntity = try reader["LastAccessedEntity"].readIfPresent()
        value.lastAccessedTime = try reader["LastAccessedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastAccessedRegion = try reader["LastAccessedRegion"].readIfPresent()
        return value
    }
}

extension IAMClientTypes.EntityDetails {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.EntityDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.EntityDetails()
        value.entityInfo = try reader["EntityInfo"].readIfPresent(with: IAMClientTypes.EntityInfo.read(from:))
        value.lastAuthenticated = try reader["LastAuthenticated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IAMClientTypes.EntityInfo {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.EntityInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.EntityInfo()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.path = try reader["Path"].readIfPresent()
        return value
    }
}

extension IAMClientTypes.DeletionTaskFailureReasonType {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.DeletionTaskFailureReasonType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.DeletionTaskFailureReasonType()
        value.reason = try reader["Reason"].readIfPresent()
        value.roleUsageList = try reader["RoleUsageList"].readListIfPresent(memberReadingClosure: IAMClientTypes.RoleUsageType.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IAMClientTypes.RoleUsageType {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.RoleUsageType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.RoleUsageType()
        value.region = try reader["Region"].readIfPresent()
        value.resources = try reader["Resources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IAMClientTypes.SSHPublicKey {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.SSHPublicKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.SSHPublicKey()
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        value.sshPublicKeyId = try reader["SSHPublicKeyId"].readIfPresent() ?? ""
        value.fingerprint = try reader["Fingerprint"].readIfPresent() ?? ""
        value.sshPublicKeyBody = try reader["SSHPublicKeyBody"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.uploadDate = try reader["UploadDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IAMClientTypes.AccessKeyMetadata {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.AccessKeyMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.AccessKeyMetadata()
        value.userName = try reader["UserName"].readIfPresent()
        value.accessKeyId = try reader["AccessKeyId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IAMClientTypes.PolicyGroup {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.PolicyGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.PolicyGroup()
        value.groupName = try reader["GroupName"].readIfPresent()
        value.groupId = try reader["GroupId"].readIfPresent()
        return value
    }
}

extension IAMClientTypes.PolicyUser {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.PolicyUser {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.PolicyUser()
        value.userName = try reader["UserName"].readIfPresent()
        value.userId = try reader["UserId"].readIfPresent()
        return value
    }
}

extension IAMClientTypes.PolicyRole {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.PolicyRole {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.PolicyRole()
        value.roleName = try reader["RoleName"].readIfPresent()
        value.roleId = try reader["RoleId"].readIfPresent()
        return value
    }
}

extension IAMClientTypes.MFADevice {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.MFADevice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.MFADevice()
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        value.serialNumber = try reader["SerialNumber"].readIfPresent() ?? ""
        value.enableDate = try reader["EnableDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension IAMClientTypes.OpenIDConnectProviderListEntry {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.OpenIDConnectProviderListEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.OpenIDConnectProviderListEntry()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension IAMClientTypes.ListPoliciesGrantingServiceAccessEntry {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.ListPoliciesGrantingServiceAccessEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.ListPoliciesGrantingServiceAccessEntry()
        value.serviceNamespace = try reader["ServiceNamespace"].readIfPresent()
        value.policies = try reader["Policies"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyGrantingServiceAccess.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IAMClientTypes.PolicyGrantingServiceAccess {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.PolicyGrantingServiceAccess {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.PolicyGrantingServiceAccess()
        value.policyName = try reader["PolicyName"].readIfPresent() ?? ""
        value.policyType = try reader["PolicyType"].readIfPresent() ?? .sdkUnknown("")
        value.policyArn = try reader["PolicyArn"].readIfPresent()
        value.entityType = try reader["EntityType"].readIfPresent()
        value.entityName = try reader["EntityName"].readIfPresent()
        return value
    }
}

extension IAMClientTypes.SAMLProviderListEntry {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.SAMLProviderListEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.SAMLProviderListEntry()
        value.arn = try reader["Arn"].readIfPresent()
        value.validUntil = try reader["ValidUntil"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IAMClientTypes.ServiceSpecificCredentialMetadata {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.ServiceSpecificCredentialMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.ServiceSpecificCredentialMetadata()
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.serviceUserName = try reader["ServiceUserName"].readIfPresent() ?? ""
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.serviceSpecificCredentialId = try reader["ServiceSpecificCredentialId"].readIfPresent() ?? ""
        value.serviceName = try reader["ServiceName"].readIfPresent() ?? ""
        return value
    }
}

extension IAMClientTypes.SigningCertificate {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.SigningCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.SigningCertificate()
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        value.certificateId = try reader["CertificateId"].readIfPresent() ?? ""
        value.certificateBody = try reader["CertificateBody"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.uploadDate = try reader["UploadDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IAMClientTypes.SSHPublicKeyMetadata {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.SSHPublicKeyMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.SSHPublicKeyMetadata()
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        value.sshPublicKeyId = try reader["SSHPublicKeyId"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.uploadDate = try reader["UploadDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension IAMClientTypes.EvaluationResult {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.EvaluationResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.EvaluationResult()
        value.evalActionName = try reader["EvalActionName"].readIfPresent() ?? ""
        value.evalResourceName = try reader["EvalResourceName"].readIfPresent()
        value.evalDecision = try reader["EvalDecision"].readIfPresent() ?? .sdkUnknown("")
        value.matchedStatements = try reader["MatchedStatements"].readListIfPresent(memberReadingClosure: IAMClientTypes.Statement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.missingContextValues = try reader["MissingContextValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.organizationsDecisionDetail = try reader["OrganizationsDecisionDetail"].readIfPresent(with: IAMClientTypes.OrganizationsDecisionDetail.read(from:))
        value.permissionsBoundaryDecisionDetail = try reader["PermissionsBoundaryDecisionDetail"].readIfPresent(with: IAMClientTypes.PermissionsBoundaryDecisionDetail.read(from:))
        value.evalDecisionDetails = try reader["EvalDecisionDetails"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosureBox<IAMClientTypes.PolicyEvaluationDecisionType>().read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.resourceSpecificResults = try reader["ResourceSpecificResults"].readListIfPresent(memberReadingClosure: IAMClientTypes.ResourceSpecificResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IAMClientTypes.ResourceSpecificResult {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.ResourceSpecificResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.ResourceSpecificResult()
        value.evalResourceName = try reader["EvalResourceName"].readIfPresent() ?? ""
        value.evalResourceDecision = try reader["EvalResourceDecision"].readIfPresent() ?? .sdkUnknown("")
        value.matchedStatements = try reader["MatchedStatements"].readListIfPresent(memberReadingClosure: IAMClientTypes.Statement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.missingContextValues = try reader["MissingContextValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.evalDecisionDetails = try reader["EvalDecisionDetails"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosureBox<IAMClientTypes.PolicyEvaluationDecisionType>().read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.permissionsBoundaryDecisionDetail = try reader["PermissionsBoundaryDecisionDetail"].readIfPresent(with: IAMClientTypes.PermissionsBoundaryDecisionDetail.read(from:))
        return value
    }
}

extension IAMClientTypes.PermissionsBoundaryDecisionDetail {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.PermissionsBoundaryDecisionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.PermissionsBoundaryDecisionDetail()
        value.allowedByPermissionsBoundary = try reader["AllowedByPermissionsBoundary"].readIfPresent() ?? false
        return value
    }
}

extension IAMClientTypes.Statement {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.Statement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.Statement()
        value.sourcePolicyId = try reader["SourcePolicyId"].readIfPresent()
        value.sourcePolicyType = try reader["SourcePolicyType"].readIfPresent()
        value.startPosition = try reader["StartPosition"].readIfPresent(with: IAMClientTypes.Position.read(from:))
        value.endPosition = try reader["EndPosition"].readIfPresent(with: IAMClientTypes.Position.read(from:))
        return value
    }
}

extension IAMClientTypes.Position {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.Position {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.Position()
        value.line = try reader["Line"].readIfPresent() ?? 0
        value.column = try reader["Column"].readIfPresent() ?? 0
        return value
    }
}

extension IAMClientTypes.OrganizationsDecisionDetail {

    static func read(from reader: SmithyXML.Reader) throws -> IAMClientTypes.OrganizationsDecisionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IAMClientTypes.OrganizationsDecisionDetail()
        value.allowedByOrganizations = try reader["AllowedByOrganizations"].readIfPresent() ?? false
        return value
    }
}

extension IAMClientTypes.ContextEntry {

    static func write(value: IAMClientTypes.ContextEntry?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ContextKeyName"].write(value.contextKeyName)
        try writer["ContextKeyType"].write(value.contextKeyType)
        try writer["ContextKeyValues"].writeList(value.contextKeyValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum IAMClientTypes {}
