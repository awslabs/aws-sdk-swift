// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IAMClientTypes {
    public enum AccessAdvisorUsageGranularityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actionLevel
        case serviceLevel
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessAdvisorUsageGranularityType] {
            return [
                .actionLevel,
                .serviceLevel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actionLevel: return "ACTION_LEVEL"
            case .serviceLevel: return "SERVICE_LEVEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessAdvisorUsageGranularityType(rawValue: rawValue) ?? AccessAdvisorUsageGranularityType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.AccessDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityPath = "EntityPath"
        case lastAuthenticatedTime = "LastAuthenticatedTime"
        case region = "Region"
        case serviceName = "ServiceName"
        case serviceNamespace = "ServiceNamespace"
        case totalAuthenticatedEntities = "TotalAuthenticatedEntities"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let entityPath = entityPath {
            try container.encode(entityPath, forKey: ClientRuntime.Key("EntityPath"))
        }
        if let lastAuthenticatedTime = lastAuthenticatedTime {
            try container.encodeTimestamp(lastAuthenticatedTime, format: .dateTime, forKey: ClientRuntime.Key("LastAuthenticatedTime"))
        }
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: ClientRuntime.Key("ServiceNamespace"))
        }
        if let totalAuthenticatedEntities = totalAuthenticatedEntities {
            try container.encode(totalAuthenticatedEntities, forKey: ClientRuntime.Key("TotalAuthenticatedEntities"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNamespace)
        serviceNamespace = serviceNamespaceDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let entityPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityPath)
        entityPath = entityPathDecoded
        let lastAuthenticatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastAuthenticatedTime)
        lastAuthenticatedTime = lastAuthenticatedTimeDecoded
        let totalAuthenticatedEntitiesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalAuthenticatedEntities)
        totalAuthenticatedEntities = totalAuthenticatedEntitiesDecoded
    }
}

extension IAMClientTypes {
    /// An object that contains details about when a principal in the reported Organizations entity last attempted to access an Amazon Web Services service. A principal can be an IAM user, an IAM role, or the Amazon Web Services account root user within the reported Organizations entity. This data type is a response element in the [GetOrganizationsAccessReport] operation.
    public struct AccessDetail: Swift.Equatable {
        /// The path of the Organizations entity (root, organizational unit, or account) from which an authenticated principal last attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no principals (IAM users, IAM roles, or root user) in the reported Organizations entity attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var entityPath: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when an authenticated principal most recently attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no principals in the reported Organizations entity attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticatedTime: ClientRuntime.Date?
        /// The Region where the last service access attempt occurred. This field is null if no principals in the reported Organizations entity attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var region: Swift.String?
        /// The name of the service in which access was attempted.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The namespace of the service in which access was attempted. To learn the service namespace of a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the Service Authorization Reference. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
        /// This member is required.
        public var serviceNamespace: Swift.String?
        /// The number of accounts with authenticated principals (root user, IAM users, and IAM roles) that attempted to access the service in the tracking period.
        public var totalAuthenticatedEntities: Swift.Int?

        public init(
            entityPath: Swift.String? = nil,
            lastAuthenticatedTime: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceNamespace: Swift.String? = nil,
            totalAuthenticatedEntities: Swift.Int? = nil
        )
        {
            self.entityPath = entityPath
            self.lastAuthenticatedTime = lastAuthenticatedTime
            self.region = region
            self.serviceName = serviceName
            self.serviceNamespace = serviceNamespace
            self.totalAuthenticatedEntities = totalAuthenticatedEntities
        }
    }

}

extension IAMClientTypes.AccessKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case createDate = "CreateDate"
        case secretAccessKey = "SecretAccessKey"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let secretAccessKey = secretAccessKey {
            try container.encode(secretAccessKey, forKey: ClientRuntime.Key("SecretAccessKey"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension IAMClientTypes.AccessKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessKey(accessKeyId: \(Swift.String(describing: accessKeyId)), createDate: \(Swift.String(describing: createDate)), status: \(Swift.String(describing: status)), userName: \(Swift.String(describing: userName)), secretAccessKey: \"CONTENT_REDACTED\")"}
}

extension IAMClientTypes {
    /// Contains information about an Amazon Web Services access key. This data type is used as a response element in the [CreateAccessKey] and [ListAccessKeys] operations. The SecretAccessKey value is returned only in response to [CreateAccessKey]. You can get a secret access key only when you first create an access key; you cannot recover the secret access key later. If you lose a secret access key, you must create a new access key.
    public struct AccessKey: Swift.Equatable {
        /// The ID for this access key.
        /// This member is required.
        public var accessKeyId: Swift.String?
        /// The date when the access key was created.
        public var createDate: ClientRuntime.Date?
        /// The secret key used to sign requests.
        /// This member is required.
        public var secretAccessKey: Swift.String?
        /// The status of the access key. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user that the access key is associated with.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            secretAccessKey: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.createDate = createDate
            self.secretAccessKey = secretAccessKey
            self.status = status
            self.userName = userName
        }
    }

}

extension IAMClientTypes.AccessKeyLastUsed: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUsedDate = "LastUsedDate"
        case region = "Region"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let lastUsedDate = lastUsedDate {
            try container.encodeTimestamp(lastUsedDate, format: .dateTime, forKey: ClientRuntime.Key("LastUsedDate"))
        }
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUsedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUsedDate)
        lastUsedDate = lastUsedDateDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about the last time an Amazon Web Services access key was used since IAM began tracking this information on April 22, 2015. This data type is used as a response element in the [GetAccessKeyLastUsed] operation.
    public struct AccessKeyLastUsed: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the access key was most recently used. This field is null in the following situations:
        ///
        /// * The user does not have an access key.
        ///
        /// * An access key exists but has not been used since IAM began tracking this information.
        ///
        /// * There is no sign-in data associated with the user.
        /// This member is required.
        public var lastUsedDate: ClientRuntime.Date?
        /// The Amazon Web Services Region where this access key was most recently used. The value for this field is "N/A" in the following situations:
        ///
        /// * The user does not have an access key.
        ///
        /// * An access key exists but has not been used since IAM began tracking this information.
        ///
        /// * There is no sign-in data associated with the user.
        ///
        ///
        /// For more information about Amazon Web Services Regions, see [Regions and endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html) in the Amazon Web Services General Reference.
        /// This member is required.
        public var region: Swift.String?
        /// The name of the Amazon Web Services service with which this access key was most recently used. The value of this field is "N/A" in the following situations:
        ///
        /// * The user does not have an access key.
        ///
        /// * An access key exists but has not been used since IAM started tracking this information.
        ///
        /// * There is no sign-in data associated with the user.
        /// This member is required.
        public var serviceName: Swift.String?

        public init(
            lastUsedDate: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.lastUsedDate = lastUsedDate
            self.region = region
            self.serviceName = serviceName
        }
    }

}

extension IAMClientTypes.AccessKeyMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case createDate = "CreateDate"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an Amazon Web Services access key, without its secret key. This data type is used as a response element in the [ListAccessKeys] operation.
    public struct AccessKeyMetadata: Swift.Equatable {
        /// The ID for this access key.
        public var accessKeyId: Swift.String?
        /// The date when the access key was created.
        public var createDate: ClientRuntime.Date?
        /// The status of the access key. Active means that the key is valid for API calls; Inactive means it is not.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user that the key is associated with.
        public var userName: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.createDate = createDate
            self.status = status
            self.userName = userName
        }
    }

}

extension AddClientIDToOpenIDConnectProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clientID = clientID {
            try container.encode(clientID, forKey: ClientRuntime.Key("ClientID"))
        }
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        try container.encode("AddClientIDToOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddClientIDToOpenIDConnectProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddClientIDToOpenIDConnectProviderInput: Swift.Equatable {
    /// The client ID (also known as audience) to add to the IAM OpenID Connect provider resource.
    /// This member is required.
    public var clientID: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM OpenID Connect (OIDC) provider resource to add the client ID to. You can get a list of OIDC provider ARNs by using the [ListOpenIDConnectProviders] operation.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init(
        clientID: Swift.String? = nil,
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.clientID = clientID
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

struct AddClientIDToOpenIDConnectProviderInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
    let clientID: Swift.String?
}

extension AddClientIDToOpenIDConnectProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientID = "ClientID"
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
        let clientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientID)
        clientID = clientIDDecoded
    }
}

extension AddClientIDToOpenIDConnectProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AddClientIDToOpenIDConnectProviderOutput: Swift.Equatable {

    public init() { }
}

enum AddClientIDToOpenIDConnectProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension AddRoleToInstanceProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("AddRoleToInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddRoleToInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddRoleToInstanceProfileInput: Swift.Equatable {
    /// The name of the instance profile to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The name of the role to add. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        instanceProfileName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.roleName = roleName
    }
}

struct AddRoleToInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
    let roleName: Swift.String?
}

extension AddRoleToInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension AddRoleToInstanceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AddRoleToInstanceProfileOutput: Swift.Equatable {

    public init() { }
}

enum AddRoleToInstanceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnmodifiableEntity": return try await UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension AddUserToGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("AddUserToGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddUserToGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddUserToGroupInput: Swift.Equatable {
    /// The name of the group to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the user to add. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.userName = userName
    }
}

struct AddUserToGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let userName: Swift.String?
}

extension AddUserToGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension AddUserToGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AddUserToGroupOutput: Swift.Equatable {

    public init() { }
}

enum AddUserToGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension IAMClientTypes {
    public enum AssignmentStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case any
        case assigned
        case unassigned
        case sdkUnknown(Swift.String)

        public static var allCases: [AssignmentStatusType] {
            return [
                .any,
                .assigned,
                .unassigned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .any: return "Any"
            case .assigned: return "Assigned"
            case .unassigned: return "Unassigned"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssignmentStatusType(rawValue: rawValue) ?? AssignmentStatusType.sdkUnknown(rawValue)
        }
    }
}

extension AttachGroupPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("AttachGroupPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AttachGroupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AttachGroupPolicyInput: Swift.Equatable {
    /// The name (friendly name, not ARN) of the group to attach the policy to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyArn = policyArn
    }
}

struct AttachGroupPolicyInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let policyArn: Swift.String?
}

extension AttachGroupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyArn = "PolicyArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension AttachGroupPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AttachGroupPolicyOutput: Swift.Equatable {

    public init() { }
}

enum AttachGroupPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PolicyNotAttachable": return try await PolicyNotAttachableException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension AttachRolePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("AttachRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AttachRolePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AttachRolePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the role to attach the policy to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.roleName = roleName
    }
}

struct AttachRolePolicyInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let policyArn: Swift.String?
}

extension AttachRolePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension AttachRolePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AttachRolePolicyOutput: Swift.Equatable {

    public init() { }
}

enum AttachRolePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PolicyNotAttachable": return try await PolicyNotAttachableException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnmodifiableEntity": return try await UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension AttachUserPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("AttachUserPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AttachUserPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AttachUserPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the IAM user to attach the policy to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.userName = userName
    }
}

struct AttachUserPolicyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let policyArn: Swift.String?
}

extension AttachUserPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension AttachUserPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AttachUserPolicyOutput: Swift.Equatable {

    public init() { }
}

enum AttachUserPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PolicyNotAttachable": return try await PolicyNotAttachableException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension IAMClientTypes.AttachedPermissionsBoundary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionsBoundaryArn = "PermissionsBoundaryArn"
        case permissionsBoundaryType = "PermissionsBoundaryType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let permissionsBoundaryArn = permissionsBoundaryArn {
            try container.encode(permissionsBoundaryArn, forKey: ClientRuntime.Key("PermissionsBoundaryArn"))
        }
        if let permissionsBoundaryType = permissionsBoundaryType {
            try container.encode(permissionsBoundaryType, forKey: ClientRuntime.Key("PermissionsBoundaryType"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsBoundaryTypeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PermissionsBoundaryAttachmentType.self, forKey: .permissionsBoundaryType)
        permissionsBoundaryType = permissionsBoundaryTypeDecoded
        let permissionsBoundaryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionsBoundaryArn)
        permissionsBoundaryArn = permissionsBoundaryArnDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an attached permissions boundary. An attached permissions boundary is a managed policy that has been attached to a user or role to set the permissions boundary. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
    public struct AttachedPermissionsBoundary: Swift.Equatable {
        /// The ARN of the policy used to set the permissions boundary for the user or role.
        public var permissionsBoundaryArn: Swift.String?
        /// The permissions boundary usage type that indicates what type of IAM resource is used as the permissions boundary for an entity. This data type can only have a value of Policy.
        public var permissionsBoundaryType: IAMClientTypes.PermissionsBoundaryAttachmentType?

        public init(
            permissionsBoundaryArn: Swift.String? = nil,
            permissionsBoundaryType: IAMClientTypes.PermissionsBoundaryAttachmentType? = nil
        )
        {
            self.permissionsBoundaryArn = permissionsBoundaryArn
            self.permissionsBoundaryType = permissionsBoundaryType
        }
    }

}

extension IAMClientTypes.AttachedPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an attached policy. An attached policy is a managed policy that has been attached to a user, group, or role. This data type is used as a response element in the [ListAttachedGroupPolicies], [ListAttachedRolePolicies], [ListAttachedUserPolicies], and [GetAccountAuthorizationDetails] operations. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct AttachedPolicy: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var policyArn: Swift.String?
        /// The friendly name of the attached policy.
        public var policyName: Swift.String?

        public init(
            policyArn: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.policyArn = policyArn
            self.policyName = policyName
        }
    }

}

extension ChangePasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChangePasswordInput(newPassword: \"CONTENT_REDACTED\", oldPassword: \"CONTENT_REDACTED\")"}
}

extension ChangePasswordInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let newPassword = newPassword {
            try container.encode(newPassword, forKey: ClientRuntime.Key("NewPassword"))
        }
        if let oldPassword = oldPassword {
            try container.encode(oldPassword, forKey: ClientRuntime.Key("OldPassword"))
        }
        try container.encode("ChangePassword", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ChangePasswordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ChangePasswordInput: Swift.Equatable {
    /// The new password. The new password must conform to the Amazon Web Services account's password policy, if one exists. The [regex pattern](http://wikipedia.org/wiki/regex) that is used to validate this parameter is a string of characters. That string can include almost any printable ASCII character from the space (\u0020) through the end of the ASCII character range (\u00FF). You can also include the tab (\u0009), line feed (\u000A), and carriage return (\u000D) characters. Any of these characters are valid in a password. However, many tools, such as the Amazon Web Services Management Console, might restrict the ability to type certain characters because they have special meaning within that tool.
    /// This member is required.
    public var newPassword: Swift.String?
    /// The IAM user's current password.
    /// This member is required.
    public var oldPassword: Swift.String?

    public init(
        newPassword: Swift.String? = nil,
        oldPassword: Swift.String? = nil
    )
    {
        self.newPassword = newPassword
        self.oldPassword = oldPassword
    }
}

struct ChangePasswordInputBody: Swift.Equatable {
    let oldPassword: Swift.String?
    let newPassword: Swift.String?
}

extension ChangePasswordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newPassword = "NewPassword"
        case oldPassword = "OldPassword"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oldPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oldPassword)
        oldPassword = oldPasswordDecoded
        let newPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newPassword)
        newPassword = newPasswordDecoded
    }
}

extension ChangePasswordOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ChangePasswordOutput: Swift.Equatable {

    public init() { }
}

enum ChangePasswordOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "EntityTemporarilyUnmodifiable": return try await EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidUserType": return try await InvalidUserTypeException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PasswordPolicyViolation": return try await PasswordPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ConcurrentModificationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ConcurrentModificationExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because multiple requests to change this object were submitted simultaneously. Wait a few minutes and submit your request again.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModification" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes.ContextEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextKeyName = "ContextKeyName"
        case contextKeyType = "ContextKeyType"
        case contextKeyValues = "ContextKeyValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let contextKeyName = contextKeyName {
            try container.encode(contextKeyName, forKey: ClientRuntime.Key("ContextKeyName"))
        }
        if let contextKeyType = contextKeyType {
            try container.encode(contextKeyType, forKey: ClientRuntime.Key("ContextKeyType"))
        }
        if let contextKeyValues = contextKeyValues {
            if !contextKeyValues.isEmpty {
                var contextKeyValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextKeyValues"))
                for (index0, contextkeyvaluetype0) in contextKeyValues.enumerated() {
                    try contextKeyValuesContainer.encode(contextkeyvaluetype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var contextKeyValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextKeyValues"))
                try contextKeyValuesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contextKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contextKeyName)
        contextKeyName = contextKeyNameDecoded
        if containerValues.contains(.contextKeyValues) {
            struct KeyVal0{struct member{}}
            let contextKeyValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .contextKeyValues)
            if let contextKeyValuesWrappedContainer = contextKeyValuesWrappedContainer {
                let contextKeyValuesContainer = try contextKeyValuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var contextKeyValuesBuffer:[Swift.String]? = nil
                if let contextKeyValuesContainer = contextKeyValuesContainer {
                    contextKeyValuesBuffer = [Swift.String]()
                    for stringContainer0 in contextKeyValuesContainer {
                        contextKeyValuesBuffer?.append(stringContainer0)
                    }
                }
                contextKeyValues = contextKeyValuesBuffer
            } else {
                contextKeyValues = []
            }
        } else {
            contextKeyValues = nil
        }
        let contextKeyTypeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ContextKeyTypeEnum.self, forKey: .contextKeyType)
        contextKeyType = contextKeyTypeDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about a condition context key. It includes the name of the key and specifies the value (or values, if the context key supports multiple values) to use in the simulation. This information is used when evaluating the Condition elements of the input policies. This data type is used as an input parameter to [SimulateCustomPolicy] and [SimulatePrincipalPolicy].
    public struct ContextEntry: Swift.Equatable {
        /// The full name of a condition context key, including the service prefix. For example, aws:SourceIp or s3:VersionId.
        public var contextKeyName: Swift.String?
        /// The data type of the value (or values) specified in the ContextKeyValues parameter.
        public var contextKeyType: IAMClientTypes.ContextKeyTypeEnum?
        /// The value (or values, if the condition context key supports multiple values) to provide to the simulation when the key is referenced by a Condition element in an input policy.
        public var contextKeyValues: [Swift.String]?

        public init(
            contextKeyName: Swift.String? = nil,
            contextKeyType: IAMClientTypes.ContextKeyTypeEnum? = nil,
            contextKeyValues: [Swift.String]? = nil
        )
        {
            self.contextKeyName = contextKeyName
            self.contextKeyType = contextKeyType
            self.contextKeyValues = contextKeyValues
        }
    }

}

extension IAMClientTypes {
    public enum ContextKeyTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case binary
        case binaryList
        case boolean
        case booleanList
        case date
        case dateList
        case ip
        case ipList
        case numeric
        case numericList
        case string
        case stringList
        case sdkUnknown(Swift.String)

        public static var allCases: [ContextKeyTypeEnum] {
            return [
                .binary,
                .binaryList,
                .boolean,
                .booleanList,
                .date,
                .dateList,
                .ip,
                .ipList,
                .numeric,
                .numericList,
                .string,
                .stringList,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .binary: return "binary"
            case .binaryList: return "binaryList"
            case .boolean: return "boolean"
            case .booleanList: return "booleanList"
            case .date: return "date"
            case .dateList: return "dateList"
            case .ip: return "ip"
            case .ipList: return "ipList"
            case .numeric: return "numeric"
            case .numericList: return "numericList"
            case .string: return "string"
            case .stringList: return "stringList"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContextKeyTypeEnum(rawValue: rawValue) ?? ContextKeyTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension CreateAccessKeyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("CreateAccessKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateAccessKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAccessKeyInput: Swift.Equatable {
    /// The name of the IAM user that the new key will belong to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

struct CreateAccessKeyInputBody: Swift.Equatable {
    let userName: Swift.String?
}

extension CreateAccessKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension CreateAccessKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccessKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessKey = output.accessKey
        } else {
            self.accessKey = nil
        }
    }
}

/// Contains the response to a successful [CreateAccessKey] request.
public struct CreateAccessKeyOutput: Swift.Equatable {
    /// A structure with details about the access key.
    /// This member is required.
    public var accessKey: IAMClientTypes.AccessKey?

    public init(
        accessKey: IAMClientTypes.AccessKey? = nil
    )
    {
        self.accessKey = accessKey
    }
}

struct CreateAccessKeyOutputBody: Swift.Equatable {
    let accessKey: IAMClientTypes.AccessKey?
}

extension CreateAccessKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKey = "AccessKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateAccessKeyResult"))
        let accessKeyDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AccessKey.self, forKey: .accessKey)
        accessKey = accessKeyDecoded
    }
}

enum CreateAccessKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateAccountAliasInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountAlias = accountAlias {
            try container.encode(accountAlias, forKey: ClientRuntime.Key("AccountAlias"))
        }
        try container.encode("CreateAccountAlias", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateAccountAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAccountAliasInput: Swift.Equatable {
    /// The account alias to create. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have two dashes in a row.
    /// This member is required.
    public var accountAlias: Swift.String?

    public init(
        accountAlias: Swift.String? = nil
    )
    {
        self.accountAlias = accountAlias
    }
}

struct CreateAccountAliasInputBody: Swift.Equatable {
    let accountAlias: Swift.String?
}

extension CreateAccountAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAlias = "AccountAlias"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountAlias)
        accountAlias = accountAliasDecoded
    }
}

extension CreateAccountAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateAccountAliasOutput: Swift.Equatable {

    public init() { }
}

enum CreateAccountAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        try container.encode("CreateGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateGroupInput: Swift.Equatable {
    /// The name of the group to create. Do not include the path in this value. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    /// This member is required.
    public var groupName: Swift.String?
    /// The path to the group. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        path: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.path = path
    }
}

struct CreateGroupInputBody: Swift.Equatable {
    let path: Swift.String?
    let groupName: Swift.String?
}

extension CreateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case path = "Path"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension CreateGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.group = output.group
        } else {
            self.group = nil
        }
    }
}

/// Contains the response to a successful [CreateGroup] request.
public struct CreateGroupOutput: Swift.Equatable {
    /// A structure containing details about the new group.
    /// This member is required.
    public var group: IAMClientTypes.Group?

    public init(
        group: IAMClientTypes.Group? = nil
    )
    {
        self.group = group
    }
}

struct CreateGroupOutputBody: Swift.Equatable {
    let group: IAMClientTypes.Group?
}

extension CreateGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateGroupResult"))
        let groupDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Group.self, forKey: .group)
        group = groupDecoded
    }
}

enum CreateGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateInstanceProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("CreateInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateInstanceProfileInput: Swift.Equatable {
    /// The name of the instance profile to create. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The path to the instance profile. For more information about paths, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// A list of tags that you want to attach to the newly created IAM instance profile. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        instanceProfileName: Swift.String? = nil,
        path: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.path = path
        self.tags = tags
    }
}

struct CreateInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
    let path: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case path = "Path"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateInstanceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateInstanceProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

/// Contains the response to a successful [CreateInstanceProfile] request.
public struct CreateInstanceProfileOutput: Swift.Equatable {
    /// A structure containing details about the new instance profile.
    /// This member is required.
    public var instanceProfile: IAMClientTypes.InstanceProfile?

    public init(
        instanceProfile: IAMClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct CreateInstanceProfileOutputBody: Swift.Equatable {
    let instanceProfile: IAMClientTypes.InstanceProfile?
}

extension CreateInstanceProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfile = "InstanceProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateInstanceProfileResult"))
        let instanceProfileDecoded = try containerValues.decodeIfPresent(IAMClientTypes.InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

enum CreateInstanceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateLoginProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLoginProfileInput(passwordResetRequired: \(Swift.String(describing: passwordResetRequired)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

extension CreateLoginProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let password = password {
            try container.encode(password, forKey: ClientRuntime.Key("Password"))
        }
        if let passwordResetRequired = passwordResetRequired {
            try container.encode(passwordResetRequired, forKey: ClientRuntime.Key("PasswordResetRequired"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("CreateLoginProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateLoginProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateLoginProfileInput: Swift.Equatable {
    /// The new password for the user. The [regex pattern](http://wikipedia.org/wiki/regex) that is used to validate this parameter is a string of characters. That string can include almost any printable ASCII character from the space (\u0020) through the end of the ASCII character range (\u00FF). You can also include the tab (\u0009), line feed (\u000A), and carriage return (\u000D) characters. Any of these characters are valid in a password. However, many tools, such as the Amazon Web Services Management Console, might restrict the ability to type certain characters because they have special meaning within that tool.
    /// This member is required.
    public var password: Swift.String?
    /// Specifies whether the user is required to set a new password on next sign-in.
    public var passwordResetRequired: Swift.Bool?
    /// The name of the IAM user to create a password for. The user must already exist. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        password: Swift.String? = nil,
        passwordResetRequired: Swift.Bool? = nil,
        userName: Swift.String? = nil
    )
    {
        self.password = password
        self.passwordResetRequired = passwordResetRequired
        self.userName = userName
    }
}

struct CreateLoginProfileInputBody: Swift.Equatable {
    let userName: Swift.String?
    let password: Swift.String?
    let passwordResetRequired: Swift.Bool?
}

extension CreateLoginProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case passwordResetRequired = "PasswordResetRequired"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let passwordResetRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .passwordResetRequired) ?? false
        passwordResetRequired = passwordResetRequiredDecoded
    }
}

extension CreateLoginProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLoginProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.loginProfile = output.loginProfile
        } else {
            self.loginProfile = nil
        }
    }
}

/// Contains the response to a successful [CreateLoginProfile] request.
public struct CreateLoginProfileOutput: Swift.Equatable {
    /// A structure containing the user name and password create date.
    /// This member is required.
    public var loginProfile: IAMClientTypes.LoginProfile?

    public init(
        loginProfile: IAMClientTypes.LoginProfile? = nil
    )
    {
        self.loginProfile = loginProfile
    }
}

struct CreateLoginProfileOutputBody: Swift.Equatable {
    let loginProfile: IAMClientTypes.LoginProfile?
}

extension CreateLoginProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loginProfile = "LoginProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateLoginProfileResult"))
        let loginProfileDecoded = try containerValues.decodeIfPresent(IAMClientTypes.LoginProfile.self, forKey: .loginProfile)
        loginProfile = loginProfileDecoded
    }
}

enum CreateLoginProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PasswordPolicyViolation": return try await PasswordPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateOpenIDConnectProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clientIDList = clientIDList {
            if !clientIDList.isEmpty {
                var clientIDListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClientIDList"))
                for (index0, clientidtype0) in clientIDList.enumerated() {
                    try clientIDListContainer.encode(clientidtype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var clientIDListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClientIDList"))
                try clientIDListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let thumbprintList = thumbprintList {
            if !thumbprintList.isEmpty {
                var thumbprintListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ThumbprintList"))
                for (index0, thumbprinttype0) in thumbprintList.enumerated() {
                    try thumbprintListContainer.encode(thumbprinttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var thumbprintListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ThumbprintList"))
                try thumbprintListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let url = url {
            try container.encode(url, forKey: ClientRuntime.Key("Url"))
        }
        try container.encode("CreateOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateOpenIDConnectProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateOpenIDConnectProviderInput: Swift.Equatable {
    /// Provides a list of client IDs, also known as audiences. When a mobile or web app registers with an OpenID Connect provider, they establish a value that identifies the application. This is the value that's sent as the client_id parameter on OAuth requests. You can register multiple client IDs with the same provider. For example, you might have multiple applications that use the same OIDC provider. You cannot register more than 100 client IDs with a single IAM OIDC provider. There is no defined format for a client ID. The CreateOpenIDConnectProviderRequest operation accepts client IDs up to 255 characters long.
    public var clientIDList: [Swift.String]?
    /// A list of tags that you want to attach to the new IAM OpenID Connect (OIDC) provider. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?
    /// A list of server certificate thumbprints for the OpenID Connect (OIDC) identity provider's server certificates. Typically this list includes only one entry. However, IAM lets you have up to five thumbprints for an OIDC provider. This lets you maintain multiple thumbprints if the identity provider is rotating certificates. The server certificate thumbprint is the hex-encoded SHA-1 hash value of the X.509 certificate used by the domain where the OpenID Connect provider makes its keys available. It is always a 40-character string. You must provide at least one thumbprint when creating an IAM OIDC provider. For example, assume that the OIDC provider is server.example.com and the provider stores its keys at https://keys.server.example.com/openid-connect. In that case, the thumbprint string would be the hex-encoded SHA-1 hash value of the certificate used by https://keys.server.example.com. For more information about obtaining the OIDC provider thumbprint, see [Obtaining the thumbprint for an OpenID Connect provider](https://docs.aws.amazon.com/IAM/latest/UserGuide/identity-providers-oidc-obtain-thumbprint.html) in the IAM user Guide.
    /// This member is required.
    public var thumbprintList: [Swift.String]?
    /// The URL of the identity provider. The URL must begin with https:// and should correspond to the iss claim in the provider's OpenID Connect ID tokens. Per the OIDC standard, path components are allowed but query parameters are not. Typically the URL consists of only a hostname, like https://server.example.org or https://example.com. The URL should not contain a port number. You cannot register the same provider multiple times in a single Amazon Web Services account. If you try to submit a URL that has already been used for an OpenID Connect provider in the Amazon Web Services account, you will get an error.
    /// This member is required.
    public var url: Swift.String?

    public init(
        clientIDList: [Swift.String]? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        thumbprintList: [Swift.String]? = nil,
        url: Swift.String? = nil
    )
    {
        self.clientIDList = clientIDList
        self.tags = tags
        self.thumbprintList = thumbprintList
        self.url = url
    }
}

struct CreateOpenIDConnectProviderInputBody: Swift.Equatable {
    let url: Swift.String?
    let clientIDList: [Swift.String]?
    let thumbprintList: [Swift.String]?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateOpenIDConnectProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIDList = "ClientIDList"
        case tags = "Tags"
        case thumbprintList = "ThumbprintList"
        case url = "Url"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        if containerValues.contains(.clientIDList) {
            struct KeyVal0{struct member{}}
            let clientIDListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .clientIDList)
            if let clientIDListWrappedContainer = clientIDListWrappedContainer {
                let clientIDListContainer = try clientIDListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var clientIDListBuffer:[Swift.String]? = nil
                if let clientIDListContainer = clientIDListContainer {
                    clientIDListBuffer = [Swift.String]()
                    for stringContainer0 in clientIDListContainer {
                        clientIDListBuffer?.append(stringContainer0)
                    }
                }
                clientIDList = clientIDListBuffer
            } else {
                clientIDList = []
            }
        } else {
            clientIDList = nil
        }
        if containerValues.contains(.thumbprintList) {
            struct KeyVal0{struct member{}}
            let thumbprintListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .thumbprintList)
            if let thumbprintListWrappedContainer = thumbprintListWrappedContainer {
                let thumbprintListContainer = try thumbprintListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var thumbprintListBuffer:[Swift.String]? = nil
                if let thumbprintListContainer = thumbprintListContainer {
                    thumbprintListBuffer = [Swift.String]()
                    for stringContainer0 in thumbprintListContainer {
                        thumbprintListBuffer?.append(stringContainer0)
                    }
                }
                thumbprintList = thumbprintListBuffer
            } else {
                thumbprintList = []
            }
        } else {
            thumbprintList = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateOpenIDConnectProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateOpenIDConnectProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.openIDConnectProviderArn = output.openIDConnectProviderArn
            self.tags = output.tags
        } else {
            self.openIDConnectProviderArn = nil
            self.tags = nil
        }
    }
}

/// Contains the response to a successful [CreateOpenIDConnectProvider] request.
public struct CreateOpenIDConnectProviderOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new IAM OpenID Connect provider that is created. For more information, see [OpenIDConnectProviderListEntry].
    public var openIDConnectProviderArn: Swift.String?
    /// A list of tags that are attached to the new IAM OIDC provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        openIDConnectProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.tags = tags
    }
}

struct CreateOpenIDConnectProviderOutputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateOpenIDConnectProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateOpenIDConnectProviderResult"))
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

enum CreateOpenIDConnectProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreatePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("CreatePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreatePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePolicyInput: Swift.Equatable {
    /// A friendly description of the policy. Typically used to store information about the permissions defined in the policy. For example, "Grants access to production DynamoDB tables." The policy description is immutable. After a value is assigned, it cannot be changed.
    public var description: Swift.String?
    /// The path for the policy. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters. You cannot use an asterisk (*) in the path name.
    public var path: Swift.String?
    /// The JSON policy document that you want to use as the content for the new policy. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). To learn more about JSON policy grammar, see [Grammar of the IAM JSON policy language](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_grammar.html) in the IAM User Guide. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The friendly name of the policy. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    /// This member is required.
    public var policyName: Swift.String?
    /// A list of tags that you want to attach to the new IAM customer managed policy. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        path: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.path = path
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.tags = tags
    }
}

struct CreatePolicyInputBody: Swift.Equatable {
    let policyName: Swift.String?
    let path: Swift.String?
    let policyDocument: Swift.String?
    let description: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreatePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case path = "Path"
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreatePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

/// Contains the response to a successful [CreatePolicy] request.
public struct CreatePolicyOutput: Swift.Equatable {
    /// A structure containing details about the new policy.
    public var policy: IAMClientTypes.Policy?

    public init(
        policy: IAMClientTypes.Policy? = nil
    )
    {
        self.policy = policy
    }
}

struct CreatePolicyOutputBody: Swift.Equatable {
    let policy: IAMClientTypes.Policy?
}

extension CreatePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreatePolicyResult"))
        let policyDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Policy.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum CreatePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreatePolicyVersionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let setAsDefault = setAsDefault {
            try container.encode(setAsDefault, forKey: ClientRuntime.Key("SetAsDefault"))
        }
        try container.encode("CreatePolicyVersion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreatePolicyVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePolicyVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy to which you want to add a new version. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The JSON policy document that you want to use as the content for this new version of the policy. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// Specifies whether to set this version as the policy's default version. When this parameter is true, the new policy version becomes the operative version. That is, it becomes the version that is in effect for the IAM users, groups, and roles that the policy is attached to. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    public var setAsDefault: Swift.Bool?

    public init(
        policyArn: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        setAsDefault: Swift.Bool? = nil
    )
    {
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.setAsDefault = setAsDefault
    }
}

struct CreatePolicyVersionInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let policyDocument: Swift.String?
    let setAsDefault: Swift.Bool?
}

extension CreatePolicyVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case policyDocument = "PolicyDocument"
        case setAsDefault = "SetAsDefault"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let setAsDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .setAsDefault) ?? false
        setAsDefault = setAsDefaultDecoded
    }
}

extension CreatePolicyVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePolicyVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyVersion = output.policyVersion
        } else {
            self.policyVersion = nil
        }
    }
}

/// Contains the response to a successful [CreatePolicyVersion] request.
public struct CreatePolicyVersionOutput: Swift.Equatable {
    /// A structure containing details about the new policy version.
    public var policyVersion: IAMClientTypes.PolicyVersion?

    public init(
        policyVersion: IAMClientTypes.PolicyVersion? = nil
    )
    {
        self.policyVersion = policyVersion
    }
}

struct CreatePolicyVersionOutputBody: Swift.Equatable {
    let policyVersion: IAMClientTypes.PolicyVersion?
}

extension CreatePolicyVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyVersion = "PolicyVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreatePolicyVersionResult"))
        let policyVersionDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyVersion.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
    }
}

enum CreatePolicyVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let assumeRolePolicyDocument = assumeRolePolicyDocument {
            try container.encode(assumeRolePolicyDocument, forKey: ClientRuntime.Key("AssumeRolePolicyDocument"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let maxSessionDuration = maxSessionDuration {
            try container.encode(maxSessionDuration, forKey: ClientRuntime.Key("MaxSessionDuration"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("CreateRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRoleInput: Swift.Equatable {
    /// The trust relationship policy document that grants an entity permission to assume the role. In IAM, you must provide a JSON policy that has been converted to a string. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// Upon success, the response includes the same trust policy in JSON format.
    /// This member is required.
    public var assumeRolePolicyDocument: Swift.String?
    /// A description of the role.
    public var description: Swift.String?
    /// The maximum session duration (in seconds) that you want to set for the specified role. If you do not specify a value for this setting, the default value of one hour is applied. This setting can have a value from 1 hour to 12 hours. Anyone who assumes the role from the CLI or API can use the DurationSeconds API parameter or the duration-seconds CLI parameter to request a longer session. The MaxSessionDuration setting determines the maximum duration that can be requested using the DurationSeconds parameter. If users don't specify a value for the DurationSeconds parameter, their security credentials are valid for one hour by default. This applies when you use the AssumeRole* API operations or the assume-role* CLI operations but does not apply when you use those operations to create a console URL. For more information, see [Using IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html) in the IAM User Guide.
    public var maxSessionDuration: Swift.Int?
    /// The path to the role. For more information about paths, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// The ARN of the managed policy that is used to set the permissions boundary for the role. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    public var permissionsBoundary: Swift.String?
    /// The name of the role to create. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource". This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?
    /// A list of tags that you want to attach to the new role. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        assumeRolePolicyDocument: Swift.String? = nil,
        description: Swift.String? = nil,
        maxSessionDuration: Swift.Int? = nil,
        path: Swift.String? = nil,
        permissionsBoundary: Swift.String? = nil,
        roleName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.assumeRolePolicyDocument = assumeRolePolicyDocument
        self.description = description
        self.maxSessionDuration = maxSessionDuration
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.roleName = roleName
        self.tags = tags
    }
}

struct CreateRoleInputBody: Swift.Equatable {
    let path: Swift.String?
    let roleName: Swift.String?
    let assumeRolePolicyDocument: Swift.String?
    let description: Swift.String?
    let maxSessionDuration: Swift.Int?
    let permissionsBoundary: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
        case description = "Description"
        case maxSessionDuration = "MaxSessionDuration"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case roleName = "RoleName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let assumeRolePolicyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assumeRolePolicyDocument)
        assumeRolePolicyDocument = assumeRolePolicyDocumentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let maxSessionDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSessionDuration)
        maxSessionDuration = maxSessionDurationDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRoleOutputBody = try responseDecoder.decode(responseBody: data)
            self.role = output.role
        } else {
            self.role = nil
        }
    }
}

/// Contains the response to a successful [CreateRole] request.
public struct CreateRoleOutput: Swift.Equatable {
    /// A structure containing details about the new role.
    /// This member is required.
    public var role: IAMClientTypes.Role?

    public init(
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

struct CreateRoleOutputBody: Swift.Equatable {
    let role: IAMClientTypes.Role?
}

extension CreateRoleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateRoleResult"))
        let roleDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Role.self, forKey: .role)
        role = roleDecoded
    }
}

enum CreateRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateSAMLProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let samlMetadataDocument = samlMetadataDocument {
            try container.encode(samlMetadataDocument, forKey: ClientRuntime.Key("SAMLMetadataDocument"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("CreateSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateSAMLProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSAMLProviderInput: Swift.Equatable {
    /// The name of the provider to create. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var name: Swift.String?
    /// An XML document generated by an identity provider (IdP) that supports SAML 2.0. The document includes the issuer's name, expiration information, and keys that can be used to validate the SAML authentication response (assertions) that are received from the IdP. You must generate the metadata document using the identity management software that is used as your organization's IdP. For more information, see [About SAML 2.0-based federation](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_saml.html) in the IAM User Guide
    /// This member is required.
    public var samlMetadataDocument: Swift.String?
    /// A list of tags that you want to attach to the new IAM SAML provider. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        name: Swift.String? = nil,
        samlMetadataDocument: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.name = name
        self.samlMetadataDocument = samlMetadataDocument
        self.tags = tags
    }
}

struct CreateSAMLProviderInputBody: Swift.Equatable {
    let samlMetadataDocument: Swift.String?
    let name: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateSAMLProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case samlMetadataDocument = "SAMLMetadataDocument"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlMetadataDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlMetadataDocument)
        samlMetadataDocument = samlMetadataDocumentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateSAMLProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSAMLProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.samlProviderArn = output.samlProviderArn
            self.tags = output.tags
        } else {
            self.samlProviderArn = nil
            self.tags = nil
        }
    }
}

/// Contains the response to a successful [CreateSAMLProvider] request.
public struct CreateSAMLProviderOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new SAML provider resource in IAM.
    public var samlProviderArn: Swift.String?
    /// A list of tags that are attached to the new IAM SAML provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        samlProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
        self.tags = tags
    }
}

struct CreateSAMLProviderOutputBody: Swift.Equatable {
    let samlProviderArn: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateSAMLProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateSAMLProviderResult"))
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

enum CreateSAMLProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateServiceLinkedRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let awsServiceName = awsServiceName {
            try container.encode(awsServiceName, forKey: ClientRuntime.Key("AWSServiceName"))
        }
        if let customSuffix = customSuffix {
            try container.encode(customSuffix, forKey: ClientRuntime.Key("CustomSuffix"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        try container.encode("CreateServiceLinkedRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateServiceLinkedRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateServiceLinkedRoleInput: Swift.Equatable {
    /// The service principal for the Amazon Web Services service to which this role is attached. You use a string similar to a URL but without the http:// in front. For example: elasticbeanstalk.amazonaws.com. Service principals are unique and case-sensitive. To find the exact service principal for your service-linked role, see [Amazon Web Services services that work with IAM](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html) in the IAM User Guide. Look for the services that have Yes in the Service-Linked Role column. Choose the Yes link to view the service-linked role documentation for that service.
    /// This member is required.
    public var awsServiceName: Swift.String?
    /// A string that you provide, which is combined with the service-provided prefix to form the complete role name. If you make multiple requests for the same service, then you must supply a different CustomSuffix for each request. Otherwise the request fails with a duplicate role name error. For example, you could add -1 or -debug to the suffix. Some services do not support the CustomSuffix parameter. If you provide an optional suffix and the operation fails, try the operation again without the suffix.
    public var customSuffix: Swift.String?
    /// The description of the role.
    public var description: Swift.String?

    public init(
        awsServiceName: Swift.String? = nil,
        customSuffix: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.awsServiceName = awsServiceName
        self.customSuffix = customSuffix
        self.description = description
    }
}

struct CreateServiceLinkedRoleInputBody: Swift.Equatable {
    let awsServiceName: Swift.String?
    let description: Swift.String?
    let customSuffix: Swift.String?
}

extension CreateServiceLinkedRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsServiceName = "AWSServiceName"
        case customSuffix = "CustomSuffix"
        case description = "Description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsServiceName)
        awsServiceName = awsServiceNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let customSuffixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customSuffix)
        customSuffix = customSuffixDecoded
    }
}

extension CreateServiceLinkedRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServiceLinkedRoleOutputBody = try responseDecoder.decode(responseBody: data)
            self.role = output.role
        } else {
            self.role = nil
        }
    }
}

public struct CreateServiceLinkedRoleOutput: Swift.Equatable {
    /// A [Role] object that contains details about the newly created role.
    public var role: IAMClientTypes.Role?

    public init(
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

struct CreateServiceLinkedRoleOutputBody: Swift.Equatable {
    let role: IAMClientTypes.Role?
}

extension CreateServiceLinkedRoleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateServiceLinkedRoleResult"))
        let roleDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Role.self, forKey: .role)
        role = roleDecoded
    }
}

enum CreateServiceLinkedRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateServiceSpecificCredentialInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("CreateServiceSpecificCredential", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateServiceSpecificCredentialInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateServiceSpecificCredentialInput: Swift.Equatable {
    /// The name of the Amazon Web Services service that is to be associated with the credentials. The service you specify here is the only service that can be accessed using these credentials.
    /// This member is required.
    public var serviceName: Swift.String?
    /// The name of the IAM user that is to be associated with the credentials. The new service-specific credentials have the same permissions as the associated user except that they can be used only to access the specified service. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serviceName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceName = serviceName
        self.userName = userName
    }
}

struct CreateServiceSpecificCredentialInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serviceName: Swift.String?
}

extension CreateServiceSpecificCredentialInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName = "ServiceName"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension CreateServiceSpecificCredentialOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServiceSpecificCredentialOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceSpecificCredential = output.serviceSpecificCredential
        } else {
            self.serviceSpecificCredential = nil
        }
    }
}

public struct CreateServiceSpecificCredentialOutput: Swift.Equatable {
    /// A structure that contains information about the newly created service-specific credential. This is the only time that the password for this credential set is available. It cannot be recovered later. Instead, you must reset the password with [ResetServiceSpecificCredential].
    public var serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential?

    public init(
        serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential? = nil
    )
    {
        self.serviceSpecificCredential = serviceSpecificCredential
    }
}

struct CreateServiceSpecificCredentialOutputBody: Swift.Equatable {
    let serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential?
}

extension CreateServiceSpecificCredentialOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSpecificCredential = "ServiceSpecificCredential"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateServiceSpecificCredentialResult"))
        let serviceSpecificCredentialDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ServiceSpecificCredential.self, forKey: .serviceSpecificCredential)
        serviceSpecificCredential = serviceSpecificCredentialDecoded
    }
}

enum CreateServiceSpecificCredentialOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NotSupportedService": return try await ServiceNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateUserInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("CreateUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The path for the user name. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// The ARN of the managed policy that is used to set the permissions boundary for the user. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    public var permissionsBoundary: Swift.String?
    /// A list of tags that you want to attach to the new user. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?
    /// The name of the user to create. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    /// This member is required.
    public var userName: Swift.String?

    public init(
        path: Swift.String? = nil,
        permissionsBoundary: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.tags = tags
        self.userName = userName
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let path: Swift.String?
    let userName: Swift.String?
    let permissionsBoundary: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case tags = "Tags"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

/// Contains the response to a successful [CreateUser] request.
public struct CreateUserOutput: Swift.Equatable {
    /// A structure with details about the new IAM user.
    public var user: IAMClientTypes.User?

    public init(
        user: IAMClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct CreateUserOutputBody: Swift.Equatable {
    let user: IAMClientTypes.User?
}

extension CreateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateUserResult"))
        let userDecoded = try containerValues.decodeIfPresent(IAMClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

enum CreateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateVirtualMFADeviceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let virtualMFADeviceName = virtualMFADeviceName {
            try container.encode(virtualMFADeviceName, forKey: ClientRuntime.Key("VirtualMFADeviceName"))
        }
        try container.encode("CreateVirtualMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateVirtualMFADeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateVirtualMFADeviceInput: Swift.Equatable {
    /// The path for the virtual MFA device. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// A list of tags that you want to attach to the new IAM virtual MFA device. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?
    /// The name of the virtual MFA device, which must be unique. Use with path to uniquely identify a virtual MFA device. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var virtualMFADeviceName: Swift.String?

    public init(
        path: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        virtualMFADeviceName: Swift.String? = nil
    )
    {
        self.path = path
        self.tags = tags
        self.virtualMFADeviceName = virtualMFADeviceName
    }
}

struct CreateVirtualMFADeviceInputBody: Swift.Equatable {
    let path: Swift.String?
    let virtualMFADeviceName: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateVirtualMFADeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "Path"
        case tags = "Tags"
        case virtualMFADeviceName = "VirtualMFADeviceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let virtualMFADeviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualMFADeviceName)
        virtualMFADeviceName = virtualMFADeviceNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateVirtualMFADeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVirtualMFADeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.virtualMFADevice = output.virtualMFADevice
        } else {
            self.virtualMFADevice = nil
        }
    }
}

/// Contains the response to a successful [CreateVirtualMFADevice] request.
public struct CreateVirtualMFADeviceOutput: Swift.Equatable {
    /// A structure containing details about the new virtual MFA device.
    /// This member is required.
    public var virtualMFADevice: IAMClientTypes.VirtualMFADevice?

    public init(
        virtualMFADevice: IAMClientTypes.VirtualMFADevice? = nil
    )
    {
        self.virtualMFADevice = virtualMFADevice
    }
}

struct CreateVirtualMFADeviceOutputBody: Swift.Equatable {
    let virtualMFADevice: IAMClientTypes.VirtualMFADevice?
}

extension CreateVirtualMFADeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualMFADevice = "VirtualMFADevice"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateVirtualMFADeviceResult"))
        let virtualMFADeviceDecoded = try containerValues.decodeIfPresent(IAMClientTypes.VirtualMFADevice.self, forKey: .virtualMFADevice)
        virtualMFADevice = virtualMFADeviceDecoded
    }
}

enum CreateVirtualMFADeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CredentialReportExpiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<CredentialReportExpiredExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because the most recent credential report has expired. To generate a new credential report, use [GenerateCredentialReport]. For more information about credential report expiration, see [Getting credential reports](https://docs.aws.amazon.com/IAM/latest/UserGuide/credential-reports.html) in the IAM User Guide.
public struct CredentialReportExpiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReportExpired" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CredentialReportExpiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CredentialReportExpiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CredentialReportNotPresentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<CredentialReportNotPresentExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because the credential report does not exist. To generate a credential report, use [GenerateCredentialReport].
public struct CredentialReportNotPresentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReportNotPresent" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CredentialReportNotPresentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CredentialReportNotPresentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CredentialReportNotReadyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<CredentialReportNotReadyExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because the credential report is still being generated.
public struct CredentialReportNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReportInProgress" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CredentialReportNotReadyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CredentialReportNotReadyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeactivateMFADeviceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeactivateMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeactivateMFADeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeactivateMFADeviceInput: Swift.Equatable {
    /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: =,.@:/-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The name of the user whose MFA device you want to deactivate. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

struct DeactivateMFADeviceInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serialNumber: Swift.String?
}

extension DeactivateMFADeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
    }
}

extension DeactivateMFADeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeactivateMFADeviceOutput: Swift.Equatable {

    public init() { }
}

enum DeactivateMFADeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "EntityTemporarilyUnmodifiable": return try await EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteAccessKeyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteAccessKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteAccessKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAccessKeyInput: Swift.Equatable {
    /// The access key ID for the access key ID and secret access key you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var accessKeyId: Swift.String?
    /// The name of the user whose access key pair you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        accessKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.userName = userName
    }
}

struct DeleteAccessKeyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let accessKeyId: Swift.String?
}

extension DeleteAccessKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
    }
}

extension DeleteAccessKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessKeyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteAccountAliasInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountAlias = accountAlias {
            try container.encode(accountAlias, forKey: ClientRuntime.Key("AccountAlias"))
        }
        try container.encode("DeleteAccountAlias", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteAccountAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAccountAliasInput: Swift.Equatable {
    /// The name of the account alias to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have two dashes in a row.
    /// This member is required.
    public var accountAlias: Swift.String?

    public init(
        accountAlias: Swift.String? = nil
    )
    {
        self.accountAlias = accountAlias
    }
}

struct DeleteAccountAliasInputBody: Swift.Equatable {
    let accountAlias: Swift.String?
}

extension DeleteAccountAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAlias = "AccountAlias"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountAlias)
        accountAlias = accountAliasDecoded
    }
}

extension DeleteAccountAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccountAliasOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccountAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteAccountPasswordPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("DeleteAccountPasswordPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteAccountPasswordPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAccountPasswordPolicyInput: Swift.Equatable {

    public init() { }
}

extension DeleteAccountPasswordPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccountPasswordPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccountPasswordPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<DeleteConflictExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because it attempted to delete a resource that has attached subordinate entities. The error message describes these entities.
public struct DeleteConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeleteConflict" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DeleteConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        try container.encode("DeleteGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGroupInput: Swift.Equatable {
    /// The name of the IAM group to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?

    public init(
        groupName: Swift.String? = nil
    )
    {
        self.groupName = groupName
    }
}

struct DeleteGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
}

extension DeleteGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension DeleteGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "DeleteConflict": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteGroupPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        try container.encode("DeleteGroupPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteGroupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGroupPolicyInput: Swift.Equatable {
    /// The name (friendly name, not ARN) identifying the group that the policy is embedded in. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name identifying the policy document to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyName = policyName
    }
}

struct DeleteGroupPolicyInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let policyName: Swift.String?
}

extension DeleteGroupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyName = "PolicyName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension DeleteGroupPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGroupPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGroupPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteInstanceProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        try container.encode("DeleteInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteInstanceProfileInput: Swift.Equatable {
    /// The name of the instance profile to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?

    public init(
        instanceProfileName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
    }
}

struct DeleteInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
}

extension DeleteInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
    }
}

extension DeleteInstanceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteInstanceProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteInstanceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "DeleteConflict": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteLoginProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteLoginProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteLoginProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLoginProfileInput: Swift.Equatable {
    /// The name of the user whose password you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

struct DeleteLoginProfileInputBody: Swift.Equatable {
    let userName: Swift.String?
}

extension DeleteLoginProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteLoginProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLoginProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLoginProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "EntityTemporarilyUnmodifiable": return try await EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteOpenIDConnectProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        try container.encode("DeleteOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteOpenIDConnectProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteOpenIDConnectProviderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM OpenID Connect provider resource object to delete. You can get a list of OpenID Connect provider resource ARNs by using the [ListOpenIDConnectProviders] operation.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init(
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

struct DeleteOpenIDConnectProviderInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
}

extension DeleteOpenIDConnectProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
    }
}

extension DeleteOpenIDConnectProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteOpenIDConnectProviderOutput: Swift.Equatable {

    public init() { }
}

enum DeleteOpenIDConnectProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeletePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("DeletePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeletePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to delete. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        policyArn: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

struct DeletePolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
}

extension DeletePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension DeletePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeletePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "DeleteConflict": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeletePolicyVersionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
        try container.encode("DeletePolicyVersion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeletePolicyVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePolicyVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy from which you want to delete a version. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The policy version to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consists of the lowercase letter 'v' followed by one or two digits, and optionally followed by a period '.' and a string of letters and digits. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.versionId = versionId
    }
}

struct DeletePolicyVersionInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let versionId: Swift.String?
}

extension DeletePolicyVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case versionId = "VersionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension DeletePolicyVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePolicyVersionOutput: Swift.Equatable {

    public init() { }
}

enum DeletePolicyVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "DeleteConflict": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("DeleteRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRoleInput: Swift.Equatable {
    /// The name of the role to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

struct DeleteRoleInputBody: Swift.Equatable {
    let roleName: Swift.String?
}

extension DeleteRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension DeleteRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRoleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "DeleteConflict": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnmodifiableEntity": return try await UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteRolePermissionsBoundaryInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("DeleteRolePermissionsBoundary", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteRolePermissionsBoundaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRolePermissionsBoundaryInput: Swift.Equatable {
    /// The name (friendly name, not ARN) of the IAM role from which you want to remove the permissions boundary.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

struct DeleteRolePermissionsBoundaryInputBody: Swift.Equatable {
    let roleName: Swift.String?
}

extension DeleteRolePermissionsBoundaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension DeleteRolePermissionsBoundaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRolePermissionsBoundaryOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRolePermissionsBoundaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnmodifiableEntity": return try await UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteRolePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("DeleteRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteRolePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRolePolicyInput: Swift.Equatable {
    /// The name of the inline policy to delete from the specified IAM role. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name (friendly name, not ARN) identifying the role that the policy is embedded in. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.roleName = roleName
    }
}

struct DeleteRolePolicyInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let policyName: Swift.String?
}

extension DeleteRolePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension DeleteRolePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRolePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRolePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnmodifiableEntity": return try await UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteSAMLProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        try container.encode("DeleteSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteSAMLProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSAMLProviderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the SAML provider to delete.
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init(
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
    }
}

struct DeleteSAMLProviderInputBody: Swift.Equatable {
    let samlProviderArn: Swift.String?
}

extension DeleteSAMLProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
    }
}

extension DeleteSAMLProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSAMLProviderOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSAMLProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteSSHPublicKeyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sshPublicKeyId = sshPublicKeyId {
            try container.encode(sshPublicKeyId, forKey: ClientRuntime.Key("SSHPublicKeyId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteSSHPublicKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteSSHPublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSSHPublicKeyInput: Swift.Equatable {
    /// The unique identifier for the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// The name of the IAM user associated with the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

struct DeleteSSHPublicKeyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let sshPublicKeyId: Swift.String?
}

extension DeleteSSHPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKeyId = "SSHPublicKeyId"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
    }
}

extension DeleteSSHPublicKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSSHPublicKeyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSSHPublicKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteServerCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        try container.encode("DeleteServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteServerCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServerCertificateInput: Swift.Equatable {
    /// The name of the server certificate you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init(
        serverCertificateName: Swift.String? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
    }
}

struct DeleteServerCertificateInputBody: Swift.Equatable {
    let serverCertificateName: Swift.String?
}

extension DeleteServerCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificateName = "ServerCertificateName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
    }
}

extension DeleteServerCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteServerCertificateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteServerCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "DeleteConflict": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteServiceLinkedRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("DeleteServiceLinkedRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteServiceLinkedRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServiceLinkedRoleInput: Swift.Equatable {
    /// The name of the service-linked role to be deleted.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

struct DeleteServiceLinkedRoleInputBody: Swift.Equatable {
    let roleName: Swift.String?
}

extension DeleteServiceLinkedRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension DeleteServiceLinkedRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteServiceLinkedRoleOutputBody = try responseDecoder.decode(responseBody: data)
            self.deletionTaskId = output.deletionTaskId
        } else {
            self.deletionTaskId = nil
        }
    }
}

public struct DeleteServiceLinkedRoleOutput: Swift.Equatable {
    /// The deletion task identifier that you can use to check the status of the deletion. This identifier is returned in the format task/aws-service-role///.
    /// This member is required.
    public var deletionTaskId: Swift.String?

    public init(
        deletionTaskId: Swift.String? = nil
    )
    {
        self.deletionTaskId = deletionTaskId
    }
}

struct DeleteServiceLinkedRoleOutputBody: Swift.Equatable {
    let deletionTaskId: Swift.String?
}

extension DeleteServiceLinkedRoleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionTaskId = "DeletionTaskId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteServiceLinkedRoleResult"))
        let deletionTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionTaskId)
        deletionTaskId = deletionTaskIdDecoded
    }
}

enum DeleteServiceLinkedRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteServiceSpecificCredentialInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: ClientRuntime.Key("ServiceSpecificCredentialId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteServiceSpecificCredential", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteServiceSpecificCredentialInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServiceSpecificCredentialInput: Swift.Equatable {
    /// The unique identifier of the service-specific credential. You can get this value by calling [ListServiceSpecificCredentials]. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var serviceSpecificCredentialId: Swift.String?
    /// The name of the IAM user associated with the service-specific credential. If this value is not specified, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        serviceSpecificCredentialId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.userName = userName
    }
}

struct DeleteServiceSpecificCredentialInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serviceSpecificCredentialId: Swift.String?
}

extension DeleteServiceSpecificCredentialInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serviceSpecificCredentialIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceSpecificCredentialId)
        serviceSpecificCredentialId = serviceSpecificCredentialIdDecoded
    }
}

extension DeleteServiceSpecificCredentialOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteServiceSpecificCredentialOutput: Swift.Equatable {

    public init() { }
}

enum DeleteServiceSpecificCredentialOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteSigningCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateId = certificateId {
            try container.encode(certificateId, forKey: ClientRuntime.Key("CertificateId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteSigningCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteSigningCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSigningCertificateInput: Swift.Equatable {
    /// The ID of the signing certificate to delete. The format of this parameter, as described by its [regex](http://wikipedia.org/wiki/regex) pattern, is a string of characters that can be upper- or lower-cased letters or digits.
    /// This member is required.
    public var certificateId: Swift.String?
    /// The name of the user the signing certificate belongs to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        certificateId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
        self.userName = userName
    }
}

struct DeleteSigningCertificateInputBody: Swift.Equatable {
    let userName: Swift.String?
    let certificateId: Swift.String?
}

extension DeleteSigningCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

extension DeleteSigningCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSigningCertificateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSigningCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteUserInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The name of the user to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    let userName: Swift.String?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "DeleteConflict": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteUserPermissionsBoundaryInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteUserPermissionsBoundary", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteUserPermissionsBoundaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserPermissionsBoundaryInput: Swift.Equatable {
    /// The name (friendly name, not ARN) of the IAM user from which you want to remove the permissions boundary.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

struct DeleteUserPermissionsBoundaryInputBody: Swift.Equatable {
    let userName: Swift.String?
}

extension DeleteUserPermissionsBoundaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteUserPermissionsBoundaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserPermissionsBoundaryOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserPermissionsBoundaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteUserPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteUserPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteUserPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserPolicyInput: Swift.Equatable {
    /// The name identifying the policy document to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name (friendly name, not ARN) identifying the user that the policy is embedded in. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.userName = userName
    }
}

struct DeleteUserPolicyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let policyName: Swift.String?
}

extension DeleteUserPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension DeleteUserPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteVirtualMFADeviceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        try container.encode("DeleteVirtualMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteVirtualMFADeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVirtualMFADeviceInput: Swift.Equatable {
    /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: =,.@:/-
    /// This member is required.
    public var serialNumber: Swift.String?

    public init(
        serialNumber: Swift.String? = nil
    )
    {
        self.serialNumber = serialNumber
    }
}

struct DeleteVirtualMFADeviceInputBody: Swift.Equatable {
    let serialNumber: Swift.String?
}

extension DeleteVirtualMFADeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serialNumber = "SerialNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
    }
}

extension DeleteVirtualMFADeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVirtualMFADeviceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVirtualMFADeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "DeleteConflict": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension IAMClientTypes.DeletionTaskFailureReasonType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "Reason"
        case roleUsageList = "RoleUsageList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let reason = reason {
            try container.encode(reason, forKey: ClientRuntime.Key("Reason"))
        }
        if let roleUsageList = roleUsageList {
            if !roleUsageList.isEmpty {
                var roleUsageListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RoleUsageList"))
                for (index0, roleusagetype0) in roleUsageList.enumerated() {
                    try roleUsageListContainer.encode(roleusagetype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var roleUsageListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RoleUsageList"))
                try roleUsageListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        if containerValues.contains(.roleUsageList) {
            struct KeyVal0{struct member{}}
            let roleUsageListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .roleUsageList)
            if let roleUsageListWrappedContainer = roleUsageListWrappedContainer {
                let roleUsageListContainer = try roleUsageListWrappedContainer.decodeIfPresent([IAMClientTypes.RoleUsageType].self, forKey: .member)
                var roleUsageListBuffer:[IAMClientTypes.RoleUsageType]? = nil
                if let roleUsageListContainer = roleUsageListContainer {
                    roleUsageListBuffer = [IAMClientTypes.RoleUsageType]()
                    for structureContainer0 in roleUsageListContainer {
                        roleUsageListBuffer?.append(structureContainer0)
                    }
                }
                roleUsageList = roleUsageListBuffer
            } else {
                roleUsageList = []
            }
        } else {
            roleUsageList = nil
        }
    }
}

extension IAMClientTypes {
    /// The reason that the service-linked role deletion failed. This data type is used as a response element in the [GetServiceLinkedRoleDeletionStatus] operation.
    public struct DeletionTaskFailureReasonType: Swift.Equatable {
        /// A short description of the reason that the service-linked role deletion failed.
        public var reason: Swift.String?
        /// A list of objects that contains details about the service-linked role deletion failure, if that information is returned by the service. If the service-linked role has active sessions or if any resources that were used by the role have not been deleted from the linked service, the role can't be deleted. This parameter includes a list of the resources that are associated with the role and the Region in which the resources are being used.
        public var roleUsageList: [IAMClientTypes.RoleUsageType]?

        public init(
            reason: Swift.String? = nil,
            roleUsageList: [IAMClientTypes.RoleUsageType]? = nil
        )
        {
            self.reason = reason
            self.roleUsageList = roleUsageList
        }
    }

}

extension IAMClientTypes {
    public enum DeletionTaskStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case notStarted
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeletionTaskStatusType] {
            return [
                .failed,
                .inProgress,
                .notStarted,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeletionTaskStatusType(rawValue: rawValue) ?? DeletionTaskStatusType.sdkUnknown(rawValue)
        }
    }
}

extension DetachGroupPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("DetachGroupPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DetachGroupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetachGroupPolicyInput: Swift.Equatable {
    /// The name (friendly name, not ARN) of the IAM group to detach the policy from. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM policy you want to detach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyArn = policyArn
    }
}

struct DetachGroupPolicyInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let policyArn: Swift.String?
}

extension DetachGroupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyArn = "PolicyArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension DetachGroupPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DetachGroupPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DetachGroupPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DetachRolePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("DetachRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DetachRolePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetachRolePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to detach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the IAM role to detach the policy from. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.roleName = roleName
    }
}

struct DetachRolePolicyInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let policyArn: Swift.String?
}

extension DetachRolePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension DetachRolePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DetachRolePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DetachRolePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnmodifiableEntity": return try await UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DetachUserPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DetachUserPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DetachUserPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetachUserPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to detach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the IAM user to detach the policy from. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.userName = userName
    }
}

struct DetachUserPolicyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let policyArn: Swift.String?
}

extension DetachUserPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension DetachUserPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DetachUserPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DetachUserPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DuplicateCertificateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<DuplicateCertificateExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because the same certificate is associated with an IAM user in the account.
public struct DuplicateCertificateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateCertificate" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DuplicateCertificateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateCertificateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateSSHPublicKeyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<DuplicateSSHPublicKeyExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because the SSH public key is already associated with the specified IAM user.
public struct DuplicateSSHPublicKeyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateSSHPublicKey" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DuplicateSSHPublicKeyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateSSHPublicKeyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EnableMFADeviceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authenticationCode1 = authenticationCode1 {
            try container.encode(authenticationCode1, forKey: ClientRuntime.Key("AuthenticationCode1"))
        }
        if let authenticationCode2 = authenticationCode2 {
            try container.encode(authenticationCode2, forKey: ClientRuntime.Key("AuthenticationCode2"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("EnableMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension EnableMFADeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EnableMFADeviceInput: Swift.Equatable {
    /// An authentication code emitted by the device. The format for this parameter is a string of six digits. Submit your request immediately after generating the authentication codes. If you generate the codes and then wait too long to submit the request, the MFA device successfully associates with the user but the MFA device becomes out of sync. This happens because time-based one-time passwords (TOTP) expire after a short period of time. If this happens, you can [resync the device](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html).
    /// This member is required.
    public var authenticationCode1: Swift.String?
    /// A subsequent authentication code emitted by the device. The format for this parameter is a string of six digits. Submit your request immediately after generating the authentication codes. If you generate the codes and then wait too long to submit the request, the MFA device successfully associates with the user but the MFA device becomes out of sync. This happens because time-based one-time passwords (TOTP) expire after a short period of time. If this happens, you can [resync the device](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html).
    /// This member is required.
    public var authenticationCode2: Swift.String?
    /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: =,.@:/-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The name of the IAM user for whom you want to enable the MFA device. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        authenticationCode1: Swift.String? = nil,
        authenticationCode2: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationCode1 = authenticationCode1
        self.authenticationCode2 = authenticationCode2
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

struct EnableMFADeviceInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serialNumber: Swift.String?
    let authenticationCode1: Swift.String?
    let authenticationCode2: Swift.String?
}

extension EnableMFADeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationCode1 = "AuthenticationCode1"
        case authenticationCode2 = "AuthenticationCode2"
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let authenticationCode1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authenticationCode1)
        authenticationCode1 = authenticationCode1Decoded
        let authenticationCode2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authenticationCode2)
        authenticationCode2 = authenticationCode2Decoded
    }
}

extension EnableMFADeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct EnableMFADeviceOutput: Swift.Equatable {

    public init() { }
}

enum EnableMFADeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "EntityTemporarilyUnmodifiable": return try await EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidAuthenticationCode": return try await InvalidAuthenticationCodeException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension IAMClientTypes {
    public enum EncodingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pem
        case ssh
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingType] {
            return [
                .pem,
                .ssh,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pem: return "PEM"
            case .ssh: return "SSH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncodingType(rawValue: rawValue) ?? EncodingType.sdkUnknown(rawValue)
        }
    }
}

extension EntityAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<EntityAlreadyExistsExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because it attempted to create a resource that already exists.
public struct EntityAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EntityAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntityAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes.EntityDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityInfo = "EntityInfo"
        case lastAuthenticated = "LastAuthenticated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let entityInfo = entityInfo {
            try container.encode(entityInfo, forKey: ClientRuntime.Key("EntityInfo"))
        }
        if let lastAuthenticated = lastAuthenticated {
            try container.encodeTimestamp(lastAuthenticated, format: .dateTime, forKey: ClientRuntime.Key("LastAuthenticated"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityInfoDecoded = try containerValues.decodeIfPresent(IAMClientTypes.EntityInfo.self, forKey: .entityInfo)
        entityInfo = entityInfoDecoded
        let lastAuthenticatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastAuthenticated)
        lastAuthenticated = lastAuthenticatedDecoded
    }
}

extension IAMClientTypes {
    /// An object that contains details about when the IAM entities (users or roles) were last used in an attempt to access the specified Amazon Web Services service. This data type is a response element in the [GetServiceLastAccessedDetailsWithEntities] operation.
    public struct EntityDetails: Swift.Equatable {
        /// The EntityInfo object that contains details about the entity (user or role).
        /// This member is required.
        public var entityInfo: IAMClientTypes.EntityInfo?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the authenticated entity last attempted to access Amazon Web Services. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticated: ClientRuntime.Date?

        public init(
            entityInfo: IAMClientTypes.EntityInfo? = nil,
            lastAuthenticated: ClientRuntime.Date? = nil
        )
        {
            self.entityInfo = entityInfo
            self.lastAuthenticated = lastAuthenticated
        }
    }

}

extension IAMClientTypes.EntityInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
        case path = "Path"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyOwnerEntityType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension IAMClientTypes {
    /// Contains details about the specified entity (user or role). This data type is an element of the [EntityDetails] object.
    public struct EntityInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        /// This member is required.
        public var arn: Swift.String?
        /// The identifier of the entity (user or role).
        /// This member is required.
        public var id: Swift.String?
        /// The name of the entity (user or role).
        /// This member is required.
        public var name: Swift.String?
        /// The path to the entity (user or role). For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The type of entity (user or role).
        /// This member is required.
        public var type: IAMClientTypes.PolicyOwnerEntityType?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            type: IAMClientTypes.PolicyOwnerEntityType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
            self.path = path
            self.type = type
        }
    }

}

extension EntityTemporarilyUnmodifiableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<EntityTemporarilyUnmodifiableExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because it referenced an entity that is temporarily unmodifiable, such as a user name that was deleted and then recreated. The error indicates that the request is likely to succeed if you try again after waiting several minutes. The error message describes the entity.
public struct EntityTemporarilyUnmodifiableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityTemporarilyUnmodifiable" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EntityTemporarilyUnmodifiableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntityTemporarilyUnmodifiableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes {
    public enum EntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsmanagedpolicy
        case group
        case localmanagedpolicy
        case role
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .awsmanagedpolicy,
                .group,
                .localmanagedpolicy,
                .role,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsmanagedpolicy: return "AWSManagedPolicy"
            case .group: return "Group"
            case .localmanagedpolicy: return "LocalManagedPolicy"
            case .role: return "Role"
            case .user: return "User"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let code = code {
            try container.encode(code, forKey: ClientRuntime.Key("Code"))
        }
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about the reason that the operation failed. This data type is used as a response element in the [GetOrganizationsAccessReport], [GetServiceLastAccessedDetails], and [GetServiceLastAccessedDetailsWithEntities] operations.
    public struct ErrorDetails: Swift.Equatable {
        /// The error code associated with the operation failure.
        /// This member is required.
        public var code: Swift.String?
        /// Detailed information about the reason that the operation failed.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IAMClientTypes.EvaluationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evalActionName = "EvalActionName"
        case evalDecision = "EvalDecision"
        case evalDecisionDetails = "EvalDecisionDetails"
        case evalResourceName = "EvalResourceName"
        case matchedStatements = "MatchedStatements"
        case missingContextValues = "MissingContextValues"
        case organizationsDecisionDetail = "OrganizationsDecisionDetail"
        case permissionsBoundaryDecisionDetail = "PermissionsBoundaryDecisionDetail"
        case resourceSpecificResults = "ResourceSpecificResults"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let evalActionName = evalActionName {
            try container.encode(evalActionName, forKey: ClientRuntime.Key("EvalActionName"))
        }
        if let evalDecision = evalDecision {
            try container.encode(evalDecision, forKey: ClientRuntime.Key("EvalDecision"))
        }
        if let evalDecisionDetails = evalDecisionDetails {
            var evalDecisionDetailsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EvalDecisionDetails"))
            for (index0, element0) in evalDecisionDetails.sorted(by: { $0.key < $1.key }).enumerated() {
                let evaldecisionsourcetypeKey0 = element0.key
                let policyevaluationdecisiontypeValue0 = element0.value
                var entryContainer0 = evalDecisionDetailsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(evaldecisionsourcetypeKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(policyevaluationdecisiontypeValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let evalResourceName = evalResourceName {
            try container.encode(evalResourceName, forKey: ClientRuntime.Key("EvalResourceName"))
        }
        if let matchedStatements = matchedStatements {
            if !matchedStatements.isEmpty {
                var matchedStatementsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MatchedStatements"))
                for (index0, statement0) in matchedStatements.enumerated() {
                    try matchedStatementsContainer.encode(statement0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var matchedStatementsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MatchedStatements"))
                try matchedStatementsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let missingContextValues = missingContextValues {
            if !missingContextValues.isEmpty {
                var missingContextValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MissingContextValues"))
                for (index0, contextkeynametype0) in missingContextValues.enumerated() {
                    try missingContextValuesContainer.encode(contextkeynametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var missingContextValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MissingContextValues"))
                try missingContextValuesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let organizationsDecisionDetail = organizationsDecisionDetail {
            try container.encode(organizationsDecisionDetail, forKey: ClientRuntime.Key("OrganizationsDecisionDetail"))
        }
        if let permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail {
            try container.encode(permissionsBoundaryDecisionDetail, forKey: ClientRuntime.Key("PermissionsBoundaryDecisionDetail"))
        }
        if let resourceSpecificResults = resourceSpecificResults {
            if !resourceSpecificResults.isEmpty {
                var resourceSpecificResultsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceSpecificResults"))
                for (index0, resourcespecificresult0) in resourceSpecificResults.enumerated() {
                    try resourceSpecificResultsContainer.encode(resourcespecificresult0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var resourceSpecificResultsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceSpecificResults"))
                try resourceSpecificResultsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evalActionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evalActionName)
        evalActionName = evalActionNameDecoded
        let evalResourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evalResourceName)
        evalResourceName = evalResourceNameDecoded
        let evalDecisionDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyEvaluationDecisionType.self, forKey: .evalDecision)
        evalDecision = evalDecisionDecoded
        if containerValues.contains(.matchedStatements) {
            struct KeyVal0{struct member{}}
            let matchedStatementsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .matchedStatements)
            if let matchedStatementsWrappedContainer = matchedStatementsWrappedContainer {
                let matchedStatementsContainer = try matchedStatementsWrappedContainer.decodeIfPresent([IAMClientTypes.Statement].self, forKey: .member)
                var matchedStatementsBuffer:[IAMClientTypes.Statement]? = nil
                if let matchedStatementsContainer = matchedStatementsContainer {
                    matchedStatementsBuffer = [IAMClientTypes.Statement]()
                    for structureContainer0 in matchedStatementsContainer {
                        matchedStatementsBuffer?.append(structureContainer0)
                    }
                }
                matchedStatements = matchedStatementsBuffer
            } else {
                matchedStatements = []
            }
        } else {
            matchedStatements = nil
        }
        if containerValues.contains(.missingContextValues) {
            struct KeyVal0{struct member{}}
            let missingContextValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .missingContextValues)
            if let missingContextValuesWrappedContainer = missingContextValuesWrappedContainer {
                let missingContextValuesContainer = try missingContextValuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var missingContextValuesBuffer:[Swift.String]? = nil
                if let missingContextValuesContainer = missingContextValuesContainer {
                    missingContextValuesBuffer = [Swift.String]()
                    for stringContainer0 in missingContextValuesContainer {
                        missingContextValuesBuffer?.append(stringContainer0)
                    }
                }
                missingContextValues = missingContextValuesBuffer
            } else {
                missingContextValues = []
            }
        } else {
            missingContextValues = nil
        }
        let organizationsDecisionDetailDecoded = try containerValues.decodeIfPresent(IAMClientTypes.OrganizationsDecisionDetail.self, forKey: .organizationsDecisionDetail)
        organizationsDecisionDetail = organizationsDecisionDetailDecoded
        let permissionsBoundaryDecisionDetailDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PermissionsBoundaryDecisionDetail.self, forKey: .permissionsBoundaryDecisionDetail)
        permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetailDecoded
        if containerValues.contains(.evalDecisionDetails) {
            struct KeyVal0{struct key{}; struct value{}}
            let evalDecisionDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, IAMClientTypes.PolicyEvaluationDecisionType, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .evalDecisionDetails)
            if let evalDecisionDetailsWrappedContainer = evalDecisionDetailsWrappedContainer {
                let evalDecisionDetailsContainer = try evalDecisionDetailsWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, IAMClientTypes.PolicyEvaluationDecisionType, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var evalDecisionDetailsBuffer: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]? = nil
                if let evalDecisionDetailsContainer = evalDecisionDetailsContainer {
                    evalDecisionDetailsBuffer = [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]()
                    for enumContainer0 in evalDecisionDetailsContainer {
                        evalDecisionDetailsBuffer?[enumContainer0.key] = enumContainer0.value
                    }
                }
                evalDecisionDetails = evalDecisionDetailsBuffer
            } else {
                evalDecisionDetails = [:]
            }
        } else {
            evalDecisionDetails = nil
        }
        if containerValues.contains(.resourceSpecificResults) {
            struct KeyVal0{struct member{}}
            let resourceSpecificResultsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .resourceSpecificResults)
            if let resourceSpecificResultsWrappedContainer = resourceSpecificResultsWrappedContainer {
                let resourceSpecificResultsContainer = try resourceSpecificResultsWrappedContainer.decodeIfPresent([IAMClientTypes.ResourceSpecificResult].self, forKey: .member)
                var resourceSpecificResultsBuffer:[IAMClientTypes.ResourceSpecificResult]? = nil
                if let resourceSpecificResultsContainer = resourceSpecificResultsContainer {
                    resourceSpecificResultsBuffer = [IAMClientTypes.ResourceSpecificResult]()
                    for structureContainer0 in resourceSpecificResultsContainer {
                        resourceSpecificResultsBuffer?.append(structureContainer0)
                    }
                }
                resourceSpecificResults = resourceSpecificResultsBuffer
            } else {
                resourceSpecificResults = []
            }
        } else {
            resourceSpecificResults = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains the results of a simulation. This data type is used by the return parameter of [SimulateCustomPolicy] and [SimulatePrincipalPolicy].
    public struct EvaluationResult: Swift.Equatable {
        /// The name of the API operation tested on the indicated resource.
        /// This member is required.
        public var evalActionName: Swift.String?
        /// The result of the simulation.
        /// This member is required.
        public var evalDecision: IAMClientTypes.PolicyEvaluationDecisionType?
        /// Additional details about the results of the cross-account evaluation decision. This parameter is populated for only cross-account simulations. It contains a brief summary of how each policy type contributes to the final evaluation decision. If the simulation evaluates policies within the same account and includes a resource ARN, then the parameter is present but the response is empty. If the simulation evaluates policies within the same account and specifies all resources (*), then the parameter is not returned. When you make a cross-account request, Amazon Web Services evaluates the request in the trusting account and the trusted account. The request is allowed only if both evaluations return true. For more information about how policies are evaluated, see [Evaluating policies within a single account](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic.html#policy-eval-basics). If an Organizations SCP included in the evaluation denies access, the simulation ends. In this case, policy evaluation does not proceed any further and this parameter is not returned.
        public var evalDecisionDetails: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]?
        /// The ARN of the resource that the indicated API operation was tested on.
        public var evalResourceName: Swift.String?
        /// A list of the statements in the input policies that determine the result for this scenario. Remember that even if multiple statements allow the operation on the resource, if only one statement denies that operation, then the explicit deny overrides any allow. In addition, the deny statement is the only entry included in the result.
        public var matchedStatements: [IAMClientTypes.Statement]?
        /// A list of context keys that are required by the included input policies but that were not provided by one of the input parameters. This list is used when the resource in a simulation is "*", either explicitly, or when the ResourceArns parameter blank. If you include a list of resources, then any missing context values are instead included under the ResourceSpecificResults section. To discover the context keys used by a set of policies, you can call [GetContextKeysForCustomPolicy] or [GetContextKeysForPrincipalPolicy].
        public var missingContextValues: [Swift.String]?
        /// A structure that details how Organizations and its service control policies affect the results of the simulation. Only applies if the simulated user's account is part of an organization.
        public var organizationsDecisionDetail: IAMClientTypes.OrganizationsDecisionDetail?
        /// Contains information about the effect that a permissions boundary has on a policy simulation when the boundary is applied to an IAM entity.
        public var permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail?
        /// The individual results of the simulation of the API operation specified in EvalActionName on each resource.
        public var resourceSpecificResults: [IAMClientTypes.ResourceSpecificResult]?

        public init(
            evalActionName: Swift.String? = nil,
            evalDecision: IAMClientTypes.PolicyEvaluationDecisionType? = nil,
            evalDecisionDetails: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]? = nil,
            evalResourceName: Swift.String? = nil,
            matchedStatements: [IAMClientTypes.Statement]? = nil,
            missingContextValues: [Swift.String]? = nil,
            organizationsDecisionDetail: IAMClientTypes.OrganizationsDecisionDetail? = nil,
            permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail? = nil,
            resourceSpecificResults: [IAMClientTypes.ResourceSpecificResult]? = nil
        )
        {
            self.evalActionName = evalActionName
            self.evalDecision = evalDecision
            self.evalDecisionDetails = evalDecisionDetails
            self.evalResourceName = evalResourceName
            self.matchedStatements = matchedStatements
            self.missingContextValues = missingContextValues
            self.organizationsDecisionDetail = organizationsDecisionDetail
            self.permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail
            self.resourceSpecificResults = resourceSpecificResults
        }
    }

}

extension GenerateCredentialReportInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GenerateCredentialReport", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GenerateCredentialReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GenerateCredentialReportInput: Swift.Equatable {

    public init() { }
}

extension GenerateCredentialReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GenerateCredentialReportOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.state = output.state
        } else {
            self.description = nil
            self.state = nil
        }
    }
}

/// Contains the response to a successful [GenerateCredentialReport] request.
public struct GenerateCredentialReportOutput: Swift.Equatable {
    /// Information about the credential report.
    public var description: Swift.String?
    /// Information about the state of the credential report.
    public var state: IAMClientTypes.ReportStateType?

    public init(
        description: Swift.String? = nil,
        state: IAMClientTypes.ReportStateType? = nil
    )
    {
        self.description = description
        self.state = state
    }
}

struct GenerateCredentialReportOutputBody: Swift.Equatable {
    let state: IAMClientTypes.ReportStateType?
    let description: Swift.String?
}

extension GenerateCredentialReportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GenerateCredentialReportResult"))
        let stateDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ReportStateType.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum GenerateCredentialReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GenerateOrganizationsAccessReportInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let entityPath = entityPath {
            try container.encode(entityPath, forKey: ClientRuntime.Key("EntityPath"))
        }
        if let organizationsPolicyId = organizationsPolicyId {
            try container.encode(organizationsPolicyId, forKey: ClientRuntime.Key("OrganizationsPolicyId"))
        }
        try container.encode("GenerateOrganizationsAccessReport", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GenerateOrganizationsAccessReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GenerateOrganizationsAccessReportInput: Swift.Equatable {
    /// The path of the Organizations entity (root, OU, or account). You can build an entity path using the known structure of your organization. For example, assume that your account ID is 123456789012 and its parent OU ID is ou-rge0-awsabcde. The organization root ID is r-f6g7h8i9j0example and your organization ID is o-a1b2c3d4e5. Your entity path is o-a1b2c3d4e5/r-f6g7h8i9j0example/ou-rge0-awsabcde/123456789012.
    /// This member is required.
    public var entityPath: Swift.String?
    /// The identifier of the Organizations service control policy (SCP). This parameter is optional. This ID is used to generate information about when an account principal that is limited by the SCP attempted to access an Amazon Web Services service.
    public var organizationsPolicyId: Swift.String?

    public init(
        entityPath: Swift.String? = nil,
        organizationsPolicyId: Swift.String? = nil
    )
    {
        self.entityPath = entityPath
        self.organizationsPolicyId = organizationsPolicyId
    }
}

struct GenerateOrganizationsAccessReportInputBody: Swift.Equatable {
    let entityPath: Swift.String?
    let organizationsPolicyId: Swift.String?
}

extension GenerateOrganizationsAccessReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityPath = "EntityPath"
        case organizationsPolicyId = "OrganizationsPolicyId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityPath)
        entityPath = entityPathDecoded
        let organizationsPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationsPolicyId)
        organizationsPolicyId = organizationsPolicyIdDecoded
    }
}

extension GenerateOrganizationsAccessReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GenerateOrganizationsAccessReportOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct GenerateOrganizationsAccessReportOutput: Swift.Equatable {
    /// The job identifier that you can use in the [GetOrganizationsAccessReport] operation.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GenerateOrganizationsAccessReportOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension GenerateOrganizationsAccessReportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GenerateOrganizationsAccessReportResult"))
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum GenerateOrganizationsAccessReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ReportGenerationLimitExceeded": return try await ReportGenerationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GenerateServiceLastAccessedDetailsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let granularity = granularity {
            try container.encode(granularity, forKey: ClientRuntime.Key("Granularity"))
        }
        try container.encode("GenerateServiceLastAccessedDetails", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GenerateServiceLastAccessedDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GenerateServiceLastAccessedDetailsInput: Swift.Equatable {
    /// The ARN of the IAM resource (user, group, role, or managed policy) used to generate information about when the resource was last used in an attempt to access an Amazon Web Services service.
    /// This member is required.
    public var arn: Swift.String?
    /// The level of detail that you want to generate. You can specify whether you want to generate information about the last attempt to access services or actions. If you specify service-level granularity, this operation generates only service data. If you specify action-level granularity, it generates service and action data. If you don't include this optional parameter, the operation generates service data.
    public var granularity: IAMClientTypes.AccessAdvisorUsageGranularityType?

    public init(
        arn: Swift.String? = nil,
        granularity: IAMClientTypes.AccessAdvisorUsageGranularityType? = nil
    )
    {
        self.arn = arn
        self.granularity = granularity
    }
}

struct GenerateServiceLastAccessedDetailsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let granularity: IAMClientTypes.AccessAdvisorUsageGranularityType?
}

extension GenerateServiceLastAccessedDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case granularity = "Granularity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AccessAdvisorUsageGranularityType.self, forKey: .granularity)
        granularity = granularityDecoded
    }
}

extension GenerateServiceLastAccessedDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GenerateServiceLastAccessedDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct GenerateServiceLastAccessedDetailsOutput: Swift.Equatable {
    /// The JobId that you can use in the [GetServiceLastAccessedDetails] or [GetServiceLastAccessedDetailsWithEntities] operations. The JobId returned by GenerateServiceLastAccessedDetail must be used by the same role within a session, or by the same user when used to call GetServiceLastAccessedDetail.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GenerateServiceLastAccessedDetailsOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension GenerateServiceLastAccessedDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GenerateServiceLastAccessedDetailsResult"))
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum GenerateServiceLastAccessedDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessKeyLastUsedInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        try container.encode("GetAccessKeyLastUsed", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetAccessKeyLastUsedInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccessKeyLastUsedInput: Swift.Equatable {
    /// The identifier of an access key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var accessKeyId: Swift.String?

    public init(
        accessKeyId: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
    }
}

struct GetAccessKeyLastUsedInputBody: Swift.Equatable {
    let accessKeyId: Swift.String?
}

extension GetAccessKeyLastUsedInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
    }
}

extension GetAccessKeyLastUsedOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessKeyLastUsedOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessKeyLastUsed = output.accessKeyLastUsed
            self.userName = output.userName
        } else {
            self.accessKeyLastUsed = nil
            self.userName = nil
        }
    }
}

/// Contains the response to a successful [GetAccessKeyLastUsed] request. It is also returned as a member of the [AccessKeyMetaData] structure returned by the [ListAccessKeys] action.
public struct GetAccessKeyLastUsedOutput: Swift.Equatable {
    /// Contains information about the last time the access key was used.
    public var accessKeyLastUsed: IAMClientTypes.AccessKeyLastUsed?
    /// The name of the IAM user that owns this access key.
    public var userName: Swift.String?

    public init(
        accessKeyLastUsed: IAMClientTypes.AccessKeyLastUsed? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessKeyLastUsed = accessKeyLastUsed
        self.userName = userName
    }
}

struct GetAccessKeyLastUsedOutputBody: Swift.Equatable {
    let userName: Swift.String?
    let accessKeyLastUsed: IAMClientTypes.AccessKeyLastUsed?
}

extension GetAccessKeyLastUsedOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyLastUsed = "AccessKeyLastUsed"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetAccessKeyLastUsedResult"))
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let accessKeyLastUsedDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AccessKeyLastUsed.self, forKey: .accessKeyLastUsed)
        accessKeyLastUsed = accessKeyLastUsedDecoded
    }
}

enum GetAccessKeyLastUsedOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccountAuthorizationDetailsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filter = filter {
            if !filter.isEmpty {
                var filterContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filter"))
                for (index0, entitytype0) in filter.enumerated() {
                    try filterContainer.encode(entitytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var filterContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filter"))
                try filterContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("GetAccountAuthorizationDetails", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetAccountAuthorizationDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccountAuthorizationDetailsInput: Swift.Equatable {
    /// A list of entity types used to filter the results. Only the entities that match the types you specify are included in the output. Use the value LocalManagedPolicy to include customer managed policies. The format for this parameter is a comma-separated (if more than one) list of strings. Each string value in the list must be one of the valid values listed below.
    public var filter: [IAMClientTypes.EntityType]?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        filter: [IAMClientTypes.EntityType]? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.filter = filter
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct GetAccountAuthorizationDetailsInputBody: Swift.Equatable {
    let filter: [IAMClientTypes.EntityType]?
    let maxItems: Swift.Int?
    let marker: Swift.String?
}

extension GetAccountAuthorizationDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.filter) {
            struct KeyVal0{struct member{}}
            let filterWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .filter)
            if let filterWrappedContainer = filterWrappedContainer {
                let filterContainer = try filterWrappedContainer.decodeIfPresent([IAMClientTypes.EntityType].self, forKey: .member)
                var filterBuffer:[IAMClientTypes.EntityType]? = nil
                if let filterContainer = filterContainer {
                    filterBuffer = [IAMClientTypes.EntityType]()
                    for enumContainer0 in filterContainer {
                        filterBuffer?.append(enumContainer0)
                    }
                }
                filter = filterBuffer
            } else {
                filter = []
            }
        } else {
            filter = nil
        }
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension GetAccountAuthorizationDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccountAuthorizationDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.groupDetailList = output.groupDetailList
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policies = output.policies
            self.roleDetailList = output.roleDetailList
            self.userDetailList = output.userDetailList
        } else {
            self.groupDetailList = nil
            self.isTruncated = false
            self.marker = nil
            self.policies = nil
            self.roleDetailList = nil
            self.userDetailList = nil
        }
    }
}

/// Contains the response to a successful [GetAccountAuthorizationDetails] request.
public struct GetAccountAuthorizationDetailsOutput: Swift.Equatable {
    /// A list containing information about IAM groups.
    public var groupDetailList: [IAMClientTypes.GroupDetail]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list containing information about managed policies.
    public var policies: [IAMClientTypes.ManagedPolicyDetail]?
    /// A list containing information about IAM roles.
    public var roleDetailList: [IAMClientTypes.RoleDetail]?
    /// A list containing information about IAM users.
    public var userDetailList: [IAMClientTypes.UserDetail]?

    public init(
        groupDetailList: [IAMClientTypes.GroupDetail]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policies: [IAMClientTypes.ManagedPolicyDetail]? = nil,
        roleDetailList: [IAMClientTypes.RoleDetail]? = nil,
        userDetailList: [IAMClientTypes.UserDetail]? = nil
    )
    {
        self.groupDetailList = groupDetailList
        self.isTruncated = isTruncated
        self.marker = marker
        self.policies = policies
        self.roleDetailList = roleDetailList
        self.userDetailList = userDetailList
    }
}

struct GetAccountAuthorizationDetailsOutputBody: Swift.Equatable {
    let userDetailList: [IAMClientTypes.UserDetail]?
    let groupDetailList: [IAMClientTypes.GroupDetail]?
    let roleDetailList: [IAMClientTypes.RoleDetail]?
    let policies: [IAMClientTypes.ManagedPolicyDetail]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension GetAccountAuthorizationDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupDetailList = "GroupDetailList"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policies = "Policies"
        case roleDetailList = "RoleDetailList"
        case userDetailList = "UserDetailList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetAccountAuthorizationDetailsResult"))
        if containerValues.contains(.userDetailList) {
            struct KeyVal0{struct member{}}
            let userDetailListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .userDetailList)
            if let userDetailListWrappedContainer = userDetailListWrappedContainer {
                let userDetailListContainer = try userDetailListWrappedContainer.decodeIfPresent([IAMClientTypes.UserDetail].self, forKey: .member)
                var userDetailListBuffer:[IAMClientTypes.UserDetail]? = nil
                if let userDetailListContainer = userDetailListContainer {
                    userDetailListBuffer = [IAMClientTypes.UserDetail]()
                    for structureContainer0 in userDetailListContainer {
                        userDetailListBuffer?.append(structureContainer0)
                    }
                }
                userDetailList = userDetailListBuffer
            } else {
                userDetailList = []
            }
        } else {
            userDetailList = nil
        }
        if containerValues.contains(.groupDetailList) {
            struct KeyVal0{struct member{}}
            let groupDetailListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groupDetailList)
            if let groupDetailListWrappedContainer = groupDetailListWrappedContainer {
                let groupDetailListContainer = try groupDetailListWrappedContainer.decodeIfPresent([IAMClientTypes.GroupDetail].self, forKey: .member)
                var groupDetailListBuffer:[IAMClientTypes.GroupDetail]? = nil
                if let groupDetailListContainer = groupDetailListContainer {
                    groupDetailListBuffer = [IAMClientTypes.GroupDetail]()
                    for structureContainer0 in groupDetailListContainer {
                        groupDetailListBuffer?.append(structureContainer0)
                    }
                }
                groupDetailList = groupDetailListBuffer
            } else {
                groupDetailList = []
            }
        } else {
            groupDetailList = nil
        }
        if containerValues.contains(.roleDetailList) {
            struct KeyVal0{struct member{}}
            let roleDetailListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .roleDetailList)
            if let roleDetailListWrappedContainer = roleDetailListWrappedContainer {
                let roleDetailListContainer = try roleDetailListWrappedContainer.decodeIfPresent([IAMClientTypes.RoleDetail].self, forKey: .member)
                var roleDetailListBuffer:[IAMClientTypes.RoleDetail]? = nil
                if let roleDetailListContainer = roleDetailListContainer {
                    roleDetailListBuffer = [IAMClientTypes.RoleDetail]()
                    for structureContainer0 in roleDetailListContainer {
                        roleDetailListBuffer?.append(structureContainer0)
                    }
                }
                roleDetailList = roleDetailListBuffer
            } else {
                roleDetailList = []
            }
        } else {
            roleDetailList = nil
        }
        if containerValues.contains(.policies) {
            struct KeyVal0{struct member{}}
            let policiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policies)
            if let policiesWrappedContainer = policiesWrappedContainer {
                let policiesContainer = try policiesWrappedContainer.decodeIfPresent([IAMClientTypes.ManagedPolicyDetail].self, forKey: .member)
                var policiesBuffer:[IAMClientTypes.ManagedPolicyDetail]? = nil
                if let policiesContainer = policiesContainer {
                    policiesBuffer = [IAMClientTypes.ManagedPolicyDetail]()
                    for structureContainer0 in policiesContainer {
                        policiesBuffer?.append(structureContainer0)
                    }
                }
                policies = policiesBuffer
            } else {
                policies = []
            }
        } else {
            policies = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum GetAccountAuthorizationDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccountPasswordPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GetAccountPasswordPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetAccountPasswordPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccountPasswordPolicyInput: Swift.Equatable {

    public init() { }
}

extension GetAccountPasswordPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccountPasswordPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.passwordPolicy = output.passwordPolicy
        } else {
            self.passwordPolicy = nil
        }
    }
}

/// Contains the response to a successful [GetAccountPasswordPolicy] request.
public struct GetAccountPasswordPolicyOutput: Swift.Equatable {
    /// A structure that contains details about the account's password policy.
    /// This member is required.
    public var passwordPolicy: IAMClientTypes.PasswordPolicy?

    public init(
        passwordPolicy: IAMClientTypes.PasswordPolicy? = nil
    )
    {
        self.passwordPolicy = passwordPolicy
    }
}

struct GetAccountPasswordPolicyOutputBody: Swift.Equatable {
    let passwordPolicy: IAMClientTypes.PasswordPolicy?
}

extension GetAccountPasswordPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case passwordPolicy = "PasswordPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetAccountPasswordPolicyResult"))
        let passwordPolicyDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PasswordPolicy.self, forKey: .passwordPolicy)
        passwordPolicy = passwordPolicyDecoded
    }
}

enum GetAccountPasswordPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccountSummaryInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GetAccountSummary", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetAccountSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccountSummaryInput: Swift.Equatable {

    public init() { }
}

extension GetAccountSummaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccountSummaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.summaryMap = output.summaryMap
        } else {
            self.summaryMap = nil
        }
    }
}

/// Contains the response to a successful [GetAccountSummary] request.
public struct GetAccountSummaryOutput: Swift.Equatable {
    /// A set of keyvalue pairs containing information about IAM entity usage and IAM quotas.
    public var summaryMap: [Swift.String:Swift.Int]?

    public init(
        summaryMap: [Swift.String:Swift.Int]? = nil
    )
    {
        self.summaryMap = summaryMap
    }
}

struct GetAccountSummaryOutputBody: Swift.Equatable {
    let summaryMap: [Swift.String:Swift.Int]?
}

extension GetAccountSummaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summaryMap = "SummaryMap"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetAccountSummaryResult"))
        if containerValues.contains(.summaryMap) {
            struct KeyVal0{struct key{}; struct value{}}
            let summaryMapWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.Int, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .summaryMap)
            if let summaryMapWrappedContainer = summaryMapWrappedContainer {
                let summaryMapContainer = try summaryMapWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.Int, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var summaryMapBuffer: [Swift.String:Swift.Int]? = nil
                if let summaryMapContainer = summaryMapContainer {
                    summaryMapBuffer = [Swift.String:Swift.Int]()
                    for integerContainer0 in summaryMapContainer {
                        summaryMapBuffer?[integerContainer0.key] = integerContainer0.value
                    }
                }
                summaryMap = summaryMapBuffer
            } else {
                summaryMap = [:]
            }
        } else {
            summaryMap = nil
        }
    }
}

enum GetAccountSummaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetContextKeysForCustomPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyInputList = policyInputList {
            if !policyInputList.isEmpty {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                for (index0, policydocumenttype0) in policyInputList.enumerated() {
                    try policyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                try policyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("GetContextKeysForCustomPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetContextKeysForCustomPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetContextKeysForCustomPolicyInput: Swift.Equatable {
    /// A list of policies for which you want the list of context keys referenced in those policies. Each document is specified as a string containing the complete, valid JSON text of an IAM policy. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyInputList: [Swift.String]?

    public init(
        policyInputList: [Swift.String]? = nil
    )
    {
        self.policyInputList = policyInputList
    }
}

struct GetContextKeysForCustomPolicyInputBody: Swift.Equatable {
    let policyInputList: [Swift.String]?
}

extension GetContextKeysForCustomPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyInputList = "PolicyInputList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.policyInputList) {
            struct KeyVal0{struct member{}}
            let policyInputListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyInputList)
            if let policyInputListWrappedContainer = policyInputListWrappedContainer {
                let policyInputListContainer = try policyInputListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyInputListBuffer:[Swift.String]? = nil
                if let policyInputListContainer = policyInputListContainer {
                    policyInputListBuffer = [Swift.String]()
                    for stringContainer0 in policyInputListContainer {
                        policyInputListBuffer?.append(stringContainer0)
                    }
                }
                policyInputList = policyInputListBuffer
            } else {
                policyInputList = []
            }
        } else {
            policyInputList = nil
        }
    }
}

extension GetContextKeysForCustomPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetContextKeysForCustomPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.contextKeyNames = output.contextKeyNames
        } else {
            self.contextKeyNames = nil
        }
    }
}

/// Contains the response to a successful [GetContextKeysForPrincipalPolicy] or [GetContextKeysForCustomPolicy] request.
public struct GetContextKeysForCustomPolicyOutput: Swift.Equatable {
    /// The list of context keys that are referenced in the input policies.
    public var contextKeyNames: [Swift.String]?

    public init(
        contextKeyNames: [Swift.String]? = nil
    )
    {
        self.contextKeyNames = contextKeyNames
    }
}

struct GetContextKeysForCustomPolicyOutputBody: Swift.Equatable {
    let contextKeyNames: [Swift.String]?
}

extension GetContextKeysForCustomPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextKeyNames = "ContextKeyNames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetContextKeysForCustomPolicyResult"))
        if containerValues.contains(.contextKeyNames) {
            struct KeyVal0{struct member{}}
            let contextKeyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .contextKeyNames)
            if let contextKeyNamesWrappedContainer = contextKeyNamesWrappedContainer {
                let contextKeyNamesContainer = try contextKeyNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var contextKeyNamesBuffer:[Swift.String]? = nil
                if let contextKeyNamesContainer = contextKeyNamesContainer {
                    contextKeyNamesBuffer = [Swift.String]()
                    for stringContainer0 in contextKeyNamesContainer {
                        contextKeyNamesBuffer?.append(stringContainer0)
                    }
                }
                contextKeyNames = contextKeyNamesBuffer
            } else {
                contextKeyNames = []
            }
        } else {
            contextKeyNames = nil
        }
    }
}

enum GetContextKeysForCustomPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetContextKeysForPrincipalPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyInputList = policyInputList {
            if !policyInputList.isEmpty {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                for (index0, policydocumenttype0) in policyInputList.enumerated() {
                    try policyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                try policyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policySourceArn = policySourceArn {
            try container.encode(policySourceArn, forKey: ClientRuntime.Key("PolicySourceArn"))
        }
        try container.encode("GetContextKeysForPrincipalPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetContextKeysForPrincipalPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetContextKeysForPrincipalPolicyInput: Swift.Equatable {
    /// An optional list of additional policies for which you want the list of context keys that are referenced. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var policyInputList: [Swift.String]?
    /// The ARN of a user, group, or role whose policies contain the context keys that you want listed. If you specify a user, the list includes context keys that are found in all policies that are attached to the user. The list also includes all groups that the user is a member of. If you pick a group or a role, then it includes only those context keys that are found in policies attached to that entity. Note that all parameters are shown in unencoded form here for clarity, but must be URL encoded to be included as a part of a real HTML request. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policySourceArn: Swift.String?

    public init(
        policyInputList: [Swift.String]? = nil,
        policySourceArn: Swift.String? = nil
    )
    {
        self.policyInputList = policyInputList
        self.policySourceArn = policySourceArn
    }
}

struct GetContextKeysForPrincipalPolicyInputBody: Swift.Equatable {
    let policySourceArn: Swift.String?
    let policyInputList: [Swift.String]?
}

extension GetContextKeysForPrincipalPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyInputList = "PolicyInputList"
        case policySourceArn = "PolicySourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policySourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policySourceArn)
        policySourceArn = policySourceArnDecoded
        if containerValues.contains(.policyInputList) {
            struct KeyVal0{struct member{}}
            let policyInputListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyInputList)
            if let policyInputListWrappedContainer = policyInputListWrappedContainer {
                let policyInputListContainer = try policyInputListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyInputListBuffer:[Swift.String]? = nil
                if let policyInputListContainer = policyInputListContainer {
                    policyInputListBuffer = [Swift.String]()
                    for stringContainer0 in policyInputListContainer {
                        policyInputListBuffer?.append(stringContainer0)
                    }
                }
                policyInputList = policyInputListBuffer
            } else {
                policyInputList = []
            }
        } else {
            policyInputList = nil
        }
    }
}

extension GetContextKeysForPrincipalPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetContextKeysForPrincipalPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.contextKeyNames = output.contextKeyNames
        } else {
            self.contextKeyNames = nil
        }
    }
}

/// Contains the response to a successful [GetContextKeysForPrincipalPolicy] or [GetContextKeysForCustomPolicy] request.
public struct GetContextKeysForPrincipalPolicyOutput: Swift.Equatable {
    /// The list of context keys that are referenced in the input policies.
    public var contextKeyNames: [Swift.String]?

    public init(
        contextKeyNames: [Swift.String]? = nil
    )
    {
        self.contextKeyNames = contextKeyNames
    }
}

struct GetContextKeysForPrincipalPolicyOutputBody: Swift.Equatable {
    let contextKeyNames: [Swift.String]?
}

extension GetContextKeysForPrincipalPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextKeyNames = "ContextKeyNames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetContextKeysForPrincipalPolicyResult"))
        if containerValues.contains(.contextKeyNames) {
            struct KeyVal0{struct member{}}
            let contextKeyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .contextKeyNames)
            if let contextKeyNamesWrappedContainer = contextKeyNamesWrappedContainer {
                let contextKeyNamesContainer = try contextKeyNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var contextKeyNamesBuffer:[Swift.String]? = nil
                if let contextKeyNamesContainer = contextKeyNamesContainer {
                    contextKeyNamesBuffer = [Swift.String]()
                    for stringContainer0 in contextKeyNamesContainer {
                        contextKeyNamesBuffer?.append(stringContainer0)
                    }
                }
                contextKeyNames = contextKeyNamesBuffer
            } else {
                contextKeyNames = []
            }
        } else {
            contextKeyNames = nil
        }
    }
}

enum GetContextKeysForPrincipalPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetCredentialReportInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GetCredentialReport", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetCredentialReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCredentialReportInput: Swift.Equatable {

    public init() { }
}

extension GetCredentialReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCredentialReportOutputBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
            self.generatedTime = output.generatedTime
            self.reportFormat = output.reportFormat
        } else {
            self.content = nil
            self.generatedTime = nil
            self.reportFormat = nil
        }
    }
}

/// Contains the response to a successful [GetCredentialReport] request.
public struct GetCredentialReportOutput: Swift.Equatable {
    /// Contains the credential report. The report is Base64-encoded.
    public var content: ClientRuntime.Data?
    /// The date and time when the credential report was created, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601).
    public var generatedTime: ClientRuntime.Date?
    /// The format (MIME type) of the credential report.
    public var reportFormat: IAMClientTypes.ReportFormatType?

    public init(
        content: ClientRuntime.Data? = nil,
        generatedTime: ClientRuntime.Date? = nil,
        reportFormat: IAMClientTypes.ReportFormatType? = nil
    )
    {
        self.content = content
        self.generatedTime = generatedTime
        self.reportFormat = reportFormat
    }
}

struct GetCredentialReportOutputBody: Swift.Equatable {
    let content: ClientRuntime.Data?
    let reportFormat: IAMClientTypes.ReportFormatType?
    let generatedTime: ClientRuntime.Date?
}

extension GetCredentialReportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case generatedTime = "GeneratedTime"
        case reportFormat = "ReportFormat"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetCredentialReportResult"))
        if containerValues.contains(.content) {
            do {
                let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
                content = contentDecoded
            } catch {
                content = "".data(using: .utf8)
            }
        } else {
            content = nil
        }
        let reportFormatDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ReportFormatType.self, forKey: .reportFormat)
        reportFormat = reportFormatDecoded
        let generatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .generatedTime)
        generatedTime = generatedTimeDecoded
    }
}

enum GetCredentialReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ReportExpired": return try await CredentialReportExpiredException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ReportNotPresent": return try await CredentialReportNotPresentException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ReportInProgress": return try await CredentialReportNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("GetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetGroupInput: Swift.Equatable {
    /// The name of the group. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        groupName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.groupName = groupName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct GetGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension GetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension GetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.group = output.group
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.users = output.users
        } else {
            self.group = nil
            self.isTruncated = false
            self.marker = nil
            self.users = nil
        }
    }
}

/// Contains the response to a successful [GetGroup] request.
public struct GetGroupOutput: Swift.Equatable {
    /// A structure that contains details about the group.
    /// This member is required.
    public var group: IAMClientTypes.Group?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of users in the group.
    /// This member is required.
    public var users: [IAMClientTypes.User]?

    public init(
        group: IAMClientTypes.Group? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        users: [IAMClientTypes.User]? = nil
    )
    {
        self.group = group
        self.isTruncated = isTruncated
        self.marker = marker
        self.users = users
    }
}

struct GetGroupOutputBody: Swift.Equatable {
    let group: IAMClientTypes.Group?
    let users: [IAMClientTypes.User]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension GetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case users = "Users"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetGroupResult"))
        let groupDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Group.self, forKey: .group)
        group = groupDecoded
        if containerValues.contains(.users) {
            struct KeyVal0{struct member{}}
            let usersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .users)
            if let usersWrappedContainer = usersWrappedContainer {
                let usersContainer = try usersWrappedContainer.decodeIfPresent([IAMClientTypes.User].self, forKey: .member)
                var usersBuffer:[IAMClientTypes.User]? = nil
                if let usersContainer = usersContainer {
                    usersBuffer = [IAMClientTypes.User]()
                    for structureContainer0 in usersContainer {
                        usersBuffer?.append(structureContainer0)
                    }
                }
                users = usersBuffer
            } else {
                users = []
            }
        } else {
            users = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum GetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetGroupPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        try container.encode("GetGroupPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetGroupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetGroupPolicyInput: Swift.Equatable {
    /// The name of the group the policy is associated with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the policy document to get. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyName = policyName
    }
}

struct GetGroupPolicyInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let policyName: Swift.String?
}

extension GetGroupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyName = "PolicyName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension GetGroupPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGroupPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.groupName = output.groupName
            self.policyDocument = output.policyDocument
            self.policyName = output.policyName
        } else {
            self.groupName = nil
            self.policyDocument = nil
            self.policyName = nil
        }
    }
}

/// Contains the response to a successful [GetGroupPolicy] request.
public struct GetGroupPolicyOutput: Swift.Equatable {
    /// The group the policy is associated with.
    /// This member is required.
    public var groupName: Swift.String?
    /// The policy document. IAM stores policies in JSON format. However, resources that were created using CloudFormation templates can be formatted in YAML. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyDocument = policyDocument
        self.policyName = policyName
    }
}

struct GetGroupPolicyOutputBody: Swift.Equatable {
    let groupName: Swift.String?
    let policyName: Swift.String?
    let policyDocument: Swift.String?
}

extension GetGroupPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetGroupPolicyResult"))
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

enum GetGroupPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetInstanceProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        try container.encode("GetInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetInstanceProfileInput: Swift.Equatable {
    /// The name of the instance profile to get information about. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?

    public init(
        instanceProfileName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
    }
}

struct GetInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
}

extension GetInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
    }
}

extension GetInstanceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInstanceProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

/// Contains the response to a successful [GetInstanceProfile] request.
public struct GetInstanceProfileOutput: Swift.Equatable {
    /// A structure containing details about the instance profile.
    /// This member is required.
    public var instanceProfile: IAMClientTypes.InstanceProfile?

    public init(
        instanceProfile: IAMClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct GetInstanceProfileOutputBody: Swift.Equatable {
    let instanceProfile: IAMClientTypes.InstanceProfile?
}

extension GetInstanceProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfile = "InstanceProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetInstanceProfileResult"))
        let instanceProfileDecoded = try containerValues.decodeIfPresent(IAMClientTypes.InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

enum GetInstanceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetLoginProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("GetLoginProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetLoginProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetLoginProfileInput: Swift.Equatable {
    /// The name of the user whose login profile you want to retrieve. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

struct GetLoginProfileInputBody: Swift.Equatable {
    let userName: Swift.String?
}

extension GetLoginProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension GetLoginProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLoginProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.loginProfile = output.loginProfile
        } else {
            self.loginProfile = nil
        }
    }
}

/// Contains the response to a successful [GetLoginProfile] request.
public struct GetLoginProfileOutput: Swift.Equatable {
    /// A structure containing the user name and the profile creation date for the user.
    /// This member is required.
    public var loginProfile: IAMClientTypes.LoginProfile?

    public init(
        loginProfile: IAMClientTypes.LoginProfile? = nil
    )
    {
        self.loginProfile = loginProfile
    }
}

struct GetLoginProfileOutputBody: Swift.Equatable {
    let loginProfile: IAMClientTypes.LoginProfile?
}

extension GetLoginProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loginProfile = "LoginProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetLoginProfileResult"))
        let loginProfileDecoded = try containerValues.decodeIfPresent(IAMClientTypes.LoginProfile.self, forKey: .loginProfile)
        loginProfile = loginProfileDecoded
    }
}

enum GetLoginProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetMFADeviceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("GetMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetMFADeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMFADeviceInput: Swift.Equatable {
    /// Serial number that uniquely identifies the MFA device. For this API, we only accept FIDO security key [ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html).
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The friendly name identifying the user.
    public var userName: Swift.String?

    public init(
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

struct GetMFADeviceInputBody: Swift.Equatable {
    let serialNumber: Swift.String?
    let userName: Swift.String?
}

extension GetMFADeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension GetMFADeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMFADeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.certifications = output.certifications
            self.enableDate = output.enableDate
            self.serialNumber = output.serialNumber
            self.userName = output.userName
        } else {
            self.certifications = nil
            self.enableDate = nil
            self.serialNumber = nil
            self.userName = nil
        }
    }
}

public struct GetMFADeviceOutput: Swift.Equatable {
    /// The certifications of a specified user's MFA device. We currently provide FIPS-140-2, FIPS-140-3, and FIDO certification levels obtained from [ FIDO Alliance Metadata Service (MDS)](https://fidoalliance.org/metadata/).
    public var certifications: [Swift.String:Swift.String]?
    /// The date that a specified user's MFA device was first enabled.
    public var enableDate: ClientRuntime.Date?
    /// Serial number that uniquely identifies the MFA device. For this API, we only accept FIDO security key [ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html).
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The friendly name identifying the user.
    public var userName: Swift.String?

    public init(
        certifications: [Swift.String:Swift.String]? = nil,
        enableDate: ClientRuntime.Date? = nil,
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.certifications = certifications
        self.enableDate = enableDate
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

struct GetMFADeviceOutputBody: Swift.Equatable {
    let userName: Swift.String?
    let serialNumber: Swift.String?
    let enableDate: ClientRuntime.Date?
    let certifications: [Swift.String:Swift.String]?
}

extension GetMFADeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certifications = "Certifications"
        case enableDate = "EnableDate"
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetMFADeviceResult"))
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let enableDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .enableDate)
        enableDate = enableDateDecoded
        if containerValues.contains(.certifications) {
            struct KeyVal0{struct key{}; struct value{}}
            let certificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .certifications)
            if let certificationsWrappedContainer = certificationsWrappedContainer {
                let certificationsContainer = try certificationsWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var certificationsBuffer: [Swift.String:Swift.String]? = nil
                if let certificationsContainer = certificationsContainer {
                    certificationsBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in certificationsContainer {
                        certificationsBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                certifications = certificationsBuffer
            } else {
                certifications = [:]
            }
        } else {
            certifications = nil
        }
    }
}

enum GetMFADeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetOpenIDConnectProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        try container.encode("GetOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetOpenIDConnectProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetOpenIDConnectProviderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the OIDC provider resource object in IAM to get information for. You can get a list of OIDC provider resource ARNs by using the [ListOpenIDConnectProviders] operation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init(
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

struct GetOpenIDConnectProviderInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
}

extension GetOpenIDConnectProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
    }
}

extension GetOpenIDConnectProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetOpenIDConnectProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientIDList = output.clientIDList
            self.createDate = output.createDate
            self.tags = output.tags
            self.thumbprintList = output.thumbprintList
            self.url = output.url
        } else {
            self.clientIDList = nil
            self.createDate = nil
            self.tags = nil
            self.thumbprintList = nil
            self.url = nil
        }
    }
}

/// Contains the response to a successful [GetOpenIDConnectProvider] request.
public struct GetOpenIDConnectProviderOutput: Swift.Equatable {
    /// A list of client IDs (also known as audiences) that are associated with the specified IAM OIDC provider resource object. For more information, see [CreateOpenIDConnectProvider].
    public var clientIDList: [Swift.String]?
    /// The date and time when the IAM OIDC provider resource object was created in the Amazon Web Services account.
    public var createDate: ClientRuntime.Date?
    /// A list of tags that are attached to the specified IAM OIDC provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?
    /// A list of certificate thumbprints that are associated with the specified IAM OIDC provider resource object. For more information, see [CreateOpenIDConnectProvider].
    public var thumbprintList: [Swift.String]?
    /// The URL that the IAM OIDC provider resource object is associated with. For more information, see [CreateOpenIDConnectProvider].
    public var url: Swift.String?

    public init(
        clientIDList: [Swift.String]? = nil,
        createDate: ClientRuntime.Date? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        thumbprintList: [Swift.String]? = nil,
        url: Swift.String? = nil
    )
    {
        self.clientIDList = clientIDList
        self.createDate = createDate
        self.tags = tags
        self.thumbprintList = thumbprintList
        self.url = url
    }
}

struct GetOpenIDConnectProviderOutputBody: Swift.Equatable {
    let url: Swift.String?
    let clientIDList: [Swift.String]?
    let thumbprintList: [Swift.String]?
    let createDate: ClientRuntime.Date?
    let tags: [IAMClientTypes.Tag]?
}

extension GetOpenIDConnectProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIDList = "ClientIDList"
        case createDate = "CreateDate"
        case tags = "Tags"
        case thumbprintList = "ThumbprintList"
        case url = "Url"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetOpenIDConnectProviderResult"))
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        if containerValues.contains(.clientIDList) {
            struct KeyVal0{struct member{}}
            let clientIDListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .clientIDList)
            if let clientIDListWrappedContainer = clientIDListWrappedContainer {
                let clientIDListContainer = try clientIDListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var clientIDListBuffer:[Swift.String]? = nil
                if let clientIDListContainer = clientIDListContainer {
                    clientIDListBuffer = [Swift.String]()
                    for stringContainer0 in clientIDListContainer {
                        clientIDListBuffer?.append(stringContainer0)
                    }
                }
                clientIDList = clientIDListBuffer
            } else {
                clientIDList = []
            }
        } else {
            clientIDList = nil
        }
        if containerValues.contains(.thumbprintList) {
            struct KeyVal0{struct member{}}
            let thumbprintListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .thumbprintList)
            if let thumbprintListWrappedContainer = thumbprintListWrappedContainer {
                let thumbprintListContainer = try thumbprintListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var thumbprintListBuffer:[Swift.String]? = nil
                if let thumbprintListContainer = thumbprintListContainer {
                    thumbprintListBuffer = [Swift.String]()
                    for stringContainer0 in thumbprintListContainer {
                        thumbprintListBuffer?.append(stringContainer0)
                    }
                }
                thumbprintList = thumbprintListBuffer
            } else {
                thumbprintList = []
            }
        } else {
            thumbprintList = nil
        }
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

enum GetOpenIDConnectProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetOrganizationsAccessReportInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let jobId = jobId {
            try container.encode(jobId, forKey: ClientRuntime.Key("JobId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let sortKey = sortKey {
            try container.encode(sortKey, forKey: ClientRuntime.Key("SortKey"))
        }
        try container.encode("GetOrganizationsAccessReport", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetOrganizationsAccessReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetOrganizationsAccessReportInput: Swift.Equatable {
    /// The identifier of the request generated by the [GenerateOrganizationsAccessReport] operation.
    /// This member is required.
    public var jobId: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The key that is used to sort the results. If you choose the namespace key, the results are returned in alphabetical order. If you choose the time key, the results are sorted numerically by the date and time.
    public var sortKey: IAMClientTypes.SortKeyType?

    public init(
        jobId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        sortKey: IAMClientTypes.SortKeyType? = nil
    )
    {
        self.jobId = jobId
        self.marker = marker
        self.maxItems = maxItems
        self.sortKey = sortKey
    }
}

struct GetOrganizationsAccessReportInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let maxItems: Swift.Int?
    let marker: Swift.String?
    let sortKey: IAMClientTypes.SortKeyType?
}

extension GetOrganizationsAccessReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case sortKey = "SortKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let sortKeyDecoded = try containerValues.decodeIfPresent(IAMClientTypes.SortKeyType.self, forKey: .sortKey)
        sortKey = sortKeyDecoded
    }
}

extension GetOrganizationsAccessReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetOrganizationsAccessReportOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessDetails = output.accessDetails
            self.errorDetails = output.errorDetails
            self.isTruncated = output.isTruncated
            self.jobCompletionDate = output.jobCompletionDate
            self.jobCreationDate = output.jobCreationDate
            self.jobStatus = output.jobStatus
            self.marker = output.marker
            self.numberOfServicesAccessible = output.numberOfServicesAccessible
            self.numberOfServicesNotAccessed = output.numberOfServicesNotAccessed
        } else {
            self.accessDetails = nil
            self.errorDetails = nil
            self.isTruncated = false
            self.jobCompletionDate = nil
            self.jobCreationDate = nil
            self.jobStatus = nil
            self.marker = nil
            self.numberOfServicesAccessible = nil
            self.numberOfServicesNotAccessed = nil
        }
    }
}

public struct GetOrganizationsAccessReportOutput: Swift.Equatable {
    /// An object that contains details about the most recent attempt to access the service.
    public var accessDetails: [IAMClientTypes.AccessDetail]?
    /// Contains information about the reason that the operation failed. This data type is used as a response element in the [GetOrganizationsAccessReport], [GetServiceLastAccessedDetails], and [GetServiceLastAccessedDetailsWithEntities] operations.
    public var errorDetails: IAMClientTypes.ErrorDetails?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the generated report job was completed or failed. This field is null if the job is still in progress, as indicated by a job status value of IN_PROGRESS.
    public var jobCompletionDate: ClientRuntime.Date?
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the report job was created.
    /// This member is required.
    public var jobCreationDate: ClientRuntime.Date?
    /// The status of the job.
    /// This member is required.
    public var jobStatus: IAMClientTypes.JobStatusType?
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The number of services that the applicable SCPs allow account principals to access.
    public var numberOfServicesAccessible: Swift.Int?
    /// The number of services that account principals are allowed but did not attempt to access.
    public var numberOfServicesNotAccessed: Swift.Int?

    public init(
        accessDetails: [IAMClientTypes.AccessDetail]? = nil,
        errorDetails: IAMClientTypes.ErrorDetails? = nil,
        isTruncated: Swift.Bool = false,
        jobCompletionDate: ClientRuntime.Date? = nil,
        jobCreationDate: ClientRuntime.Date? = nil,
        jobStatus: IAMClientTypes.JobStatusType? = nil,
        marker: Swift.String? = nil,
        numberOfServicesAccessible: Swift.Int? = nil,
        numberOfServicesNotAccessed: Swift.Int? = nil
    )
    {
        self.accessDetails = accessDetails
        self.errorDetails = errorDetails
        self.isTruncated = isTruncated
        self.jobCompletionDate = jobCompletionDate
        self.jobCreationDate = jobCreationDate
        self.jobStatus = jobStatus
        self.marker = marker
        self.numberOfServicesAccessible = numberOfServicesAccessible
        self.numberOfServicesNotAccessed = numberOfServicesNotAccessed
    }
}

struct GetOrganizationsAccessReportOutputBody: Swift.Equatable {
    let jobStatus: IAMClientTypes.JobStatusType?
    let jobCreationDate: ClientRuntime.Date?
    let jobCompletionDate: ClientRuntime.Date?
    let numberOfServicesAccessible: Swift.Int?
    let numberOfServicesNotAccessed: Swift.Int?
    let accessDetails: [IAMClientTypes.AccessDetail]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
    let errorDetails: IAMClientTypes.ErrorDetails?
}

extension GetOrganizationsAccessReportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessDetails = "AccessDetails"
        case errorDetails = "ErrorDetails"
        case isTruncated = "IsTruncated"
        case jobCompletionDate = "JobCompletionDate"
        case jobCreationDate = "JobCreationDate"
        case jobStatus = "JobStatus"
        case marker = "Marker"
        case numberOfServicesAccessible = "NumberOfServicesAccessible"
        case numberOfServicesNotAccessed = "NumberOfServicesNotAccessed"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetOrganizationsAccessReportResult"))
        let jobStatusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.JobStatusType.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .jobCreationDate)
        jobCreationDate = jobCreationDateDecoded
        let jobCompletionDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .jobCompletionDate)
        jobCompletionDate = jobCompletionDateDecoded
        let numberOfServicesAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfServicesAccessible)
        numberOfServicesAccessible = numberOfServicesAccessibleDecoded
        let numberOfServicesNotAccessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfServicesNotAccessed)
        numberOfServicesNotAccessed = numberOfServicesNotAccessedDecoded
        if containerValues.contains(.accessDetails) {
            struct KeyVal0{struct member{}}
            let accessDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accessDetails)
            if let accessDetailsWrappedContainer = accessDetailsWrappedContainer {
                let accessDetailsContainer = try accessDetailsWrappedContainer.decodeIfPresent([IAMClientTypes.AccessDetail].self, forKey: .member)
                var accessDetailsBuffer:[IAMClientTypes.AccessDetail]? = nil
                if let accessDetailsContainer = accessDetailsContainer {
                    accessDetailsBuffer = [IAMClientTypes.AccessDetail]()
                    for structureContainer0 in accessDetailsContainer {
                        accessDetailsBuffer?.append(structureContainer0)
                    }
                }
                accessDetails = accessDetailsBuffer
            } else {
                accessDetails = []
            }
        } else {
            accessDetails = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
    }
}

enum GetOrganizationsAccessReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("GetPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the managed policy that you want information about. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        policyArn: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

struct GetPolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
}

extension GetPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension GetPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

/// Contains the response to a successful [GetPolicy] request.
public struct GetPolicyOutput: Swift.Equatable {
    /// A structure containing details about the policy.
    public var policy: IAMClientTypes.Policy?

    public init(
        policy: IAMClientTypes.Policy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetPolicyOutputBody: Swift.Equatable {
    let policy: IAMClientTypes.Policy?
}

extension GetPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetPolicyResult"))
        let policyDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Policy.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetPolicyVersionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
        try container.encode("GetPolicyVersion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetPolicyVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPolicyVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the managed policy that you want information about. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// Identifies the policy version to retrieve. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consists of the lowercase letter 'v' followed by one or two digits, and optionally followed by a period '.' and a string of letters and digits.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.versionId = versionId
    }
}

struct GetPolicyVersionInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let versionId: Swift.String?
}

extension GetPolicyVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case versionId = "VersionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension GetPolicyVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPolicyVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyVersion = output.policyVersion
        } else {
            self.policyVersion = nil
        }
    }
}

/// Contains the response to a successful [GetPolicyVersion] request.
public struct GetPolicyVersionOutput: Swift.Equatable {
    /// A structure containing details about the policy version.
    public var policyVersion: IAMClientTypes.PolicyVersion?

    public init(
        policyVersion: IAMClientTypes.PolicyVersion? = nil
    )
    {
        self.policyVersion = policyVersion
    }
}

struct GetPolicyVersionOutputBody: Swift.Equatable {
    let policyVersion: IAMClientTypes.PolicyVersion?
}

extension GetPolicyVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyVersion = "PolicyVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetPolicyVersionResult"))
        let policyVersionDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyVersion.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
    }
}

enum GetPolicyVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("GetRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRoleInput: Swift.Equatable {
    /// The name of the IAM role to get information about. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

struct GetRoleInputBody: Swift.Equatable {
    let roleName: Swift.String?
}

extension GetRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension GetRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRoleOutputBody = try responseDecoder.decode(responseBody: data)
            self.role = output.role
        } else {
            self.role = nil
        }
    }
}

/// Contains the response to a successful [GetRole] request.
public struct GetRoleOutput: Swift.Equatable {
    /// A structure containing details about the IAM role.
    /// This member is required.
    public var role: IAMClientTypes.Role?

    public init(
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

struct GetRoleOutputBody: Swift.Equatable {
    let role: IAMClientTypes.Role?
}

extension GetRoleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetRoleResult"))
        let roleDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Role.self, forKey: .role)
        role = roleDecoded
    }
}

enum GetRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetRolePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("GetRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetRolePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRolePolicyInput: Swift.Equatable {
    /// The name of the policy document to get. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the role associated with the policy. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.roleName = roleName
    }
}

struct GetRolePolicyInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let policyName: Swift.String?
}

extension GetRolePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension GetRolePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRolePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyDocument = output.policyDocument
            self.policyName = output.policyName
            self.roleName = output.roleName
        } else {
            self.policyDocument = nil
            self.policyName = nil
            self.roleName = nil
        }
    }
}

/// Contains the response to a successful [GetRolePolicy] request.
public struct GetRolePolicyOutput: Swift.Equatable {
    /// The policy document. IAM stores policies in JSON format. However, resources that were created using CloudFormation templates can be formatted in YAML. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?
    /// The role the policy is associated with.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.roleName = roleName
    }
}

struct GetRolePolicyOutputBody: Swift.Equatable {
    let roleName: Swift.String?
    let policyName: Swift.String?
    let policyDocument: Swift.String?
}

extension GetRolePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetRolePolicyResult"))
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

enum GetRolePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetSAMLProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        try container.encode("GetSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetSAMLProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSAMLProviderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the SAML provider resource object in IAM to get information about. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init(
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
    }
}

struct GetSAMLProviderInputBody: Swift.Equatable {
    let samlProviderArn: Swift.String?
}

extension GetSAMLProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
    }
}

extension GetSAMLProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSAMLProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.createDate = output.createDate
            self.samlMetadataDocument = output.samlMetadataDocument
            self.tags = output.tags
            self.validUntil = output.validUntil
        } else {
            self.createDate = nil
            self.samlMetadataDocument = nil
            self.tags = nil
            self.validUntil = nil
        }
    }
}

/// Contains the response to a successful [GetSAMLProvider] request.
public struct GetSAMLProviderOutput: Swift.Equatable {
    /// The date and time when the SAML provider was created.
    public var createDate: ClientRuntime.Date?
    /// The XML metadata document that includes information about an identity provider.
    public var samlMetadataDocument: Swift.String?
    /// A list of tags that are attached to the specified IAM SAML provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?
    /// The expiration date and time for the SAML provider.
    public var validUntil: ClientRuntime.Date?

    public init(
        createDate: ClientRuntime.Date? = nil,
        samlMetadataDocument: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        validUntil: ClientRuntime.Date? = nil
    )
    {
        self.createDate = createDate
        self.samlMetadataDocument = samlMetadataDocument
        self.tags = tags
        self.validUntil = validUntil
    }
}

struct GetSAMLProviderOutputBody: Swift.Equatable {
    let samlMetadataDocument: Swift.String?
    let createDate: ClientRuntime.Date?
    let validUntil: ClientRuntime.Date?
    let tags: [IAMClientTypes.Tag]?
}

extension GetSAMLProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case samlMetadataDocument = "SAMLMetadataDocument"
        case tags = "Tags"
        case validUntil = "ValidUntil"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetSAMLProviderResult"))
        let samlMetadataDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlMetadataDocument)
        samlMetadataDocument = samlMetadataDocumentDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let validUntilDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .validUntil)
        validUntil = validUntilDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

enum GetSAMLProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetSSHPublicKeyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let encoding = encoding {
            try container.encode(encoding, forKey: ClientRuntime.Key("Encoding"))
        }
        if let sshPublicKeyId = sshPublicKeyId {
            try container.encode(sshPublicKeyId, forKey: ClientRuntime.Key("SSHPublicKeyId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("GetSSHPublicKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetSSHPublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSSHPublicKeyInput: Swift.Equatable {
    /// Specifies the public key encoding format to use in the response. To retrieve the public key in ssh-rsa format, use SSH. To retrieve the public key in PEM format, use PEM.
    /// This member is required.
    public var encoding: IAMClientTypes.EncodingType?
    /// The unique identifier for the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// The name of the IAM user associated with the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        encoding: IAMClientTypes.EncodingType? = nil,
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.encoding = encoding
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

struct GetSSHPublicKeyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let sshPublicKeyId: Swift.String?
    let encoding: IAMClientTypes.EncodingType?
}

extension GetSSHPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encoding = "Encoding"
        case sshPublicKeyId = "SSHPublicKeyId"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let encodingDecoded = try containerValues.decodeIfPresent(IAMClientTypes.EncodingType.self, forKey: .encoding)
        encoding = encodingDecoded
    }
}

extension GetSSHPublicKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSSHPublicKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.sshPublicKey = output.sshPublicKey
        } else {
            self.sshPublicKey = nil
        }
    }
}

/// Contains the response to a successful [GetSSHPublicKey] request.
public struct GetSSHPublicKeyOutput: Swift.Equatable {
    /// A structure containing details about the SSH public key.
    public var sshPublicKey: IAMClientTypes.SSHPublicKey?

    public init(
        sshPublicKey: IAMClientTypes.SSHPublicKey? = nil
    )
    {
        self.sshPublicKey = sshPublicKey
    }
}

struct GetSSHPublicKeyOutputBody: Swift.Equatable {
    let sshPublicKey: IAMClientTypes.SSHPublicKey?
}

extension GetSSHPublicKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKey = "SSHPublicKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetSSHPublicKeyResult"))
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(IAMClientTypes.SSHPublicKey.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

enum GetSSHPublicKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnrecognizedPublicKeyEncoding": return try await UnrecognizedPublicKeyEncodingException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetServerCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        try container.encode("GetServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetServerCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServerCertificateInput: Swift.Equatable {
    /// The name of the server certificate you want to retrieve information about. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init(
        serverCertificateName: Swift.String? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
    }
}

struct GetServerCertificateInputBody: Swift.Equatable {
    let serverCertificateName: Swift.String?
}

extension GetServerCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificateName = "ServerCertificateName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
    }
}

extension GetServerCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServerCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.serverCertificate = output.serverCertificate
        } else {
            self.serverCertificate = nil
        }
    }
}

/// Contains the response to a successful [GetServerCertificate] request.
public struct GetServerCertificateOutput: Swift.Equatable {
    /// A structure containing details about the server certificate.
    /// This member is required.
    public var serverCertificate: IAMClientTypes.ServerCertificate?

    public init(
        serverCertificate: IAMClientTypes.ServerCertificate? = nil
    )
    {
        self.serverCertificate = serverCertificate
    }
}

struct GetServerCertificateOutputBody: Swift.Equatable {
    let serverCertificate: IAMClientTypes.ServerCertificate?
}

extension GetServerCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificate = "ServerCertificate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetServerCertificateResult"))
        let serverCertificateDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ServerCertificate.self, forKey: .serverCertificate)
        serverCertificate = serverCertificateDecoded
    }
}

enum GetServerCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetServiceLastAccessedDetailsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let jobId = jobId {
            try container.encode(jobId, forKey: ClientRuntime.Key("JobId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("GetServiceLastAccessedDetails", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetServiceLastAccessedDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceLastAccessedDetailsInput: Swift.Equatable {
    /// The ID of the request generated by the [GenerateServiceLastAccessedDetails] operation. The JobId returned by GenerateServiceLastAccessedDetail must be used by the same role within a session, or by the same user when used to call GetServiceLastAccessedDetail.
    /// This member is required.
    public var jobId: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        jobId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.jobId = jobId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct GetServiceLastAccessedDetailsInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let maxItems: Swift.Int?
    let marker: Swift.String?
}

extension GetServiceLastAccessedDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension GetServiceLastAccessedDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceLastAccessedDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.isTruncated = output.isTruncated
            self.jobCompletionDate = output.jobCompletionDate
            self.jobCreationDate = output.jobCreationDate
            self.jobStatus = output.jobStatus
            self.jobType = output.jobType
            self.marker = output.marker
            self.servicesLastAccessed = output.servicesLastAccessed
        } else {
            self.error = nil
            self.isTruncated = false
            self.jobCompletionDate = nil
            self.jobCreationDate = nil
            self.jobStatus = nil
            self.jobType = nil
            self.marker = nil
            self.servicesLastAccessed = nil
        }
    }
}

public struct GetServiceLastAccessedDetailsOutput: Swift.Equatable {
    /// An object that contains details about the reason the operation failed.
    public var error: IAMClientTypes.ErrorDetails?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the generated report job was completed or failed. This field is null if the job is still in progress, as indicated by a job status value of IN_PROGRESS.
    /// This member is required.
    public var jobCompletionDate: ClientRuntime.Date?
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the report job was created.
    /// This member is required.
    public var jobCreationDate: ClientRuntime.Date?
    /// The status of the job.
    /// This member is required.
    public var jobStatus: IAMClientTypes.JobStatusType?
    /// The type of job. Service jobs return information about when each service was last accessed. Action jobs also include information about when tracked actions within the service were last accessed.
    public var jobType: IAMClientTypes.AccessAdvisorUsageGranularityType?
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A ServiceLastAccessed object that contains details about the most recent attempt to access the service.
    /// This member is required.
    public var servicesLastAccessed: [IAMClientTypes.ServiceLastAccessed]?

    public init(
        error: IAMClientTypes.ErrorDetails? = nil,
        isTruncated: Swift.Bool = false,
        jobCompletionDate: ClientRuntime.Date? = nil,
        jobCreationDate: ClientRuntime.Date? = nil,
        jobStatus: IAMClientTypes.JobStatusType? = nil,
        jobType: IAMClientTypes.AccessAdvisorUsageGranularityType? = nil,
        marker: Swift.String? = nil,
        servicesLastAccessed: [IAMClientTypes.ServiceLastAccessed]? = nil
    )
    {
        self.error = error
        self.isTruncated = isTruncated
        self.jobCompletionDate = jobCompletionDate
        self.jobCreationDate = jobCreationDate
        self.jobStatus = jobStatus
        self.jobType = jobType
        self.marker = marker
        self.servicesLastAccessed = servicesLastAccessed
    }
}

struct GetServiceLastAccessedDetailsOutputBody: Swift.Equatable {
    let jobStatus: IAMClientTypes.JobStatusType?
    let jobType: IAMClientTypes.AccessAdvisorUsageGranularityType?
    let jobCreationDate: ClientRuntime.Date?
    let servicesLastAccessed: [IAMClientTypes.ServiceLastAccessed]?
    let jobCompletionDate: ClientRuntime.Date?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
    let error: IAMClientTypes.ErrorDetails?
}

extension GetServiceLastAccessedDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case isTruncated = "IsTruncated"
        case jobCompletionDate = "JobCompletionDate"
        case jobCreationDate = "JobCreationDate"
        case jobStatus = "JobStatus"
        case jobType = "JobType"
        case marker = "Marker"
        case servicesLastAccessed = "ServicesLastAccessed"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetServiceLastAccessedDetailsResult"))
        let jobStatusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.JobStatusType.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AccessAdvisorUsageGranularityType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let jobCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .jobCreationDate)
        jobCreationDate = jobCreationDateDecoded
        if containerValues.contains(.servicesLastAccessed) {
            struct KeyVal0{struct member{}}
            let servicesLastAccessedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .servicesLastAccessed)
            if let servicesLastAccessedWrappedContainer = servicesLastAccessedWrappedContainer {
                let servicesLastAccessedContainer = try servicesLastAccessedWrappedContainer.decodeIfPresent([IAMClientTypes.ServiceLastAccessed].self, forKey: .member)
                var servicesLastAccessedBuffer:[IAMClientTypes.ServiceLastAccessed]? = nil
                if let servicesLastAccessedContainer = servicesLastAccessedContainer {
                    servicesLastAccessedBuffer = [IAMClientTypes.ServiceLastAccessed]()
                    for structureContainer0 in servicesLastAccessedContainer {
                        servicesLastAccessedBuffer?.append(structureContainer0)
                    }
                }
                servicesLastAccessed = servicesLastAccessedBuffer
            } else {
                servicesLastAccessed = []
            }
        } else {
            servicesLastAccessed = nil
        }
        let jobCompletionDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .jobCompletionDate)
        jobCompletionDate = jobCompletionDateDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

enum GetServiceLastAccessedDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetServiceLastAccessedDetailsWithEntitiesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let jobId = jobId {
            try container.encode(jobId, forKey: ClientRuntime.Key("JobId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: ClientRuntime.Key("ServiceNamespace"))
        }
        try container.encode("GetServiceLastAccessedDetailsWithEntities", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetServiceLastAccessedDetailsWithEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceLastAccessedDetailsWithEntitiesInput: Swift.Equatable {
    /// The ID of the request generated by the GenerateServiceLastAccessedDetails operation.
    /// This member is required.
    public var jobId: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The service namespace for an Amazon Web Services service. Provide the service namespace to learn when the IAM entity last attempted to access the specified service. To learn the service namespace for a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the IAM User Guide. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
    /// This member is required.
    public var serviceNamespace: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        serviceNamespace: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.marker = marker
        self.maxItems = maxItems
        self.serviceNamespace = serviceNamespace
    }
}

struct GetServiceLastAccessedDetailsWithEntitiesInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let serviceNamespace: Swift.String?
    let maxItems: Swift.Int?
    let marker: Swift.String?
}

extension GetServiceLastAccessedDetailsWithEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case serviceNamespace = "ServiceNamespace"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let serviceNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNamespace)
        serviceNamespace = serviceNamespaceDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension GetServiceLastAccessedDetailsWithEntitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceLastAccessedDetailsWithEntitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.entityDetailsList = output.entityDetailsList
            self.error = output.error
            self.isTruncated = output.isTruncated
            self.jobCompletionDate = output.jobCompletionDate
            self.jobCreationDate = output.jobCreationDate
            self.jobStatus = output.jobStatus
            self.marker = output.marker
        } else {
            self.entityDetailsList = nil
            self.error = nil
            self.isTruncated = false
            self.jobCompletionDate = nil
            self.jobCreationDate = nil
            self.jobStatus = nil
            self.marker = nil
        }
    }
}

public struct GetServiceLastAccessedDetailsWithEntitiesOutput: Swift.Equatable {
    /// An EntityDetailsList object that contains details about when an IAM entity (user or role) used group or policy permissions in an attempt to access the specified Amazon Web Services service.
    /// This member is required.
    public var entityDetailsList: [IAMClientTypes.EntityDetails]?
    /// An object that contains details about the reason the operation failed.
    public var error: IAMClientTypes.ErrorDetails?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the generated report job was completed or failed. This field is null if the job is still in progress, as indicated by a job status value of IN_PROGRESS.
    /// This member is required.
    public var jobCompletionDate: ClientRuntime.Date?
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the report job was created.
    /// This member is required.
    public var jobCreationDate: ClientRuntime.Date?
    /// The status of the job.
    /// This member is required.
    public var jobStatus: IAMClientTypes.JobStatusType?
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        entityDetailsList: [IAMClientTypes.EntityDetails]? = nil,
        error: IAMClientTypes.ErrorDetails? = nil,
        isTruncated: Swift.Bool = false,
        jobCompletionDate: ClientRuntime.Date? = nil,
        jobCreationDate: ClientRuntime.Date? = nil,
        jobStatus: IAMClientTypes.JobStatusType? = nil,
        marker: Swift.String? = nil
    )
    {
        self.entityDetailsList = entityDetailsList
        self.error = error
        self.isTruncated = isTruncated
        self.jobCompletionDate = jobCompletionDate
        self.jobCreationDate = jobCreationDate
        self.jobStatus = jobStatus
        self.marker = marker
    }
}

struct GetServiceLastAccessedDetailsWithEntitiesOutputBody: Swift.Equatable {
    let jobStatus: IAMClientTypes.JobStatusType?
    let jobCreationDate: ClientRuntime.Date?
    let jobCompletionDate: ClientRuntime.Date?
    let entityDetailsList: [IAMClientTypes.EntityDetails]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
    let error: IAMClientTypes.ErrorDetails?
}

extension GetServiceLastAccessedDetailsWithEntitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityDetailsList = "EntityDetailsList"
        case error = "Error"
        case isTruncated = "IsTruncated"
        case jobCompletionDate = "JobCompletionDate"
        case jobCreationDate = "JobCreationDate"
        case jobStatus = "JobStatus"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetServiceLastAccessedDetailsWithEntitiesResult"))
        let jobStatusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.JobStatusType.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .jobCreationDate)
        jobCreationDate = jobCreationDateDecoded
        let jobCompletionDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .jobCompletionDate)
        jobCompletionDate = jobCompletionDateDecoded
        if containerValues.contains(.entityDetailsList) {
            struct KeyVal0{struct member{}}
            let entityDetailsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .entityDetailsList)
            if let entityDetailsListWrappedContainer = entityDetailsListWrappedContainer {
                let entityDetailsListContainer = try entityDetailsListWrappedContainer.decodeIfPresent([IAMClientTypes.EntityDetails].self, forKey: .member)
                var entityDetailsListBuffer:[IAMClientTypes.EntityDetails]? = nil
                if let entityDetailsListContainer = entityDetailsListContainer {
                    entityDetailsListBuffer = [IAMClientTypes.EntityDetails]()
                    for structureContainer0 in entityDetailsListContainer {
                        entityDetailsListBuffer?.append(structureContainer0)
                    }
                }
                entityDetailsList = entityDetailsListBuffer
            } else {
                entityDetailsList = []
            }
        } else {
            entityDetailsList = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

enum GetServiceLastAccessedDetailsWithEntitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetServiceLinkedRoleDeletionStatusInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deletionTaskId = deletionTaskId {
            try container.encode(deletionTaskId, forKey: ClientRuntime.Key("DeletionTaskId"))
        }
        try container.encode("GetServiceLinkedRoleDeletionStatus", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetServiceLinkedRoleDeletionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceLinkedRoleDeletionStatusInput: Swift.Equatable {
    /// The deletion task identifier. This identifier is returned by the [DeleteServiceLinkedRole] operation in the format task/aws-service-role///.
    /// This member is required.
    public var deletionTaskId: Swift.String?

    public init(
        deletionTaskId: Swift.String? = nil
    )
    {
        self.deletionTaskId = deletionTaskId
    }
}

struct GetServiceLinkedRoleDeletionStatusInputBody: Swift.Equatable {
    let deletionTaskId: Swift.String?
}

extension GetServiceLinkedRoleDeletionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionTaskId = "DeletionTaskId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionTaskId)
        deletionTaskId = deletionTaskIdDecoded
    }
}

extension GetServiceLinkedRoleDeletionStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceLinkedRoleDeletionStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.reason = output.reason
            self.status = output.status
        } else {
            self.reason = nil
            self.status = nil
        }
    }
}

public struct GetServiceLinkedRoleDeletionStatusOutput: Swift.Equatable {
    /// An object that contains details about the reason the deletion failed.
    public var reason: IAMClientTypes.DeletionTaskFailureReasonType?
    /// The status of the deletion.
    /// This member is required.
    public var status: IAMClientTypes.DeletionTaskStatusType?

    public init(
        reason: IAMClientTypes.DeletionTaskFailureReasonType? = nil,
        status: IAMClientTypes.DeletionTaskStatusType? = nil
    )
    {
        self.reason = reason
        self.status = status
    }
}

struct GetServiceLinkedRoleDeletionStatusOutputBody: Swift.Equatable {
    let status: IAMClientTypes.DeletionTaskStatusType?
    let reason: IAMClientTypes.DeletionTaskFailureReasonType?
}

extension GetServiceLinkedRoleDeletionStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "Reason"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetServiceLinkedRoleDeletionStatusResult"))
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.DeletionTaskStatusType.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(IAMClientTypes.DeletionTaskFailureReasonType.self, forKey: .reason)
        reason = reasonDecoded
    }
}

enum GetServiceLinkedRoleDeletionStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetUserInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("GetUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetUserInput: Swift.Equatable {
    /// The name of the user to get information about. This parameter is optional. If it is not included, it defaults to the user making the request. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

struct GetUserInputBody: Swift.Equatable {
    let userName: Swift.String?
}

extension GetUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension GetUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

/// Contains the response to a successful [GetUser] request.
public struct GetUserOutput: Swift.Equatable {
    /// A structure containing details about the IAM user. Due to a service issue, password last used data does not include password use from May 3, 2018 22:50 PDT to May 23, 2018 14:08 PDT. This affects [last sign-in](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_finding-unused.html) dates shown in the IAM console and password last used dates in the [IAM credential report](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_getting-report.html), and returned by this operation. If users signed in during the affected time, the password last used date that is returned is the date the user last signed in before May 3, 2018. For users that signed in after May 23, 2018 14:08 PDT, the returned password last used date is accurate. You can use password last used information to identify unused credentials for deletion. For example, you might delete users who did not sign in to Amazon Web Services in the last 90 days. In cases like this, we recommend that you adjust your evaluation window to include dates after May 23, 2018. Alternatively, if your users use access keys to access Amazon Web Services programmatically you can refer to access key last used information because it is accurate for all dates.
    /// This member is required.
    public var user: IAMClientTypes.User?

    public init(
        user: IAMClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct GetUserOutputBody: Swift.Equatable {
    let user: IAMClientTypes.User?
}

extension GetUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetUserResult"))
        let userDecoded = try containerValues.decodeIfPresent(IAMClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

enum GetUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetUserPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("GetUserPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetUserPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetUserPolicyInput: Swift.Equatable {
    /// The name of the policy document to get. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the user who the policy is associated with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.userName = userName
    }
}

struct GetUserPolicyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let policyName: Swift.String?
}

extension GetUserPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension GetUserPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUserPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyDocument = output.policyDocument
            self.policyName = output.policyName
            self.userName = output.userName
        } else {
            self.policyDocument = nil
            self.policyName = nil
            self.userName = nil
        }
    }
}

/// Contains the response to a successful [GetUserPolicy] request.
public struct GetUserPolicyOutput: Swift.Equatable {
    /// The policy document. IAM stores policies in JSON format. However, resources that were created using CloudFormation templates can be formatted in YAML. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?
    /// The user the policy is associated with.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.userName = userName
    }
}

struct GetUserPolicyOutputBody: Swift.Equatable {
    let userName: Swift.String?
    let policyName: Swift.String?
    let policyDocument: Swift.String?
}

extension GetUserPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetUserPolicyResult"))
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

enum GetUserPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension IAMClientTypes {
    public enum GlobalEndpointTokenVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case v1token
        case v2token
        case sdkUnknown(Swift.String)

        public static var allCases: [GlobalEndpointTokenVersion] {
            return [
                .v1token,
                .v2token,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .v1token: return "v1Token"
            case .v2token: return "v2Token"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GlobalEndpointTokenVersion(rawValue: rawValue) ?? GlobalEndpointTokenVersion.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.Group: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let groupId = groupId {
            try container.encode(groupId, forKey: ClientRuntime.Key("GroupId"))
        }
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM group entity. This data type is used as a response element in the following operations:
    ///
    /// * [CreateGroup]
    ///
    /// * [GetGroup]
    ///
    /// * [ListGroups]
    public struct Group: Swift.Equatable {
        /// The Amazon Resource Name (ARN) specifying the group. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the group was created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// The stable and unique string identifying the group. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var groupId: Swift.String?
        /// The friendly name that identifies the group.
        /// This member is required.
        public var groupName: Swift.String?
        /// The path to the group. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.groupId = groupId
            self.groupName = groupName
            self.path = path
        }
    }

}

extension IAMClientTypes.GroupDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case groupPolicyList = "GroupPolicyList"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let attachedManagedPolicies = attachedManagedPolicies {
            if !attachedManagedPolicies.isEmpty {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                for (index0, attachedpolicy0) in attachedManagedPolicies.enumerated() {
                    try attachedManagedPoliciesContainer.encode(attachedpolicy0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                try attachedManagedPoliciesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let groupId = groupId {
            try container.encode(groupId, forKey: ClientRuntime.Key("GroupId"))
        }
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let groupPolicyList = groupPolicyList {
            if !groupPolicyList.isEmpty {
                var groupPolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupPolicyList"))
                for (index0, policydetail0) in groupPolicyList.enumerated() {
                    try groupPolicyListContainer.encode(policydetail0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var groupPolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupPolicyList"))
                try groupPolicyListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        if containerValues.contains(.groupPolicyList) {
            struct KeyVal0{struct member{}}
            let groupPolicyListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groupPolicyList)
            if let groupPolicyListWrappedContainer = groupPolicyListWrappedContainer {
                let groupPolicyListContainer = try groupPolicyListWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyDetail].self, forKey: .member)
                var groupPolicyListBuffer:[IAMClientTypes.PolicyDetail]? = nil
                if let groupPolicyListContainer = groupPolicyListContainer {
                    groupPolicyListBuffer = [IAMClientTypes.PolicyDetail]()
                    for structureContainer0 in groupPolicyListContainer {
                        groupPolicyListBuffer?.append(structureContainer0)
                    }
                }
                groupPolicyList = groupPolicyListBuffer
            } else {
                groupPolicyList = []
            }
        } else {
            groupPolicyList = nil
        }
        if containerValues.contains(.attachedManagedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedManagedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedManagedPolicies)
            if let attachedManagedPoliciesWrappedContainer = attachedManagedPoliciesWrappedContainer {
                let attachedManagedPoliciesContainer = try attachedManagedPoliciesWrappedContainer.decodeIfPresent([IAMClientTypes.AttachedPolicy].self, forKey: .member)
                var attachedManagedPoliciesBuffer:[IAMClientTypes.AttachedPolicy]? = nil
                if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
                    attachedManagedPoliciesBuffer = [IAMClientTypes.AttachedPolicy]()
                    for structureContainer0 in attachedManagedPoliciesContainer {
                        attachedManagedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedManagedPolicies = attachedManagedPoliciesBuffer
            } else {
                attachedManagedPolicies = []
            }
        } else {
            attachedManagedPolicies = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM group, including all of the group's policies. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct GroupDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// A list of the managed policies attached to the group.
        public var attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the group was created.
        public var createDate: ClientRuntime.Date?
        /// The stable and unique string identifying the group. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var groupId: Swift.String?
        /// The friendly name that identifies the group.
        public var groupName: Swift.String?
        /// A list of the inline policies embedded in the group.
        public var groupPolicyList: [IAMClientTypes.PolicyDetail]?
        /// The path to the group. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?

        public init(
            arn: Swift.String? = nil,
            attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
            createDate: ClientRuntime.Date? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            groupPolicyList: [IAMClientTypes.PolicyDetail]? = nil,
            path: Swift.String? = nil
        )
        {
            self.arn = arn
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupId = groupId
            self.groupName = groupName
            self.groupPolicyList = groupPolicyList
            self.path = path
        }
    }

}

extension IAMClientTypes.InstanceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case instanceProfileId = "InstanceProfileId"
        case instanceProfileName = "InstanceProfileName"
        case path = "Path"
        case roles = "Roles"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let instanceProfileId = instanceProfileId {
            try container.encode(instanceProfileId, forKey: ClientRuntime.Key("InstanceProfileId"))
        }
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let roles = roles {
            if !roles.isEmpty {
                var rolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Roles"))
                for (index0, role0) in roles.enumerated() {
                    try rolesContainer.encode(role0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var rolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Roles"))
                try rolesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let instanceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileId)
        instanceProfileId = instanceProfileIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        if containerValues.contains(.roles) {
            struct KeyVal0{struct member{}}
            let rolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .roles)
            if let rolesWrappedContainer = rolesWrappedContainer {
                let rolesContainer = try rolesWrappedContainer.decodeIfPresent([IAMClientTypes.Role].self, forKey: .member)
                var rolesBuffer:[IAMClientTypes.Role]? = nil
                if let rolesContainer = rolesContainer {
                    rolesBuffer = [IAMClientTypes.Role]()
                    for structureContainer0 in rolesContainer {
                        rolesBuffer?.append(structureContainer0)
                    }
                }
                roles = rolesBuffer
            } else {
                roles = []
            }
        } else {
            roles = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an instance profile. This data type is used as a response element in the following operations:
    ///
    /// * [CreateInstanceProfile]
    ///
    /// * [GetInstanceProfile]
    ///
    /// * [ListInstanceProfiles]
    ///
    /// * [ListInstanceProfilesForRole]
    public struct InstanceProfile: Swift.Equatable {
        /// The Amazon Resource Name (ARN) specifying the instance profile. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date when the instance profile was created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// The stable and unique string identifying the instance profile. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var instanceProfileId: Swift.String?
        /// The name identifying the instance profile.
        /// This member is required.
        public var instanceProfileName: Swift.String?
        /// The path to the instance profile. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?
        /// The role associated with the instance profile.
        /// This member is required.
        public var roles: [IAMClientTypes.Role]?
        /// A list of tags that are attached to the instance profile. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init(
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            instanceProfileId: Swift.String? = nil,
            instanceProfileName: Swift.String? = nil,
            path: Swift.String? = nil,
            roles: [IAMClientTypes.Role]? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.instanceProfileId = instanceProfileId
            self.instanceProfileName = instanceProfileName
            self.path = path
            self.roles = roles
            self.tags = tags
        }
    }

}

extension InvalidAuthenticationCodeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidAuthenticationCodeExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because the authentication code was not recognized. The error message describes the specific error.
public struct InvalidAuthenticationCodeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAuthenticationCode" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidAuthenticationCodeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAuthenticationCodeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCertificateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidCertificateExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because the certificate is invalid.
public struct InvalidCertificateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCertificate" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidCertificateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCertificateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidInputExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because an invalid or out-of-range value was supplied for an input parameter.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInput" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPublicKeyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidPublicKeyExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because the public key is malformed or otherwise invalid.
public struct InvalidPublicKeyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPublicKey" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPublicKeyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPublicKeyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUserTypeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidUserTypeExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because the type of user for the transaction was incorrect.
public struct InvalidUserTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidUserType" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidUserTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidUserTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes {
    public enum JobStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatusType] {
            return [
                .completed,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatusType(rawValue: rawValue) ?? JobStatusType.sdkUnknown(rawValue)
        }
    }
}

extension KeyPairMismatchException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<KeyPairMismatchExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because the public key certificate and the private key do not match.
public struct KeyPairMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KeyPairMismatch" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct KeyPairMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KeyPairMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<LimitExceededExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because it attempted to create resources beyond the current Amazon Web Services account limits. The error message describes the limit exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccessKeysInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListAccessKeys", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListAccessKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccessKeysInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

struct ListAccessKeysInputBody: Swift.Equatable {
    let userName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListAccessKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListAccessKeysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccessKeysOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessKeyMetadata = output.accessKeyMetadata
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.accessKeyMetadata = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListAccessKeys] request.
public struct ListAccessKeysOutput: Swift.Equatable {
    /// A list of objects containing metadata about the access keys.
    /// This member is required.
    public var accessKeyMetadata: [IAMClientTypes.AccessKeyMetadata]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        accessKeyMetadata: [IAMClientTypes.AccessKeyMetadata]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.accessKeyMetadata = accessKeyMetadata
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListAccessKeysOutputBody: Swift.Equatable {
    let accessKeyMetadata: [IAMClientTypes.AccessKeyMetadata]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListAccessKeysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyMetadata = "AccessKeyMetadata"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListAccessKeysResult"))
        if containerValues.contains(.accessKeyMetadata) {
            struct KeyVal0{struct member{}}
            let accessKeyMetadataWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accessKeyMetadata)
            if let accessKeyMetadataWrappedContainer = accessKeyMetadataWrappedContainer {
                let accessKeyMetadataContainer = try accessKeyMetadataWrappedContainer.decodeIfPresent([IAMClientTypes.AccessKeyMetadata].self, forKey: .member)
                var accessKeyMetadataBuffer:[IAMClientTypes.AccessKeyMetadata]? = nil
                if let accessKeyMetadataContainer = accessKeyMetadataContainer {
                    accessKeyMetadataBuffer = [IAMClientTypes.AccessKeyMetadata]()
                    for structureContainer0 in accessKeyMetadataContainer {
                        accessKeyMetadataBuffer?.append(structureContainer0)
                    }
                }
                accessKeyMetadata = accessKeyMetadataBuffer
            } else {
                accessKeyMetadata = []
            }
        } else {
            accessKeyMetadata = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListAccessKeysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListAccountAliasesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("ListAccountAliases", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListAccountAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccountAliasesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListAccountAliasesInputBody: Swift.Equatable {
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListAccountAliasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListAccountAliasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccountAliasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAliases = output.accountAliases
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.accountAliases = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListAccountAliases] request.
public struct ListAccountAliasesOutput: Swift.Equatable {
    /// A list of aliases associated with the account. Amazon Web Services supports only one alias per account.
    /// This member is required.
    public var accountAliases: [Swift.String]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        accountAliases: [Swift.String]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.accountAliases = accountAliases
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListAccountAliasesOutputBody: Swift.Equatable {
    let accountAliases: [Swift.String]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListAccountAliasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAliases = "AccountAliases"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListAccountAliasesResult"))
        if containerValues.contains(.accountAliases) {
            struct KeyVal0{struct member{}}
            let accountAliasesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accountAliases)
            if let accountAliasesWrappedContainer = accountAliasesWrappedContainer {
                let accountAliasesContainer = try accountAliasesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var accountAliasesBuffer:[Swift.String]? = nil
                if let accountAliasesContainer = accountAliasesContainer {
                    accountAliasesBuffer = [Swift.String]()
                    for stringContainer0 in accountAliasesContainer {
                        accountAliasesBuffer?.append(stringContainer0)
                    }
                }
                accountAliases = accountAliasesBuffer
            } else {
                accountAliases = []
            }
        } else {
            accountAliases = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListAccountAliasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListAttachedGroupPoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListAttachedGroupPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListAttachedGroupPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAttachedGroupPoliciesInput: Swift.Equatable {
    /// The name (friendly name, not ARN) of the group to list attached policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

struct ListAttachedGroupPoliciesInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListAttachedGroupPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListAttachedGroupPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAttachedGroupPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attachedPolicies = output.attachedPolicies
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.attachedPolicies = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListAttachedGroupPolicies] request.
public struct ListAttachedGroupPoliciesOutput: Swift.Equatable {
    /// A list of the attached policies.
    public var attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        attachedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.attachedPolicies = attachedPolicies
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListAttachedGroupPoliciesOutputBody: Swift.Equatable {
    let attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListAttachedGroupPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedPolicies = "AttachedPolicies"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListAttachedGroupPoliciesResult"))
        if containerValues.contains(.attachedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedPolicies)
            if let attachedPoliciesWrappedContainer = attachedPoliciesWrappedContainer {
                let attachedPoliciesContainer = try attachedPoliciesWrappedContainer.decodeIfPresent([IAMClientTypes.AttachedPolicy].self, forKey: .member)
                var attachedPoliciesBuffer:[IAMClientTypes.AttachedPolicy]? = nil
                if let attachedPoliciesContainer = attachedPoliciesContainer {
                    attachedPoliciesBuffer = [IAMClientTypes.AttachedPolicy]()
                    for structureContainer0 in attachedPoliciesContainer {
                        attachedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedPolicies = attachedPoliciesBuffer
            } else {
                attachedPolicies = []
            }
        } else {
            attachedPolicies = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListAttachedGroupPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListAttachedRolePoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("ListAttachedRolePolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListAttachedRolePoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAttachedRolePoliciesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The name (friendly name, not ARN) of the role to list attached policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
        self.roleName = roleName
    }
}

struct ListAttachedRolePoliciesInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListAttachedRolePoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListAttachedRolePoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAttachedRolePoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attachedPolicies = output.attachedPolicies
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.attachedPolicies = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListAttachedRolePolicies] request.
public struct ListAttachedRolePoliciesOutput: Swift.Equatable {
    /// A list of the attached policies.
    public var attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        attachedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.attachedPolicies = attachedPolicies
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListAttachedRolePoliciesOutputBody: Swift.Equatable {
    let attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListAttachedRolePoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedPolicies = "AttachedPolicies"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListAttachedRolePoliciesResult"))
        if containerValues.contains(.attachedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedPolicies)
            if let attachedPoliciesWrappedContainer = attachedPoliciesWrappedContainer {
                let attachedPoliciesContainer = try attachedPoliciesWrappedContainer.decodeIfPresent([IAMClientTypes.AttachedPolicy].self, forKey: .member)
                var attachedPoliciesBuffer:[IAMClientTypes.AttachedPolicy]? = nil
                if let attachedPoliciesContainer = attachedPoliciesContainer {
                    attachedPoliciesBuffer = [IAMClientTypes.AttachedPolicy]()
                    for structureContainer0 in attachedPoliciesContainer {
                        attachedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedPolicies = attachedPoliciesBuffer
            } else {
                attachedPolicies = []
            }
        } else {
            attachedPolicies = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListAttachedRolePoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListAttachedUserPoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListAttachedUserPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListAttachedUserPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAttachedUserPoliciesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The name (friendly name, not ARN) of the user to list attached policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
        self.userName = userName
    }
}

struct ListAttachedUserPoliciesInputBody: Swift.Equatable {
    let userName: Swift.String?
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListAttachedUserPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListAttachedUserPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAttachedUserPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attachedPolicies = output.attachedPolicies
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.attachedPolicies = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListAttachedUserPolicies] request.
public struct ListAttachedUserPoliciesOutput: Swift.Equatable {
    /// A list of the attached policies.
    public var attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        attachedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.attachedPolicies = attachedPolicies
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListAttachedUserPoliciesOutputBody: Swift.Equatable {
    let attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListAttachedUserPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedPolicies = "AttachedPolicies"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListAttachedUserPoliciesResult"))
        if containerValues.contains(.attachedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedPolicies)
            if let attachedPoliciesWrappedContainer = attachedPoliciesWrappedContainer {
                let attachedPoliciesContainer = try attachedPoliciesWrappedContainer.decodeIfPresent([IAMClientTypes.AttachedPolicy].self, forKey: .member)
                var attachedPoliciesBuffer:[IAMClientTypes.AttachedPolicy]? = nil
                if let attachedPoliciesContainer = attachedPoliciesContainer {
                    attachedPoliciesBuffer = [IAMClientTypes.AttachedPolicy]()
                    for structureContainer0 in attachedPoliciesContainer {
                        attachedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedPolicies = attachedPoliciesBuffer
            } else {
                attachedPolicies = []
            }
        } else {
            attachedPolicies = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListAttachedUserPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListEntitiesForPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let entityFilter = entityFilter {
            try container.encode(entityFilter, forKey: ClientRuntime.Key("EntityFilter"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let policyUsageFilter = policyUsageFilter {
            try container.encode(policyUsageFilter, forKey: ClientRuntime.Key("PolicyUsageFilter"))
        }
        try container.encode("ListEntitiesForPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListEntitiesForPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEntitiesForPolicyInput: Swift.Equatable {
    /// The entity type to use for filtering the results. For example, when EntityFilter is Role, only the roles that are attached to the specified policy are returned. This parameter is optional. If it is not included, all attached entities (users, groups, and roles) are returned. The argument for this parameter must be one of the valid values listed below.
    public var entityFilter: IAMClientTypes.EntityType?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all entities. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM policy for which you want the versions. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The policy usage method to use for filtering the results. To list only permissions policies, set PolicyUsageFilter to PermissionsPolicy. To list only the policies used to set permissions boundaries, set the value to PermissionsBoundary. This parameter is optional. If it is not included, all policies are returned.
    public var policyUsageFilter: IAMClientTypes.PolicyUsageType?

    public init(
        entityFilter: IAMClientTypes.EntityType? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        policyUsageFilter: IAMClientTypes.PolicyUsageType? = nil
    )
    {
        self.entityFilter = entityFilter
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
        self.policyArn = policyArn
        self.policyUsageFilter = policyUsageFilter
    }
}

struct ListEntitiesForPolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let entityFilter: IAMClientTypes.EntityType?
    let pathPrefix: Swift.String?
    let policyUsageFilter: IAMClientTypes.PolicyUsageType?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListEntitiesForPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityFilter = "EntityFilter"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
        case policyArn = "PolicyArn"
        case policyUsageFilter = "PolicyUsageFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let entityFilterDecoded = try containerValues.decodeIfPresent(IAMClientTypes.EntityType.self, forKey: .entityFilter)
        entityFilter = entityFilterDecoded
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let policyUsageFilterDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyUsageType.self, forKey: .policyUsageFilter)
        policyUsageFilter = policyUsageFilterDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListEntitiesForPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEntitiesForPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policyGroups = output.policyGroups
            self.policyRoles = output.policyRoles
            self.policyUsers = output.policyUsers
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policyGroups = nil
            self.policyRoles = nil
            self.policyUsers = nil
        }
    }
}

/// Contains the response to a successful [ListEntitiesForPolicy] request.
public struct ListEntitiesForPolicyOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of IAM groups that the policy is attached to.
    public var policyGroups: [IAMClientTypes.PolicyGroup]?
    /// A list of IAM roles that the policy is attached to.
    public var policyRoles: [IAMClientTypes.PolicyRole]?
    /// A list of IAM users that the policy is attached to.
    public var policyUsers: [IAMClientTypes.PolicyUser]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyGroups: [IAMClientTypes.PolicyGroup]? = nil,
        policyRoles: [IAMClientTypes.PolicyRole]? = nil,
        policyUsers: [IAMClientTypes.PolicyUser]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyGroups = policyGroups
        self.policyRoles = policyRoles
        self.policyUsers = policyUsers
    }
}

struct ListEntitiesForPolicyOutputBody: Swift.Equatable {
    let policyGroups: [IAMClientTypes.PolicyGroup]?
    let policyUsers: [IAMClientTypes.PolicyUser]?
    let policyRoles: [IAMClientTypes.PolicyRole]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListEntitiesForPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policyGroups = "PolicyGroups"
        case policyRoles = "PolicyRoles"
        case policyUsers = "PolicyUsers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListEntitiesForPolicyResult"))
        if containerValues.contains(.policyGroups) {
            struct KeyVal0{struct member{}}
            let policyGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyGroups)
            if let policyGroupsWrappedContainer = policyGroupsWrappedContainer {
                let policyGroupsContainer = try policyGroupsWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyGroup].self, forKey: .member)
                var policyGroupsBuffer:[IAMClientTypes.PolicyGroup]? = nil
                if let policyGroupsContainer = policyGroupsContainer {
                    policyGroupsBuffer = [IAMClientTypes.PolicyGroup]()
                    for structureContainer0 in policyGroupsContainer {
                        policyGroupsBuffer?.append(structureContainer0)
                    }
                }
                policyGroups = policyGroupsBuffer
            } else {
                policyGroups = []
            }
        } else {
            policyGroups = nil
        }
        if containerValues.contains(.policyUsers) {
            struct KeyVal0{struct member{}}
            let policyUsersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyUsers)
            if let policyUsersWrappedContainer = policyUsersWrappedContainer {
                let policyUsersContainer = try policyUsersWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyUser].self, forKey: .member)
                var policyUsersBuffer:[IAMClientTypes.PolicyUser]? = nil
                if let policyUsersContainer = policyUsersContainer {
                    policyUsersBuffer = [IAMClientTypes.PolicyUser]()
                    for structureContainer0 in policyUsersContainer {
                        policyUsersBuffer?.append(structureContainer0)
                    }
                }
                policyUsers = policyUsersBuffer
            } else {
                policyUsers = []
            }
        } else {
            policyUsers = nil
        }
        if containerValues.contains(.policyRoles) {
            struct KeyVal0{struct member{}}
            let policyRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyRoles)
            if let policyRolesWrappedContainer = policyRolesWrappedContainer {
                let policyRolesContainer = try policyRolesWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyRole].self, forKey: .member)
                var policyRolesBuffer:[IAMClientTypes.PolicyRole]? = nil
                if let policyRolesContainer = policyRolesContainer {
                    policyRolesBuffer = [IAMClientTypes.PolicyRole]()
                    for structureContainer0 in policyRolesContainer {
                        policyRolesBuffer?.append(structureContainer0)
                    }
                }
                policyRoles = policyRolesBuffer
            } else {
                policyRoles = []
            }
        } else {
            policyRoles = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListEntitiesForPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListGroupPoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("ListGroupPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListGroupPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupPoliciesInput: Swift.Equatable {
    /// The name of the group to list policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        groupName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.groupName = groupName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListGroupPoliciesInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListGroupPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListGroupPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGroupPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policyNames = output.policyNames
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policyNames = nil
        }
    }
}

/// Contains the response to a successful [ListGroupPolicies] request.
public struct ListGroupPoliciesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy names. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyNames = policyNames
    }
}

struct ListGroupPoliciesOutputBody: Swift.Equatable {
    let policyNames: [Swift.String]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListGroupPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policyNames = "PolicyNames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListGroupPoliciesResult"))
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyNamesBuffer:[Swift.String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [Swift.String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListGroupPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListGroupsForUserInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListGroupsForUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListGroupsForUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupsForUserInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user to list groups for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

struct ListGroupsForUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListGroupsForUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListGroupsForUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGroupsForUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.groups = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListGroupsForUser] request.
public struct ListGroupsForUserOutput: Swift.Equatable {
    /// A list of groups.
    /// This member is required.
    public var groups: [IAMClientTypes.Group]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        groups: [IAMClientTypes.Group]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.groups = groups
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListGroupsForUserOutputBody: Swift.Equatable {
    let groups: [IAMClientTypes.Group]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListGroupsForUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListGroupsForUserResult"))
        if containerValues.contains(.groups) {
            struct KeyVal0{struct member{}}
            let groupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groups)
            if let groupsWrappedContainer = groupsWrappedContainer {
                let groupsContainer = try groupsWrappedContainer.decodeIfPresent([IAMClientTypes.Group].self, forKey: .member)
                var groupsBuffer:[IAMClientTypes.Group]? = nil
                if let groupsContainer = groupsContainer {
                    groupsBuffer = [IAMClientTypes.Group]()
                    for structureContainer0 in groupsContainer {
                        groupsBuffer?.append(structureContainer0)
                    }
                }
                groups = groupsBuffer
            } else {
                groups = []
            }
        } else {
            groups = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListGroupsForUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListGroupsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example, the prefix /division_abc/subdivision_xyz/ gets all groups whose path starts with /division_abc/subdivision_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all groups. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

struct ListGroupsInputBody: Swift.Equatable {
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.groups = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListGroups] request.
public struct ListGroupsOutput: Swift.Equatable {
    /// A list of groups.
    /// This member is required.
    public var groups: [IAMClientTypes.Group]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        groups: [IAMClientTypes.Group]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.groups = groups
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListGroupsOutputBody: Swift.Equatable {
    let groups: [IAMClientTypes.Group]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListGroupsResult"))
        if containerValues.contains(.groups) {
            struct KeyVal0{struct member{}}
            let groupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groups)
            if let groupsWrappedContainer = groupsWrappedContainer {
                let groupsContainer = try groupsWrappedContainer.decodeIfPresent([IAMClientTypes.Group].self, forKey: .member)
                var groupsBuffer:[IAMClientTypes.Group]? = nil
                if let groupsContainer = groupsContainer {
                    groupsBuffer = [IAMClientTypes.Group]()
                    for structureContainer0 in groupsContainer {
                        groupsBuffer?.append(structureContainer0)
                    }
                }
                groups = groupsBuffer
            } else {
                groups = []
            }
        } else {
            groups = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListInstanceProfileTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("ListInstanceProfileTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListInstanceProfileTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListInstanceProfileTagsInput: Swift.Equatable {
    /// The name of the IAM instance profile whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        instanceProfileName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListInstanceProfileTagsInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListInstanceProfileTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListInstanceProfileTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListInstanceProfileTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListInstanceProfileTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the IAM instance profile. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListInstanceProfileTagsOutputBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListInstanceProfileTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListInstanceProfileTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListInstanceProfileTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListInstanceProfilesForRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("ListInstanceProfilesForRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListInstanceProfilesForRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListInstanceProfilesForRoleInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the role to list instance profiles for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.roleName = roleName
    }
}

struct ListInstanceProfilesForRoleInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListInstanceProfilesForRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListInstanceProfilesForRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListInstanceProfilesForRoleOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfiles = output.instanceProfiles
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.instanceProfiles = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListInstanceProfilesForRole] request.
public struct ListInstanceProfilesForRoleOutput: Swift.Equatable {
    /// A list of instance profiles.
    /// This member is required.
    public var instanceProfiles: [IAMClientTypes.InstanceProfile]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        instanceProfiles: [IAMClientTypes.InstanceProfile]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListInstanceProfilesForRoleOutputBody: Swift.Equatable {
    let instanceProfiles: [IAMClientTypes.InstanceProfile]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListInstanceProfilesForRoleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfiles = "InstanceProfiles"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListInstanceProfilesForRoleResult"))
        if containerValues.contains(.instanceProfiles) {
            struct KeyVal0{struct member{}}
            let instanceProfilesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instanceProfiles)
            if let instanceProfilesWrappedContainer = instanceProfilesWrappedContainer {
                let instanceProfilesContainer = try instanceProfilesWrappedContainer.decodeIfPresent([IAMClientTypes.InstanceProfile].self, forKey: .member)
                var instanceProfilesBuffer:[IAMClientTypes.InstanceProfile]? = nil
                if let instanceProfilesContainer = instanceProfilesContainer {
                    instanceProfilesBuffer = [IAMClientTypes.InstanceProfile]()
                    for structureContainer0 in instanceProfilesContainer {
                        instanceProfilesBuffer?.append(structureContainer0)
                    }
                }
                instanceProfiles = instanceProfilesBuffer
            } else {
                instanceProfiles = []
            }
        } else {
            instanceProfiles = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListInstanceProfilesForRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListInstanceProfilesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListInstanceProfiles", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListInstanceProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListInstanceProfilesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example, the prefix /application_abc/component_xyz/ gets all instance profiles whose path starts with /application_abc/component_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all instance profiles. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

struct ListInstanceProfilesInputBody: Swift.Equatable {
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListInstanceProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListInstanceProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListInstanceProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfiles = output.instanceProfiles
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.instanceProfiles = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListInstanceProfiles] request.
public struct ListInstanceProfilesOutput: Swift.Equatable {
    /// A list of instance profiles.
    /// This member is required.
    public var instanceProfiles: [IAMClientTypes.InstanceProfile]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        instanceProfiles: [IAMClientTypes.InstanceProfile]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListInstanceProfilesOutputBody: Swift.Equatable {
    let instanceProfiles: [IAMClientTypes.InstanceProfile]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListInstanceProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfiles = "InstanceProfiles"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListInstanceProfilesResult"))
        if containerValues.contains(.instanceProfiles) {
            struct KeyVal0{struct member{}}
            let instanceProfilesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instanceProfiles)
            if let instanceProfilesWrappedContainer = instanceProfilesWrappedContainer {
                let instanceProfilesContainer = try instanceProfilesWrappedContainer.decodeIfPresent([IAMClientTypes.InstanceProfile].self, forKey: .member)
                var instanceProfilesBuffer:[IAMClientTypes.InstanceProfile]? = nil
                if let instanceProfilesContainer = instanceProfilesContainer {
                    instanceProfilesBuffer = [IAMClientTypes.InstanceProfile]()
                    for structureContainer0 in instanceProfilesContainer {
                        instanceProfilesBuffer?.append(structureContainer0)
                    }
                }
                instanceProfiles = instanceProfilesBuffer
            } else {
                instanceProfiles = []
            }
        } else {
            instanceProfiles = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListInstanceProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListMFADeviceTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        try container.encode("ListMFADeviceTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListMFADeviceTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMFADeviceTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The unique identifier for the IAM virtual MFA device whose tags you want to see. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        serialNumber: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.serialNumber = serialNumber
    }
}

struct ListMFADeviceTagsInputBody: Swift.Equatable {
    let serialNumber: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListMFADeviceTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case serialNumber = "SerialNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListMFADeviceTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMFADeviceTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListMFADeviceTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the virtual MFA device. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListMFADeviceTagsOutputBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListMFADeviceTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListMFADeviceTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListMFADeviceTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListMFADevicesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListMFADevices", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListMFADevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMFADevicesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user whose MFA devices you want to list. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

struct ListMFADevicesInputBody: Swift.Equatable {
    let userName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListMFADevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListMFADevicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMFADevicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.mfaDevices = output.mfaDevices
        } else {
            self.isTruncated = false
            self.mfaDevices = nil
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListMFADevices] request.
public struct ListMFADevicesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of MFA devices.
    /// This member is required.
    public var mfaDevices: [IAMClientTypes.MFADevice]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        mfaDevices: [IAMClientTypes.MFADevice]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.mfaDevices = mfaDevices
    }
}

struct ListMFADevicesOutputBody: Swift.Equatable {
    let mfaDevices: [IAMClientTypes.MFADevice]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListMFADevicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case mfaDevices = "MFADevices"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListMFADevicesResult"))
        if containerValues.contains(.mfaDevices) {
            struct KeyVal0{struct member{}}
            let mfaDevicesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .mfaDevices)
            if let mfaDevicesWrappedContainer = mfaDevicesWrappedContainer {
                let mfaDevicesContainer = try mfaDevicesWrappedContainer.decodeIfPresent([IAMClientTypes.MFADevice].self, forKey: .member)
                var mfaDevicesBuffer:[IAMClientTypes.MFADevice]? = nil
                if let mfaDevicesContainer = mfaDevicesContainer {
                    mfaDevicesBuffer = [IAMClientTypes.MFADevice]()
                    for structureContainer0 in mfaDevicesContainer {
                        mfaDevicesBuffer?.append(structureContainer0)
                    }
                }
                mfaDevices = mfaDevicesBuffer
            } else {
                mfaDevices = []
            }
        } else {
            mfaDevices = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListMFADevicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListOpenIDConnectProviderTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        try container.encode("ListOpenIDConnectProviderTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListOpenIDConnectProviderTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListOpenIDConnectProviderTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The ARN of the OpenID Connect (OIDC) identity provider whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

struct ListOpenIDConnectProviderTagsInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListOpenIDConnectProviderTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListOpenIDConnectProviderTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOpenIDConnectProviderTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListOpenIDConnectProviderTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the OpenID Connect (OIDC) identity provider. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListOpenIDConnectProviderTagsOutputBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListOpenIDConnectProviderTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListOpenIDConnectProviderTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListOpenIDConnectProviderTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListOpenIDConnectProvidersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("ListOpenIDConnectProviders", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListOpenIDConnectProvidersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListOpenIDConnectProvidersInput: Swift.Equatable {

    public init() { }
}

extension ListOpenIDConnectProvidersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOpenIDConnectProvidersOutputBody = try responseDecoder.decode(responseBody: data)
            self.openIDConnectProviderList = output.openIDConnectProviderList
        } else {
            self.openIDConnectProviderList = nil
        }
    }
}

/// Contains the response to a successful [ListOpenIDConnectProviders] request.
public struct ListOpenIDConnectProvidersOutput: Swift.Equatable {
    /// The list of IAM OIDC provider resource objects defined in the Amazon Web Services account.
    public var openIDConnectProviderList: [IAMClientTypes.OpenIDConnectProviderListEntry]?

    public init(
        openIDConnectProviderList: [IAMClientTypes.OpenIDConnectProviderListEntry]? = nil
    )
    {
        self.openIDConnectProviderList = openIDConnectProviderList
    }
}

struct ListOpenIDConnectProvidersOutputBody: Swift.Equatable {
    let openIDConnectProviderList: [IAMClientTypes.OpenIDConnectProviderListEntry]?
}

extension ListOpenIDConnectProvidersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderList = "OpenIDConnectProviderList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListOpenIDConnectProvidersResult"))
        if containerValues.contains(.openIDConnectProviderList) {
            struct KeyVal0{struct member{}}
            let openIDConnectProviderListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .openIDConnectProviderList)
            if let openIDConnectProviderListWrappedContainer = openIDConnectProviderListWrappedContainer {
                let openIDConnectProviderListContainer = try openIDConnectProviderListWrappedContainer.decodeIfPresent([IAMClientTypes.OpenIDConnectProviderListEntry].self, forKey: .member)
                var openIDConnectProviderListBuffer:[IAMClientTypes.OpenIDConnectProviderListEntry]? = nil
                if let openIDConnectProviderListContainer = openIDConnectProviderListContainer {
                    openIDConnectProviderListBuffer = [IAMClientTypes.OpenIDConnectProviderListEntry]()
                    for structureContainer0 in openIDConnectProviderListContainer {
                        openIDConnectProviderListBuffer?.append(structureContainer0)
                    }
                }
                openIDConnectProviderList = openIDConnectProviderListBuffer
            } else {
                openIDConnectProviderList = []
            }
        } else {
            openIDConnectProviderList = nil
        }
    }
}

enum ListOpenIDConnectProvidersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension IAMClientTypes.ListPoliciesGrantingServiceAccessEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policies = "Policies"
        case serviceNamespace = "ServiceNamespace"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policies = policies {
            if !policies.isEmpty {
                var policiesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Policies"))
                for (index0, policygrantingserviceaccess0) in policies.enumerated() {
                    try policiesContainer.encode(policygrantingserviceaccess0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policiesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Policies"))
                try policiesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: ClientRuntime.Key("ServiceNamespace"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNamespace)
        serviceNamespace = serviceNamespaceDecoded
        if containerValues.contains(.policies) {
            struct KeyVal0{struct member{}}
            let policiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policies)
            if let policiesWrappedContainer = policiesWrappedContainer {
                let policiesContainer = try policiesWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyGrantingServiceAccess].self, forKey: .member)
                var policiesBuffer:[IAMClientTypes.PolicyGrantingServiceAccess]? = nil
                if let policiesContainer = policiesContainer {
                    policiesBuffer = [IAMClientTypes.PolicyGrantingServiceAccess]()
                    for structureContainer0 in policiesContainer {
                        policiesBuffer?.append(structureContainer0)
                    }
                }
                policies = policiesBuffer
            } else {
                policies = []
            }
        } else {
            policies = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains details about the permissions policies that are attached to the specified identity (user, group, or role). This data type is used as a response element in the [ListPoliciesGrantingServiceAccess] operation.
    public struct ListPoliciesGrantingServiceAccessEntry: Swift.Equatable {
        /// The PoliciesGrantingServiceAccess object that contains details about the policy.
        public var policies: [IAMClientTypes.PolicyGrantingServiceAccess]?
        /// The namespace of the service that was accessed. To learn the service namespace of a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the Service Authorization Reference. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
        public var serviceNamespace: Swift.String?

        public init(
            policies: [IAMClientTypes.PolicyGrantingServiceAccess]? = nil,
            serviceNamespace: Swift.String? = nil
        )
        {
            self.policies = policies
            self.serviceNamespace = serviceNamespace
        }
    }

}

extension ListPoliciesGrantingServiceAccessInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let serviceNamespaces = serviceNamespaces {
            if !serviceNamespaces.isEmpty {
                var serviceNamespacesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ServiceNamespaces"))
                for (index0, servicenamespacetype0) in serviceNamespaces.enumerated() {
                    try serviceNamespacesContainer.encode(servicenamespacetype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var serviceNamespacesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ServiceNamespaces"))
                try serviceNamespacesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("ListPoliciesGrantingServiceAccess", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPoliciesGrantingServiceAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPoliciesGrantingServiceAccessInput: Swift.Equatable {
    /// The ARN of the IAM identity (user, group, or role) whose policies you want to list.
    /// This member is required.
    public var arn: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// The service namespace for the Amazon Web Services services whose policies you want to list. To learn the service namespace for a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the IAM User Guide. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
    /// This member is required.
    public var serviceNamespaces: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        marker: Swift.String? = nil,
        serviceNamespaces: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.marker = marker
        self.serviceNamespaces = serviceNamespaces
    }
}

struct ListPoliciesGrantingServiceAccessInputBody: Swift.Equatable {
    let marker: Swift.String?
    let arn: Swift.String?
    let serviceNamespaces: [Swift.String]?
}

extension ListPoliciesGrantingServiceAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case marker = "Marker"
        case serviceNamespaces = "ServiceNamespaces"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        if containerValues.contains(.serviceNamespaces) {
            struct KeyVal0{struct member{}}
            let serviceNamespacesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .serviceNamespaces)
            if let serviceNamespacesWrappedContainer = serviceNamespacesWrappedContainer {
                let serviceNamespacesContainer = try serviceNamespacesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var serviceNamespacesBuffer:[Swift.String]? = nil
                if let serviceNamespacesContainer = serviceNamespacesContainer {
                    serviceNamespacesBuffer = [Swift.String]()
                    for stringContainer0 in serviceNamespacesContainer {
                        serviceNamespacesBuffer?.append(stringContainer0)
                    }
                }
                serviceNamespaces = serviceNamespacesBuffer
            } else {
                serviceNamespaces = []
            }
        } else {
            serviceNamespaces = nil
        }
    }
}

extension ListPoliciesGrantingServiceAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPoliciesGrantingServiceAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policiesGrantingServiceAccess = output.policiesGrantingServiceAccess
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policiesGrantingServiceAccess = nil
        }
    }
}

public struct ListPoliciesGrantingServiceAccessOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A ListPoliciesGrantingServiceAccess object that contains details about the permissions policies attached to the specified identity (user, group, or role).
    /// This member is required.
    public var policiesGrantingServiceAccess: [IAMClientTypes.ListPoliciesGrantingServiceAccessEntry]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policiesGrantingServiceAccess: [IAMClientTypes.ListPoliciesGrantingServiceAccessEntry]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policiesGrantingServiceAccess = policiesGrantingServiceAccess
    }
}

struct ListPoliciesGrantingServiceAccessOutputBody: Swift.Equatable {
    let policiesGrantingServiceAccess: [IAMClientTypes.ListPoliciesGrantingServiceAccessEntry]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListPoliciesGrantingServiceAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policiesGrantingServiceAccess = "PoliciesGrantingServiceAccess"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListPoliciesGrantingServiceAccessResult"))
        if containerValues.contains(.policiesGrantingServiceAccess) {
            struct KeyVal0{struct member{}}
            let policiesGrantingServiceAccessWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policiesGrantingServiceAccess)
            if let policiesGrantingServiceAccessWrappedContainer = policiesGrantingServiceAccessWrappedContainer {
                let policiesGrantingServiceAccessContainer = try policiesGrantingServiceAccessWrappedContainer.decodeIfPresent([IAMClientTypes.ListPoliciesGrantingServiceAccessEntry].self, forKey: .member)
                var policiesGrantingServiceAccessBuffer:[IAMClientTypes.ListPoliciesGrantingServiceAccessEntry]? = nil
                if let policiesGrantingServiceAccessContainer = policiesGrantingServiceAccessContainer {
                    policiesGrantingServiceAccessBuffer = [IAMClientTypes.ListPoliciesGrantingServiceAccessEntry]()
                    for structureContainer0 in policiesGrantingServiceAccessContainer {
                        policiesGrantingServiceAccessBuffer?.append(structureContainer0)
                    }
                }
                policiesGrantingServiceAccess = policiesGrantingServiceAccessBuffer
            } else {
                policiesGrantingServiceAccess = []
            }
        } else {
            policiesGrantingServiceAccess = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListPoliciesGrantingServiceAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListPoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let onlyAttached = onlyAttached {
            try container.encode(onlyAttached, forKey: ClientRuntime.Key("OnlyAttached"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        if let policyUsageFilter = policyUsageFilter {
            try container.encode(policyUsageFilter, forKey: ClientRuntime.Key("PolicyUsageFilter"))
        }
        if let scope = scope {
            try container.encode(scope, forKey: ClientRuntime.Key("Scope"))
        }
        try container.encode("ListPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPoliciesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// A flag to filter the results to only the attached policies. When OnlyAttached is true, the returned list contains only the policies that are attached to an IAM user, group, or role. When OnlyAttached is false, or when the parameter is not included, all policies are returned.
    public var onlyAttached: Swift.Bool?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The policy usage method to use for filtering the results. To list only permissions policies, set PolicyUsageFilter to PermissionsPolicy. To list only the policies used to set permissions boundaries, set the value to PermissionsBoundary. This parameter is optional. If it is not included, all policies are returned.
    public var policyUsageFilter: IAMClientTypes.PolicyUsageType?
    /// The scope to use for filtering the results. To list only Amazon Web Services managed policies, set Scope to AWS. To list only the customer managed policies in your Amazon Web Services account, set Scope to Local. This parameter is optional. If it is not included, or if it is set to All, all policies are returned.
    public var scope: IAMClientTypes.PolicyScopeType?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        onlyAttached: Swift.Bool? = nil,
        pathPrefix: Swift.String? = nil,
        policyUsageFilter: IAMClientTypes.PolicyUsageType? = nil,
        scope: IAMClientTypes.PolicyScopeType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.onlyAttached = onlyAttached
        self.pathPrefix = pathPrefix
        self.policyUsageFilter = policyUsageFilter
        self.scope = scope
    }
}

struct ListPoliciesInputBody: Swift.Equatable {
    let scope: IAMClientTypes.PolicyScopeType?
    let onlyAttached: Swift.Bool?
    let pathPrefix: Swift.String?
    let policyUsageFilter: IAMClientTypes.PolicyUsageType?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case onlyAttached = "OnlyAttached"
        case pathPrefix = "PathPrefix"
        case policyUsageFilter = "PolicyUsageFilter"
        case scope = "Scope"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyScopeType.self, forKey: .scope)
        scope = scopeDecoded
        let onlyAttachedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .onlyAttached) ?? false
        onlyAttached = onlyAttachedDecoded
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let policyUsageFilterDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyUsageType.self, forKey: .policyUsageFilter)
        policyUsageFilter = policyUsageFilterDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policies = output.policies
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policies = nil
        }
    }
}

/// Contains the response to a successful [ListPolicies] request.
public struct ListPoliciesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policies.
    public var policies: [IAMClientTypes.Policy]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policies: [IAMClientTypes.Policy]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policies = policies
    }
}

struct ListPoliciesOutputBody: Swift.Equatable {
    let policies: [IAMClientTypes.Policy]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policies = "Policies"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListPoliciesResult"))
        if containerValues.contains(.policies) {
            struct KeyVal0{struct member{}}
            let policiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policies)
            if let policiesWrappedContainer = policiesWrappedContainer {
                let policiesContainer = try policiesWrappedContainer.decodeIfPresent([IAMClientTypes.Policy].self, forKey: .member)
                var policiesBuffer:[IAMClientTypes.Policy]? = nil
                if let policiesContainer = policiesContainer {
                    policiesBuffer = [IAMClientTypes.Policy]()
                    for structureContainer0 in policiesContainer {
                        policiesBuffer?.append(structureContainer0)
                    }
                }
                policies = policiesBuffer
            } else {
                policies = []
            }
        } else {
            policies = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListPolicyTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("ListPolicyTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPolicyTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPolicyTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The ARN of the IAM customer managed policy whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.policyArn = policyArn
    }
}

struct ListPolicyTagsInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListPolicyTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case policyArn = "PolicyArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListPolicyTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPolicyTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListPolicyTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the IAM customer managed policy. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListPolicyTagsOutputBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListPolicyTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListPolicyTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListPolicyTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListPolicyVersionsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("ListPolicyVersions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPolicyVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPolicyVersionsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The Amazon Resource Name (ARN) of the IAM policy for which you want the versions. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.policyArn = policyArn
    }
}

struct ListPolicyVersionsInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListPolicyVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case policyArn = "PolicyArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListPolicyVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPolicyVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.versions = output.versions
        } else {
            self.isTruncated = false
            self.marker = nil
            self.versions = nil
        }
    }
}

/// Contains the response to a successful [ListPolicyVersions] request.
public struct ListPolicyVersionsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy versions. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    public var versions: [IAMClientTypes.PolicyVersion]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        versions: [IAMClientTypes.PolicyVersion]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.versions = versions
    }
}

struct ListPolicyVersionsOutputBody: Swift.Equatable {
    let versions: [IAMClientTypes.PolicyVersion]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListPolicyVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case versions = "Versions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListPolicyVersionsResult"))
        if containerValues.contains(.versions) {
            struct KeyVal0{struct member{}}
            let versionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .versions)
            if let versionsWrappedContainer = versionsWrappedContainer {
                let versionsContainer = try versionsWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyVersion].self, forKey: .member)
                var versionsBuffer:[IAMClientTypes.PolicyVersion]? = nil
                if let versionsContainer = versionsContainer {
                    versionsBuffer = [IAMClientTypes.PolicyVersion]()
                    for structureContainer0 in versionsContainer {
                        versionsBuffer?.append(structureContainer0)
                    }
                }
                versions = versionsBuffer
            } else {
                versions = []
            }
        } else {
            versions = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListPolicyVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListRolePoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("ListRolePolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListRolePoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRolePoliciesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the role to list policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.roleName = roleName
    }
}

struct ListRolePoliciesInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListRolePoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListRolePoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRolePoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policyNames = output.policyNames
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policyNames = nil
        }
    }
}

/// Contains the response to a successful [ListRolePolicies] request.
public struct ListRolePoliciesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy names.
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyNames = policyNames
    }
}

struct ListRolePoliciesOutputBody: Swift.Equatable {
    let policyNames: [Swift.String]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListRolePoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policyNames = "PolicyNames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListRolePoliciesResult"))
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyNamesBuffer:[Swift.String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [Swift.String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListRolePoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListRoleTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("ListRoleTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListRoleTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRoleTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM role for which you want to see the list of tags. This parameter accepts (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.roleName = roleName
    }
}

struct ListRoleTagsInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListRoleTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListRoleTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRoleTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListRoleTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the role. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListRoleTagsOutputBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListRoleTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListRoleTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListRoleTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListRolesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListRoles", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListRolesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRolesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example, the prefix /application_abc/component_xyz/ gets all roles whose path starts with /application_abc/component_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all roles. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

struct ListRolesInputBody: Swift.Equatable {
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListRolesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListRolesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRolesOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.roles = output.roles
        } else {
            self.isTruncated = false
            self.marker = nil
            self.roles = nil
        }
    }
}

/// Contains the response to a successful [ListRoles] request.
public struct ListRolesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of roles.
    /// This member is required.
    public var roles: [IAMClientTypes.Role]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        roles: [IAMClientTypes.Role]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.roles = roles
    }
}

struct ListRolesOutputBody: Swift.Equatable {
    let roles: [IAMClientTypes.Role]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListRolesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case roles = "Roles"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListRolesResult"))
        if containerValues.contains(.roles) {
            struct KeyVal0{struct member{}}
            let rolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .roles)
            if let rolesWrappedContainer = rolesWrappedContainer {
                let rolesContainer = try rolesWrappedContainer.decodeIfPresent([IAMClientTypes.Role].self, forKey: .member)
                var rolesBuffer:[IAMClientTypes.Role]? = nil
                if let rolesContainer = rolesContainer {
                    rolesBuffer = [IAMClientTypes.Role]()
                    for structureContainer0 in rolesContainer {
                        rolesBuffer?.append(structureContainer0)
                    }
                }
                roles = rolesBuffer
            } else {
                roles = []
            }
        } else {
            roles = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListRolesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListSAMLProviderTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        try container.encode("ListSAMLProviderTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSAMLProviderTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSAMLProviderTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The ARN of the Security Assertion Markup Language (SAML) identity provider whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        samlProviderArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.samlProviderArn = samlProviderArn
    }
}

struct ListSAMLProviderTagsInputBody: Swift.Equatable {
    let samlProviderArn: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListSAMLProviderTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case samlProviderArn = "SAMLProviderArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListSAMLProviderTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSAMLProviderTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListSAMLProviderTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the Security Assertion Markup Language (SAML) identity provider. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListSAMLProviderTagsOutputBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListSAMLProviderTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListSAMLProviderTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListSAMLProviderTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListSAMLProvidersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("ListSAMLProviders", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSAMLProvidersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSAMLProvidersInput: Swift.Equatable {

    public init() { }
}

extension ListSAMLProvidersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSAMLProvidersOutputBody = try responseDecoder.decode(responseBody: data)
            self.samlProviderList = output.samlProviderList
        } else {
            self.samlProviderList = nil
        }
    }
}

/// Contains the response to a successful [ListSAMLProviders] request.
public struct ListSAMLProvidersOutput: Swift.Equatable {
    /// The list of SAML provider resource objects defined in IAM for this Amazon Web Services account.
    public var samlProviderList: [IAMClientTypes.SAMLProviderListEntry]?

    public init(
        samlProviderList: [IAMClientTypes.SAMLProviderListEntry]? = nil
    )
    {
        self.samlProviderList = samlProviderList
    }
}

struct ListSAMLProvidersOutputBody: Swift.Equatable {
    let samlProviderList: [IAMClientTypes.SAMLProviderListEntry]?
}

extension ListSAMLProvidersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderList = "SAMLProviderList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListSAMLProvidersResult"))
        if containerValues.contains(.samlProviderList) {
            struct KeyVal0{struct member{}}
            let samlProviderListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .samlProviderList)
            if let samlProviderListWrappedContainer = samlProviderListWrappedContainer {
                let samlProviderListContainer = try samlProviderListWrappedContainer.decodeIfPresent([IAMClientTypes.SAMLProviderListEntry].self, forKey: .member)
                var samlProviderListBuffer:[IAMClientTypes.SAMLProviderListEntry]? = nil
                if let samlProviderListContainer = samlProviderListContainer {
                    samlProviderListBuffer = [IAMClientTypes.SAMLProviderListEntry]()
                    for structureContainer0 in samlProviderListContainer {
                        samlProviderListBuffer?.append(structureContainer0)
                    }
                }
                samlProviderList = samlProviderListBuffer
            } else {
                samlProviderList = []
            }
        } else {
            samlProviderList = nil
        }
    }
}

enum ListSAMLProvidersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListSSHPublicKeysInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListSSHPublicKeys", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSSHPublicKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSSHPublicKeysInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM user to list SSH public keys for. If none is specified, the UserName field is determined implicitly based on the Amazon Web Services access key used to sign the request. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

struct ListSSHPublicKeysInputBody: Swift.Equatable {
    let userName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListSSHPublicKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListSSHPublicKeysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSSHPublicKeysOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.sshPublicKeys = output.sshPublicKeys
        } else {
            self.isTruncated = false
            self.marker = nil
            self.sshPublicKeys = nil
        }
    }
}

/// Contains the response to a successful [ListSSHPublicKeys] request.
public struct ListSSHPublicKeysOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of the SSH public keys assigned to IAM user.
    public var sshPublicKeys: [IAMClientTypes.SSHPublicKeyMetadata]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        sshPublicKeys: [IAMClientTypes.SSHPublicKeyMetadata]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.sshPublicKeys = sshPublicKeys
    }
}

struct ListSSHPublicKeysOutputBody: Swift.Equatable {
    let sshPublicKeys: [IAMClientTypes.SSHPublicKeyMetadata]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListSSHPublicKeysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case sshPublicKeys = "SSHPublicKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListSSHPublicKeysResult"))
        if containerValues.contains(.sshPublicKeys) {
            struct KeyVal0{struct member{}}
            let sshPublicKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sshPublicKeys)
            if let sshPublicKeysWrappedContainer = sshPublicKeysWrappedContainer {
                let sshPublicKeysContainer = try sshPublicKeysWrappedContainer.decodeIfPresent([IAMClientTypes.SSHPublicKeyMetadata].self, forKey: .member)
                var sshPublicKeysBuffer:[IAMClientTypes.SSHPublicKeyMetadata]? = nil
                if let sshPublicKeysContainer = sshPublicKeysContainer {
                    sshPublicKeysBuffer = [IAMClientTypes.SSHPublicKeyMetadata]()
                    for structureContainer0 in sshPublicKeysContainer {
                        sshPublicKeysBuffer?.append(structureContainer0)
                    }
                }
                sshPublicKeys = sshPublicKeysBuffer
            } else {
                sshPublicKeys = []
            }
        } else {
            sshPublicKeys = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListSSHPublicKeysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListServerCertificateTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        try container.encode("ListServerCertificateTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListServerCertificateTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServerCertificateTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM server certificate whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        serverCertificateName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.serverCertificateName = serverCertificateName
    }
}

struct ListServerCertificateTagsInputBody: Swift.Equatable {
    let serverCertificateName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListServerCertificateTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case serverCertificateName = "ServerCertificateName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListServerCertificateTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServerCertificateTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListServerCertificateTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the IAM server certificate. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListServerCertificateTagsOutputBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListServerCertificateTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListServerCertificateTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListServerCertificateTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListServerCertificatesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListServerCertificates", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListServerCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServerCertificatesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example: /company/servercerts would get all server certificates for which the path starts with /company/servercerts. This parameter is optional. If it is not included, it defaults to a slash (/), listing all server certificates. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

struct ListServerCertificatesInputBody: Swift.Equatable {
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListServerCertificatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListServerCertificatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServerCertificatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.serverCertificateMetadataList = output.serverCertificateMetadataList
        } else {
            self.isTruncated = false
            self.marker = nil
            self.serverCertificateMetadataList = nil
        }
    }
}

/// Contains the response to a successful [ListServerCertificates] request.
public struct ListServerCertificatesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of server certificates.
    /// This member is required.
    public var serverCertificateMetadataList: [IAMClientTypes.ServerCertificateMetadata]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        serverCertificateMetadataList: [IAMClientTypes.ServerCertificateMetadata]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.serverCertificateMetadataList = serverCertificateMetadataList
    }
}

struct ListServerCertificatesOutputBody: Swift.Equatable {
    let serverCertificateMetadataList: [IAMClientTypes.ServerCertificateMetadata]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListServerCertificatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case serverCertificateMetadataList = "ServerCertificateMetadataList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListServerCertificatesResult"))
        if containerValues.contains(.serverCertificateMetadataList) {
            struct KeyVal0{struct member{}}
            let serverCertificateMetadataListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .serverCertificateMetadataList)
            if let serverCertificateMetadataListWrappedContainer = serverCertificateMetadataListWrappedContainer {
                let serverCertificateMetadataListContainer = try serverCertificateMetadataListWrappedContainer.decodeIfPresent([IAMClientTypes.ServerCertificateMetadata].self, forKey: .member)
                var serverCertificateMetadataListBuffer:[IAMClientTypes.ServerCertificateMetadata]? = nil
                if let serverCertificateMetadataListContainer = serverCertificateMetadataListContainer {
                    serverCertificateMetadataListBuffer = [IAMClientTypes.ServerCertificateMetadata]()
                    for structureContainer0 in serverCertificateMetadataListContainer {
                        serverCertificateMetadataListBuffer?.append(structureContainer0)
                    }
                }
                serverCertificateMetadataList = serverCertificateMetadataListBuffer
            } else {
                serverCertificateMetadataList = []
            }
        } else {
            serverCertificateMetadataList = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListServerCertificatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListServiceSpecificCredentialsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListServiceSpecificCredentials", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListServiceSpecificCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServiceSpecificCredentialsInput: Swift.Equatable {
    /// Filters the returned results to only those for the specified Amazon Web Services service. If not specified, then Amazon Web Services returns service-specific credentials for all services.
    public var serviceName: Swift.String?
    /// The name of the user whose service-specific credentials you want information about. If this value is not specified, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        serviceName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceName = serviceName
        self.userName = userName
    }
}

struct ListServiceSpecificCredentialsInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serviceName: Swift.String?
}

extension ListServiceSpecificCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName = "ServiceName"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension ListServiceSpecificCredentialsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceSpecificCredentialsOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceSpecificCredentials = output.serviceSpecificCredentials
        } else {
            self.serviceSpecificCredentials = nil
        }
    }
}

public struct ListServiceSpecificCredentialsOutput: Swift.Equatable {
    /// A list of structures that each contain details about a service-specific credential.
    public var serviceSpecificCredentials: [IAMClientTypes.ServiceSpecificCredentialMetadata]?

    public init(
        serviceSpecificCredentials: [IAMClientTypes.ServiceSpecificCredentialMetadata]? = nil
    )
    {
        self.serviceSpecificCredentials = serviceSpecificCredentials
    }
}

struct ListServiceSpecificCredentialsOutputBody: Swift.Equatable {
    let serviceSpecificCredentials: [IAMClientTypes.ServiceSpecificCredentialMetadata]?
}

extension ListServiceSpecificCredentialsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSpecificCredentials = "ServiceSpecificCredentials"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListServiceSpecificCredentialsResult"))
        if containerValues.contains(.serviceSpecificCredentials) {
            struct KeyVal0{struct member{}}
            let serviceSpecificCredentialsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .serviceSpecificCredentials)
            if let serviceSpecificCredentialsWrappedContainer = serviceSpecificCredentialsWrappedContainer {
                let serviceSpecificCredentialsContainer = try serviceSpecificCredentialsWrappedContainer.decodeIfPresent([IAMClientTypes.ServiceSpecificCredentialMetadata].self, forKey: .member)
                var serviceSpecificCredentialsBuffer:[IAMClientTypes.ServiceSpecificCredentialMetadata]? = nil
                if let serviceSpecificCredentialsContainer = serviceSpecificCredentialsContainer {
                    serviceSpecificCredentialsBuffer = [IAMClientTypes.ServiceSpecificCredentialMetadata]()
                    for structureContainer0 in serviceSpecificCredentialsContainer {
                        serviceSpecificCredentialsBuffer?.append(structureContainer0)
                    }
                }
                serviceSpecificCredentials = serviceSpecificCredentialsBuffer
            } else {
                serviceSpecificCredentials = []
            }
        } else {
            serviceSpecificCredentials = nil
        }
    }
}

enum ListServiceSpecificCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NotSupportedService": return try await ServiceNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListSigningCertificatesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListSigningCertificates", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSigningCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSigningCertificatesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM user whose signing certificates you want to examine. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

struct ListSigningCertificatesInputBody: Swift.Equatable {
    let userName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListSigningCertificatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListSigningCertificatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSigningCertificatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificates = output.certificates
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.certificates = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListSigningCertificates] request.
public struct ListSigningCertificatesOutput: Swift.Equatable {
    /// A list of the user's signing certificate information.
    /// This member is required.
    public var certificates: [IAMClientTypes.SigningCertificate]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        certificates: [IAMClientTypes.SigningCertificate]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListSigningCertificatesOutputBody: Swift.Equatable {
    let certificates: [IAMClientTypes.SigningCertificate]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListSigningCertificatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificates = "Certificates"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListSigningCertificatesResult"))
        if containerValues.contains(.certificates) {
            struct KeyVal0{struct member{}}
            let certificatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .certificates)
            if let certificatesWrappedContainer = certificatesWrappedContainer {
                let certificatesContainer = try certificatesWrappedContainer.decodeIfPresent([IAMClientTypes.SigningCertificate].self, forKey: .member)
                var certificatesBuffer:[IAMClientTypes.SigningCertificate]? = nil
                if let certificatesContainer = certificatesContainer {
                    certificatesBuffer = [IAMClientTypes.SigningCertificate]()
                    for structureContainer0 in certificatesContainer {
                        certificatesBuffer?.append(structureContainer0)
                    }
                }
                certificates = certificatesBuffer
            } else {
                certificates = []
            }
        } else {
            certificates = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListSigningCertificatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListUserPoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListUserPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListUserPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUserPoliciesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user to list policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

struct ListUserPoliciesInputBody: Swift.Equatable {
    let userName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListUserPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListUserPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUserPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policyNames = output.policyNames
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policyNames = nil
        }
    }
}

/// Contains the response to a successful [ListUserPolicies] request.
public struct ListUserPoliciesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy names.
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyNames = policyNames
    }
}

struct ListUserPoliciesOutputBody: Swift.Equatable {
    let policyNames: [Swift.String]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListUserPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policyNames = "PolicyNames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListUserPoliciesResult"))
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyNamesBuffer:[Swift.String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [Swift.String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListUserPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListUserTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListUserTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListUserTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUserTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM user whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

struct ListUserTagsInputBody: Swift.Equatable {
    let userName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListUserTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListUserTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUserTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListUserTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the user. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListUserTagsOutputBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListUserTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListUserTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListUserTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListUsersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListUsers", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example: /division_abc/subdivision_xyz/, which would get all user names whose path starts with /division_abc/subdivision_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all user names. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

struct ListUsersInputBody: Swift.Equatable {
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.users = output.users
        } else {
            self.isTruncated = false
            self.marker = nil
            self.users = nil
        }
    }
}

/// Contains the response to a successful [ListUsers] request.
public struct ListUsersOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of users.
    /// This member is required.
    public var users: [IAMClientTypes.User]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        users: [IAMClientTypes.User]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.users = users
    }
}

struct ListUsersOutputBody: Swift.Equatable {
    let users: [IAMClientTypes.User]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case users = "Users"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListUsersResult"))
        if containerValues.contains(.users) {
            struct KeyVal0{struct member{}}
            let usersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .users)
            if let usersWrappedContainer = usersWrappedContainer {
                let usersContainer = try usersWrappedContainer.decodeIfPresent([IAMClientTypes.User].self, forKey: .member)
                var usersBuffer:[IAMClientTypes.User]? = nil
                if let usersContainer = usersContainer {
                    usersBuffer = [IAMClientTypes.User]()
                    for structureContainer0 in usersContainer {
                        usersBuffer?.append(structureContainer0)
                    }
                }
                users = usersBuffer
            } else {
                users = []
            }
        } else {
            users = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListVirtualMFADevicesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let assignmentStatus = assignmentStatus {
            try container.encode(assignmentStatus, forKey: ClientRuntime.Key("AssignmentStatus"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("ListVirtualMFADevices", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListVirtualMFADevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVirtualMFADevicesInput: Swift.Equatable {
    /// The status (Unassigned or Assigned) of the devices to list. If you do not specify an AssignmentStatus, the operation defaults to Any, which lists both assigned and unassigned virtual MFA devices.,
    public var assignmentStatus: IAMClientTypes.AssignmentStatusType?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        assignmentStatus: IAMClientTypes.AssignmentStatusType? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.assignmentStatus = assignmentStatus
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListVirtualMFADevicesInputBody: Swift.Equatable {
    let assignmentStatus: IAMClientTypes.AssignmentStatusType?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListVirtualMFADevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentStatus = "AssignmentStatus"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AssignmentStatusType.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListVirtualMFADevicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVirtualMFADevicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.virtualMFADevices = output.virtualMFADevices
        } else {
            self.isTruncated = false
            self.marker = nil
            self.virtualMFADevices = nil
        }
    }
}

/// Contains the response to a successful [ListVirtualMFADevices] request.
public struct ListVirtualMFADevicesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of virtual MFA devices in the current account that match the AssignmentStatus value that was passed in the request.
    /// This member is required.
    public var virtualMFADevices: [IAMClientTypes.VirtualMFADevice]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        virtualMFADevices: [IAMClientTypes.VirtualMFADevice]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.virtualMFADevices = virtualMFADevices
    }
}

struct ListVirtualMFADevicesOutputBody: Swift.Equatable {
    let virtualMFADevices: [IAMClientTypes.VirtualMFADevice]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListVirtualMFADevicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case virtualMFADevices = "VirtualMFADevices"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListVirtualMFADevicesResult"))
        if containerValues.contains(.virtualMFADevices) {
            struct KeyVal0{struct member{}}
            let virtualMFADevicesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .virtualMFADevices)
            if let virtualMFADevicesWrappedContainer = virtualMFADevicesWrappedContainer {
                let virtualMFADevicesContainer = try virtualMFADevicesWrappedContainer.decodeIfPresent([IAMClientTypes.VirtualMFADevice].self, forKey: .member)
                var virtualMFADevicesBuffer:[IAMClientTypes.VirtualMFADevice]? = nil
                if let virtualMFADevicesContainer = virtualMFADevicesContainer {
                    virtualMFADevicesBuffer = [IAMClientTypes.VirtualMFADevice]()
                    for structureContainer0 in virtualMFADevicesContainer {
                        virtualMFADevicesBuffer?.append(structureContainer0)
                    }
                }
                virtualMFADevices = virtualMFADevicesBuffer
            } else {
                virtualMFADevices = []
            }
        } else {
            virtualMFADevices = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum ListVirtualMFADevicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension IAMClientTypes.LoginProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case passwordResetRequired = "PasswordResetRequired"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if passwordResetRequired != false {
            try container.encode(passwordResetRequired, forKey: ClientRuntime.Key("PasswordResetRequired"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let passwordResetRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .passwordResetRequired) ?? false
        passwordResetRequired = passwordResetRequiredDecoded
    }
}

extension IAMClientTypes {
    /// Contains the user name and password create date for a user. This data type is used as a response element in the [CreateLoginProfile] and [GetLoginProfile] operations.
    public struct LoginProfile: Swift.Equatable {
        /// The date when the password for the user was created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// Specifies whether the user is required to set a new password on next sign-in.
        public var passwordResetRequired: Swift.Bool
        /// The name of the user, which can be used for signing in to the Amazon Web Services Management Console.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            createDate: ClientRuntime.Date? = nil,
            passwordResetRequired: Swift.Bool = false,
            userName: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.passwordResetRequired = passwordResetRequired
            self.userName = userName
        }
    }

}

extension IAMClientTypes.MFADevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableDate = "EnableDate"
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enableDate = enableDate {
            try container.encodeTimestamp(enableDate, format: .dateTime, forKey: ClientRuntime.Key("EnableDate"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let enableDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .enableDate)
        enableDate = enableDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an MFA device. This data type is used as a response element in the [ListMFADevices] operation.
    public struct MFADevice: Swift.Equatable {
        /// The date when the MFA device was enabled for the user.
        /// This member is required.
        public var enableDate: ClientRuntime.Date?
        /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN.
        /// This member is required.
        public var serialNumber: Swift.String?
        /// The user with whom the MFA device is associated.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            enableDate: ClientRuntime.Date? = nil,
            serialNumber: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.enableDate = enableDate
            self.serialNumber = serialNumber
            self.userName = userName
        }
    }

}

extension MalformedCertificateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<MalformedCertificateExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because the certificate was malformed or expired. The error message describes the specific error.
public struct MalformedCertificateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MalformedCertificate" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MalformedCertificateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MalformedCertificateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MalformedPolicyDocumentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<MalformedPolicyDocumentExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because the policy document was malformed. The error message describes the specific error.
public struct MalformedPolicyDocumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MalformedPolicyDocument" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MalformedPolicyDocumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MalformedPolicyDocumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes.ManagedPolicyDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case attachmentCount = "AttachmentCount"
        case createDate = "CreateDate"
        case defaultVersionId = "DefaultVersionId"
        case description = "Description"
        case isAttachable = "IsAttachable"
        case path = "Path"
        case permissionsBoundaryUsageCount = "PermissionsBoundaryUsageCount"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case policyVersionList = "PolicyVersionList"
        case updateDate = "UpdateDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let attachmentCount = attachmentCount {
            try container.encode(attachmentCount, forKey: ClientRuntime.Key("AttachmentCount"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let defaultVersionId = defaultVersionId {
            try container.encode(defaultVersionId, forKey: ClientRuntime.Key("DefaultVersionId"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if isAttachable != false {
            try container.encode(isAttachable, forKey: ClientRuntime.Key("IsAttachable"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundaryUsageCount = permissionsBoundaryUsageCount {
            try container.encode(permissionsBoundaryUsageCount, forKey: ClientRuntime.Key("PermissionsBoundaryUsageCount"))
        }
        if let policyId = policyId {
            try container.encode(policyId, forKey: ClientRuntime.Key("PolicyId"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let policyVersionList = policyVersionList {
            if !policyVersionList.isEmpty {
                var policyVersionListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyVersionList"))
                for (index0, policyversion0) in policyVersionList.enumerated() {
                    try policyVersionListContainer.encode(policyversion0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyVersionListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyVersionList"))
                try policyVersionListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let updateDate = updateDate {
            try container.encodeTimestamp(updateDate, format: .dateTime, forKey: ClientRuntime.Key("UpdateDate"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let attachmentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attachmentCount)
        attachmentCount = attachmentCountDecoded
        let permissionsBoundaryUsageCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permissionsBoundaryUsageCount)
        permissionsBoundaryUsageCount = permissionsBoundaryUsageCountDecoded
        let isAttachableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAttachable) ?? false
        isAttachable = isAttachableDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let updateDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateDate)
        updateDate = updateDateDecoded
        if containerValues.contains(.policyVersionList) {
            struct KeyVal0{struct member{}}
            let policyVersionListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyVersionList)
            if let policyVersionListWrappedContainer = policyVersionListWrappedContainer {
                let policyVersionListContainer = try policyVersionListWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyVersion].self, forKey: .member)
                var policyVersionListBuffer:[IAMClientTypes.PolicyVersion]? = nil
                if let policyVersionListContainer = policyVersionListContainer {
                    policyVersionListBuffer = [IAMClientTypes.PolicyVersion]()
                    for structureContainer0 in policyVersionListContainer {
                        policyVersionListBuffer?.append(structureContainer0)
                    }
                }
                policyVersionList = policyVersionListBuffer
            } else {
                policyVersionList = []
            }
        } else {
            policyVersionList = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a managed policy, including the policy's ARN, versions, and the number of principal entities (users, groups, and roles) that the policy is attached to. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation. For more information about managed policies, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct ManagedPolicyDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The number of principal entities (users, groups, and roles) that the policy is attached to.
        public var attachmentCount: Swift.Int?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was created.
        public var createDate: ClientRuntime.Date?
        /// The identifier for the version of the policy that is set as the default (operative) version. For more information about policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
        public var defaultVersionId: Swift.String?
        /// A friendly description of the policy.
        public var description: Swift.String?
        /// Specifies whether the policy can be attached to an IAM user, group, or role.
        public var isAttachable: Swift.Bool
        /// The path to the policy. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The number of entities (users and roles) for which the policy is used as the permissions boundary. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundaryUsageCount: Swift.Int?
        /// The stable and unique string identifying the policy. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var policyId: Swift.String?
        /// The friendly name (not ARN) identifying the policy.
        public var policyName: Swift.String?
        /// A list containing information about the versions of the policy.
        public var policyVersionList: [IAMClientTypes.PolicyVersion]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was last updated. When a policy has only one version, this field contains the date and time when the policy was created. When a policy has more than one version, this field contains the date and time when the most recent policy version was created.
        public var updateDate: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            attachmentCount: Swift.Int? = nil,
            createDate: ClientRuntime.Date? = nil,
            defaultVersionId: Swift.String? = nil,
            description: Swift.String? = nil,
            isAttachable: Swift.Bool = false,
            path: Swift.String? = nil,
            permissionsBoundaryUsageCount: Swift.Int? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyVersionList: [IAMClientTypes.PolicyVersion]? = nil,
            updateDate: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.attachmentCount = attachmentCount
            self.createDate = createDate
            self.defaultVersionId = defaultVersionId
            self.description = description
            self.isAttachable = isAttachable
            self.path = path
            self.permissionsBoundaryUsageCount = permissionsBoundaryUsageCount
            self.policyId = policyId
            self.policyName = policyName
            self.policyVersionList = policyVersionList
            self.updateDate = updateDate
        }
    }

}

extension NoSuchEntityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchEntityExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because it referenced a resource entity that does not exist. The error message describes the resource.
public struct NoSuchEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchEntity" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchEntityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes.OpenIDConnectProviderListEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IAMClientTypes {
    /// Contains the Amazon Resource Name (ARN) for an IAM OpenID Connect provider.
    public struct OpenIDConnectProviderListEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension IAMClientTypes.OrganizationsDecisionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedByOrganizations = "AllowedByOrganizations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowedByOrganizations != false {
            try container.encode(allowedByOrganizations, forKey: ClientRuntime.Key("AllowedByOrganizations"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedByOrganizationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowedByOrganizations) ?? false
        allowedByOrganizations = allowedByOrganizationsDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about the effect that Organizations has on a policy simulation.
    public struct OrganizationsDecisionDetail: Swift.Equatable {
        /// Specifies whether the simulated operation is allowed by the Organizations service control policies that impact the simulated user's account.
        public var allowedByOrganizations: Swift.Bool

        public init(
            allowedByOrganizations: Swift.Bool = false
        )
        {
            self.allowedByOrganizations = allowedByOrganizations
        }
    }

}

extension IAMClientTypes.PasswordPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUsersToChangePassword = "AllowUsersToChangePassword"
        case expirePasswords = "ExpirePasswords"
        case hardExpiry = "HardExpiry"
        case maxPasswordAge = "MaxPasswordAge"
        case minimumPasswordLength = "MinimumPasswordLength"
        case passwordReusePrevention = "PasswordReusePrevention"
        case requireLowercaseCharacters = "RequireLowercaseCharacters"
        case requireNumbers = "RequireNumbers"
        case requireSymbols = "RequireSymbols"
        case requireUppercaseCharacters = "RequireUppercaseCharacters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowUsersToChangePassword != false {
            try container.encode(allowUsersToChangePassword, forKey: ClientRuntime.Key("AllowUsersToChangePassword"))
        }
        if expirePasswords != false {
            try container.encode(expirePasswords, forKey: ClientRuntime.Key("ExpirePasswords"))
        }
        if let hardExpiry = hardExpiry {
            try container.encode(hardExpiry, forKey: ClientRuntime.Key("HardExpiry"))
        }
        if let maxPasswordAge = maxPasswordAge {
            try container.encode(maxPasswordAge, forKey: ClientRuntime.Key("MaxPasswordAge"))
        }
        if let minimumPasswordLength = minimumPasswordLength {
            try container.encode(minimumPasswordLength, forKey: ClientRuntime.Key("MinimumPasswordLength"))
        }
        if let passwordReusePrevention = passwordReusePrevention {
            try container.encode(passwordReusePrevention, forKey: ClientRuntime.Key("PasswordReusePrevention"))
        }
        if requireLowercaseCharacters != false {
            try container.encode(requireLowercaseCharacters, forKey: ClientRuntime.Key("RequireLowercaseCharacters"))
        }
        if requireNumbers != false {
            try container.encode(requireNumbers, forKey: ClientRuntime.Key("RequireNumbers"))
        }
        if requireSymbols != false {
            try container.encode(requireSymbols, forKey: ClientRuntime.Key("RequireSymbols"))
        }
        if requireUppercaseCharacters != false {
            try container.encode(requireUppercaseCharacters, forKey: ClientRuntime.Key("RequireUppercaseCharacters"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumPasswordLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumPasswordLength)
        minimumPasswordLength = minimumPasswordLengthDecoded
        let requireSymbolsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireSymbols) ?? false
        requireSymbols = requireSymbolsDecoded
        let requireNumbersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireNumbers) ?? false
        requireNumbers = requireNumbersDecoded
        let requireUppercaseCharactersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireUppercaseCharacters) ?? false
        requireUppercaseCharacters = requireUppercaseCharactersDecoded
        let requireLowercaseCharactersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireLowercaseCharacters) ?? false
        requireLowercaseCharacters = requireLowercaseCharactersDecoded
        let allowUsersToChangePasswordDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowUsersToChangePassword) ?? false
        allowUsersToChangePassword = allowUsersToChangePasswordDecoded
        let expirePasswordsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .expirePasswords) ?? false
        expirePasswords = expirePasswordsDecoded
        let maxPasswordAgeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxPasswordAge)
        maxPasswordAge = maxPasswordAgeDecoded
        let passwordReusePreventionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .passwordReusePrevention)
        passwordReusePrevention = passwordReusePreventionDecoded
        let hardExpiryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hardExpiry)
        hardExpiry = hardExpiryDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about the account password policy. This data type is used as a response element in the [GetAccountPasswordPolicy] operation.
    public struct PasswordPolicy: Swift.Equatable {
        /// Specifies whether IAM users are allowed to change their own password. Gives IAM users permissions to iam:ChangePassword for only their user and to the iam:GetAccountPasswordPolicy action. This option does not attach a permissions policy to each user, rather the permissions are applied at the account-level for all users by IAM.
        public var allowUsersToChangePassword: Swift.Bool
        /// Indicates whether passwords in the account expire. Returns true if MaxPasswordAge contains a value greater than 0. Returns false if MaxPasswordAge is 0 or not present.
        public var expirePasswords: Swift.Bool
        /// Specifies whether IAM users are prevented from setting a new password via the Amazon Web Services Management Console after their password has expired. The IAM user cannot access the console until an administrator resets the password. IAM users with iam:ChangePassword permission and active access keys can reset their own expired console password using the CLI or API.
        public var hardExpiry: Swift.Bool?
        /// The number of days that an IAM user password is valid.
        public var maxPasswordAge: Swift.Int?
        /// Minimum length to require for IAM user passwords.
        public var minimumPasswordLength: Swift.Int?
        /// Specifies the number of previous passwords that IAM users are prevented from reusing.
        public var passwordReusePrevention: Swift.Int?
        /// Specifies whether IAM user passwords must contain at least one lowercase character (a to z).
        public var requireLowercaseCharacters: Swift.Bool
        /// Specifies whether IAM user passwords must contain at least one numeric character (0 to 9).
        public var requireNumbers: Swift.Bool
        /// Specifies whether IAM user passwords must contain at least one of the following symbols: ! @ # $ % ^ & * ( ) _ + - = [ ] { } | '
        public var requireSymbols: Swift.Bool
        /// Specifies whether IAM user passwords must contain at least one uppercase character (A to Z).
        public var requireUppercaseCharacters: Swift.Bool

        public init(
            allowUsersToChangePassword: Swift.Bool = false,
            expirePasswords: Swift.Bool = false,
            hardExpiry: Swift.Bool? = nil,
            maxPasswordAge: Swift.Int? = nil,
            minimumPasswordLength: Swift.Int? = nil,
            passwordReusePrevention: Swift.Int? = nil,
            requireLowercaseCharacters: Swift.Bool = false,
            requireNumbers: Swift.Bool = false,
            requireSymbols: Swift.Bool = false,
            requireUppercaseCharacters: Swift.Bool = false
        )
        {
            self.allowUsersToChangePassword = allowUsersToChangePassword
            self.expirePasswords = expirePasswords
            self.hardExpiry = hardExpiry
            self.maxPasswordAge = maxPasswordAge
            self.minimumPasswordLength = minimumPasswordLength
            self.passwordReusePrevention = passwordReusePrevention
            self.requireLowercaseCharacters = requireLowercaseCharacters
            self.requireNumbers = requireNumbers
            self.requireSymbols = requireSymbols
            self.requireUppercaseCharacters = requireUppercaseCharacters
        }
    }

}

extension PasswordPolicyViolationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<PasswordPolicyViolationExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because the provided password did not meet the requirements imposed by the account password policy.
public struct PasswordPolicyViolationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PasswordPolicyViolation" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PasswordPolicyViolationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PasswordPolicyViolationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes {
    public enum PermissionsBoundaryAttachmentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case policy
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionsBoundaryAttachmentType] {
            return [
                .policy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .policy: return "PermissionsBoundaryPolicy"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionsBoundaryAttachmentType(rawValue: rawValue) ?? PermissionsBoundaryAttachmentType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.PermissionsBoundaryDecisionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedByPermissionsBoundary = "AllowedByPermissionsBoundary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowedByPermissionsBoundary != false {
            try container.encode(allowedByPermissionsBoundary, forKey: ClientRuntime.Key("AllowedByPermissionsBoundary"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedByPermissionsBoundaryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowedByPermissionsBoundary) ?? false
        allowedByPermissionsBoundary = allowedByPermissionsBoundaryDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about the effect that a permissions boundary has on a policy simulation when the boundary is applied to an IAM entity.
    public struct PermissionsBoundaryDecisionDetail: Swift.Equatable {
        /// Specifies whether an action is allowed by a permissions boundary that is applied to an IAM entity (user or role). A value of true means that the permissions boundary does not deny the action. This means that the policy includes an Allow statement that matches the request. In this case, if an identity-based policy also allows the action, the request is allowed. A value of false means that either the requested action is not allowed (implicitly denied) or that the action is explicitly denied by the permissions boundary. In both of these cases, the action is not allowed, regardless of the identity-based policy.
        public var allowedByPermissionsBoundary: Swift.Bool

        public init(
            allowedByPermissionsBoundary: Swift.Bool = false
        )
        {
            self.allowedByPermissionsBoundary = allowedByPermissionsBoundary
        }
    }

}

extension IAMClientTypes.Policy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case attachmentCount = "AttachmentCount"
        case createDate = "CreateDate"
        case defaultVersionId = "DefaultVersionId"
        case description = "Description"
        case isAttachable = "IsAttachable"
        case path = "Path"
        case permissionsBoundaryUsageCount = "PermissionsBoundaryUsageCount"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case tags = "Tags"
        case updateDate = "UpdateDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let attachmentCount = attachmentCount {
            try container.encode(attachmentCount, forKey: ClientRuntime.Key("AttachmentCount"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let defaultVersionId = defaultVersionId {
            try container.encode(defaultVersionId, forKey: ClientRuntime.Key("DefaultVersionId"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if isAttachable != false {
            try container.encode(isAttachable, forKey: ClientRuntime.Key("IsAttachable"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundaryUsageCount = permissionsBoundaryUsageCount {
            try container.encode(permissionsBoundaryUsageCount, forKey: ClientRuntime.Key("PermissionsBoundaryUsageCount"))
        }
        if let policyId = policyId {
            try container.encode(policyId, forKey: ClientRuntime.Key("PolicyId"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let updateDate = updateDate {
            try container.encodeTimestamp(updateDate, format: .dateTime, forKey: ClientRuntime.Key("UpdateDate"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let attachmentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attachmentCount)
        attachmentCount = attachmentCountDecoded
        let permissionsBoundaryUsageCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permissionsBoundaryUsageCount)
        permissionsBoundaryUsageCount = permissionsBoundaryUsageCountDecoded
        let isAttachableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAttachable) ?? false
        isAttachable = isAttachableDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let updateDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateDate)
        updateDate = updateDateDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a managed policy. This data type is used as a response element in the [CreatePolicy], [GetPolicy], and [ListPolicies] operations. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct Policy: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The number of entities (users, groups, and roles) that the policy is attached to.
        public var attachmentCount: Swift.Int?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was created.
        public var createDate: ClientRuntime.Date?
        /// The identifier for the version of the policy that is set as the default version.
        public var defaultVersionId: Swift.String?
        /// A friendly description of the policy. This element is included in the response to the [GetPolicy] operation. It is not included in the response to the [ListPolicies] operation.
        public var description: Swift.String?
        /// Specifies whether the policy can be attached to an IAM user, group, or role.
        public var isAttachable: Swift.Bool
        /// The path to the policy. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The number of entities (users and roles) for which the policy is used to set the permissions boundary. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundaryUsageCount: Swift.Int?
        /// The stable and unique string identifying the policy. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var policyId: Swift.String?
        /// The friendly name (not ARN) identifying the policy.
        public var policyName: Swift.String?
        /// A list of tags that are attached to the instance profile. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was last updated. When a policy has only one version, this field contains the date and time when the policy was created. When a policy has more than one version, this field contains the date and time when the most recent policy version was created.
        public var updateDate: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            attachmentCount: Swift.Int? = nil,
            createDate: ClientRuntime.Date? = nil,
            defaultVersionId: Swift.String? = nil,
            description: Swift.String? = nil,
            isAttachable: Swift.Bool = false,
            path: Swift.String? = nil,
            permissionsBoundaryUsageCount: Swift.Int? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            updateDate: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.attachmentCount = attachmentCount
            self.createDate = createDate
            self.defaultVersionId = defaultVersionId
            self.description = description
            self.isAttachable = isAttachable
            self.path = path
            self.permissionsBoundaryUsageCount = permissionsBoundaryUsageCount
            self.policyId = policyId
            self.policyName = policyName
            self.tags = tags
            self.updateDate = updateDate
        }
    }

}

extension IAMClientTypes.PolicyDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM policy, including the policy document. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct PolicyDetail: Swift.Equatable {
        /// The policy document.
        public var policyDocument: Swift.String?
        /// The name of the policy.
        public var policyName: Swift.String?

        public init(
            policyDocument: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.policyDocument = policyDocument
            self.policyName = policyName
        }
    }

}

extension IAMClientTypes {
    public enum PolicyEvaluationDecisionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allowed
        case explicitDeny
        case implicitDeny
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyEvaluationDecisionType] {
            return [
                .allowed,
                .explicitDeny,
                .implicitDeny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allowed: return "allowed"
            case .explicitDeny: return "explicitDeny"
            case .implicitDeny: return "implicitDeny"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyEvaluationDecisionType(rawValue: rawValue) ?? PolicyEvaluationDecisionType.sdkUnknown(rawValue)
        }
    }
}

extension PolicyEvaluationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<PolicyEvaluationExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because a provided policy could not be successfully evaluated. An additional detailed message indicates the source of the failure.
public struct PolicyEvaluationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyEvaluation" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PolicyEvaluationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PolicyEvaluationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes.PolicyGrantingServiceAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityName = "EntityName"
        case entityType = "EntityType"
        case policyArn = "PolicyArn"
        case policyName = "PolicyName"
        case policyType = "PolicyType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let entityName = entityName {
            try container.encode(entityName, forKey: ClientRuntime.Key("EntityName"))
        }
        if let entityType = entityType {
            try container.encode(entityType, forKey: ClientRuntime.Key("EntityType"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let policyType = policyType {
            try container.encode(policyType, forKey: ClientRuntime.Key("PolicyType"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyType.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyOwnerEntityType.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
    }
}

extension IAMClientTypes {
    /// Contains details about the permissions policies that are attached to the specified identity (user, group, or role). This data type is an element of the [ListPoliciesGrantingServiceAccessEntry] object.
    public struct PolicyGrantingServiceAccess: Swift.Equatable {
        /// The name of the entity (user or role) to which the inline policy is attached. This field is null for managed policies. For more information about these policy types, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html) in the IAM User Guide.
        public var entityName: Swift.String?
        /// The type of entity (user or role) that used the policy to access the service to which the inline policy is attached. This field is null for managed policies. For more information about these policy types, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html) in the IAM User Guide.
        public var entityType: IAMClientTypes.PolicyOwnerEntityType?
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var policyArn: Swift.String?
        /// The policy name.
        /// This member is required.
        public var policyName: Swift.String?
        /// The policy type. For more information about these policy types, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html) in the IAM User Guide.
        /// This member is required.
        public var policyType: IAMClientTypes.PolicyType?

        public init(
            entityName: Swift.String? = nil,
            entityType: IAMClientTypes.PolicyOwnerEntityType? = nil,
            policyArn: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyType: IAMClientTypes.PolicyType? = nil
        )
        {
            self.entityName = entityName
            self.entityType = entityType
            self.policyArn = policyArn
            self.policyName = policyName
            self.policyType = policyType
        }
    }

}

extension IAMClientTypes.PolicyGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupId = groupId {
            try container.encode(groupId, forKey: ClientRuntime.Key("GroupId"))
        }
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about a group that a managed policy is attached to. This data type is used as a response element in the [ListEntitiesForPolicy] operation. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyGroup: Swift.Equatable {
        /// The stable and unique string identifying the group. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        public var groupId: Swift.String?
        /// The name (friendly name, not ARN) identifying the group.
        public var groupName: Swift.String?

        public init(
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }

}

extension PolicyNotAttachableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<PolicyNotAttachableExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because Amazon Web Services service role policies can only be attached to the service-linked role for that service.
public struct PolicyNotAttachableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyNotAttachable" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PolicyNotAttachableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PolicyNotAttachableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes {
    public enum PolicyOwnerEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case role
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyOwnerEntityType] {
            return [
                .group,
                .role,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .role: return "ROLE"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyOwnerEntityType(rawValue: rawValue) ?? PolicyOwnerEntityType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.PolicyRole: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleId = "RoleId"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleId = roleId {
            try container.encode(roleId, forKey: ClientRuntime.Key("RoleId"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleId)
        roleId = roleIdDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about a role that a managed policy is attached to. This data type is used as a response element in the [ListEntitiesForPolicy] operation. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyRole: Swift.Equatable {
        /// The stable and unique string identifying the role. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        public var roleId: Swift.String?
        /// The name (friendly name, not ARN) identifying the role.
        public var roleName: Swift.String?

        public init(
            roleId: Swift.String? = nil,
            roleName: Swift.String? = nil
        )
        {
            self.roleId = roleId
            self.roleName = roleName
        }
    }

}

extension IAMClientTypes {
    public enum PolicyScopeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aws
        case all
        case local
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyScopeType] {
            return [
                .aws,
                .all,
                .local,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .all: return "All"
            case .local: return "Local"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyScopeType(rawValue: rawValue) ?? PolicyScopeType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes {
    public enum PolicySourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsManaged
        case group
        case `none`
        case resource
        case role
        case user
        case userManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicySourceType] {
            return [
                .awsManaged,
                .group,
                .none,
                .resource,
                .role,
                .user,
                .userManaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsManaged: return "aws-managed"
            case .group: return "group"
            case .none: return "none"
            case .resource: return "resource"
            case .role: return "role"
            case .user: return "user"
            case .userManaged: return "user-managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicySourceType(rawValue: rawValue) ?? PolicySourceType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes {
    public enum PolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inline
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyType] {
            return [
                .inline,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inline: return "INLINE"
            case .managed: return "MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyType(rawValue: rawValue) ?? PolicyType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes {
    /// The policy usage type that indicates whether the policy is used as a permissions policy or as the permissions boundary for an entity. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
    public enum PolicyUsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case permissionsboundary
        case permissionspolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyUsageType] {
            return [
                .permissionsboundary,
                .permissionspolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .permissionsboundary: return "PermissionsBoundary"
            case .permissionspolicy: return "PermissionsPolicy"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyUsageType(rawValue: rawValue) ?? PolicyUsageType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.PolicyUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId = "UserId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userId = userId {
            try container.encode(userId, forKey: ClientRuntime.Key("UserId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about a user that a managed policy is attached to. This data type is used as a response element in the [ListEntitiesForPolicy] operation. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyUser: Swift.Equatable {
        /// The stable and unique string identifying the user. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        public var userId: Swift.String?
        /// The name (friendly name, not ARN) identifying the user.
        public var userName: Swift.String?

        public init(
            userId: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.userId = userId
            self.userName = userName
        }
    }

}

extension IAMClientTypes.PolicyVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case document = "Document"
        case isDefaultVersion = "IsDefaultVersion"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let document = document {
            try container.encode(document, forKey: ClientRuntime.Key("Document"))
        }
        if isDefaultVersion != false {
            try container.encode(isDefaultVersion, forKey: ClientRuntime.Key("IsDefaultVersion"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let isDefaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefaultVersion) ?? false
        isDefaultVersion = isDefaultVersionDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about a version of a managed policy. This data type is used as a response element in the [CreatePolicyVersion], [GetPolicyVersion], [ListPolicyVersions], and [GetAccountAuthorizationDetails] operations. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyVersion: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy version was created.
        public var createDate: ClientRuntime.Date?
        /// The policy document. The policy document is returned in the response to the [GetPolicyVersion] and [GetAccountAuthorizationDetails] operations. It is not returned in the response to the [CreatePolicyVersion] or [ListPolicyVersions] operations. The policy document returned in this structure is URL-encoded compliant with [RFC 3986](https://tools.ietf.org/html/rfc3986). You can use a URL decoding method to convert the policy back to plain JSON text. For example, if you use Java, you can use the decode method of the java.net.URLDecoder utility class in the Java SDK. Other languages and SDKs provide similar functionality.
        public var document: Swift.String?
        /// Specifies whether the policy version is set as the policy's default version.
        public var isDefaultVersion: Swift.Bool
        /// The identifier for the policy version. Policy version identifiers always begin with v (always lowercase). When a policy is created, the first policy version is v1.
        public var versionId: Swift.String?

        public init(
            createDate: ClientRuntime.Date? = nil,
            document: Swift.String? = nil,
            isDefaultVersion: Swift.Bool = false,
            versionId: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.document = document
            self.isDefaultVersion = isDefaultVersion
            self.versionId = versionId
        }
    }

}

extension IAMClientTypes.Position: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column = "Column"
        case line = "Line"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if column != 0 {
            try container.encode(column, forKey: ClientRuntime.Key("Column"))
        }
        if line != 0 {
            try container.encode(line, forKey: ClientRuntime.Key("Line"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .line) ?? 0
        line = lineDecoded
        let columnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .column) ?? 0
        column = columnDecoded
    }
}

extension IAMClientTypes {
    /// Contains the row and column of a location of a Statement element in a policy document. This data type is used as a member of the [Statement] type.
    public struct Position: Swift.Equatable {
        /// The column in the line containing the specified position in the document.
        public var column: Swift.Int
        /// The line containing the specified position in the document.
        public var line: Swift.Int

        public init(
            column: Swift.Int = 0,
            line: Swift.Int = 0
        )
        {
            self.column = column
            self.line = line
        }
    }

}

extension PutGroupPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        try container.encode("PutGroupPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutGroupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutGroupPolicyInput: Swift.Equatable {
    /// The name of the group to associate the policy with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-.
    /// This member is required.
    public var groupName: Swift.String?
    /// The policy document. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy document. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyDocument = policyDocument
        self.policyName = policyName
    }
}

struct PutGroupPolicyInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let policyName: Swift.String?
    let policyDocument: Swift.String?
}

extension PutGroupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutGroupPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutGroupPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutGroupPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutRolePermissionsBoundaryInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("PutRolePermissionsBoundary", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutRolePermissionsBoundaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRolePermissionsBoundaryInput: Swift.Equatable {
    /// The ARN of the managed policy that is used to set the permissions boundary for the role. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    /// This member is required.
    public var permissionsBoundary: Swift.String?
    /// The name (friendly name, not ARN) of the IAM role for which you want to set the permissions boundary.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        permissionsBoundary: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.permissionsBoundary = permissionsBoundary
        self.roleName = roleName
    }
}

struct PutRolePermissionsBoundaryInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let permissionsBoundary: Swift.String?
}

extension PutRolePermissionsBoundaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionsBoundary = "PermissionsBoundary"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
    }
}

extension PutRolePermissionsBoundaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutRolePermissionsBoundaryOutput: Swift.Equatable {

    public init() { }
}

enum PutRolePermissionsBoundaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PolicyNotAttachable": return try await PolicyNotAttachableException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnmodifiableEntity": return try await UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutRolePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("PutRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutRolePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRolePolicyInput: Swift.Equatable {
    /// The policy document. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy document. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the role to associate the policy with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.roleName = roleName
    }
}

struct PutRolePolicyInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let policyName: Swift.String?
    let policyDocument: Swift.String?
}

extension PutRolePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutRolePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutRolePolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutRolePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnmodifiableEntity": return try await UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutUserPermissionsBoundaryInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("PutUserPermissionsBoundary", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutUserPermissionsBoundaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutUserPermissionsBoundaryInput: Swift.Equatable {
    /// The ARN of the managed policy that is used to set the permissions boundary for the user. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    /// This member is required.
    public var permissionsBoundary: Swift.String?
    /// The name (friendly name, not ARN) of the IAM user for which you want to set the permissions boundary.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        permissionsBoundary: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.permissionsBoundary = permissionsBoundary
        self.userName = userName
    }
}

struct PutUserPermissionsBoundaryInputBody: Swift.Equatable {
    let userName: Swift.String?
    let permissionsBoundary: Swift.String?
}

extension PutUserPermissionsBoundaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionsBoundary = "PermissionsBoundary"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
    }
}

extension PutUserPermissionsBoundaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutUserPermissionsBoundaryOutput: Swift.Equatable {

    public init() { }
}

enum PutUserPermissionsBoundaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PolicyNotAttachable": return try await PolicyNotAttachableException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutUserPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("PutUserPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutUserPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutUserPolicyInput: Swift.Equatable {
    /// The policy document. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy document. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the user to associate the policy with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.userName = userName
    }
}

struct PutUserPolicyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let policyName: Swift.String?
    let policyDocument: Swift.String?
}

extension PutUserPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutUserPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutUserPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutUserPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension RemoveClientIDFromOpenIDConnectProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clientID = clientID {
            try container.encode(clientID, forKey: ClientRuntime.Key("ClientID"))
        }
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        try container.encode("RemoveClientIDFromOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveClientIDFromOpenIDConnectProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveClientIDFromOpenIDConnectProviderInput: Swift.Equatable {
    /// The client ID (also known as audience) to remove from the IAM OIDC provider resource. For more information about client IDs, see [CreateOpenIDConnectProvider].
    /// This member is required.
    public var clientID: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM OIDC provider resource to remove the client ID from. You can get a list of OIDC provider ARNs by using the [ListOpenIDConnectProviders] operation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init(
        clientID: Swift.String? = nil,
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.clientID = clientID
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

struct RemoveClientIDFromOpenIDConnectProviderInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
    let clientID: Swift.String?
}

extension RemoveClientIDFromOpenIDConnectProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientID = "ClientID"
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
        let clientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientID)
        clientID = clientIDDecoded
    }
}

extension RemoveClientIDFromOpenIDConnectProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveClientIDFromOpenIDConnectProviderOutput: Swift.Equatable {

    public init() { }
}

enum RemoveClientIDFromOpenIDConnectProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension RemoveRoleFromInstanceProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("RemoveRoleFromInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveRoleFromInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveRoleFromInstanceProfileInput: Swift.Equatable {
    /// The name of the instance profile to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The name of the role to remove. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        instanceProfileName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.roleName = roleName
    }
}

struct RemoveRoleFromInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
    let roleName: Swift.String?
}

extension RemoveRoleFromInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension RemoveRoleFromInstanceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveRoleFromInstanceProfileOutput: Swift.Equatable {

    public init() { }
}

enum RemoveRoleFromInstanceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnmodifiableEntity": return try await UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension RemoveUserFromGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("RemoveUserFromGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveUserFromGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveUserFromGroupInput: Swift.Equatable {
    /// The name of the group to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the user to remove. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.userName = userName
    }
}

struct RemoveUserFromGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let userName: Swift.String?
}

extension RemoveUserFromGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension RemoveUserFromGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveUserFromGroupOutput: Swift.Equatable {

    public init() { }
}

enum RemoveUserFromGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension IAMClientTypes {
    public enum ReportFormatType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case textCsv
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFormatType] {
            return [
                .textCsv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .textCsv: return "text/csv"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFormatType(rawValue: rawValue) ?? ReportFormatType.sdkUnknown(rawValue)
        }
    }
}

extension ReportGenerationLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ReportGenerationLimitExceededExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because the maximum number of concurrent requests for this account are already running.
public struct ReportGenerationLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReportGenerationLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReportGenerationLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReportGenerationLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes {
    public enum ReportStateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case inprogress
        case started
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportStateType] {
            return [
                .complete,
                .inprogress,
                .started,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .inprogress: return "INPROGRESS"
            case .started: return "STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportStateType(rawValue: rawValue) ?? ReportStateType.sdkUnknown(rawValue)
        }
    }
}

extension ResetServiceSpecificCredentialInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: ClientRuntime.Key("ServiceSpecificCredentialId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ResetServiceSpecificCredential", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ResetServiceSpecificCredentialInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResetServiceSpecificCredentialInput: Swift.Equatable {
    /// The unique identifier of the service-specific credential. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var serviceSpecificCredentialId: Swift.String?
    /// The name of the IAM user associated with the service-specific credential. If this value is not specified, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        serviceSpecificCredentialId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.userName = userName
    }
}

struct ResetServiceSpecificCredentialInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serviceSpecificCredentialId: Swift.String?
}

extension ResetServiceSpecificCredentialInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serviceSpecificCredentialIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceSpecificCredentialId)
        serviceSpecificCredentialId = serviceSpecificCredentialIdDecoded
    }
}

extension ResetServiceSpecificCredentialOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResetServiceSpecificCredentialOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceSpecificCredential = output.serviceSpecificCredential
        } else {
            self.serviceSpecificCredential = nil
        }
    }
}

public struct ResetServiceSpecificCredentialOutput: Swift.Equatable {
    /// A structure with details about the updated service-specific credential, including the new password. This is the only time that you can access the password. You cannot recover the password later, but you can reset it again.
    public var serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential?

    public init(
        serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential? = nil
    )
    {
        self.serviceSpecificCredential = serviceSpecificCredential
    }
}

struct ResetServiceSpecificCredentialOutputBody: Swift.Equatable {
    let serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential?
}

extension ResetServiceSpecificCredentialOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSpecificCredential = "ServiceSpecificCredential"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ResetServiceSpecificCredentialResult"))
        let serviceSpecificCredentialDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ServiceSpecificCredential.self, forKey: .serviceSpecificCredential)
        serviceSpecificCredential = serviceSpecificCredentialDecoded
    }
}

enum ResetServiceSpecificCredentialOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension IAMClientTypes.ResourceSpecificResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evalDecisionDetails = "EvalDecisionDetails"
        case evalResourceDecision = "EvalResourceDecision"
        case evalResourceName = "EvalResourceName"
        case matchedStatements = "MatchedStatements"
        case missingContextValues = "MissingContextValues"
        case permissionsBoundaryDecisionDetail = "PermissionsBoundaryDecisionDetail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let evalDecisionDetails = evalDecisionDetails {
            var evalDecisionDetailsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EvalDecisionDetails"))
            for (index0, element0) in evalDecisionDetails.sorted(by: { $0.key < $1.key }).enumerated() {
                let evaldecisionsourcetypeKey0 = element0.key
                let policyevaluationdecisiontypeValue0 = element0.value
                var entryContainer0 = evalDecisionDetailsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(evaldecisionsourcetypeKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(policyevaluationdecisiontypeValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let evalResourceDecision = evalResourceDecision {
            try container.encode(evalResourceDecision, forKey: ClientRuntime.Key("EvalResourceDecision"))
        }
        if let evalResourceName = evalResourceName {
            try container.encode(evalResourceName, forKey: ClientRuntime.Key("EvalResourceName"))
        }
        if let matchedStatements = matchedStatements {
            if !matchedStatements.isEmpty {
                var matchedStatementsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MatchedStatements"))
                for (index0, statement0) in matchedStatements.enumerated() {
                    try matchedStatementsContainer.encode(statement0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var matchedStatementsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MatchedStatements"))
                try matchedStatementsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let missingContextValues = missingContextValues {
            if !missingContextValues.isEmpty {
                var missingContextValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MissingContextValues"))
                for (index0, contextkeynametype0) in missingContextValues.enumerated() {
                    try missingContextValuesContainer.encode(contextkeynametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var missingContextValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MissingContextValues"))
                try missingContextValuesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail {
            try container.encode(permissionsBoundaryDecisionDetail, forKey: ClientRuntime.Key("PermissionsBoundaryDecisionDetail"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evalResourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evalResourceName)
        evalResourceName = evalResourceNameDecoded
        let evalResourceDecisionDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyEvaluationDecisionType.self, forKey: .evalResourceDecision)
        evalResourceDecision = evalResourceDecisionDecoded
        if containerValues.contains(.matchedStatements) {
            struct KeyVal0{struct member{}}
            let matchedStatementsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .matchedStatements)
            if let matchedStatementsWrappedContainer = matchedStatementsWrappedContainer {
                let matchedStatementsContainer = try matchedStatementsWrappedContainer.decodeIfPresent([IAMClientTypes.Statement].self, forKey: .member)
                var matchedStatementsBuffer:[IAMClientTypes.Statement]? = nil
                if let matchedStatementsContainer = matchedStatementsContainer {
                    matchedStatementsBuffer = [IAMClientTypes.Statement]()
                    for structureContainer0 in matchedStatementsContainer {
                        matchedStatementsBuffer?.append(structureContainer0)
                    }
                }
                matchedStatements = matchedStatementsBuffer
            } else {
                matchedStatements = []
            }
        } else {
            matchedStatements = nil
        }
        if containerValues.contains(.missingContextValues) {
            struct KeyVal0{struct member{}}
            let missingContextValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .missingContextValues)
            if let missingContextValuesWrappedContainer = missingContextValuesWrappedContainer {
                let missingContextValuesContainer = try missingContextValuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var missingContextValuesBuffer:[Swift.String]? = nil
                if let missingContextValuesContainer = missingContextValuesContainer {
                    missingContextValuesBuffer = [Swift.String]()
                    for stringContainer0 in missingContextValuesContainer {
                        missingContextValuesBuffer?.append(stringContainer0)
                    }
                }
                missingContextValues = missingContextValuesBuffer
            } else {
                missingContextValues = []
            }
        } else {
            missingContextValues = nil
        }
        if containerValues.contains(.evalDecisionDetails) {
            struct KeyVal0{struct key{}; struct value{}}
            let evalDecisionDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, IAMClientTypes.PolicyEvaluationDecisionType, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .evalDecisionDetails)
            if let evalDecisionDetailsWrappedContainer = evalDecisionDetailsWrappedContainer {
                let evalDecisionDetailsContainer = try evalDecisionDetailsWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, IAMClientTypes.PolicyEvaluationDecisionType, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var evalDecisionDetailsBuffer: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]? = nil
                if let evalDecisionDetailsContainer = evalDecisionDetailsContainer {
                    evalDecisionDetailsBuffer = [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]()
                    for enumContainer0 in evalDecisionDetailsContainer {
                        evalDecisionDetailsBuffer?[enumContainer0.key] = enumContainer0.value
                    }
                }
                evalDecisionDetails = evalDecisionDetailsBuffer
            } else {
                evalDecisionDetails = [:]
            }
        } else {
            evalDecisionDetails = nil
        }
        let permissionsBoundaryDecisionDetailDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PermissionsBoundaryDecisionDetail.self, forKey: .permissionsBoundaryDecisionDetail)
        permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetailDecoded
    }
}

extension IAMClientTypes {
    /// Contains the result of the simulation of a single API operation call on a single resource. This data type is used by a member of the [EvaluationResult] data type.
    public struct ResourceSpecificResult: Swift.Equatable {
        /// Additional details about the results of the evaluation decision on a single resource. This parameter is returned only for cross-account simulations. This parameter explains how each policy type contributes to the resource-specific evaluation decision.
        public var evalDecisionDetails: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]?
        /// The result of the simulation of the simulated API operation on the resource specified in EvalResourceName.
        /// This member is required.
        public var evalResourceDecision: IAMClientTypes.PolicyEvaluationDecisionType?
        /// The name of the simulated resource, in Amazon Resource Name (ARN) format.
        /// This member is required.
        public var evalResourceName: Swift.String?
        /// A list of the statements in the input policies that determine the result for this part of the simulation. Remember that even if multiple statements allow the operation on the resource, if any statement denies that operation, then the explicit deny overrides any allow. In addition, the deny statement is the only entry included in the result.
        public var matchedStatements: [IAMClientTypes.Statement]?
        /// A list of context keys that are required by the included input policies but that were not provided by one of the input parameters. This list is used when a list of ARNs is included in the ResourceArns parameter instead of "*". If you do not specify individual resources, by setting ResourceArns to "*" or by not including the ResourceArns parameter, then any missing context values are instead included under the EvaluationResults section. To discover the context keys used by a set of policies, you can call [GetContextKeysForCustomPolicy] or [GetContextKeysForPrincipalPolicy].
        public var missingContextValues: [Swift.String]?
        /// Contains information about the effect that a permissions boundary has on a policy simulation when that boundary is applied to an IAM entity.
        public var permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail?

        public init(
            evalDecisionDetails: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]? = nil,
            evalResourceDecision: IAMClientTypes.PolicyEvaluationDecisionType? = nil,
            evalResourceName: Swift.String? = nil,
            matchedStatements: [IAMClientTypes.Statement]? = nil,
            missingContextValues: [Swift.String]? = nil,
            permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail? = nil
        )
        {
            self.evalDecisionDetails = evalDecisionDetails
            self.evalResourceDecision = evalResourceDecision
            self.evalResourceName = evalResourceName
            self.matchedStatements = matchedStatements
            self.missingContextValues = missingContextValues
            self.permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail
        }
    }

}

extension ResyncMFADeviceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authenticationCode1 = authenticationCode1 {
            try container.encode(authenticationCode1, forKey: ClientRuntime.Key("AuthenticationCode1"))
        }
        if let authenticationCode2 = authenticationCode2 {
            try container.encode(authenticationCode2, forKey: ClientRuntime.Key("AuthenticationCode2"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ResyncMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ResyncMFADeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResyncMFADeviceInput: Swift.Equatable {
    /// An authentication code emitted by the device. The format for this parameter is a sequence of six digits.
    /// This member is required.
    public var authenticationCode1: Swift.String?
    /// A subsequent authentication code emitted by the device. The format for this parameter is a sequence of six digits.
    /// This member is required.
    public var authenticationCode2: Swift.String?
    /// Serial number that uniquely identifies the MFA device. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The name of the user whose MFA device you want to resynchronize. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        authenticationCode1: Swift.String? = nil,
        authenticationCode2: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationCode1 = authenticationCode1
        self.authenticationCode2 = authenticationCode2
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

struct ResyncMFADeviceInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serialNumber: Swift.String?
    let authenticationCode1: Swift.String?
    let authenticationCode2: Swift.String?
}

extension ResyncMFADeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationCode1 = "AuthenticationCode1"
        case authenticationCode2 = "AuthenticationCode2"
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let authenticationCode1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authenticationCode1)
        authenticationCode1 = authenticationCode1Decoded
        let authenticationCode2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authenticationCode2)
        authenticationCode2 = authenticationCode2Decoded
    }
}

extension ResyncMFADeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ResyncMFADeviceOutput: Swift.Equatable {

    public init() { }
}

enum ResyncMFADeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidAuthenticationCode": return try await InvalidAuthenticationCodeException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension IAMClientTypes.Role: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
        case createDate = "CreateDate"
        case description = "Description"
        case maxSessionDuration = "MaxSessionDuration"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case roleId = "RoleId"
        case roleLastUsed = "RoleLastUsed"
        case roleName = "RoleName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let assumeRolePolicyDocument = assumeRolePolicyDocument {
            try container.encode(assumeRolePolicyDocument, forKey: ClientRuntime.Key("AssumeRolePolicyDocument"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let maxSessionDuration = maxSessionDuration {
            try container.encode(maxSessionDuration, forKey: ClientRuntime.Key("MaxSessionDuration"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let roleId = roleId {
            try container.encode(roleId, forKey: ClientRuntime.Key("RoleId"))
        }
        if let roleLastUsed = roleLastUsed {
            try container.encode(roleLastUsed, forKey: ClientRuntime.Key("RoleLastUsed"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleId)
        roleId = roleIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let assumeRolePolicyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assumeRolePolicyDocument)
        assumeRolePolicyDocument = assumeRolePolicyDocumentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let maxSessionDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSessionDuration)
        maxSessionDuration = maxSessionDurationDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AttachedPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let roleLastUsedDecoded = try containerValues.decodeIfPresent(IAMClientTypes.RoleLastUsed.self, forKey: .roleLastUsed)
        roleLastUsed = roleLastUsedDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM role. This structure is returned as a response element in several API operations that interact with roles.
    public struct Role: Swift.Equatable {
        /// The Amazon Resource Name (ARN) specifying the role. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The policy that grants an entity permission to assume the role.
        public var assumeRolePolicyDocument: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the role was created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// A description of the role that you provide.
        public var description: Swift.String?
        /// The maximum session duration (in seconds) for the specified role. Anyone who uses the CLI, or API to assume the role can specify the duration using the optional DurationSeconds API parameter or duration-seconds CLI parameter.
        public var maxSessionDuration: Swift.Int?
        /// The path to the role. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?
        /// The ARN of the policy used to set the permissions boundary for the role. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// The stable and unique string identifying the role. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var roleId: Swift.String?
        /// Contains information about the last time that an IAM role was used. This includes the date and time and the Region in which the role was last used. Activity is only reported for the trailing 400 days. This period can be shorter if your Region began supporting these features within the last year. The role might have been used more than 400 days ago. For more information, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM user Guide.
        public var roleLastUsed: IAMClientTypes.RoleLastUsed?
        /// The friendly name that identifies the role.
        /// This member is required.
        public var roleName: Swift.String?
        /// A list of tags that are attached to the role. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init(
            arn: Swift.String? = nil,
            assumeRolePolicyDocument: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            maxSessionDuration: Swift.Int? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            roleId: Swift.String? = nil,
            roleLastUsed: IAMClientTypes.RoleLastUsed? = nil,
            roleName: Swift.String? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.arn = arn
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.createDate = createDate
            self.description = description
            self.maxSessionDuration = maxSessionDuration
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.roleId = roleId
            self.roleLastUsed = roleLastUsed
            self.roleName = roleName
            self.tags = tags
        }
    }

}

extension IAMClientTypes.RoleDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case instanceProfileList = "InstanceProfileList"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case roleId = "RoleId"
        case roleLastUsed = "RoleLastUsed"
        case roleName = "RoleName"
        case rolePolicyList = "RolePolicyList"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let assumeRolePolicyDocument = assumeRolePolicyDocument {
            try container.encode(assumeRolePolicyDocument, forKey: ClientRuntime.Key("AssumeRolePolicyDocument"))
        }
        if let attachedManagedPolicies = attachedManagedPolicies {
            if !attachedManagedPolicies.isEmpty {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                for (index0, attachedpolicy0) in attachedManagedPolicies.enumerated() {
                    try attachedManagedPoliciesContainer.encode(attachedpolicy0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                try attachedManagedPoliciesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let instanceProfileList = instanceProfileList {
            if !instanceProfileList.isEmpty {
                var instanceProfileListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("InstanceProfileList"))
                for (index0, instanceprofile0) in instanceProfileList.enumerated() {
                    try instanceProfileListContainer.encode(instanceprofile0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var instanceProfileListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("InstanceProfileList"))
                try instanceProfileListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let roleId = roleId {
            try container.encode(roleId, forKey: ClientRuntime.Key("RoleId"))
        }
        if let roleLastUsed = roleLastUsed {
            try container.encode(roleLastUsed, forKey: ClientRuntime.Key("RoleLastUsed"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        if let rolePolicyList = rolePolicyList {
            if !rolePolicyList.isEmpty {
                var rolePolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RolePolicyList"))
                for (index0, policydetail0) in rolePolicyList.enumerated() {
                    try rolePolicyListContainer.encode(policydetail0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var rolePolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RolePolicyList"))
                try rolePolicyListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleId)
        roleId = roleIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let assumeRolePolicyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assumeRolePolicyDocument)
        assumeRolePolicyDocument = assumeRolePolicyDocumentDecoded
        if containerValues.contains(.instanceProfileList) {
            struct KeyVal0{struct member{}}
            let instanceProfileListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instanceProfileList)
            if let instanceProfileListWrappedContainer = instanceProfileListWrappedContainer {
                let instanceProfileListContainer = try instanceProfileListWrappedContainer.decodeIfPresent([IAMClientTypes.InstanceProfile].self, forKey: .member)
                var instanceProfileListBuffer:[IAMClientTypes.InstanceProfile]? = nil
                if let instanceProfileListContainer = instanceProfileListContainer {
                    instanceProfileListBuffer = [IAMClientTypes.InstanceProfile]()
                    for structureContainer0 in instanceProfileListContainer {
                        instanceProfileListBuffer?.append(structureContainer0)
                    }
                }
                instanceProfileList = instanceProfileListBuffer
            } else {
                instanceProfileList = []
            }
        } else {
            instanceProfileList = nil
        }
        if containerValues.contains(.rolePolicyList) {
            struct KeyVal0{struct member{}}
            let rolePolicyListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .rolePolicyList)
            if let rolePolicyListWrappedContainer = rolePolicyListWrappedContainer {
                let rolePolicyListContainer = try rolePolicyListWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyDetail].self, forKey: .member)
                var rolePolicyListBuffer:[IAMClientTypes.PolicyDetail]? = nil
                if let rolePolicyListContainer = rolePolicyListContainer {
                    rolePolicyListBuffer = [IAMClientTypes.PolicyDetail]()
                    for structureContainer0 in rolePolicyListContainer {
                        rolePolicyListBuffer?.append(structureContainer0)
                    }
                }
                rolePolicyList = rolePolicyListBuffer
            } else {
                rolePolicyList = []
            }
        } else {
            rolePolicyList = nil
        }
        if containerValues.contains(.attachedManagedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedManagedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedManagedPolicies)
            if let attachedManagedPoliciesWrappedContainer = attachedManagedPoliciesWrappedContainer {
                let attachedManagedPoliciesContainer = try attachedManagedPoliciesWrappedContainer.decodeIfPresent([IAMClientTypes.AttachedPolicy].self, forKey: .member)
                var attachedManagedPoliciesBuffer:[IAMClientTypes.AttachedPolicy]? = nil
                if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
                    attachedManagedPoliciesBuffer = [IAMClientTypes.AttachedPolicy]()
                    for structureContainer0 in attachedManagedPoliciesContainer {
                        attachedManagedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedManagedPolicies = attachedManagedPoliciesBuffer
            } else {
                attachedManagedPolicies = []
            }
        } else {
            attachedManagedPolicies = nil
        }
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AttachedPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let roleLastUsedDecoded = try containerValues.decodeIfPresent(IAMClientTypes.RoleLastUsed.self, forKey: .roleLastUsed)
        roleLastUsed = roleLastUsedDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM role, including all of the role's policies. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct RoleDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The trust policy that grants permission to assume the role.
        public var assumeRolePolicyDocument: Swift.String?
        /// A list of managed policies attached to the role. These policies are the role's access (permissions) policies.
        public var attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the role was created.
        public var createDate: ClientRuntime.Date?
        /// A list of instance profiles that contain this role.
        public var instanceProfileList: [IAMClientTypes.InstanceProfile]?
        /// The path to the role. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The ARN of the policy used to set the permissions boundary for the role. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// The stable and unique string identifying the role. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var roleId: Swift.String?
        /// Contains information about the last time that an IAM role was used. This includes the date and time and the Region in which the role was last used. Activity is only reported for the trailing 400 days. This period can be shorter if your Region began supporting these features within the last year. The role might have been used more than 400 days ago. For more information, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM User Guide.
        public var roleLastUsed: IAMClientTypes.RoleLastUsed?
        /// The friendly name that identifies the role.
        public var roleName: Swift.String?
        /// A list of inline policies embedded in the role. These policies are the role's access (permissions) policies.
        public var rolePolicyList: [IAMClientTypes.PolicyDetail]?
        /// A list of tags that are attached to the role. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init(
            arn: Swift.String? = nil,
            assumeRolePolicyDocument: Swift.String? = nil,
            attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
            createDate: ClientRuntime.Date? = nil,
            instanceProfileList: [IAMClientTypes.InstanceProfile]? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            roleId: Swift.String? = nil,
            roleLastUsed: IAMClientTypes.RoleLastUsed? = nil,
            roleName: Swift.String? = nil,
            rolePolicyList: [IAMClientTypes.PolicyDetail]? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.arn = arn
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.instanceProfileList = instanceProfileList
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.roleId = roleId
            self.roleLastUsed = roleLastUsed
            self.roleName = roleName
            self.rolePolicyList = rolePolicyList
            self.tags = tags
        }
    }

}

extension IAMClientTypes.RoleLastUsed: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUsedDate = "LastUsedDate"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let lastUsedDate = lastUsedDate {
            try container.encodeTimestamp(lastUsedDate, format: .dateTime, forKey: ClientRuntime.Key("LastUsedDate"))
        }
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUsedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUsedDate)
        lastUsedDate = lastUsedDateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about the last time that an IAM role was used. This includes the date and time and the Region in which the role was last used. Activity is only reported for the trailing 400 days. This period can be shorter if your Region began supporting these features within the last year. The role might have been used more than 400 days ago. For more information, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM user Guide. This data type is returned as a response element in the [GetRole] and [GetAccountAuthorizationDetails] operations.
    public struct RoleLastUsed: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601) that the role was last used. This field is null if the role has not been used within the IAM tracking period. For more information about the tracking period, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM User Guide.
        public var lastUsedDate: ClientRuntime.Date?
        /// The name of the Amazon Web Services Region in which the role was last used.
        public var region: Swift.String?

        public init(
            lastUsedDate: ClientRuntime.Date? = nil,
            region: Swift.String? = nil
        )
        {
            self.lastUsedDate = lastUsedDate
            self.region = region
        }
    }

}

extension IAMClientTypes.RoleUsageType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case region = "Region"
        case resources = "Resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
        if let resources = resources {
            if !resources.isEmpty {
                var resourcesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Resources"))
                for (index0, arntype0) in resources.enumerated() {
                    try resourcesContainer.encode(arntype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var resourcesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Resources"))
                try resourcesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        if containerValues.contains(.resources) {
            struct KeyVal0{struct member{}}
            let resourcesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .resources)
            if let resourcesWrappedContainer = resourcesWrappedContainer {
                let resourcesContainer = try resourcesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var resourcesBuffer:[Swift.String]? = nil
                if let resourcesContainer = resourcesContainer {
                    resourcesBuffer = [Swift.String]()
                    for stringContainer0 in resourcesContainer {
                        resourcesBuffer?.append(stringContainer0)
                    }
                }
                resources = resourcesBuffer
            } else {
                resources = []
            }
        } else {
            resources = nil
        }
    }
}

extension IAMClientTypes {
    /// An object that contains details about how a service-linked role is used, if that information is returned by the service. This data type is used as a response element in the [GetServiceLinkedRoleDeletionStatus] operation.
    public struct RoleUsageType: Swift.Equatable {
        /// The name of the Region where the service-linked role is being used.
        public var region: Swift.String?
        /// The name of the resource that is using the service-linked role.
        public var resources: [Swift.String]?

        public init(
            region: Swift.String? = nil,
            resources: [Swift.String]? = nil
        )
        {
            self.region = region
            self.resources = resources
        }
    }

}

extension IAMClientTypes.SAMLProviderListEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case validUntil = "ValidUntil"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let validUntil = validUntil {
            try container.encodeTimestamp(validUntil, format: .dateTime, forKey: ClientRuntime.Key("ValidUntil"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let validUntilDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .validUntil)
        validUntil = validUntilDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains the list of SAML providers for this account.
    public struct SAMLProviderListEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the SAML provider.
        public var arn: Swift.String?
        /// The date and time when the SAML provider was created.
        public var createDate: ClientRuntime.Date?
        /// The expiration date and time for the SAML provider.
        public var validUntil: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            validUntil: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.validUntil = validUntil
        }
    }

}

extension IAMClientTypes.SSHPublicKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fingerprint = "Fingerprint"
        case sshPublicKeyBody = "SSHPublicKeyBody"
        case sshPublicKeyId = "SSHPublicKeyId"
        case status = "Status"
        case uploadDate = "UploadDate"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let fingerprint = fingerprint {
            try container.encode(fingerprint, forKey: ClientRuntime.Key("Fingerprint"))
        }
        if let sshPublicKeyBody = sshPublicKeyBody {
            try container.encode(sshPublicKeyBody, forKey: ClientRuntime.Key("SSHPublicKeyBody"))
        }
        if let sshPublicKeyId = sshPublicKeyId {
            try container.encode(sshPublicKeyId, forKey: ClientRuntime.Key("SSHPublicKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let uploadDate = uploadDate {
            try container.encodeTimestamp(uploadDate, format: .dateTime, forKey: ClientRuntime.Key("UploadDate"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
        let uploadDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .uploadDate)
        uploadDate = uploadDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an SSH public key. This data type is used as a response element in the [GetSSHPublicKey] and [UploadSSHPublicKey] operations.
    public struct SSHPublicKey: Swift.Equatable {
        /// The MD5 message digest of the SSH public key.
        /// This member is required.
        public var fingerprint: Swift.String?
        /// The SSH public key.
        /// This member is required.
        public var sshPublicKeyBody: Swift.String?
        /// The unique identifier for the SSH public key.
        /// This member is required.
        public var sshPublicKeyId: Swift.String?
        /// The status of the SSH public key. Active means that the key can be used for authentication with an CodeCommit repository. Inactive means that the key cannot be used.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the SSH public key was uploaded.
        public var uploadDate: ClientRuntime.Date?
        /// The name of the IAM user associated with the SSH public key.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            fingerprint: Swift.String? = nil,
            sshPublicKeyBody: Swift.String? = nil,
            sshPublicKeyId: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            uploadDate: ClientRuntime.Date? = nil,
            userName: Swift.String? = nil
        )
        {
            self.fingerprint = fingerprint
            self.sshPublicKeyBody = sshPublicKeyBody
            self.sshPublicKeyId = sshPublicKeyId
            self.status = status
            self.uploadDate = uploadDate
            self.userName = userName
        }
    }

}

extension IAMClientTypes.SSHPublicKeyMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKeyId = "SSHPublicKeyId"
        case status = "Status"
        case uploadDate = "UploadDate"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sshPublicKeyId = sshPublicKeyId {
            try container.encode(sshPublicKeyId, forKey: ClientRuntime.Key("SSHPublicKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let uploadDate = uploadDate {
            try container.encodeTimestamp(uploadDate, format: .dateTime, forKey: ClientRuntime.Key("UploadDate"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
        let uploadDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .uploadDate)
        uploadDate = uploadDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an SSH public key, without the key's body or fingerprint. This data type is used as a response element in the [ListSSHPublicKeys] operation.
    public struct SSHPublicKeyMetadata: Swift.Equatable {
        /// The unique identifier for the SSH public key.
        /// This member is required.
        public var sshPublicKeyId: Swift.String?
        /// The status of the SSH public key. Active means that the key can be used for authentication with an CodeCommit repository. Inactive means that the key cannot be used.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the SSH public key was uploaded.
        /// This member is required.
        public var uploadDate: ClientRuntime.Date?
        /// The name of the IAM user associated with the SSH public key.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            sshPublicKeyId: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            uploadDate: ClientRuntime.Date? = nil,
            userName: Swift.String? = nil
        )
        {
            self.sshPublicKeyId = sshPublicKeyId
            self.status = status
            self.uploadDate = uploadDate
            self.userName = userName
        }
    }

}

extension IAMClientTypes.ServerCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBody = "CertificateBody"
        case certificateChain = "CertificateChain"
        case serverCertificateMetadata = "ServerCertificateMetadata"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: ClientRuntime.Key("CertificateBody"))
        }
        if let certificateChain = certificateChain {
            try container.encode(certificateChain, forKey: ClientRuntime.Key("CertificateChain"))
        }
        if let serverCertificateMetadata = serverCertificateMetadata {
            try container.encode(serverCertificateMetadata, forKey: ClientRuntime.Key("ServerCertificateMetadata"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateMetadataDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ServerCertificateMetadata.self, forKey: .serverCertificateMetadata)
        serverCertificateMetadata = serverCertificateMetadataDecoded
        let certificateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateBody)
        certificateBody = certificateBodyDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a server certificate. This data type is used as a response element in the [GetServerCertificate] operation.
    public struct ServerCertificate: Swift.Equatable {
        /// The contents of the public key certificate.
        /// This member is required.
        public var certificateBody: Swift.String?
        /// The contents of the public key certificate chain.
        public var certificateChain: Swift.String?
        /// The meta information of the server certificate, such as its name, path, ID, and ARN.
        /// This member is required.
        public var serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata?
        /// A list of tags that are attached to the server certificate. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init(
            certificateBody: Swift.String? = nil,
            certificateChain: Swift.String? = nil,
            serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.certificateBody = certificateBody
            self.certificateChain = certificateChain
            self.serverCertificateMetadata = serverCertificateMetadata
            self.tags = tags
        }
    }

}

extension IAMClientTypes.ServerCertificateMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case expiration = "Expiration"
        case path = "Path"
        case serverCertificateId = "ServerCertificateId"
        case serverCertificateName = "ServerCertificateName"
        case uploadDate = "UploadDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let expiration = expiration {
            try container.encodeTimestamp(expiration, format: .dateTime, forKey: ClientRuntime.Key("Expiration"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let serverCertificateId = serverCertificateId {
            try container.encode(serverCertificateId, forKey: ClientRuntime.Key("ServerCertificateId"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        if let uploadDate = uploadDate {
            try container.encodeTimestamp(uploadDate, format: .dateTime, forKey: ClientRuntime.Key("UploadDate"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
        let serverCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateId)
        serverCertificateId = serverCertificateIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let uploadDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .uploadDate)
        uploadDate = uploadDateDecoded
        let expirationDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expiration)
        expiration = expirationDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about a server certificate without its certificate body, certificate chain, and private key. This data type is used as a response element in the [UploadServerCertificate] and [ListServerCertificates] operations.
    public struct ServerCertificateMetadata: Swift.Equatable {
        /// The Amazon Resource Name (ARN) specifying the server certificate. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date on which the certificate is set to expire.
        public var expiration: ClientRuntime.Date?
        /// The path to the server certificate. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?
        /// The stable and unique string identifying the server certificate. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var serverCertificateId: Swift.String?
        /// The name that identifies the server certificate.
        /// This member is required.
        public var serverCertificateName: Swift.String?
        /// The date when the server certificate was uploaded.
        public var uploadDate: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            expiration: ClientRuntime.Date? = nil,
            path: Swift.String? = nil,
            serverCertificateId: Swift.String? = nil,
            serverCertificateName: Swift.String? = nil,
            uploadDate: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.expiration = expiration
            self.path = path
            self.serverCertificateId = serverCertificateId
            self.serverCertificateName = serverCertificateName
            self.uploadDate = uploadDate
        }
    }

}

extension ServiceFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ServiceFailureExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct ServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceFailure" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes.ServiceLastAccessed: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastAuthenticated = "LastAuthenticated"
        case lastAuthenticatedEntity = "LastAuthenticatedEntity"
        case lastAuthenticatedRegion = "LastAuthenticatedRegion"
        case serviceName = "ServiceName"
        case serviceNamespace = "ServiceNamespace"
        case totalAuthenticatedEntities = "TotalAuthenticatedEntities"
        case trackedActionsLastAccessed = "TrackedActionsLastAccessed"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let lastAuthenticated = lastAuthenticated {
            try container.encodeTimestamp(lastAuthenticated, format: .dateTime, forKey: ClientRuntime.Key("LastAuthenticated"))
        }
        if let lastAuthenticatedEntity = lastAuthenticatedEntity {
            try container.encode(lastAuthenticatedEntity, forKey: ClientRuntime.Key("LastAuthenticatedEntity"))
        }
        if let lastAuthenticatedRegion = lastAuthenticatedRegion {
            try container.encode(lastAuthenticatedRegion, forKey: ClientRuntime.Key("LastAuthenticatedRegion"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: ClientRuntime.Key("ServiceNamespace"))
        }
        if let totalAuthenticatedEntities = totalAuthenticatedEntities {
            try container.encode(totalAuthenticatedEntities, forKey: ClientRuntime.Key("TotalAuthenticatedEntities"))
        }
        if let trackedActionsLastAccessed = trackedActionsLastAccessed {
            if !trackedActionsLastAccessed.isEmpty {
                var trackedActionsLastAccessedContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TrackedActionsLastAccessed"))
                for (index0, trackedactionlastaccessed0) in trackedActionsLastAccessed.enumerated() {
                    try trackedActionsLastAccessedContainer.encode(trackedactionlastaccessed0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var trackedActionsLastAccessedContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TrackedActionsLastAccessed"))
                try trackedActionsLastAccessedContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let lastAuthenticatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastAuthenticated)
        lastAuthenticated = lastAuthenticatedDecoded
        let serviceNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNamespace)
        serviceNamespace = serviceNamespaceDecoded
        let lastAuthenticatedEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAuthenticatedEntity)
        lastAuthenticatedEntity = lastAuthenticatedEntityDecoded
        let lastAuthenticatedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAuthenticatedRegion)
        lastAuthenticatedRegion = lastAuthenticatedRegionDecoded
        let totalAuthenticatedEntitiesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalAuthenticatedEntities)
        totalAuthenticatedEntities = totalAuthenticatedEntitiesDecoded
        if containerValues.contains(.trackedActionsLastAccessed) {
            struct KeyVal0{struct member{}}
            let trackedActionsLastAccessedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .trackedActionsLastAccessed)
            if let trackedActionsLastAccessedWrappedContainer = trackedActionsLastAccessedWrappedContainer {
                let trackedActionsLastAccessedContainer = try trackedActionsLastAccessedWrappedContainer.decodeIfPresent([IAMClientTypes.TrackedActionLastAccessed].self, forKey: .member)
                var trackedActionsLastAccessedBuffer:[IAMClientTypes.TrackedActionLastAccessed]? = nil
                if let trackedActionsLastAccessedContainer = trackedActionsLastAccessedContainer {
                    trackedActionsLastAccessedBuffer = [IAMClientTypes.TrackedActionLastAccessed]()
                    for structureContainer0 in trackedActionsLastAccessedContainer {
                        trackedActionsLastAccessedBuffer?.append(structureContainer0)
                    }
                }
                trackedActionsLastAccessed = trackedActionsLastAccessedBuffer
            } else {
                trackedActionsLastAccessed = []
            }
        } else {
            trackedActionsLastAccessed = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains details about the most recent attempt to access the service. This data type is used as a response element in the [GetServiceLastAccessedDetails] operation.
    public struct ServiceLastAccessed: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when an authenticated entity most recently attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticated: ClientRuntime.Date?
        /// The ARN of the authenticated entity (user or role) that last attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticatedEntity: Swift.String?
        /// The Region from which the authenticated entity (user or role) last attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticatedRegion: Swift.String?
        /// The name of the service in which access was attempted.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The namespace of the service in which access was attempted. To learn the service namespace of a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the Service Authorization Reference. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services Service Namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
        /// This member is required.
        public var serviceNamespace: Swift.String?
        /// The total number of authenticated principals (root user, IAM users, or IAM roles) that have attempted to access the service. This field is null if no principals attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var totalAuthenticatedEntities: Swift.Int?
        /// An object that contains details about the most recent attempt to access a tracked action within the service. This field is null if there no tracked actions or if the principal did not use the tracked actions within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period). This field is also null if the report was generated at the service level and not the action level. For more information, see the Granularity field in [GenerateServiceLastAccessedDetails].
        public var trackedActionsLastAccessed: [IAMClientTypes.TrackedActionLastAccessed]?

        public init(
            lastAuthenticated: ClientRuntime.Date? = nil,
            lastAuthenticatedEntity: Swift.String? = nil,
            lastAuthenticatedRegion: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceNamespace: Swift.String? = nil,
            totalAuthenticatedEntities: Swift.Int? = nil,
            trackedActionsLastAccessed: [IAMClientTypes.TrackedActionLastAccessed]? = nil
        )
        {
            self.lastAuthenticated = lastAuthenticated
            self.lastAuthenticatedEntity = lastAuthenticatedEntity
            self.lastAuthenticatedRegion = lastAuthenticatedRegion
            self.serviceName = serviceName
            self.serviceNamespace = serviceNamespace
            self.totalAuthenticatedEntities = totalAuthenticatedEntities
            self.trackedActionsLastAccessed = trackedActionsLastAccessed
        }
    }

}

extension ServiceNotSupportedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ServiceNotSupportedExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified service does not support service-specific credentials.
public struct ServiceNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotSupportedService" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes.ServiceSpecificCredential: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case serviceName = "ServiceName"
        case servicePassword = "ServicePassword"
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case serviceUserName = "ServiceUserName"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let servicePassword = servicePassword {
            try container.encode(servicePassword, forKey: ClientRuntime.Key("ServicePassword"))
        }
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: ClientRuntime.Key("ServiceSpecificCredentialId"))
        }
        if let serviceUserName = serviceUserName {
            try container.encode(serviceUserName, forKey: ClientRuntime.Key("ServiceUserName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUserName)
        serviceUserName = serviceUserNameDecoded
        let servicePasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .servicePassword)
        servicePassword = servicePasswordDecoded
        let serviceSpecificCredentialIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceSpecificCredentialId)
        serviceSpecificCredentialId = serviceSpecificCredentialIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension IAMClientTypes.ServiceSpecificCredential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceSpecificCredential(createDate: \(Swift.String(describing: createDate)), serviceName: \(Swift.String(describing: serviceName)), serviceSpecificCredentialId: \(Swift.String(describing: serviceSpecificCredentialId)), serviceUserName: \(Swift.String(describing: serviceUserName)), status: \(Swift.String(describing: status)), userName: \(Swift.String(describing: userName)), servicePassword: \"CONTENT_REDACTED\")"}
}

extension IAMClientTypes {
    /// Contains the details of a service-specific credential.
    public struct ServiceSpecificCredential: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the service-specific credential were created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// The name of the service associated with the service-specific credential.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The generated password for the service-specific credential.
        /// This member is required.
        public var servicePassword: Swift.String?
        /// The unique identifier for the service-specific credential.
        /// This member is required.
        public var serviceSpecificCredentialId: Swift.String?
        /// The generated user name for the service-specific credential. This value is generated by combining the IAM user's name combined with the ID number of the Amazon Web Services account, as in jane-at-123456789012, for example. This value cannot be configured by the user.
        /// This member is required.
        public var serviceUserName: Swift.String?
        /// The status of the service-specific credential. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user associated with the service-specific credential.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            createDate: ClientRuntime.Date? = nil,
            serviceName: Swift.String? = nil,
            servicePassword: Swift.String? = nil,
            serviceSpecificCredentialId: Swift.String? = nil,
            serviceUserName: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.serviceName = serviceName
            self.servicePassword = servicePassword
            self.serviceSpecificCredentialId = serviceSpecificCredentialId
            self.serviceUserName = serviceUserName
            self.status = status
            self.userName = userName
        }
    }

}

extension IAMClientTypes.ServiceSpecificCredentialMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case serviceName = "ServiceName"
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case serviceUserName = "ServiceUserName"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: ClientRuntime.Key("ServiceSpecificCredentialId"))
        }
        if let serviceUserName = serviceUserName {
            try container.encode(serviceUserName, forKey: ClientRuntime.Key("ServiceUserName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
        let serviceUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUserName)
        serviceUserName = serviceUserNameDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let serviceSpecificCredentialIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceSpecificCredentialId)
        serviceSpecificCredentialId = serviceSpecificCredentialIdDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension IAMClientTypes {
    /// Contains additional details about a service-specific credential.
    public struct ServiceSpecificCredentialMetadata: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the service-specific credential were created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// The name of the service associated with the service-specific credential.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The unique identifier for the service-specific credential.
        /// This member is required.
        public var serviceSpecificCredentialId: Swift.String?
        /// The generated user name for the service-specific credential.
        /// This member is required.
        public var serviceUserName: Swift.String?
        /// The status of the service-specific credential. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user associated with the service-specific credential.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            createDate: ClientRuntime.Date? = nil,
            serviceName: Swift.String? = nil,
            serviceSpecificCredentialId: Swift.String? = nil,
            serviceUserName: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.serviceName = serviceName
            self.serviceSpecificCredentialId = serviceSpecificCredentialId
            self.serviceUserName = serviceUserName
            self.status = status
            self.userName = userName
        }
    }

}

extension SetDefaultPolicyVersionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
        try container.encode("SetDefaultPolicyVersion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetDefaultPolicyVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetDefaultPolicyVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy whose default version you want to set. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The version of the policy to set as the default (operative) version. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.versionId = versionId
    }
}

struct SetDefaultPolicyVersionInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let versionId: Swift.String?
}

extension SetDefaultPolicyVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case versionId = "VersionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension SetDefaultPolicyVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SetDefaultPolicyVersionOutput: Swift.Equatable {

    public init() { }
}

enum SetDefaultPolicyVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension SetSecurityTokenServicePreferencesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let globalEndpointTokenVersion = globalEndpointTokenVersion {
            try container.encode(globalEndpointTokenVersion, forKey: ClientRuntime.Key("GlobalEndpointTokenVersion"))
        }
        try container.encode("SetSecurityTokenServicePreferences", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetSecurityTokenServicePreferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetSecurityTokenServicePreferencesInput: Swift.Equatable {
    /// The version of the global endpoint token. Version 1 tokens are valid only in Amazon Web Services Regions that are available by default. These tokens do not work in manually enabled Regions, such as Asia Pacific (Hong Kong). Version 2 tokens are valid in all Regions. However, version 2 tokens are longer and might affect systems where you temporarily store tokens. For information, see [Activating and deactivating STS in an Amazon Web Services Region](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html) in the IAM User Guide.
    /// This member is required.
    public var globalEndpointTokenVersion: IAMClientTypes.GlobalEndpointTokenVersion?

    public init(
        globalEndpointTokenVersion: IAMClientTypes.GlobalEndpointTokenVersion? = nil
    )
    {
        self.globalEndpointTokenVersion = globalEndpointTokenVersion
    }
}

struct SetSecurityTokenServicePreferencesInputBody: Swift.Equatable {
    let globalEndpointTokenVersion: IAMClientTypes.GlobalEndpointTokenVersion?
}

extension SetSecurityTokenServicePreferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalEndpointTokenVersion = "GlobalEndpointTokenVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalEndpointTokenVersionDecoded = try containerValues.decodeIfPresent(IAMClientTypes.GlobalEndpointTokenVersion.self, forKey: .globalEndpointTokenVersion)
        globalEndpointTokenVersion = globalEndpointTokenVersionDecoded
    }
}

extension SetSecurityTokenServicePreferencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SetSecurityTokenServicePreferencesOutput: Swift.Equatable {

    public init() { }
}

enum SetSecurityTokenServicePreferencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension IAMClientTypes.SigningCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBody = "CertificateBody"
        case certificateId = "CertificateId"
        case status = "Status"
        case uploadDate = "UploadDate"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: ClientRuntime.Key("CertificateBody"))
        }
        if let certificateId = certificateId {
            try container.encode(certificateId, forKey: ClientRuntime.Key("CertificateId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let uploadDate = uploadDate {
            try container.encodeTimestamp(uploadDate, format: .dateTime, forKey: ClientRuntime.Key("UploadDate"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let certificateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateBody)
        certificateBody = certificateBodyDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
        let uploadDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .uploadDate)
        uploadDate = uploadDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an X.509 signing certificate. This data type is used as a response element in the [UploadSigningCertificate] and [ListSigningCertificates] operations.
    public struct SigningCertificate: Swift.Equatable {
        /// The contents of the signing certificate.
        /// This member is required.
        public var certificateBody: Swift.String?
        /// The ID for the signing certificate.
        /// This member is required.
        public var certificateId: Swift.String?
        /// The status of the signing certificate. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The date when the signing certificate was uploaded.
        public var uploadDate: ClientRuntime.Date?
        /// The name of the user the signing certificate is associated with.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            certificateBody: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            uploadDate: ClientRuntime.Date? = nil,
            userName: Swift.String? = nil
        )
        {
            self.certificateBody = certificateBody
            self.certificateId = certificateId
            self.status = status
            self.uploadDate = uploadDate
            self.userName = userName
        }
    }

}

extension SimulateCustomPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let actionNames = actionNames {
            if !actionNames.isEmpty {
                var actionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionNames"))
                for (index0, actionnametype0) in actionNames.enumerated() {
                    try actionNamesContainer.encode(actionnametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var actionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionNames"))
                try actionNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let callerArn = callerArn {
            try container.encode(callerArn, forKey: ClientRuntime.Key("CallerArn"))
        }
        if let contextEntries = contextEntries {
            if !contextEntries.isEmpty {
                var contextEntriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextEntries"))
                for (index0, contextentry0) in contextEntries.enumerated() {
                    try contextEntriesContainer.encode(contextentry0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var contextEntriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextEntries"))
                try contextEntriesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList {
            if !permissionsBoundaryPolicyInputList.isEmpty {
                var permissionsBoundaryPolicyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PermissionsBoundaryPolicyInputList"))
                for (index0, policydocumenttype0) in permissionsBoundaryPolicyInputList.enumerated() {
                    try permissionsBoundaryPolicyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var permissionsBoundaryPolicyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PermissionsBoundaryPolicyInputList"))
                try permissionsBoundaryPolicyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policyInputList = policyInputList {
            if !policyInputList.isEmpty {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                for (index0, policydocumenttype0) in policyInputList.enumerated() {
                    try policyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                try policyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let resourceArns = resourceArns {
            if !resourceArns.isEmpty {
                var resourceArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceArns"))
                for (index0, resourcenametype0) in resourceArns.enumerated() {
                    try resourceArnsContainer.encode(resourcenametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var resourceArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceArns"))
                try resourceArnsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let resourceHandlingOption = resourceHandlingOption {
            try container.encode(resourceHandlingOption, forKey: ClientRuntime.Key("ResourceHandlingOption"))
        }
        if let resourceOwner = resourceOwner {
            try container.encode(resourceOwner, forKey: ClientRuntime.Key("ResourceOwner"))
        }
        if let resourcePolicy = resourcePolicy {
            try container.encode(resourcePolicy, forKey: ClientRuntime.Key("ResourcePolicy"))
        }
        try container.encode("SimulateCustomPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension SimulateCustomPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SimulateCustomPolicyInput: Swift.Equatable {
    /// A list of names of API operations to evaluate in the simulation. Each operation is evaluated against each resource. Each operation must include the service identifier, such as iam:CreateUser. This operation does not support using wildcards (*) in an action name.
    /// This member is required.
    public var actionNames: [Swift.String]?
    /// The ARN of the IAM user that you want to use as the simulated caller of the API operations. CallerArn is required if you include a ResourcePolicy so that the policy's Principal element has a value to use in evaluating the policy. You can specify only the ARN of an IAM user. You cannot specify the ARN of an assumed role, federated user, or a service principal.
    public var callerArn: Swift.String?
    /// A list of context keys and corresponding values for the simulation to use. Whenever a context key is evaluated in one of the simulated IAM permissions policies, the corresponding value is supplied.
    public var contextEntries: [IAMClientTypes.ContextEntry]?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The IAM permissions boundary policy to simulate. The permissions boundary sets the maximum permissions that an IAM entity can have. You can input only one permissions boundary when you pass a policy to this operation. For more information about permissions boundaries, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. The policy input is specified as a string that contains the complete, valid JSON text of a permissions boundary policy. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var permissionsBoundaryPolicyInputList: [Swift.String]?
    /// A list of policy documents to include in the simulation. Each document is specified as a string containing the complete, valid JSON text of an IAM policy. Do not include any resource-based policies in this parameter. Any resource-based policy must be submitted with the ResourcePolicy parameter. The policies cannot be "scope-down" policies, such as you could include in a call to [GetFederationToken](https://docs.aws.amazon.com/IAM/latest/APIReference/API_GetFederationToken.html) or one of the [AssumeRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_AssumeRole.html) API operations. In other words, do not use policies designed to restrict what a user can do while using the temporary credentials. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyInputList: [Swift.String]?
    /// A list of ARNs of Amazon Web Services resources to include in the simulation. If this parameter is not provided, then the value defaults to * (all resources). Each API in the ActionNames parameter is evaluated for each resource in this list. The simulation determines the access result (allowed or denied) of each combination and reports it in the response. You can simulate resources that don't exist in your account. The simulation does not automatically retrieve policies for the specified resources. If you want to include a resource policy in the simulation, then you must include the policy as a string in the ResourcePolicy parameter. If you include a ResourcePolicy, then it must be applicable to all of the resources included in the simulation or you receive an invalid input error. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. Simulation of resource-based policies isn't supported for IAM roles.
    public var resourceArns: [Swift.String]?
    /// Specifies the type of simulation to run. Different API operations that support resource-based policies require different combinations of resources. By specifying the type of simulation to run, you enable the policy simulator to enforce the presence of the required resources to ensure reliable simulation results. If your simulation does not match one of the following scenarios, then you can omit this parameter. The following list shows each of the supported scenario values and the resources that you must define to run the simulation. Each of the EC2 scenarios requires that you specify instance, image, and security group resources. If your scenario includes an EBS volume, then you must specify that volume as a resource. If the EC2 scenario includes VPC, then you must supply the network interface resource. If it includes an IP subnet, then you must specify the subnet resource. For more information on the EC2 scenario options, see [Supported platforms](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html) in the Amazon EC2 User Guide.
    ///
    /// * EC2-VPC-InstanceStore instance, image, security group, network interface
    ///
    /// * EC2-VPC-InstanceStore-Subnet instance, image, security group, network interface, subnet
    ///
    /// * EC2-VPC-EBS instance, image, security group, network interface, volume
    ///
    /// * EC2-VPC-EBS-Subnet instance, image, security group, network interface, subnet, volume
    public var resourceHandlingOption: Swift.String?
    /// An ARN representing the Amazon Web Services account ID that specifies the owner of any simulated resource that does not identify its owner in the resource ARN. Examples of resource ARNs include an S3 bucket or object. If ResourceOwner is specified, it is also used as the account owner of any ResourcePolicy included in the simulation. If the ResourceOwner parameter is not specified, then the owner of the resources and the resource policy defaults to the account of the identity provided in CallerArn. This parameter is required only if you specify a resource-based policy and account that owns the resource is different from the account that owns the simulated calling user CallerArn. The ARN for an account uses the following syntax: arn:aws:iam::AWS-account-ID:root. For example, to represent the account with the 112233445566 ID, use the following ARN: arn:aws:iam::112233445566-ID:root.
    public var resourceOwner: Swift.String?
    /// A resource-based policy to include in the simulation provided as a string. Each resource in the simulation is treated as if it had this policy attached. You can include only one resource-based policy in a simulation. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// Simulation of resource-based policies isn't supported for IAM roles.
    public var resourcePolicy: Swift.String?

    public init(
        actionNames: [Swift.String]? = nil,
        callerArn: Swift.String? = nil,
        contextEntries: [IAMClientTypes.ContextEntry]? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        permissionsBoundaryPolicyInputList: [Swift.String]? = nil,
        policyInputList: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceHandlingOption: Swift.String? = nil,
        resourceOwner: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.actionNames = actionNames
        self.callerArn = callerArn
        self.contextEntries = contextEntries
        self.marker = marker
        self.maxItems = maxItems
        self.permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList
        self.policyInputList = policyInputList
        self.resourceArns = resourceArns
        self.resourceHandlingOption = resourceHandlingOption
        self.resourceOwner = resourceOwner
        self.resourcePolicy = resourcePolicy
    }
}

struct SimulateCustomPolicyInputBody: Swift.Equatable {
    let policyInputList: [Swift.String]?
    let permissionsBoundaryPolicyInputList: [Swift.String]?
    let actionNames: [Swift.String]?
    let resourceArns: [Swift.String]?
    let resourcePolicy: Swift.String?
    let resourceOwner: Swift.String?
    let callerArn: Swift.String?
    let contextEntries: [IAMClientTypes.ContextEntry]?
    let resourceHandlingOption: Swift.String?
    let maxItems: Swift.Int?
    let marker: Swift.String?
}

extension SimulateCustomPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionNames = "ActionNames"
        case callerArn = "CallerArn"
        case contextEntries = "ContextEntries"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case permissionsBoundaryPolicyInputList = "PermissionsBoundaryPolicyInputList"
        case policyInputList = "PolicyInputList"
        case resourceArns = "ResourceArns"
        case resourceHandlingOption = "ResourceHandlingOption"
        case resourceOwner = "ResourceOwner"
        case resourcePolicy = "ResourcePolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.policyInputList) {
            struct KeyVal0{struct member{}}
            let policyInputListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyInputList)
            if let policyInputListWrappedContainer = policyInputListWrappedContainer {
                let policyInputListContainer = try policyInputListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyInputListBuffer:[Swift.String]? = nil
                if let policyInputListContainer = policyInputListContainer {
                    policyInputListBuffer = [Swift.String]()
                    for stringContainer0 in policyInputListContainer {
                        policyInputListBuffer?.append(stringContainer0)
                    }
                }
                policyInputList = policyInputListBuffer
            } else {
                policyInputList = []
            }
        } else {
            policyInputList = nil
        }
        if containerValues.contains(.permissionsBoundaryPolicyInputList) {
            struct KeyVal0{struct member{}}
            let permissionsBoundaryPolicyInputListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .permissionsBoundaryPolicyInputList)
            if let permissionsBoundaryPolicyInputListWrappedContainer = permissionsBoundaryPolicyInputListWrappedContainer {
                let permissionsBoundaryPolicyInputListContainer = try permissionsBoundaryPolicyInputListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var permissionsBoundaryPolicyInputListBuffer:[Swift.String]? = nil
                if let permissionsBoundaryPolicyInputListContainer = permissionsBoundaryPolicyInputListContainer {
                    permissionsBoundaryPolicyInputListBuffer = [Swift.String]()
                    for stringContainer0 in permissionsBoundaryPolicyInputListContainer {
                        permissionsBoundaryPolicyInputListBuffer?.append(stringContainer0)
                    }
                }
                permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputListBuffer
            } else {
                permissionsBoundaryPolicyInputList = []
            }
        } else {
            permissionsBoundaryPolicyInputList = nil
        }
        if containerValues.contains(.actionNames) {
            struct KeyVal0{struct member{}}
            let actionNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .actionNames)
            if let actionNamesWrappedContainer = actionNamesWrappedContainer {
                let actionNamesContainer = try actionNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var actionNamesBuffer:[Swift.String]? = nil
                if let actionNamesContainer = actionNamesContainer {
                    actionNamesBuffer = [Swift.String]()
                    for stringContainer0 in actionNamesContainer {
                        actionNamesBuffer?.append(stringContainer0)
                    }
                }
                actionNames = actionNamesBuffer
            } else {
                actionNames = []
            }
        } else {
            actionNames = nil
        }
        if containerValues.contains(.resourceArns) {
            struct KeyVal0{struct member{}}
            let resourceArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .resourceArns)
            if let resourceArnsWrappedContainer = resourceArnsWrappedContainer {
                let resourceArnsContainer = try resourceArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var resourceArnsBuffer:[Swift.String]? = nil
                if let resourceArnsContainer = resourceArnsContainer {
                    resourceArnsBuffer = [Swift.String]()
                    for stringContainer0 in resourceArnsContainer {
                        resourceArnsBuffer?.append(stringContainer0)
                    }
                }
                resourceArns = resourceArnsBuffer
            } else {
                resourceArns = []
            }
        } else {
            resourceArns = nil
        }
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let callerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerArn)
        callerArn = callerArnDecoded
        if containerValues.contains(.contextEntries) {
            struct KeyVal0{struct member{}}
            let contextEntriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .contextEntries)
            if let contextEntriesWrappedContainer = contextEntriesWrappedContainer {
                let contextEntriesContainer = try contextEntriesWrappedContainer.decodeIfPresent([IAMClientTypes.ContextEntry].self, forKey: .member)
                var contextEntriesBuffer:[IAMClientTypes.ContextEntry]? = nil
                if let contextEntriesContainer = contextEntriesContainer {
                    contextEntriesBuffer = [IAMClientTypes.ContextEntry]()
                    for structureContainer0 in contextEntriesContainer {
                        contextEntriesBuffer?.append(structureContainer0)
                    }
                }
                contextEntries = contextEntriesBuffer
            } else {
                contextEntries = []
            }
        } else {
            contextEntries = nil
        }
        let resourceHandlingOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceHandlingOption)
        resourceHandlingOption = resourceHandlingOptionDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension SimulateCustomPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SimulateCustomPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluationResults = output.evaluationResults
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.evaluationResults = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [SimulatePrincipalPolicy] or [SimulateCustomPolicy] request.
public struct SimulateCustomPolicyOutput: Swift.Equatable {
    /// The results of the simulation.
    public var evaluationResults: [IAMClientTypes.EvaluationResult]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        evaluationResults: [IAMClientTypes.EvaluationResult]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct SimulateCustomPolicyOutputBody: Swift.Equatable {
    let evaluationResults: [IAMClientTypes.EvaluationResult]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension SimulateCustomPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationResults = "EvaluationResults"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("SimulateCustomPolicyResult"))
        if containerValues.contains(.evaluationResults) {
            struct KeyVal0{struct member{}}
            let evaluationResultsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .evaluationResults)
            if let evaluationResultsWrappedContainer = evaluationResultsWrappedContainer {
                let evaluationResultsContainer = try evaluationResultsWrappedContainer.decodeIfPresent([IAMClientTypes.EvaluationResult].self, forKey: .member)
                var evaluationResultsBuffer:[IAMClientTypes.EvaluationResult]? = nil
                if let evaluationResultsContainer = evaluationResultsContainer {
                    evaluationResultsBuffer = [IAMClientTypes.EvaluationResult]()
                    for structureContainer0 in evaluationResultsContainer {
                        evaluationResultsBuffer?.append(structureContainer0)
                    }
                }
                evaluationResults = evaluationResultsBuffer
            } else {
                evaluationResults = []
            }
        } else {
            evaluationResults = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum SimulateCustomPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PolicyEvaluation": return try await PolicyEvaluationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension SimulatePrincipalPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let actionNames = actionNames {
            if !actionNames.isEmpty {
                var actionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionNames"))
                for (index0, actionnametype0) in actionNames.enumerated() {
                    try actionNamesContainer.encode(actionnametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var actionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionNames"))
                try actionNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let callerArn = callerArn {
            try container.encode(callerArn, forKey: ClientRuntime.Key("CallerArn"))
        }
        if let contextEntries = contextEntries {
            if !contextEntries.isEmpty {
                var contextEntriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextEntries"))
                for (index0, contextentry0) in contextEntries.enumerated() {
                    try contextEntriesContainer.encode(contextentry0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var contextEntriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextEntries"))
                try contextEntriesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList {
            if !permissionsBoundaryPolicyInputList.isEmpty {
                var permissionsBoundaryPolicyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PermissionsBoundaryPolicyInputList"))
                for (index0, policydocumenttype0) in permissionsBoundaryPolicyInputList.enumerated() {
                    try permissionsBoundaryPolicyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var permissionsBoundaryPolicyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PermissionsBoundaryPolicyInputList"))
                try permissionsBoundaryPolicyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policyInputList = policyInputList {
            if !policyInputList.isEmpty {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                for (index0, policydocumenttype0) in policyInputList.enumerated() {
                    try policyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                try policyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policySourceArn = policySourceArn {
            try container.encode(policySourceArn, forKey: ClientRuntime.Key("PolicySourceArn"))
        }
        if let resourceArns = resourceArns {
            if !resourceArns.isEmpty {
                var resourceArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceArns"))
                for (index0, resourcenametype0) in resourceArns.enumerated() {
                    try resourceArnsContainer.encode(resourcenametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var resourceArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceArns"))
                try resourceArnsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let resourceHandlingOption = resourceHandlingOption {
            try container.encode(resourceHandlingOption, forKey: ClientRuntime.Key("ResourceHandlingOption"))
        }
        if let resourceOwner = resourceOwner {
            try container.encode(resourceOwner, forKey: ClientRuntime.Key("ResourceOwner"))
        }
        if let resourcePolicy = resourcePolicy {
            try container.encode(resourcePolicy, forKey: ClientRuntime.Key("ResourcePolicy"))
        }
        try container.encode("SimulatePrincipalPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension SimulatePrincipalPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SimulatePrincipalPolicyInput: Swift.Equatable {
    /// A list of names of API operations to evaluate in the simulation. Each operation is evaluated for each resource. Each operation must include the service identifier, such as iam:CreateUser.
    /// This member is required.
    public var actionNames: [Swift.String]?
    /// The ARN of the IAM user that you want to specify as the simulated caller of the API operations. If you do not specify a CallerArn, it defaults to the ARN of the user that you specify in PolicySourceArn, if you specified a user. If you include both a PolicySourceArn (for example, arn:aws:iam::123456789012:user/David) and a CallerArn (for example, arn:aws:iam::123456789012:user/Bob), the result is that you simulate calling the API operations as Bob, as if Bob had David's policies. You can specify only the ARN of an IAM user. You cannot specify the ARN of an assumed role, federated user, or a service principal. CallerArn is required if you include a ResourcePolicy and the PolicySourceArn is not the ARN for an IAM user. This is required so that the resource-based policy's Principal element has a value to use in evaluating the policy. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    public var callerArn: Swift.String?
    /// A list of context keys and corresponding values for the simulation to use. Whenever a context key is evaluated in one of the simulated IAM permissions policies, the corresponding value is supplied.
    public var contextEntries: [IAMClientTypes.ContextEntry]?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The IAM permissions boundary policy to simulate. The permissions boundary sets the maximum permissions that the entity can have. You can input only one permissions boundary when you pass a policy to this operation. An IAM entity can only have one permissions boundary in effect at a time. For example, if a permissions boundary is attached to an entity and you pass in a different permissions boundary policy using this parameter, then the new permissions boundary policy is used for the simulation. For more information about permissions boundaries, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. The policy input is specified as a string containing the complete, valid JSON text of a permissions boundary policy. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var permissionsBoundaryPolicyInputList: [Swift.String]?
    /// An optional list of additional policy documents to include in the simulation. Each document is specified as a string containing the complete, valid JSON text of an IAM policy. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var policyInputList: [Swift.String]?
    /// The Amazon Resource Name (ARN) of a user, group, or role whose policies you want to include in the simulation. If you specify a user, group, or role, the simulation includes all policies that are associated with that entity. If you specify a user, the simulation also includes all policies that are attached to any groups the user belongs to. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policySourceArn: Swift.String?
    /// A list of ARNs of Amazon Web Services resources to include in the simulation. If this parameter is not provided, then the value defaults to * (all resources). Each API in the ActionNames parameter is evaluated for each resource in this list. The simulation determines the access result (allowed or denied) of each combination and reports it in the response. You can simulate resources that don't exist in your account. The simulation does not automatically retrieve policies for the specified resources. If you want to include a resource policy in the simulation, then you must include the policy as a string in the ResourcePolicy parameter. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. Simulation of resource-based policies isn't supported for IAM roles.
    public var resourceArns: [Swift.String]?
    /// Specifies the type of simulation to run. Different API operations that support resource-based policies require different combinations of resources. By specifying the type of simulation to run, you enable the policy simulator to enforce the presence of the required resources to ensure reliable simulation results. If your simulation does not match one of the following scenarios, then you can omit this parameter. The following list shows each of the supported scenario values and the resources that you must define to run the simulation. Each of the EC2 scenarios requires that you specify instance, image, and security group resources. If your scenario includes an EBS volume, then you must specify that volume as a resource. If the EC2 scenario includes VPC, then you must supply the network interface resource. If it includes an IP subnet, then you must specify the subnet resource. For more information on the EC2 scenario options, see [Supported platforms](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html) in the Amazon EC2 User Guide.
    ///
    /// * EC2-VPC-InstanceStore instance, image, security group, network interface
    ///
    /// * EC2-VPC-InstanceStore-Subnet instance, image, security group, network interface, subnet
    ///
    /// * EC2-VPC-EBS instance, image, security group, network interface, volume
    ///
    /// * EC2-VPC-EBS-Subnet instance, image, security group, network interface, subnet, volume
    public var resourceHandlingOption: Swift.String?
    /// An Amazon Web Services account ID that specifies the owner of any simulated resource that does not identify its owner in the resource ARN. Examples of resource ARNs include an S3 bucket or object. If ResourceOwner is specified, it is also used as the account owner of any ResourcePolicy included in the simulation. If the ResourceOwner parameter is not specified, then the owner of the resources and the resource policy defaults to the account of the identity provided in CallerArn. This parameter is required only if you specify a resource-based policy and account that owns the resource is different from the account that owns the simulated calling user CallerArn.
    public var resourceOwner: Swift.String?
    /// A resource-based policy to include in the simulation provided as a string. Each resource in the simulation is treated as if it had this policy attached. You can include only one resource-based policy in a simulation. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// Simulation of resource-based policies isn't supported for IAM roles.
    public var resourcePolicy: Swift.String?

    public init(
        actionNames: [Swift.String]? = nil,
        callerArn: Swift.String? = nil,
        contextEntries: [IAMClientTypes.ContextEntry]? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        permissionsBoundaryPolicyInputList: [Swift.String]? = nil,
        policyInputList: [Swift.String]? = nil,
        policySourceArn: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceHandlingOption: Swift.String? = nil,
        resourceOwner: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.actionNames = actionNames
        self.callerArn = callerArn
        self.contextEntries = contextEntries
        self.marker = marker
        self.maxItems = maxItems
        self.permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList
        self.policyInputList = policyInputList
        self.policySourceArn = policySourceArn
        self.resourceArns = resourceArns
        self.resourceHandlingOption = resourceHandlingOption
        self.resourceOwner = resourceOwner
        self.resourcePolicy = resourcePolicy
    }
}

struct SimulatePrincipalPolicyInputBody: Swift.Equatable {
    let policySourceArn: Swift.String?
    let policyInputList: [Swift.String]?
    let permissionsBoundaryPolicyInputList: [Swift.String]?
    let actionNames: [Swift.String]?
    let resourceArns: [Swift.String]?
    let resourcePolicy: Swift.String?
    let resourceOwner: Swift.String?
    let callerArn: Swift.String?
    let contextEntries: [IAMClientTypes.ContextEntry]?
    let resourceHandlingOption: Swift.String?
    let maxItems: Swift.Int?
    let marker: Swift.String?
}

extension SimulatePrincipalPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionNames = "ActionNames"
        case callerArn = "CallerArn"
        case contextEntries = "ContextEntries"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case permissionsBoundaryPolicyInputList = "PermissionsBoundaryPolicyInputList"
        case policyInputList = "PolicyInputList"
        case policySourceArn = "PolicySourceArn"
        case resourceArns = "ResourceArns"
        case resourceHandlingOption = "ResourceHandlingOption"
        case resourceOwner = "ResourceOwner"
        case resourcePolicy = "ResourcePolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policySourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policySourceArn)
        policySourceArn = policySourceArnDecoded
        if containerValues.contains(.policyInputList) {
            struct KeyVal0{struct member{}}
            let policyInputListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyInputList)
            if let policyInputListWrappedContainer = policyInputListWrappedContainer {
                let policyInputListContainer = try policyInputListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyInputListBuffer:[Swift.String]? = nil
                if let policyInputListContainer = policyInputListContainer {
                    policyInputListBuffer = [Swift.String]()
                    for stringContainer0 in policyInputListContainer {
                        policyInputListBuffer?.append(stringContainer0)
                    }
                }
                policyInputList = policyInputListBuffer
            } else {
                policyInputList = []
            }
        } else {
            policyInputList = nil
        }
        if containerValues.contains(.permissionsBoundaryPolicyInputList) {
            struct KeyVal0{struct member{}}
            let permissionsBoundaryPolicyInputListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .permissionsBoundaryPolicyInputList)
            if let permissionsBoundaryPolicyInputListWrappedContainer = permissionsBoundaryPolicyInputListWrappedContainer {
                let permissionsBoundaryPolicyInputListContainer = try permissionsBoundaryPolicyInputListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var permissionsBoundaryPolicyInputListBuffer:[Swift.String]? = nil
                if let permissionsBoundaryPolicyInputListContainer = permissionsBoundaryPolicyInputListContainer {
                    permissionsBoundaryPolicyInputListBuffer = [Swift.String]()
                    for stringContainer0 in permissionsBoundaryPolicyInputListContainer {
                        permissionsBoundaryPolicyInputListBuffer?.append(stringContainer0)
                    }
                }
                permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputListBuffer
            } else {
                permissionsBoundaryPolicyInputList = []
            }
        } else {
            permissionsBoundaryPolicyInputList = nil
        }
        if containerValues.contains(.actionNames) {
            struct KeyVal0{struct member{}}
            let actionNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .actionNames)
            if let actionNamesWrappedContainer = actionNamesWrappedContainer {
                let actionNamesContainer = try actionNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var actionNamesBuffer:[Swift.String]? = nil
                if let actionNamesContainer = actionNamesContainer {
                    actionNamesBuffer = [Swift.String]()
                    for stringContainer0 in actionNamesContainer {
                        actionNamesBuffer?.append(stringContainer0)
                    }
                }
                actionNames = actionNamesBuffer
            } else {
                actionNames = []
            }
        } else {
            actionNames = nil
        }
        if containerValues.contains(.resourceArns) {
            struct KeyVal0{struct member{}}
            let resourceArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .resourceArns)
            if let resourceArnsWrappedContainer = resourceArnsWrappedContainer {
                let resourceArnsContainer = try resourceArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var resourceArnsBuffer:[Swift.String]? = nil
                if let resourceArnsContainer = resourceArnsContainer {
                    resourceArnsBuffer = [Swift.String]()
                    for stringContainer0 in resourceArnsContainer {
                        resourceArnsBuffer?.append(stringContainer0)
                    }
                }
                resourceArns = resourceArnsBuffer
            } else {
                resourceArns = []
            }
        } else {
            resourceArns = nil
        }
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let callerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerArn)
        callerArn = callerArnDecoded
        if containerValues.contains(.contextEntries) {
            struct KeyVal0{struct member{}}
            let contextEntriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .contextEntries)
            if let contextEntriesWrappedContainer = contextEntriesWrappedContainer {
                let contextEntriesContainer = try contextEntriesWrappedContainer.decodeIfPresent([IAMClientTypes.ContextEntry].self, forKey: .member)
                var contextEntriesBuffer:[IAMClientTypes.ContextEntry]? = nil
                if let contextEntriesContainer = contextEntriesContainer {
                    contextEntriesBuffer = [IAMClientTypes.ContextEntry]()
                    for structureContainer0 in contextEntriesContainer {
                        contextEntriesBuffer?.append(structureContainer0)
                    }
                }
                contextEntries = contextEntriesBuffer
            } else {
                contextEntries = []
            }
        } else {
            contextEntries = nil
        }
        let resourceHandlingOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceHandlingOption)
        resourceHandlingOption = resourceHandlingOptionDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension SimulatePrincipalPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SimulatePrincipalPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluationResults = output.evaluationResults
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.evaluationResults = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [SimulatePrincipalPolicy] or [SimulateCustomPolicy] request.
public struct SimulatePrincipalPolicyOutput: Swift.Equatable {
    /// The results of the simulation.
    public var evaluationResults: [IAMClientTypes.EvaluationResult]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        evaluationResults: [IAMClientTypes.EvaluationResult]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct SimulatePrincipalPolicyOutputBody: Swift.Equatable {
    let evaluationResults: [IAMClientTypes.EvaluationResult]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension SimulatePrincipalPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationResults = "EvaluationResults"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("SimulatePrincipalPolicyResult"))
        if containerValues.contains(.evaluationResults) {
            struct KeyVal0{struct member{}}
            let evaluationResultsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .evaluationResults)
            if let evaluationResultsWrappedContainer = evaluationResultsWrappedContainer {
                let evaluationResultsContainer = try evaluationResultsWrappedContainer.decodeIfPresent([IAMClientTypes.EvaluationResult].self, forKey: .member)
                var evaluationResultsBuffer:[IAMClientTypes.EvaluationResult]? = nil
                if let evaluationResultsContainer = evaluationResultsContainer {
                    evaluationResultsBuffer = [IAMClientTypes.EvaluationResult]()
                    for structureContainer0 in evaluationResultsContainer {
                        evaluationResultsBuffer?.append(structureContainer0)
                    }
                }
                evaluationResults = evaluationResultsBuffer
            } else {
                evaluationResults = []
            }
        } else {
            evaluationResults = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum SimulatePrincipalPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PolicyEvaluation": return try await PolicyEvaluationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension IAMClientTypes {
    public enum SortKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lastAuthenticatedTimeAscending
        case lastAuthenticatedTimeDescending
        case serviceNamespaceAscending
        case serviceNamespaceDescending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortKeyType] {
            return [
                .lastAuthenticatedTimeAscending,
                .lastAuthenticatedTimeDescending,
                .serviceNamespaceAscending,
                .serviceNamespaceDescending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lastAuthenticatedTimeAscending: return "LAST_AUTHENTICATED_TIME_ASCENDING"
            case .lastAuthenticatedTimeDescending: return "LAST_AUTHENTICATED_TIME_DESCENDING"
            case .serviceNamespaceAscending: return "SERVICE_NAMESPACE_ASCENDING"
            case .serviceNamespaceDescending: return "SERVICE_NAMESPACE_DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortKeyType(rawValue: rawValue) ?? SortKeyType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.Statement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endPosition = "EndPosition"
        case sourcePolicyId = "SourcePolicyId"
        case sourcePolicyType = "SourcePolicyType"
        case startPosition = "StartPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endPosition = endPosition {
            try container.encode(endPosition, forKey: ClientRuntime.Key("EndPosition"))
        }
        if let sourcePolicyId = sourcePolicyId {
            try container.encode(sourcePolicyId, forKey: ClientRuntime.Key("SourcePolicyId"))
        }
        if let sourcePolicyType = sourcePolicyType {
            try container.encode(sourcePolicyType, forKey: ClientRuntime.Key("SourcePolicyType"))
        }
        if let startPosition = startPosition {
            try container.encode(startPosition, forKey: ClientRuntime.Key("StartPosition"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcePolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePolicyId)
        sourcePolicyId = sourcePolicyIdDecoded
        let sourcePolicyTypeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicySourceType.self, forKey: .sourcePolicyType)
        sourcePolicyType = sourcePolicyTypeDecoded
        let startPositionDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Position.self, forKey: .startPosition)
        startPosition = startPositionDecoded
        let endPositionDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Position.self, forKey: .endPosition)
        endPosition = endPositionDecoded
    }
}

extension IAMClientTypes {
    /// Contains a reference to a Statement element in a policy document that determines the result of the simulation. This data type is used by the MatchedStatements member of the [EvaluationResult] type.
    public struct Statement: Swift.Equatable {
        /// The row and column of the end of a Statement in an IAM policy.
        public var endPosition: IAMClientTypes.Position?
        /// The identifier of the policy that was provided as an input.
        public var sourcePolicyId: Swift.String?
        /// The type of the policy.
        public var sourcePolicyType: IAMClientTypes.PolicySourceType?
        /// The row and column of the beginning of the Statement in an IAM policy.
        public var startPosition: IAMClientTypes.Position?

        public init(
            endPosition: IAMClientTypes.Position? = nil,
            sourcePolicyId: Swift.String? = nil,
            sourcePolicyType: IAMClientTypes.PolicySourceType? = nil,
            startPosition: IAMClientTypes.Position? = nil
        )
        {
            self.endPosition = endPosition
            self.sourcePolicyId = sourcePolicyId
            self.sourcePolicyType = sourcePolicyType
            self.startPosition = startPosition
        }
    }

}

extension IAMClientTypes {
    public enum StatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusType] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusType(rawValue: rawValue) ?? StatusType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes {
    public enum SummaryKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accesskeysperuserquota
        case accountaccesskeyspresent
        case accountmfaenabled
        case accountsigningcertificatespresent
        case attachedpoliciespergroupquota
        case attachedpoliciesperrolequota
        case attachedpoliciesperuserquota
        case globalendpointtokenversion
        case grouppolicysizequota
        case groups
        case groupsperuserquota
        case groupsquota
        case mfadevices
        case mfadevicesinuse
        case policies
        case policiesquota
        case policysizequota
        case policyversionsinuse
        case policyversionsinusequota
        case servercertificates
        case servercertificatesquota
        case signingcertificatesperuserquota
        case userpolicysizequota
        case users
        case usersquota
        case versionsperpolicyquota
        case sdkUnknown(Swift.String)

        public static var allCases: [SummaryKeyType] {
            return [
                .accesskeysperuserquota,
                .accountaccesskeyspresent,
                .accountmfaenabled,
                .accountsigningcertificatespresent,
                .attachedpoliciespergroupquota,
                .attachedpoliciesperrolequota,
                .attachedpoliciesperuserquota,
                .globalendpointtokenversion,
                .grouppolicysizequota,
                .groups,
                .groupsperuserquota,
                .groupsquota,
                .mfadevices,
                .mfadevicesinuse,
                .policies,
                .policiesquota,
                .policysizequota,
                .policyversionsinuse,
                .policyversionsinusequota,
                .servercertificates,
                .servercertificatesquota,
                .signingcertificatesperuserquota,
                .userpolicysizequota,
                .users,
                .usersquota,
                .versionsperpolicyquota,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accesskeysperuserquota: return "AccessKeysPerUserQuota"
            case .accountaccesskeyspresent: return "AccountAccessKeysPresent"
            case .accountmfaenabled: return "AccountMFAEnabled"
            case .accountsigningcertificatespresent: return "AccountSigningCertificatesPresent"
            case .attachedpoliciespergroupquota: return "AttachedPoliciesPerGroupQuota"
            case .attachedpoliciesperrolequota: return "AttachedPoliciesPerRoleQuota"
            case .attachedpoliciesperuserquota: return "AttachedPoliciesPerUserQuota"
            case .globalendpointtokenversion: return "GlobalEndpointTokenVersion"
            case .grouppolicysizequota: return "GroupPolicySizeQuota"
            case .groups: return "Groups"
            case .groupsperuserquota: return "GroupsPerUserQuota"
            case .groupsquota: return "GroupsQuota"
            case .mfadevices: return "MFADevices"
            case .mfadevicesinuse: return "MFADevicesInUse"
            case .policies: return "Policies"
            case .policiesquota: return "PoliciesQuota"
            case .policysizequota: return "PolicySizeQuota"
            case .policyversionsinuse: return "PolicyVersionsInUse"
            case .policyversionsinusequota: return "PolicyVersionsInUseQuota"
            case .servercertificates: return "ServerCertificates"
            case .servercertificatesquota: return "ServerCertificatesQuota"
            case .signingcertificatesperuserquota: return "SigningCertificatesPerUserQuota"
            case .userpolicysizequota: return "UserPolicySizeQuota"
            case .users: return "Users"
            case .usersquota: return "UsersQuota"
            case .versionsperpolicyquota: return "VersionsPerPolicyQuota"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SummaryKeyType(rawValue: rawValue) ?? SummaryKeyType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IAMClientTypes {
    /// A structure that represents user-provided metadata that can be associated with an IAM resource. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public struct Tag: Swift.Equatable {
        /// The key name that can be used to look up or retrieve the associated value. For example, Department or Cost Center are common choices.
        /// This member is required.
        public var key: Swift.String?
        /// The value associated with this tag. For example, tags with a key name of Department could have values such as Human Resources, Accounting, and Support. Tags with a key name of Cost Center might have values that consist of the number associated with the different cost centers in your company. Typically, many resources have tags with the same key name but with different values. Amazon Web Services always interprets the tag Value as a single string. If you need to store an array, you can store comma-separated values in the string. However, you must interpret the value in your code.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagInstanceProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagInstanceProfileInput: Swift.Equatable {
    /// The name of the IAM instance profile to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The list of tags that you want to attach to the IAM instance profile. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        instanceProfileName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.tags = tags
    }
}

struct TagInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagInstanceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagInstanceProfileOutput: Swift.Equatable {

    public init() { }
}

enum TagInstanceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension TagMFADeviceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagMFADeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagMFADeviceInput: Swift.Equatable {
    /// The unique identifier for the IAM virtual MFA device to which you want to add tags. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The list of tags that you want to attach to the IAM virtual MFA device. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        serialNumber: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.serialNumber = serialNumber
        self.tags = tags
    }
}

struct TagMFADeviceInputBody: Swift.Equatable {
    let serialNumber: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagMFADeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serialNumber = "SerialNumber"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagMFADeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagMFADeviceOutput: Swift.Equatable {

    public init() { }
}

enum TagMFADeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension TagOpenIDConnectProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagOpenIDConnectProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagOpenIDConnectProviderInput: Swift.Equatable {
    /// The ARN of the OIDC identity provider in IAM to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?
    /// The list of tags that you want to attach to the OIDC identity provider in IAM. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        openIDConnectProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.tags = tags
    }
}

struct TagOpenIDConnectProviderInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagOpenIDConnectProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagOpenIDConnectProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagOpenIDConnectProviderOutput: Swift.Equatable {

    public init() { }
}

enum TagOpenIDConnectProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension TagPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagPolicyInput: Swift.Equatable {
    /// The ARN of the IAM customer managed policy to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyArn: Swift.String?
    /// The list of tags that you want to attach to the IAM customer managed policy. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        policyArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.policyArn = policyArn
        self.tags = tags
    }
}

struct TagPolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagPolicyOutput: Swift.Equatable {

    public init() { }
}

enum TagPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension TagRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagRoleInput: Swift.Equatable {
    /// The name of the IAM role to which you want to add tags. This parameter accepts (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?
    /// The list of tags that you want to attach to the IAM role. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        roleName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.roleName = roleName
        self.tags = tags
    }
}

struct TagRoleInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagRoleOutput: Swift.Equatable {

    public init() { }
}

enum TagRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension TagSAMLProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagSAMLProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagSAMLProviderInput: Swift.Equatable {
    /// The ARN of the SAML identity provider in IAM to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var samlProviderArn: Swift.String?
    /// The list of tags that you want to attach to the SAML identity provider in IAM. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        samlProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
        self.tags = tags
    }
}

struct TagSAMLProviderInputBody: Swift.Equatable {
    let samlProviderArn: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagSAMLProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagSAMLProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagSAMLProviderOutput: Swift.Equatable {

    public init() { }
}

enum TagSAMLProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension TagServerCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagServerCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagServerCertificateInput: Swift.Equatable {
    /// The name of the IAM server certificate to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?
    /// The list of tags that you want to attach to the IAM server certificate. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        serverCertificateName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
        self.tags = tags
    }
}

struct TagServerCertificateInputBody: Swift.Equatable {
    let serverCertificateName: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagServerCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificateName = "ServerCertificateName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagServerCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagServerCertificateOutput: Swift.Equatable {

    public init() { }
}

enum TagServerCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension TagUserInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("TagUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagUserInput: Swift.Equatable {
    /// The list of tags that you want to attach to the IAM user. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?
    /// The name of the IAM user to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        tags: [IAMClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.tags = tags
        self.userName = userName
    }
}

struct TagUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagUserOutput: Swift.Equatable {

    public init() { }
}

enum TagUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension IAMClientTypes.TrackedActionLastAccessed: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionName = "ActionName"
        case lastAccessedEntity = "LastAccessedEntity"
        case lastAccessedRegion = "LastAccessedRegion"
        case lastAccessedTime = "LastAccessedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let actionName = actionName {
            try container.encode(actionName, forKey: ClientRuntime.Key("ActionName"))
        }
        if let lastAccessedEntity = lastAccessedEntity {
            try container.encode(lastAccessedEntity, forKey: ClientRuntime.Key("LastAccessedEntity"))
        }
        if let lastAccessedRegion = lastAccessedRegion {
            try container.encode(lastAccessedRegion, forKey: ClientRuntime.Key("LastAccessedRegion"))
        }
        if let lastAccessedTime = lastAccessedTime {
            try container.encodeTimestamp(lastAccessedTime, format: .dateTime, forKey: ClientRuntime.Key("LastAccessedTime"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let lastAccessedEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAccessedEntity)
        lastAccessedEntity = lastAccessedEntityDecoded
        let lastAccessedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastAccessedTime)
        lastAccessedTime = lastAccessedTimeDecoded
        let lastAccessedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAccessedRegion)
        lastAccessedRegion = lastAccessedRegionDecoded
    }
}

extension IAMClientTypes {
    /// Contains details about the most recent attempt to access an action within the service. This data type is used as a response element in the [GetServiceLastAccessedDetails] operation.
    public struct TrackedActionLastAccessed: Swift.Equatable {
        /// The name of the tracked action to which access was attempted. Tracked actions are actions that report activity to IAM.
        public var actionName: Swift.String?
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var lastAccessedEntity: Swift.String?
        /// The Region from which the authenticated entity (user or role) last attempted to access the tracked action. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAccessedRegion: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when an authenticated entity most recently attempted to access the tracked service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAccessedTime: ClientRuntime.Date?

        public init(
            actionName: Swift.String? = nil,
            lastAccessedEntity: Swift.String? = nil,
            lastAccessedRegion: Swift.String? = nil,
            lastAccessedTime: ClientRuntime.Date? = nil
        )
        {
            self.actionName = actionName
            self.lastAccessedEntity = lastAccessedEntity
            self.lastAccessedRegion = lastAccessedRegion
            self.lastAccessedTime = lastAccessedTime
        }
    }

}

extension UnmodifiableEntityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<UnmodifiableEntityExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because service-linked roles are protected Amazon Web Services resources. Only the service that depends on the service-linked role can modify or delete the role on your behalf. The error message includes the name of the service that depends on this service-linked role. You must request the change through that service.
public struct UnmodifiableEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnmodifiableEntity" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnmodifiableEntityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnmodifiableEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnrecognizedPublicKeyEncodingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<UnrecognizedPublicKeyEncodingExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because the public key encoding format is unsupported or unrecognized.
public struct UnrecognizedPublicKeyEncodingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnrecognizedPublicKeyEncoding" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnrecognizedPublicKeyEncodingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnrecognizedPublicKeyEncodingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagInstanceProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagInstanceProfileInput: Swift.Equatable {
    /// The name of the IAM instance profile from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified instance profile.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        instanceProfileName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.tagKeys = tagKeys
    }
}

struct UntagInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagInstanceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagInstanceProfileOutput: Swift.Equatable {

    public init() { }
}

enum UntagInstanceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UntagMFADeviceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagMFADeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagMFADeviceInput: Swift.Equatable {
    /// The unique identifier for the IAM virtual MFA device from which you want to remove tags. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified instance profile.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        serialNumber: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.serialNumber = serialNumber
        self.tagKeys = tagKeys
    }
}

struct UntagMFADeviceInputBody: Swift.Equatable {
    let serialNumber: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagMFADeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serialNumber = "SerialNumber"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagMFADeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagMFADeviceOutput: Swift.Equatable {

    public init() { }
}

enum UntagMFADeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UntagOpenIDConnectProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagOpenIDConnectProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagOpenIDConnectProviderInput: Swift.Equatable {
    /// The ARN of the OIDC provider in IAM from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified OIDC provider.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        openIDConnectProviderArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.tagKeys = tagKeys
    }
}

struct UntagOpenIDConnectProviderInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagOpenIDConnectProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagOpenIDConnectProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagOpenIDConnectProviderOutput: Swift.Equatable {

    public init() { }
}

enum UntagOpenIDConnectProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UntagPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagPolicyInput: Swift.Equatable {
    /// The ARN of the IAM customer managed policy from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyArn: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified policy.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        policyArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.policyArn = policyArn
        self.tagKeys = tagKeys
    }
}

struct UntagPolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagPolicyOutput: Swift.Equatable {

    public init() { }
}

enum UntagPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UntagRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagRoleInput: Swift.Equatable {
    /// The name of the IAM role from which you want to remove tags. This parameter accepts (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified role.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        roleName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.roleName = roleName
        self.tagKeys = tagKeys
    }
}

struct UntagRoleInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagRoleOutput: Swift.Equatable {

    public init() { }
}

enum UntagRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UntagSAMLProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagSAMLProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagSAMLProviderInput: Swift.Equatable {
    /// The ARN of the SAML identity provider in IAM from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var samlProviderArn: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified SAML identity provider.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        samlProviderArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
        self.tagKeys = tagKeys
    }
}

struct UntagSAMLProviderInputBody: Swift.Equatable {
    let samlProviderArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagSAMLProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagSAMLProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagSAMLProviderOutput: Swift.Equatable {

    public init() { }
}

enum UntagSAMLProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UntagServerCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagServerCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagServerCertificateInput: Swift.Equatable {
    /// The name of the IAM server certificate from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified IAM server certificate.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        serverCertificateName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
        self.tagKeys = tagKeys
    }
}

struct UntagServerCertificateInputBody: Swift.Equatable {
    let serverCertificateName: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagServerCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificateName = "ServerCertificateName"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagServerCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagServerCertificateOutput: Swift.Equatable {

    public init() { }
}

enum UntagServerCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UntagUserInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UntagUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagUserInput: Swift.Equatable {
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified user.
    /// This member is required.
    public var tagKeys: [Swift.String]?
    /// The name of the IAM user from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        tagKeys: [Swift.String]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.tagKeys = tagKeys
        self.userName = userName
    }
}

struct UntagUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagUserOutput: Swift.Equatable {

    public init() { }
}

enum UntagUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateAccessKeyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateAccessKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateAccessKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAccessKeyInput: Swift.Equatable {
    /// The access key ID of the secret access key you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var accessKeyId: Swift.String?
    /// The status you want to assign to the secret access key. Active means that the key can be used for programmatic calls to Amazon Web Services, while Inactive means that the key cannot be used.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the user whose key you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        accessKeyId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.status = status
        self.userName = userName
    }
}

struct UpdateAccessKeyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let accessKeyId: Swift.String?
    let status: IAMClientTypes.StatusType?
}

extension UpdateAccessKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case status = "Status"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateAccessKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateAccessKeyOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAccessKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateAccountPasswordPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowUsersToChangePassword = allowUsersToChangePassword {
            try container.encode(allowUsersToChangePassword, forKey: ClientRuntime.Key("AllowUsersToChangePassword"))
        }
        if let hardExpiry = hardExpiry {
            try container.encode(hardExpiry, forKey: ClientRuntime.Key("HardExpiry"))
        }
        if let maxPasswordAge = maxPasswordAge {
            try container.encode(maxPasswordAge, forKey: ClientRuntime.Key("MaxPasswordAge"))
        }
        if let minimumPasswordLength = minimumPasswordLength {
            try container.encode(minimumPasswordLength, forKey: ClientRuntime.Key("MinimumPasswordLength"))
        }
        if let passwordReusePrevention = passwordReusePrevention {
            try container.encode(passwordReusePrevention, forKey: ClientRuntime.Key("PasswordReusePrevention"))
        }
        if let requireLowercaseCharacters = requireLowercaseCharacters {
            try container.encode(requireLowercaseCharacters, forKey: ClientRuntime.Key("RequireLowercaseCharacters"))
        }
        if let requireNumbers = requireNumbers {
            try container.encode(requireNumbers, forKey: ClientRuntime.Key("RequireNumbers"))
        }
        if let requireSymbols = requireSymbols {
            try container.encode(requireSymbols, forKey: ClientRuntime.Key("RequireSymbols"))
        }
        if let requireUppercaseCharacters = requireUppercaseCharacters {
            try container.encode(requireUppercaseCharacters, forKey: ClientRuntime.Key("RequireUppercaseCharacters"))
        }
        try container.encode("UpdateAccountPasswordPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateAccountPasswordPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAccountPasswordPolicyInput: Swift.Equatable {
    /// Allows all IAM users in your account to use the Amazon Web Services Management Console to change their own passwords. For more information, see [Permitting IAM users to change their own passwords](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_passwords_enable-user-change.html) in the IAM User Guide. If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that IAM users in the account do not automatically have permissions to change their own password.
    public var allowUsersToChangePassword: Swift.Bool?
    /// Prevents IAM users who are accessing the account via the Amazon Web Services Management Console from setting a new console password after their password has expired. The IAM user cannot access the console until an administrator resets the password. If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that IAM users can change their passwords after they expire and continue to sign in as the user. In the Amazon Web Services Management Console, the custom password policy option Allow users to change their own password gives IAM users permissions to iam:ChangePassword for only their user and to the iam:GetAccountPasswordPolicy action. This option does not attach a permissions policy to each user, rather the permissions are applied at the account-level for all users by IAM. IAM users with iam:ChangePassword permission and active access keys can reset their own expired console password using the CLI or API.
    public var hardExpiry: Swift.Bool?
    /// The number of days that an IAM user password is valid. If you do not specify a value for this parameter, then the operation uses the default value of 0. The result is that IAM user passwords never expire.
    public var maxPasswordAge: Swift.Int?
    /// The minimum number of characters allowed in an IAM user password. If you do not specify a value for this parameter, then the operation uses the default value of 6.
    public var minimumPasswordLength: Swift.Int?
    /// Specifies the number of previous passwords that IAM users are prevented from reusing. If you do not specify a value for this parameter, then the operation uses the default value of 0. The result is that IAM users are not prevented from reusing previous passwords.
    public var passwordReusePrevention: Swift.Int?
    /// Specifies whether IAM user passwords must contain at least one lowercase character from the ISO basic Latin alphabet (a to z). If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one lowercase character.
    public var requireLowercaseCharacters: Swift.Bool?
    /// Specifies whether IAM user passwords must contain at least one numeric character (0 to 9). If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one numeric character.
    public var requireNumbers: Swift.Bool?
    /// Specifies whether IAM user passwords must contain at least one of the following non-alphanumeric characters: ! @ # $ % ^ & * ( ) _ + - = [ ] { } | ' If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one symbol character.
    public var requireSymbols: Swift.Bool?
    /// Specifies whether IAM user passwords must contain at least one uppercase character from the ISO basic Latin alphabet (A to Z). If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one uppercase character.
    public var requireUppercaseCharacters: Swift.Bool?

    public init(
        allowUsersToChangePassword: Swift.Bool? = nil,
        hardExpiry: Swift.Bool? = nil,
        maxPasswordAge: Swift.Int? = nil,
        minimumPasswordLength: Swift.Int? = nil,
        passwordReusePrevention: Swift.Int? = nil,
        requireLowercaseCharacters: Swift.Bool? = nil,
        requireNumbers: Swift.Bool? = nil,
        requireSymbols: Swift.Bool? = nil,
        requireUppercaseCharacters: Swift.Bool? = nil
    )
    {
        self.allowUsersToChangePassword = allowUsersToChangePassword
        self.hardExpiry = hardExpiry
        self.maxPasswordAge = maxPasswordAge
        self.minimumPasswordLength = minimumPasswordLength
        self.passwordReusePrevention = passwordReusePrevention
        self.requireLowercaseCharacters = requireLowercaseCharacters
        self.requireNumbers = requireNumbers
        self.requireSymbols = requireSymbols
        self.requireUppercaseCharacters = requireUppercaseCharacters
    }
}

struct UpdateAccountPasswordPolicyInputBody: Swift.Equatable {
    let minimumPasswordLength: Swift.Int?
    let requireSymbols: Swift.Bool?
    let requireNumbers: Swift.Bool?
    let requireUppercaseCharacters: Swift.Bool?
    let requireLowercaseCharacters: Swift.Bool?
    let allowUsersToChangePassword: Swift.Bool?
    let maxPasswordAge: Swift.Int?
    let passwordReusePrevention: Swift.Int?
    let hardExpiry: Swift.Bool?
}

extension UpdateAccountPasswordPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUsersToChangePassword = "AllowUsersToChangePassword"
        case hardExpiry = "HardExpiry"
        case maxPasswordAge = "MaxPasswordAge"
        case minimumPasswordLength = "MinimumPasswordLength"
        case passwordReusePrevention = "PasswordReusePrevention"
        case requireLowercaseCharacters = "RequireLowercaseCharacters"
        case requireNumbers = "RequireNumbers"
        case requireSymbols = "RequireSymbols"
        case requireUppercaseCharacters = "RequireUppercaseCharacters"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumPasswordLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumPasswordLength)
        minimumPasswordLength = minimumPasswordLengthDecoded
        let requireSymbolsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireSymbols) ?? false
        requireSymbols = requireSymbolsDecoded
        let requireNumbersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireNumbers) ?? false
        requireNumbers = requireNumbersDecoded
        let requireUppercaseCharactersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireUppercaseCharacters) ?? false
        requireUppercaseCharacters = requireUppercaseCharactersDecoded
        let requireLowercaseCharactersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireLowercaseCharacters) ?? false
        requireLowercaseCharacters = requireLowercaseCharactersDecoded
        let allowUsersToChangePasswordDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowUsersToChangePassword) ?? false
        allowUsersToChangePassword = allowUsersToChangePasswordDecoded
        let maxPasswordAgeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxPasswordAge)
        maxPasswordAge = maxPasswordAgeDecoded
        let passwordReusePreventionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .passwordReusePrevention)
        passwordReusePrevention = passwordReusePreventionDecoded
        let hardExpiryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hardExpiry)
        hardExpiry = hardExpiryDecoded
    }
}

extension UpdateAccountPasswordPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateAccountPasswordPolicyOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAccountPasswordPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateAssumeRolePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("UpdateAssumeRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateAssumeRolePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAssumeRolePolicyInput: Swift.Equatable {
    /// The policy that grants an entity permission to assume the role. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the role to update with the new policy. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.roleName = roleName
    }
}

struct UpdateAssumeRolePolicyInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let policyDocument: Swift.String?
}

extension UpdateAssumeRolePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension UpdateAssumeRolePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateAssumeRolePolicyOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAssumeRolePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnmodifiableEntity": return try await UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let newGroupName = newGroupName {
            try container.encode(newGroupName, forKey: ClientRuntime.Key("NewGroupName"))
        }
        if let newPath = newPath {
            try container.encode(newPath, forKey: ClientRuntime.Key("NewPath"))
        }
        try container.encode("UpdateGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateGroupInput: Swift.Equatable {
    /// Name of the IAM group to update. If you're changing the name of the group, this is the original name. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// New name for the IAM group. Only include this if changing the group's name. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    public var newGroupName: Swift.String?
    /// New path for the IAM group. Only include this if changing the group's path. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var newPath: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        newGroupName: Swift.String? = nil,
        newPath: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.newGroupName = newGroupName
        self.newPath = newPath
    }
}

struct UpdateGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let newPath: Swift.String?
    let newGroupName: Swift.String?
}

extension UpdateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case newGroupName = "NewGroupName"
        case newPath = "NewPath"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let newPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newPath)
        newPath = newPathDecoded
        let newGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newGroupName)
        newGroupName = newGroupNameDecoded
    }
}

extension UpdateGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateGroupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateLoginProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLoginProfileInput(passwordResetRequired: \(Swift.String(describing: passwordResetRequired)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

extension UpdateLoginProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let password = password {
            try container.encode(password, forKey: ClientRuntime.Key("Password"))
        }
        if let passwordResetRequired = passwordResetRequired {
            try container.encode(passwordResetRequired, forKey: ClientRuntime.Key("PasswordResetRequired"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateLoginProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateLoginProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateLoginProfileInput: Swift.Equatable {
    /// The new password for the specified IAM user. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// However, the format can be further restricted by the account administrator by setting a password policy on the Amazon Web Services account. For more information, see [UpdateAccountPasswordPolicy].
    public var password: Swift.String?
    /// Allows this new password to be used only once by requiring the specified IAM user to set a new password on next sign-in.
    public var passwordResetRequired: Swift.Bool?
    /// The name of the user whose password you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        password: Swift.String? = nil,
        passwordResetRequired: Swift.Bool? = nil,
        userName: Swift.String? = nil
    )
    {
        self.password = password
        self.passwordResetRequired = passwordResetRequired
        self.userName = userName
    }
}

struct UpdateLoginProfileInputBody: Swift.Equatable {
    let userName: Swift.String?
    let password: Swift.String?
    let passwordResetRequired: Swift.Bool?
}

extension UpdateLoginProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case passwordResetRequired = "PasswordResetRequired"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let passwordResetRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .passwordResetRequired)
        passwordResetRequired = passwordResetRequiredDecoded
    }
}

extension UpdateLoginProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateLoginProfileOutput: Swift.Equatable {

    public init() { }
}

enum UpdateLoginProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "EntityTemporarilyUnmodifiable": return try await EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PasswordPolicyViolation": return try await PasswordPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateOpenIDConnectProviderThumbprintInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        if let thumbprintList = thumbprintList {
            if !thumbprintList.isEmpty {
                var thumbprintListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ThumbprintList"))
                for (index0, thumbprinttype0) in thumbprintList.enumerated() {
                    try thumbprintListContainer.encode(thumbprinttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var thumbprintListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ThumbprintList"))
                try thumbprintListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UpdateOpenIDConnectProviderThumbprint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateOpenIDConnectProviderThumbprintInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateOpenIDConnectProviderThumbprintInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM OIDC provider resource object for which you want to update the thumbprint. You can get a list of OIDC provider ARNs by using the [ListOpenIDConnectProviders] operation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?
    /// A list of certificate thumbprints that are associated with the specified IAM OpenID Connect provider. For more information, see [CreateOpenIDConnectProvider].
    /// This member is required.
    public var thumbprintList: [Swift.String]?

    public init(
        openIDConnectProviderArn: Swift.String? = nil,
        thumbprintList: [Swift.String]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.thumbprintList = thumbprintList
    }
}

struct UpdateOpenIDConnectProviderThumbprintInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
    let thumbprintList: [Swift.String]?
}

extension UpdateOpenIDConnectProviderThumbprintInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
        case thumbprintList = "ThumbprintList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
        if containerValues.contains(.thumbprintList) {
            struct KeyVal0{struct member{}}
            let thumbprintListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .thumbprintList)
            if let thumbprintListWrappedContainer = thumbprintListWrappedContainer {
                let thumbprintListContainer = try thumbprintListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var thumbprintListBuffer:[Swift.String]? = nil
                if let thumbprintListContainer = thumbprintListContainer {
                    thumbprintListBuffer = [Swift.String]()
                    for stringContainer0 in thumbprintListContainer {
                        thumbprintListBuffer?.append(stringContainer0)
                    }
                }
                thumbprintList = thumbprintListBuffer
            } else {
                thumbprintList = []
            }
        } else {
            thumbprintList = nil
        }
    }
}

extension UpdateOpenIDConnectProviderThumbprintOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateOpenIDConnectProviderThumbprintOutput: Swift.Equatable {

    public init() { }
}

enum UpdateOpenIDConnectProviderThumbprintOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateRoleDescriptionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("UpdateRoleDescription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateRoleDescriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRoleDescriptionInput: Swift.Equatable {
    /// The new description that you want to apply to the specified role.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the role that you want to modify.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        description: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.description = description
        self.roleName = roleName
    }
}

struct UpdateRoleDescriptionInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let description: Swift.String?
}

extension UpdateRoleDescriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRoleDescriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRoleDescriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.role = output.role
        } else {
            self.role = nil
        }
    }
}

public struct UpdateRoleDescriptionOutput: Swift.Equatable {
    /// A structure that contains details about the modified role.
    public var role: IAMClientTypes.Role?

    public init(
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

struct UpdateRoleDescriptionOutputBody: Swift.Equatable {
    let role: IAMClientTypes.Role?
}

extension UpdateRoleDescriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UpdateRoleDescriptionResult"))
        let roleDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Role.self, forKey: .role)
        role = roleDecoded
    }
}

enum UpdateRoleDescriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnmodifiableEntity": return try await UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let maxSessionDuration = maxSessionDuration {
            try container.encode(maxSessionDuration, forKey: ClientRuntime.Key("MaxSessionDuration"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("UpdateRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRoleInput: Swift.Equatable {
    /// The new description that you want to apply to the specified role.
    public var description: Swift.String?
    /// The maximum session duration (in seconds) that you want to set for the specified role. If you do not specify a value for this setting, the default value of one hour is applied. This setting can have a value from 1 hour to 12 hours. Anyone who assumes the role from the CLI or API can use the DurationSeconds API parameter or the duration-seconds CLI parameter to request a longer session. The MaxSessionDuration setting determines the maximum duration that can be requested using the DurationSeconds parameter. If users don't specify a value for the DurationSeconds parameter, their security credentials are valid for one hour by default. This applies when you use the AssumeRole* API operations or the assume-role* CLI operations but does not apply when you use those operations to create a console URL. For more information, see [Using IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html) in the IAM User Guide.
    public var maxSessionDuration: Swift.Int?
    /// The name of the role that you want to modify.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        description: Swift.String? = nil,
        maxSessionDuration: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.description = description
        self.maxSessionDuration = maxSessionDuration
        self.roleName = roleName
    }
}

struct UpdateRoleInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let description: Swift.String?
    let maxSessionDuration: Swift.Int?
}

extension UpdateRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case maxSessionDuration = "MaxSessionDuration"
        case roleName = "RoleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let maxSessionDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSessionDuration)
        maxSessionDuration = maxSessionDurationDecoded
    }
}

extension UpdateRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRoleOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnmodifiableEntity": return try await UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateSAMLProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let samlMetadataDocument = samlMetadataDocument {
            try container.encode(samlMetadataDocument, forKey: ClientRuntime.Key("SAMLMetadataDocument"))
        }
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        try container.encode("UpdateSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateSAMLProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSAMLProviderInput: Swift.Equatable {
    /// An XML document generated by an identity provider (IdP) that supports SAML 2.0. The document includes the issuer's name, expiration information, and keys that can be used to validate the SAML authentication response (assertions) that are received from the IdP. You must generate the metadata document using the identity management software that is used as your organization's IdP.
    /// This member is required.
    public var samlMetadataDocument: Swift.String?
    /// The Amazon Resource Name (ARN) of the SAML provider to update. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init(
        samlMetadataDocument: Swift.String? = nil,
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlMetadataDocument = samlMetadataDocument
        self.samlProviderArn = samlProviderArn
    }
}

struct UpdateSAMLProviderInputBody: Swift.Equatable {
    let samlMetadataDocument: Swift.String?
    let samlProviderArn: Swift.String?
}

extension UpdateSAMLProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlMetadataDocument = "SAMLMetadataDocument"
        case samlProviderArn = "SAMLProviderArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlMetadataDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlMetadataDocument)
        samlMetadataDocument = samlMetadataDocumentDecoded
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
    }
}

extension UpdateSAMLProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSAMLProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.samlProviderArn = output.samlProviderArn
        } else {
            self.samlProviderArn = nil
        }
    }
}

/// Contains the response to a successful [UpdateSAMLProvider] request.
public struct UpdateSAMLProviderOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the SAML provider that was updated.
    public var samlProviderArn: Swift.String?

    public init(
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
    }
}

struct UpdateSAMLProviderOutputBody: Swift.Equatable {
    let samlProviderArn: Swift.String?
}

extension UpdateSAMLProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UpdateSAMLProviderResult"))
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
    }
}

enum UpdateSAMLProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateSSHPublicKeyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sshPublicKeyId = sshPublicKeyId {
            try container.encode(sshPublicKeyId, forKey: ClientRuntime.Key("SSHPublicKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateSSHPublicKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateSSHPublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSSHPublicKeyInput: Swift.Equatable {
    /// The unique identifier for the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// The status to assign to the SSH public key. Active means that the key can be used for authentication with an CodeCommit repository. Inactive means that the key cannot be used.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the IAM user associated with the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        sshPublicKeyId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.sshPublicKeyId = sshPublicKeyId
        self.status = status
        self.userName = userName
    }
}

struct UpdateSSHPublicKeyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let sshPublicKeyId: Swift.String?
    let status: IAMClientTypes.StatusType?
}

extension UpdateSSHPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKeyId = "SSHPublicKeyId"
        case status = "Status"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateSSHPublicKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateSSHPublicKeyOutput: Swift.Equatable {

    public init() { }
}

enum UpdateSSHPublicKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateServerCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let newPath = newPath {
            try container.encode(newPath, forKey: ClientRuntime.Key("NewPath"))
        }
        if let newServerCertificateName = newServerCertificateName {
            try container.encode(newServerCertificateName, forKey: ClientRuntime.Key("NewServerCertificateName"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        try container.encode("UpdateServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateServerCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServerCertificateInput: Swift.Equatable {
    /// The new path for the server certificate. Include this only if you are updating the server certificate's path. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var newPath: Swift.String?
    /// The new name for the server certificate. Include this only if you are updating the server certificate's name. The name of the certificate cannot contain any spaces. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var newServerCertificateName: Swift.String?
    /// The name of the server certificate that you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init(
        newPath: Swift.String? = nil,
        newServerCertificateName: Swift.String? = nil,
        serverCertificateName: Swift.String? = nil
    )
    {
        self.newPath = newPath
        self.newServerCertificateName = newServerCertificateName
        self.serverCertificateName = serverCertificateName
    }
}

struct UpdateServerCertificateInputBody: Swift.Equatable {
    let serverCertificateName: Swift.String?
    let newPath: Swift.String?
    let newServerCertificateName: Swift.String?
}

extension UpdateServerCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newPath = "NewPath"
        case newServerCertificateName = "NewServerCertificateName"
        case serverCertificateName = "ServerCertificateName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
        let newPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newPath)
        newPath = newPathDecoded
        let newServerCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newServerCertificateName)
        newServerCertificateName = newServerCertificateNameDecoded
    }
}

extension UpdateServerCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateServerCertificateOutput: Swift.Equatable {

    public init() { }
}

enum UpdateServerCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateServiceSpecificCredentialInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: ClientRuntime.Key("ServiceSpecificCredentialId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateServiceSpecificCredential", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateServiceSpecificCredentialInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServiceSpecificCredentialInput: Swift.Equatable {
    /// The unique identifier of the service-specific credential. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var serviceSpecificCredentialId: Swift.String?
    /// The status to be assigned to the service-specific credential.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the IAM user associated with the service-specific credential. If you do not specify this value, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        serviceSpecificCredentialId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.status = status
        self.userName = userName
    }
}

struct UpdateServiceSpecificCredentialInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serviceSpecificCredentialId: Swift.String?
    let status: IAMClientTypes.StatusType?
}

extension UpdateServiceSpecificCredentialInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case status = "Status"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serviceSpecificCredentialIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceSpecificCredentialId)
        serviceSpecificCredentialId = serviceSpecificCredentialIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateServiceSpecificCredentialOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateServiceSpecificCredentialOutput: Swift.Equatable {

    public init() { }
}

enum UpdateServiceSpecificCredentialOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateSigningCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateId = certificateId {
            try container.encode(certificateId, forKey: ClientRuntime.Key("CertificateId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateSigningCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateSigningCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSigningCertificateInput: Swift.Equatable {
    /// The ID of the signing certificate you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var certificateId: Swift.String?
    /// The status you want to assign to the certificate. Active means that the certificate can be used for programmatic calls to Amazon Web Services Inactive means that the certificate cannot be used.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the IAM user the signing certificate belongs to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        certificateId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
        self.status = status
        self.userName = userName
    }
}

struct UpdateSigningCertificateInputBody: Swift.Equatable {
    let userName: Swift.String?
    let certificateId: Swift.String?
    let status: IAMClientTypes.StatusType?
}

extension UpdateSigningCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
        case status = "Status"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateSigningCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateSigningCertificateOutput: Swift.Equatable {

    public init() { }
}

enum UpdateSigningCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateUserInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let newPath = newPath {
            try container.encode(newPath, forKey: ClientRuntime.Key("NewPath"))
        }
        if let newUserName = newUserName {
            try container.encode(newUserName, forKey: ClientRuntime.Key("NewUserName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// New path for the IAM user. Include this parameter only if you're changing the user's path. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var newPath: Swift.String?
    /// New name for the user. Include this parameter only if you're changing the user's name. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    public var newUserName: Swift.String?
    /// Name of the user to update. If you're changing the name of the user, this is the original user name. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        newPath: Swift.String? = nil,
        newUserName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.newPath = newPath
        self.newUserName = newUserName
        self.userName = userName
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let newPath: Swift.String?
    let newUserName: Swift.String?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newPath = "NewPath"
        case newUserName = "NewUserName"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let newPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newPath)
        newPath = newPathDecoded
        let newUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newUserName)
        newUserName = newUserNameDecoded
    }
}

extension UpdateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateUserOutput: Swift.Equatable {

    public init() { }
}

enum UpdateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "EntityTemporarilyUnmodifiable": return try await EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UploadSSHPublicKeyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sshPublicKeyBody = sshPublicKeyBody {
            try container.encode(sshPublicKeyBody, forKey: ClientRuntime.Key("SSHPublicKeyBody"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UploadSSHPublicKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UploadSSHPublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UploadSSHPublicKeyInput: Swift.Equatable {
    /// The SSH public key. The public key must be encoded in ssh-rsa format or PEM format. The minimum bit-length of the public key is 2048 bits. For example, you can generate a 2048-bit key, and the resulting PEM file is 1679 bytes long. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var sshPublicKeyBody: Swift.String?
    /// The name of the IAM user to associate the SSH public key with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        sshPublicKeyBody: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.sshPublicKeyBody = sshPublicKeyBody
        self.userName = userName
    }
}

struct UploadSSHPublicKeyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let sshPublicKeyBody: Swift.String?
}

extension UploadSSHPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKeyBody = "SSHPublicKeyBody"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
    }
}

extension UploadSSHPublicKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UploadSSHPublicKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.sshPublicKey = output.sshPublicKey
        } else {
            self.sshPublicKey = nil
        }
    }
}

/// Contains the response to a successful [UploadSSHPublicKey] request.
public struct UploadSSHPublicKeyOutput: Swift.Equatable {
    /// Contains information about the SSH public key.
    public var sshPublicKey: IAMClientTypes.SSHPublicKey?

    public init(
        sshPublicKey: IAMClientTypes.SSHPublicKey? = nil
    )
    {
        self.sshPublicKey = sshPublicKey
    }
}

struct UploadSSHPublicKeyOutputBody: Swift.Equatable {
    let sshPublicKey: IAMClientTypes.SSHPublicKey?
}

extension UploadSSHPublicKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKey = "SSHPublicKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UploadSSHPublicKeyResult"))
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(IAMClientTypes.SSHPublicKey.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

enum UploadSSHPublicKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "DuplicateSSHPublicKey": return try await DuplicateSSHPublicKeyException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidPublicKey": return try await InvalidPublicKeyException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnrecognizedPublicKeyEncoding": return try await UnrecognizedPublicKeyEncodingException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UploadServerCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadServerCertificateInput(certificateBody: \(Swift.String(describing: certificateBody)), certificateChain: \(Swift.String(describing: certificateChain)), path: \(Swift.String(describing: path)), serverCertificateName: \(Swift.String(describing: serverCertificateName)), tags: \(Swift.String(describing: tags)), privateKey: \"CONTENT_REDACTED\")"}
}

extension UploadServerCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: ClientRuntime.Key("CertificateBody"))
        }
        if let certificateChain = certificateChain {
            try container.encode(certificateChain, forKey: ClientRuntime.Key("CertificateChain"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let privateKey = privateKey {
            try container.encode(privateKey, forKey: ClientRuntime.Key("PrivateKey"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UploadServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UploadServerCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UploadServerCertificateInput: Swift.Equatable {
    /// The contents of the public key certificate in PEM-encoded format. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var certificateBody: Swift.String?
    /// The contents of the certificate chain. This is typically a concatenation of the PEM-encoded public key certificates of the chain. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var certificateChain: Swift.String?
    /// The path for the server certificate. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters. If you are uploading a server certificate specifically for use with Amazon CloudFront distributions, you must specify a path using the path parameter. The path must begin with /cloudfront and must include a trailing slash (for example, /cloudfront/test/).
    public var path: Swift.String?
    /// The contents of the private key in PEM-encoded format. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var privateKey: Swift.String?
    /// The name for the server certificate. Do not include the path in this value. The name of the certificate cannot contain any spaces. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?
    /// A list of tags that you want to attach to the new IAM server certificate resource. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        certificateBody: Swift.String? = nil,
        certificateChain: Swift.String? = nil,
        path: Swift.String? = nil,
        privateKey: Swift.String? = nil,
        serverCertificateName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.certificateBody = certificateBody
        self.certificateChain = certificateChain
        self.path = path
        self.privateKey = privateKey
        self.serverCertificateName = serverCertificateName
        self.tags = tags
    }
}

struct UploadServerCertificateInputBody: Swift.Equatable {
    let path: Swift.String?
    let serverCertificateName: Swift.String?
    let certificateBody: Swift.String?
    let privateKey: Swift.String?
    let certificateChain: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension UploadServerCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBody = "CertificateBody"
        case certificateChain = "CertificateChain"
        case path = "Path"
        case privateKey = "PrivateKey"
        case serverCertificateName = "ServerCertificateName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
        let certificateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateBody)
        certificateBody = certificateBodyDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension UploadServerCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UploadServerCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.serverCertificateMetadata = output.serverCertificateMetadata
            self.tags = output.tags
        } else {
            self.serverCertificateMetadata = nil
            self.tags = nil
        }
    }
}

/// Contains the response to a successful [UploadServerCertificate] request.
public struct UploadServerCertificateOutput: Swift.Equatable {
    /// The meta information of the uploaded server certificate without its certificate body, certificate chain, and private key.
    public var serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata?
    /// A list of tags that are attached to the new IAM server certificate. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.serverCertificateMetadata = serverCertificateMetadata
        self.tags = tags
    }
}

struct UploadServerCertificateOutputBody: Swift.Equatable {
    let serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata?
    let tags: [IAMClientTypes.Tag]?
}

extension UploadServerCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificateMetadata = "ServerCertificateMetadata"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UploadServerCertificateResult"))
        let serverCertificateMetadataDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ServerCertificateMetadata.self, forKey: .serverCertificateMetadata)
        serverCertificateMetadata = serverCertificateMetadataDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

enum UploadServerCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidInput": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "KeyPairMismatch": return try await KeyPairMismatchException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MalformedCertificate": return try await MalformedCertificateException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UploadSigningCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: ClientRuntime.Key("CertificateBody"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UploadSigningCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UploadSigningCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UploadSigningCertificateInput: Swift.Equatable {
    /// The contents of the signing certificate. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var certificateBody: Swift.String?
    /// The name of the user the signing certificate is for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        certificateBody: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.certificateBody = certificateBody
        self.userName = userName
    }
}

struct UploadSigningCertificateInputBody: Swift.Equatable {
    let userName: Swift.String?
    let certificateBody: Swift.String?
}

extension UploadSigningCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBody = "CertificateBody"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let certificateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateBody)
        certificateBody = certificateBodyDecoded
    }
}

extension UploadSigningCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UploadSigningCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

/// Contains the response to a successful [UploadSigningCertificate] request.
public struct UploadSigningCertificateOutput: Swift.Equatable {
    /// Information about the certificate.
    /// This member is required.
    public var certificate: IAMClientTypes.SigningCertificate?

    public init(
        certificate: IAMClientTypes.SigningCertificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct UploadSigningCertificateOutputBody: Swift.Equatable {
    let certificate: IAMClientTypes.SigningCertificate?
}

extension UploadSigningCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UploadSigningCertificateResult"))
        let certificateDecoded = try containerValues.decodeIfPresent(IAMClientTypes.SigningCertificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

enum UploadSigningCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "DuplicateCertificate": return try await DuplicateCertificateException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "EntityAlreadyExists": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidCertificate": return try await InvalidCertificateException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MalformedCertificate": return try await MalformedCertificateException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchEntity": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ServiceFailure": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension IAMClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case passwordLastUsed = "PasswordLastUsed"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case tags = "Tags"
        case userId = "UserId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let passwordLastUsed = passwordLastUsed {
            try container.encodeTimestamp(passwordLastUsed, format: .dateTime, forKey: ClientRuntime.Key("PasswordLastUsed"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userId = userId {
            try container.encode(userId, forKey: ClientRuntime.Key("UserId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let passwordLastUsedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .passwordLastUsed)
        passwordLastUsed = passwordLastUsedDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AttachedPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM user entity. This data type is used as a response element in the following operations:
    ///
    /// * [CreateUser]
    ///
    /// * [GetUser]
    ///
    /// * [ListUsers]
    public struct User: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the user was created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the user's password was last used to sign in to an Amazon Web Services website. For a list of Amazon Web Services websites that capture a user's last sign-in time, see the [Credential reports](https://docs.aws.amazon.com/IAM/latest/UserGuide/credential-reports.html) topic in the IAM User Guide. If a password is used more than once in a five-minute span, only the first use is returned in this field. If the field is null (no value), then it indicates that they never signed in with a password. This can be because:
        ///
        /// * The user never had a password.
        ///
        /// * A password exists but has not been used since IAM started tracking this information on October 20, 2014.
        ///
        ///
        /// A null value does not mean that the user never had a password. Also, if the user does not currently have a password but had one in the past, then this field contains the date and time the most recent password was used. This value is returned only in the [GetUser] and [ListUsers] operations.
        public var passwordLastUsed: ClientRuntime.Date?
        /// The path to the user. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. The ARN of the policy used to set the permissions boundary for the user.
        /// This member is required.
        public var path: Swift.String?
        /// For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// A list of tags that are associated with the user. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The stable and unique string identifying the user. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var userId: Swift.String?
        /// The friendly name identifying the user.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            passwordLastUsed: ClientRuntime.Date? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            userId: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.passwordLastUsed = passwordLastUsed
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.tags = tags
            self.userId = userId
            self.userName = userName
        }
    }

}

extension IAMClientTypes.UserDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case groupList = "GroupList"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case tags = "Tags"
        case userId = "UserId"
        case userName = "UserName"
        case userPolicyList = "UserPolicyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let attachedManagedPolicies = attachedManagedPolicies {
            if !attachedManagedPolicies.isEmpty {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                for (index0, attachedpolicy0) in attachedManagedPolicies.enumerated() {
                    try attachedManagedPoliciesContainer.encode(attachedpolicy0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                try attachedManagedPoliciesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let groupList = groupList {
            if !groupList.isEmpty {
                var groupListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupList"))
                for (index0, groupnametype0) in groupList.enumerated() {
                    try groupListContainer.encode(groupnametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var groupListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupList"))
                try groupListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userId = userId {
            try container.encode(userId, forKey: ClientRuntime.Key("UserId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        if let userPolicyList = userPolicyList {
            if !userPolicyList.isEmpty {
                var userPolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("UserPolicyList"))
                for (index0, policydetail0) in userPolicyList.enumerated() {
                    try userPolicyListContainer.encode(policydetail0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var userPolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("UserPolicyList"))
                try userPolicyListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        if containerValues.contains(.userPolicyList) {
            struct KeyVal0{struct member{}}
            let userPolicyListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .userPolicyList)
            if let userPolicyListWrappedContainer = userPolicyListWrappedContainer {
                let userPolicyListContainer = try userPolicyListWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyDetail].self, forKey: .member)
                var userPolicyListBuffer:[IAMClientTypes.PolicyDetail]? = nil
                if let userPolicyListContainer = userPolicyListContainer {
                    userPolicyListBuffer = [IAMClientTypes.PolicyDetail]()
                    for structureContainer0 in userPolicyListContainer {
                        userPolicyListBuffer?.append(structureContainer0)
                    }
                }
                userPolicyList = userPolicyListBuffer
            } else {
                userPolicyList = []
            }
        } else {
            userPolicyList = nil
        }
        if containerValues.contains(.groupList) {
            struct KeyVal0{struct member{}}
            let groupListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groupList)
            if let groupListWrappedContainer = groupListWrappedContainer {
                let groupListContainer = try groupListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var groupListBuffer:[Swift.String]? = nil
                if let groupListContainer = groupListContainer {
                    groupListBuffer = [Swift.String]()
                    for stringContainer0 in groupListContainer {
                        groupListBuffer?.append(stringContainer0)
                    }
                }
                groupList = groupListBuffer
            } else {
                groupList = []
            }
        } else {
            groupList = nil
        }
        if containerValues.contains(.attachedManagedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedManagedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedManagedPolicies)
            if let attachedManagedPoliciesWrappedContainer = attachedManagedPoliciesWrappedContainer {
                let attachedManagedPoliciesContainer = try attachedManagedPoliciesWrappedContainer.decodeIfPresent([IAMClientTypes.AttachedPolicy].self, forKey: .member)
                var attachedManagedPoliciesBuffer:[IAMClientTypes.AttachedPolicy]? = nil
                if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
                    attachedManagedPoliciesBuffer = [IAMClientTypes.AttachedPolicy]()
                    for structureContainer0 in attachedManagedPoliciesContainer {
                        attachedManagedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedManagedPolicies = attachedManagedPoliciesBuffer
            } else {
                attachedManagedPolicies = []
            }
        } else {
            attachedManagedPolicies = nil
        }
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AttachedPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM user, including all the user's policies and all the IAM groups the user is in. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct UserDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// A list of the managed policies attached to the user.
        public var attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the user was created.
        public var createDate: ClientRuntime.Date?
        /// A list of IAM groups that the user is in.
        public var groupList: [Swift.String]?
        /// The path to the user. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The ARN of the policy used to set the permissions boundary for the user. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// A list of tags that are associated with the user. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The stable and unique string identifying the user. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var userId: Swift.String?
        /// The friendly name identifying the user.
        public var userName: Swift.String?
        /// A list of the inline policies embedded in the user.
        public var userPolicyList: [IAMClientTypes.PolicyDetail]?

        public init(
            arn: Swift.String? = nil,
            attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
            createDate: ClientRuntime.Date? = nil,
            groupList: [Swift.String]? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            userId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userPolicyList: [IAMClientTypes.PolicyDetail]? = nil
        )
        {
            self.arn = arn
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupList = groupList
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.tags = tags
            self.userId = userId
            self.userName = userName
            self.userPolicyList = userPolicyList
        }
    }

}

extension IAMClientTypes.VirtualMFADevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base32StringSeed = "Base32StringSeed"
        case enableDate = "EnableDate"
        case qrCodePNG = "QRCodePNG"
        case serialNumber = "SerialNumber"
        case tags = "Tags"
        case user = "User"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let base32StringSeed = base32StringSeed {
            try container.encode(base32StringSeed.base64EncodedString(), forKey: ClientRuntime.Key("Base32StringSeed"))
        }
        if let enableDate = enableDate {
            try container.encodeTimestamp(enableDate, format: .dateTime, forKey: ClientRuntime.Key("EnableDate"))
        }
        if let qrCodePNG = qrCodePNG {
            try container.encode(qrCodePNG.base64EncodedString(), forKey: ClientRuntime.Key("QRCodePNG"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let user = user {
            try container.encode(user, forKey: ClientRuntime.Key("User"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        if containerValues.contains(.base32StringSeed) {
            do {
                let base32StringSeedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .base32StringSeed)
                base32StringSeed = base32StringSeedDecoded
            } catch {
                base32StringSeed = "".data(using: .utf8)
            }
        } else {
            base32StringSeed = nil
        }
        if containerValues.contains(.qrCodePNG) {
            do {
                let qrCodePNGDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .qrCodePNG)
                qrCodePNG = qrCodePNGDecoded
            } catch {
                qrCodePNG = "".data(using: .utf8)
            }
        } else {
            qrCodePNG = nil
        }
        let userDecoded = try containerValues.decodeIfPresent(IAMClientTypes.User.self, forKey: .user)
        user = userDecoded
        let enableDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .enableDate)
        enableDate = enableDateDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension IAMClientTypes.VirtualMFADevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VirtualMFADevice(enableDate: \(Swift.String(describing: enableDate)), serialNumber: \(Swift.String(describing: serialNumber)), tags: \(Swift.String(describing: tags)), user: \(Swift.String(describing: user)), base32StringSeed: \"CONTENT_REDACTED\", qrCodePNG: \"CONTENT_REDACTED\")"}
}

extension IAMClientTypes {
    /// Contains information about a virtual MFA device.
    public struct VirtualMFADevice: Swift.Equatable {
        /// The base32 seed defined as specified in [RFC3548](https://tools.ietf.org/html/rfc3548.txt). The Base32StringSeed is base32-encoded.
        public var base32StringSeed: ClientRuntime.Data?
        /// The date and time on which the virtual MFA device was enabled.
        public var enableDate: ClientRuntime.Date?
        /// A QR code PNG image that encodes otpauth://totp/$virtualMFADeviceName@$AccountName?secret=$Base32String where $virtualMFADeviceName is one of the create call arguments. AccountName is the user name if set (otherwise, the account ID otherwise), and Base32String is the seed in base32 format. The Base32String value is base64-encoded.
        public var qrCodePNG: ClientRuntime.Data?
        /// The serial number associated with VirtualMFADevice.
        /// This member is required.
        public var serialNumber: Swift.String?
        /// A list of tags that are attached to the virtual MFA device. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The IAM user associated with this virtual MFA device.
        public var user: IAMClientTypes.User?

        public init(
            base32StringSeed: ClientRuntime.Data? = nil,
            enableDate: ClientRuntime.Date? = nil,
            qrCodePNG: ClientRuntime.Data? = nil,
            serialNumber: Swift.String? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            user: IAMClientTypes.User? = nil
        )
        {
            self.base32StringSeed = base32StringSeed
            self.enableDate = enableDate
            self.qrCodePNG = qrCodePNG
            self.serialNumber = serialNumber
            self.tags = tags
            self.user = user
        }
    }

}
