// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyReadWrite
import SmithyXML

extension IAMClientTypes {
    public enum AccessAdvisorUsageGranularityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actionLevel
        case serviceLevel
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessAdvisorUsageGranularityType] {
            return [
                .actionLevel,
                .serviceLevel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actionLevel: return "ACTION_LEVEL"
            case .serviceLevel: return "SERVICE_LEVEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessAdvisorUsageGranularityType(rawValue: rawValue) ?? AccessAdvisorUsageGranularityType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.AccessDetail: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityPath = "EntityPath"
        case lastAuthenticatedTime = "LastAuthenticatedTime"
        case region = "Region"
        case serviceName = "ServiceName"
        case serviceNamespace = "ServiceNamespace"
        case totalAuthenticatedEntities = "TotalAuthenticatedEntities"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let entityPath = entityPath {
            try container.encode(entityPath, forKey: ClientRuntime.Key("EntityPath"))
        }
        if let lastAuthenticatedTime = lastAuthenticatedTime {
            try container.encodeTimestamp(lastAuthenticatedTime, format: .dateTime, forKey: ClientRuntime.Key("LastAuthenticatedTime"))
        }
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: ClientRuntime.Key("ServiceNamespace"))
        }
        if let totalAuthenticatedEntities = totalAuthenticatedEntities {
            try container.encode(totalAuthenticatedEntities, forKey: ClientRuntime.Key("TotalAuthenticatedEntities"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.AccessDetail, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.AccessDetail()
            value.serviceName = try reader["ServiceName"].readIfPresent()
            value.serviceNamespace = try reader["ServiceNamespace"].readIfPresent()
            value.region = try reader["Region"].readIfPresent()
            value.entityPath = try reader["EntityPath"].readIfPresent()
            value.lastAuthenticatedTime = try reader["LastAuthenticatedTime"].readTimestampIfPresent(format: .dateTime)
            value.totalAuthenticatedEntities = try reader["TotalAuthenticatedEntities"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// An object that contains details about when a principal in the reported Organizations entity last attempted to access an Amazon Web Services service. A principal can be an IAM user, an IAM role, or the Amazon Web Services account root user within the reported Organizations entity. This data type is a response element in the [GetOrganizationsAccessReport] operation.
    public struct AccessDetail: Swift.Equatable {
        /// The path of the Organizations entity (root, organizational unit, or account) from which an authenticated principal last attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no principals (IAM users, IAM roles, or root user) in the reported Organizations entity attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var entityPath: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when an authenticated principal most recently attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no principals in the reported Organizations entity attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticatedTime: ClientRuntime.Date?
        /// The Region where the last service access attempt occurred. This field is null if no principals in the reported Organizations entity attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var region: Swift.String?
        /// The name of the service in which access was attempted.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The namespace of the service in which access was attempted. To learn the service namespace of a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the Service Authorization Reference. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
        /// This member is required.
        public var serviceNamespace: Swift.String?
        /// The number of accounts with authenticated principals (root user, IAM users, and IAM roles) that attempted to access the service in the tracking period.
        public var totalAuthenticatedEntities: Swift.Int?

        public init(
            entityPath: Swift.String? = nil,
            lastAuthenticatedTime: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceNamespace: Swift.String? = nil,
            totalAuthenticatedEntities: Swift.Int? = nil
        )
        {
            self.entityPath = entityPath
            self.lastAuthenticatedTime = lastAuthenticatedTime
            self.region = region
            self.serviceName = serviceName
            self.serviceNamespace = serviceNamespace
            self.totalAuthenticatedEntities = totalAuthenticatedEntities
        }
    }

}

extension IAMClientTypes.AccessKey: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case createDate = "CreateDate"
        case secretAccessKey = "SecretAccessKey"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let secretAccessKey = secretAccessKey {
            try container.encode(secretAccessKey, forKey: ClientRuntime.Key("SecretAccessKey"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.AccessKey, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.AccessKey()
            value.userName = try reader["UserName"].readIfPresent()
            value.accessKeyId = try reader["AccessKeyId"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.secretAccessKey = try reader["SecretAccessKey"].readIfPresent()
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            return value
        }
    }
}

extension IAMClientTypes.AccessKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessKey(accessKeyId: \(Swift.String(describing: accessKeyId)), createDate: \(Swift.String(describing: createDate)), status: \(Swift.String(describing: status)), userName: \(Swift.String(describing: userName)), secretAccessKey: \"CONTENT_REDACTED\")"}
}

extension IAMClientTypes {
    /// Contains information about an Amazon Web Services access key. This data type is used as a response element in the [CreateAccessKey] and [ListAccessKeys] operations. The SecretAccessKey value is returned only in response to [CreateAccessKey]. You can get a secret access key only when you first create an access key; you cannot recover the secret access key later. If you lose a secret access key, you must create a new access key.
    public struct AccessKey: Swift.Equatable {
        /// The ID for this access key.
        /// This member is required.
        public var accessKeyId: Swift.String?
        /// The date when the access key was created.
        public var createDate: ClientRuntime.Date?
        /// The secret key used to sign requests.
        /// This member is required.
        public var secretAccessKey: Swift.String?
        /// The status of the access key. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user that the access key is associated with.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            secretAccessKey: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.createDate = createDate
            self.secretAccessKey = secretAccessKey
            self.status = status
            self.userName = userName
        }
    }

}

extension IAMClientTypes.AccessKeyLastUsed: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUsedDate = "LastUsedDate"
        case region = "Region"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let lastUsedDate = lastUsedDate {
            try container.encodeTimestamp(lastUsedDate, format: .dateTime, forKey: ClientRuntime.Key("LastUsedDate"))
        }
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.AccessKeyLastUsed, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.AccessKeyLastUsed()
            value.lastUsedDate = try reader["LastUsedDate"].readTimestampIfPresent(format: .dateTime)
            value.serviceName = try reader["ServiceName"].readIfPresent()
            value.region = try reader["Region"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about the last time an Amazon Web Services access key was used since IAM began tracking this information on April 22, 2015. This data type is used as a response element in the [GetAccessKeyLastUsed] operation.
    public struct AccessKeyLastUsed: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the access key was most recently used. This field is null in the following situations:
        ///
        /// * The user does not have an access key.
        ///
        /// * An access key exists but has not been used since IAM began tracking this information.
        ///
        /// * There is no sign-in data associated with the user.
        /// This member is required.
        public var lastUsedDate: ClientRuntime.Date?
        /// The Amazon Web Services Region where this access key was most recently used. The value for this field is "N/A" in the following situations:
        ///
        /// * The user does not have an access key.
        ///
        /// * An access key exists but has not been used since IAM began tracking this information.
        ///
        /// * There is no sign-in data associated with the user.
        ///
        ///
        /// For more information about Amazon Web Services Regions, see [Regions and endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html) in the Amazon Web Services General Reference.
        /// This member is required.
        public var region: Swift.String?
        /// The name of the Amazon Web Services service with which this access key was most recently used. The value of this field is "N/A" in the following situations:
        ///
        /// * The user does not have an access key.
        ///
        /// * An access key exists but has not been used since IAM started tracking this information.
        ///
        /// * There is no sign-in data associated with the user.
        /// This member is required.
        public var serviceName: Swift.String?

        public init(
            lastUsedDate: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.lastUsedDate = lastUsedDate
            self.region = region
            self.serviceName = serviceName
        }
    }

}

extension IAMClientTypes.AccessKeyMetadata: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case createDate = "CreateDate"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.AccessKeyMetadata, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.AccessKeyMetadata()
            value.userName = try reader["UserName"].readIfPresent()
            value.accessKeyId = try reader["AccessKeyId"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an Amazon Web Services access key, without its secret key. This data type is used as a response element in the [ListAccessKeys] operation.
    public struct AccessKeyMetadata: Swift.Equatable {
        /// The ID for this access key.
        public var accessKeyId: Swift.String?
        /// The date when the access key was created.
        public var createDate: ClientRuntime.Date?
        /// The status of the access key. Active means that the key is valid for API calls; Inactive means it is not.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user that the key is associated with.
        public var userName: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.createDate = createDate
            self.status = status
            self.userName = userName
        }
    }

}

extension AddClientIDToOpenIDConnectProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientID = "ClientID"
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clientID = clientID {
            try container.encode(clientID, forKey: ClientRuntime.Key("ClientID"))
        }
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        try container.encode("AddClientIDToOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddClientIDToOpenIDConnectProviderInput {

    static func urlPathProvider(_ value: AddClientIDToOpenIDConnectProviderInput) -> Swift.String? {
        return "/"
    }
}

public struct AddClientIDToOpenIDConnectProviderInput: Swift.Equatable {
    /// The client ID (also known as audience) to add to the IAM OpenID Connect provider resource.
    /// This member is required.
    public var clientID: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM OpenID Connect (OIDC) provider resource to add the client ID to. You can get a list of OIDC provider ARNs by using the [ListOpenIDConnectProviders] operation.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init(
        clientID: Swift.String? = nil,
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.clientID = clientID
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

extension AddClientIDToOpenIDConnectProviderOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<AddClientIDToOpenIDConnectProviderOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return AddClientIDToOpenIDConnectProviderOutput()
        }
    }
}

public struct AddClientIDToOpenIDConnectProviderOutput: Swift.Equatable {

    public init() { }
}

enum AddClientIDToOpenIDConnectProviderOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension AddRoleToInstanceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("AddRoleToInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddRoleToInstanceProfileInput {

    static func urlPathProvider(_ value: AddRoleToInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

public struct AddRoleToInstanceProfileInput: Swift.Equatable {
    /// The name of the instance profile to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The name of the role to add. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        instanceProfileName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.roleName = roleName
    }
}

extension AddRoleToInstanceProfileOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<AddRoleToInstanceProfileOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return AddRoleToInstanceProfileOutput()
        }
    }
}

public struct AddRoleToInstanceProfileOutput: Swift.Equatable {

    public init() { }
}

enum AddRoleToInstanceProfileOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnmodifiableEntity": return try await UnmodifiableEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension AddUserToGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("AddUserToGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddUserToGroupInput {

    static func urlPathProvider(_ value: AddUserToGroupInput) -> Swift.String? {
        return "/"
    }
}

public struct AddUserToGroupInput: Swift.Equatable {
    /// The name of the group to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the user to add. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.userName = userName
    }
}

extension AddUserToGroupOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<AddUserToGroupOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return AddUserToGroupOutput()
        }
    }
}

public struct AddUserToGroupOutput: Swift.Equatable {

    public init() { }
}

enum AddUserToGroupOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension IAMClientTypes {
    public enum AssignmentStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case any
        case assigned
        case unassigned
        case sdkUnknown(Swift.String)

        public static var allCases: [AssignmentStatusType] {
            return [
                .any,
                .assigned,
                .unassigned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .any: return "Any"
            case .assigned: return "Assigned"
            case .unassigned: return "Unassigned"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssignmentStatusType(rawValue: rawValue) ?? AssignmentStatusType.sdkUnknown(rawValue)
        }
    }
}

extension AttachGroupPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("AttachGroupPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AttachGroupPolicyInput {

    static func urlPathProvider(_ value: AttachGroupPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct AttachGroupPolicyInput: Swift.Equatable {
    /// The name (friendly name, not ARN) of the group to attach the policy to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyArn = policyArn
    }
}

extension AttachGroupPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<AttachGroupPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return AttachGroupPolicyOutput()
        }
    }
}

public struct AttachGroupPolicyOutput: Swift.Equatable {

    public init() { }
}

enum AttachGroupPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PolicyNotAttachable": return try await PolicyNotAttachableException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension AttachRolePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("AttachRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AttachRolePolicyInput {

    static func urlPathProvider(_ value: AttachRolePolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct AttachRolePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the role to attach the policy to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.roleName = roleName
    }
}

extension AttachRolePolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<AttachRolePolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return AttachRolePolicyOutput()
        }
    }
}

public struct AttachRolePolicyOutput: Swift.Equatable {

    public init() { }
}

enum AttachRolePolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PolicyNotAttachable": return try await PolicyNotAttachableException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnmodifiableEntity": return try await UnmodifiableEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension AttachUserPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("AttachUserPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AttachUserPolicyInput {

    static func urlPathProvider(_ value: AttachUserPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct AttachUserPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the IAM user to attach the policy to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.userName = userName
    }
}

extension AttachUserPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<AttachUserPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return AttachUserPolicyOutput()
        }
    }
}

public struct AttachUserPolicyOutput: Swift.Equatable {

    public init() { }
}

enum AttachUserPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PolicyNotAttachable": return try await PolicyNotAttachableException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension IAMClientTypes.AttachedPermissionsBoundary: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionsBoundaryArn = "PermissionsBoundaryArn"
        case permissionsBoundaryType = "PermissionsBoundaryType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let permissionsBoundaryArn = permissionsBoundaryArn {
            try container.encode(permissionsBoundaryArn, forKey: ClientRuntime.Key("PermissionsBoundaryArn"))
        }
        if let permissionsBoundaryType = permissionsBoundaryType {
            try container.encode(permissionsBoundaryType, forKey: ClientRuntime.Key("PermissionsBoundaryType"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.AttachedPermissionsBoundary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.AttachedPermissionsBoundary()
            value.permissionsBoundaryType = try reader["PermissionsBoundaryType"].readIfPresent()
            value.permissionsBoundaryArn = try reader["PermissionsBoundaryArn"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an attached permissions boundary. An attached permissions boundary is a managed policy that has been attached to a user or role to set the permissions boundary. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
    public struct AttachedPermissionsBoundary: Swift.Equatable {
        /// The ARN of the policy used to set the permissions boundary for the user or role.
        public var permissionsBoundaryArn: Swift.String?
        /// The permissions boundary usage type that indicates what type of IAM resource is used as the permissions boundary for an entity. This data type can only have a value of Policy.
        public var permissionsBoundaryType: IAMClientTypes.PermissionsBoundaryAttachmentType?

        public init(
            permissionsBoundaryArn: Swift.String? = nil,
            permissionsBoundaryType: IAMClientTypes.PermissionsBoundaryAttachmentType? = nil
        )
        {
            self.permissionsBoundaryArn = permissionsBoundaryArn
            self.permissionsBoundaryType = permissionsBoundaryType
        }
    }

}

extension IAMClientTypes.AttachedPolicy: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.AttachedPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.AttachedPolicy()
            value.policyName = try reader["PolicyName"].readIfPresent()
            value.policyArn = try reader["PolicyArn"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an attached policy. An attached policy is a managed policy that has been attached to a user, group, or role. This data type is used as a response element in the [ListAttachedGroupPolicies], [ListAttachedRolePolicies], [ListAttachedUserPolicies], and [GetAccountAuthorizationDetails] operations. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct AttachedPolicy: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var policyArn: Swift.String?
        /// The friendly name of the attached policy.
        public var policyName: Swift.String?

        public init(
            policyArn: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.policyArn = policyArn
            self.policyName = policyName
        }
    }

}

extension ChangePasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChangePasswordInput(newPassword: \"CONTENT_REDACTED\", oldPassword: \"CONTENT_REDACTED\")"}
}

extension ChangePasswordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newPassword = "NewPassword"
        case oldPassword = "OldPassword"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let newPassword = newPassword {
            try container.encode(newPassword, forKey: ClientRuntime.Key("NewPassword"))
        }
        if let oldPassword = oldPassword {
            try container.encode(oldPassword, forKey: ClientRuntime.Key("OldPassword"))
        }
        try container.encode("ChangePassword", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ChangePasswordInput {

    static func urlPathProvider(_ value: ChangePasswordInput) -> Swift.String? {
        return "/"
    }
}

public struct ChangePasswordInput: Swift.Equatable {
    /// The new password. The new password must conform to the Amazon Web Services account's password policy, if one exists. The [regex pattern](http://wikipedia.org/wiki/regex) that is used to validate this parameter is a string of characters. That string can include almost any printable ASCII character from the space (\u0020) through the end of the ASCII character range (\u00FF). You can also include the tab (\u0009), line feed (\u000A), and carriage return (\u000D) characters. Any of these characters are valid in a password. However, many tools, such as the Amazon Web Services Management Console, might restrict the ability to type certain characters because they have special meaning within that tool.
    /// This member is required.
    public var newPassword: Swift.String?
    /// The IAM user's current password.
    /// This member is required.
    public var oldPassword: Swift.String?

    public init(
        newPassword: Swift.String? = nil,
        oldPassword: Swift.String? = nil
    )
    {
        self.newPassword = newPassword
        self.oldPassword = oldPassword
    }
}

extension ChangePasswordOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ChangePasswordOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return ChangePasswordOutput()
        }
    }
}

public struct ChangePasswordOutput: Swift.Equatable {

    public init() { }
}

enum ChangePasswordOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "EntityTemporarilyUnmodifiable": return try await EntityTemporarilyUnmodifiableException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidUserType": return try await InvalidUserTypeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PasswordPolicyViolation": return try await PasswordPolicyViolationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ConcurrentModificationException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ConcurrentModificationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because multiple requests to change this object were submitted simultaneously. Wait a few minutes and submit your request again.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModification" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IAMClientTypes.ContextEntry: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextKeyName = "ContextKeyName"
        case contextKeyType = "ContextKeyType"
        case contextKeyValues = "ContextKeyValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let contextKeyName = contextKeyName {
            try container.encode(contextKeyName, forKey: ClientRuntime.Key("ContextKeyName"))
        }
        if let contextKeyType = contextKeyType {
            try container.encode(contextKeyType, forKey: ClientRuntime.Key("ContextKeyType"))
        }
        if let contextKeyValues = contextKeyValues {
            if !contextKeyValues.isEmpty {
                var contextKeyValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextKeyValues"))
                for (index0, contextkeyvaluetype0) in contextKeyValues.enumerated() {
                    try contextKeyValuesContainer.encode(contextkeyvaluetype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var contextKeyValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextKeyValues"))
                try contextKeyValuesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.ContextEntry, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.ContextEntry()
            value.contextKeyName = try reader["ContextKeyName"].readIfPresent()
            value.contextKeyValues = try reader["ContextKeyValues"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.contextKeyType = try reader["ContextKeyType"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a condition context key. It includes the name of the key and specifies the value (or values, if the context key supports multiple values) to use in the simulation. This information is used when evaluating the Condition elements of the input policies. This data type is used as an input parameter to [SimulateCustomPolicy] and [SimulatePrincipalPolicy].
    public struct ContextEntry: Swift.Equatable {
        /// The full name of a condition context key, including the service prefix. For example, aws:SourceIp or s3:VersionId.
        public var contextKeyName: Swift.String?
        /// The data type of the value (or values) specified in the ContextKeyValues parameter.
        public var contextKeyType: IAMClientTypes.ContextKeyTypeEnum?
        /// The value (or values, if the condition context key supports multiple values) to provide to the simulation when the key is referenced by a Condition element in an input policy.
        public var contextKeyValues: [Swift.String]?

        public init(
            contextKeyName: Swift.String? = nil,
            contextKeyType: IAMClientTypes.ContextKeyTypeEnum? = nil,
            contextKeyValues: [Swift.String]? = nil
        )
        {
            self.contextKeyName = contextKeyName
            self.contextKeyType = contextKeyType
            self.contextKeyValues = contextKeyValues
        }
    }

}

extension IAMClientTypes {
    public enum ContextKeyTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case binary
        case binaryList
        case boolean
        case booleanList
        case date
        case dateList
        case ip
        case ipList
        case numeric
        case numericList
        case string
        case stringList
        case sdkUnknown(Swift.String)

        public static var allCases: [ContextKeyTypeEnum] {
            return [
                .binary,
                .binaryList,
                .boolean,
                .booleanList,
                .date,
                .dateList,
                .ip,
                .ipList,
                .numeric,
                .numericList,
                .string,
                .stringList,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .binary: return "binary"
            case .binaryList: return "binaryList"
            case .boolean: return "boolean"
            case .booleanList: return "booleanList"
            case .date: return "date"
            case .dateList: return "dateList"
            case .ip: return "ip"
            case .ipList: return "ipList"
            case .numeric: return "numeric"
            case .numericList: return "numericList"
            case .string: return "string"
            case .stringList: return "stringList"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContextKeyTypeEnum(rawValue: rawValue) ?? ContextKeyTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension CreateAccessKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("CreateAccessKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateAccessKeyInput {

    static func urlPathProvider(_ value: CreateAccessKeyInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateAccessKeyInput: Swift.Equatable {
    /// The name of the IAM user that the new key will belong to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

extension CreateAccessKeyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateAccessKeyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreateAccessKeyResult"]
            var value = CreateAccessKeyOutput()
            value.accessKey = try reader["AccessKey"].readIfPresent(readingClosure: IAMClientTypes.AccessKey.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [CreateAccessKey] request.
public struct CreateAccessKeyOutput: Swift.Equatable {
    /// A structure with details about the access key.
    /// This member is required.
    public var accessKey: IAMClientTypes.AccessKey?

    public init(
        accessKey: IAMClientTypes.AccessKey? = nil
    )
    {
        self.accessKey = accessKey
    }
}

enum CreateAccessKeyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateAccountAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAlias = "AccountAlias"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountAlias = accountAlias {
            try container.encode(accountAlias, forKey: ClientRuntime.Key("AccountAlias"))
        }
        try container.encode("CreateAccountAlias", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateAccountAliasInput {

    static func urlPathProvider(_ value: CreateAccountAliasInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateAccountAliasInput: Swift.Equatable {
    /// The account alias to create. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have two dashes in a row.
    /// This member is required.
    public var accountAlias: Swift.String?

    public init(
        accountAlias: Swift.String? = nil
    )
    {
        self.accountAlias = accountAlias
    }
}

extension CreateAccountAliasOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateAccountAliasOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return CreateAccountAliasOutput()
        }
    }
}

public struct CreateAccountAliasOutput: Swift.Equatable {

    public init() { }
}

enum CreateAccountAliasOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        try container.encode("CreateGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateGroupInput {

    static func urlPathProvider(_ value: CreateGroupInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateGroupInput: Swift.Equatable {
    /// The name of the group to create. Do not include the path in this value. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    /// This member is required.
    public var groupName: Swift.String?
    /// The path to the group. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        path: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.path = path
    }
}

extension CreateGroupOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateGroupOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreateGroupResult"]
            var value = CreateGroupOutput()
            value.group = try reader["Group"].readIfPresent(readingClosure: IAMClientTypes.Group.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [CreateGroup] request.
public struct CreateGroupOutput: Swift.Equatable {
    /// A structure containing details about the new group.
    /// This member is required.
    public var group: IAMClientTypes.Group?

    public init(
        group: IAMClientTypes.Group? = nil
    )
    {
        self.group = group
    }
}

enum CreateGroupOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateInstanceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case path = "Path"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("CreateInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateInstanceProfileInput {

    static func urlPathProvider(_ value: CreateInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateInstanceProfileInput: Swift.Equatable {
    /// The name of the instance profile to create. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The path to the instance profile. For more information about paths, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// A list of tags that you want to attach to the newly created IAM instance profile. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        instanceProfileName: Swift.String? = nil,
        path: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.path = path
        self.tags = tags
    }
}

extension CreateInstanceProfileOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateInstanceProfileOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreateInstanceProfileResult"]
            var value = CreateInstanceProfileOutput()
            value.instanceProfile = try reader["InstanceProfile"].readIfPresent(readingClosure: IAMClientTypes.InstanceProfile.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [CreateInstanceProfile] request.
public struct CreateInstanceProfileOutput: Swift.Equatable {
    /// A structure containing details about the new instance profile.
    /// This member is required.
    public var instanceProfile: IAMClientTypes.InstanceProfile?

    public init(
        instanceProfile: IAMClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

enum CreateInstanceProfileOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateLoginProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLoginProfileInput(passwordResetRequired: \(Swift.String(describing: passwordResetRequired)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

extension CreateLoginProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case passwordResetRequired = "PasswordResetRequired"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let password = password {
            try container.encode(password, forKey: ClientRuntime.Key("Password"))
        }
        if let passwordResetRequired = passwordResetRequired {
            try container.encode(passwordResetRequired, forKey: ClientRuntime.Key("PasswordResetRequired"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("CreateLoginProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateLoginProfileInput {

    static func urlPathProvider(_ value: CreateLoginProfileInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateLoginProfileInput: Swift.Equatable {
    /// The new password for the user. The [regex pattern](http://wikipedia.org/wiki/regex) that is used to validate this parameter is a string of characters. That string can include almost any printable ASCII character from the space (\u0020) through the end of the ASCII character range (\u00FF). You can also include the tab (\u0009), line feed (\u000A), and carriage return (\u000D) characters. Any of these characters are valid in a password. However, many tools, such as the Amazon Web Services Management Console, might restrict the ability to type certain characters because they have special meaning within that tool.
    /// This member is required.
    public var password: Swift.String?
    /// Specifies whether the user is required to set a new password on next sign-in.
    public var passwordResetRequired: Swift.Bool?
    /// The name of the IAM user to create a password for. The user must already exist. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        password: Swift.String? = nil,
        passwordResetRequired: Swift.Bool? = nil,
        userName: Swift.String? = nil
    )
    {
        self.password = password
        self.passwordResetRequired = passwordResetRequired
        self.userName = userName
    }
}

extension CreateLoginProfileOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateLoginProfileOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreateLoginProfileResult"]
            var value = CreateLoginProfileOutput()
            value.loginProfile = try reader["LoginProfile"].readIfPresent(readingClosure: IAMClientTypes.LoginProfile.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [CreateLoginProfile] request.
public struct CreateLoginProfileOutput: Swift.Equatable {
    /// A structure containing the user name and password create date.
    /// This member is required.
    public var loginProfile: IAMClientTypes.LoginProfile?

    public init(
        loginProfile: IAMClientTypes.LoginProfile? = nil
    )
    {
        self.loginProfile = loginProfile
    }
}

enum CreateLoginProfileOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PasswordPolicyViolation": return try await PasswordPolicyViolationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateOpenIDConnectProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIDList = "ClientIDList"
        case tags = "Tags"
        case thumbprintList = "ThumbprintList"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clientIDList = clientIDList {
            if !clientIDList.isEmpty {
                var clientIDListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClientIDList"))
                for (index0, clientidtype0) in clientIDList.enumerated() {
                    try clientIDListContainer.encode(clientidtype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var clientIDListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClientIDList"))
                try clientIDListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let thumbprintList = thumbprintList {
            if !thumbprintList.isEmpty {
                var thumbprintListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ThumbprintList"))
                for (index0, thumbprinttype0) in thumbprintList.enumerated() {
                    try thumbprintListContainer.encode(thumbprinttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var thumbprintListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ThumbprintList"))
                try thumbprintListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let url = url {
            try container.encode(url, forKey: ClientRuntime.Key("Url"))
        }
        try container.encode("CreateOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateOpenIDConnectProviderInput {

    static func urlPathProvider(_ value: CreateOpenIDConnectProviderInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateOpenIDConnectProviderInput: Swift.Equatable {
    /// Provides a list of client IDs, also known as audiences. When a mobile or web app registers with an OpenID Connect provider, they establish a value that identifies the application. This is the value that's sent as the client_id parameter on OAuth requests. You can register multiple client IDs with the same provider. For example, you might have multiple applications that use the same OIDC provider. You cannot register more than 100 client IDs with a single IAM OIDC provider. There is no defined format for a client ID. The CreateOpenIDConnectProviderRequest operation accepts client IDs up to 255 characters long.
    public var clientIDList: [Swift.String]?
    /// A list of tags that you want to attach to the new IAM OpenID Connect (OIDC) provider. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?
    /// A list of server certificate thumbprints for the OpenID Connect (OIDC) identity provider's server certificates. Typically this list includes only one entry. However, IAM lets you have up to five thumbprints for an OIDC provider. This lets you maintain multiple thumbprints if the identity provider is rotating certificates. The server certificate thumbprint is the hex-encoded SHA-1 hash value of the X.509 certificate used by the domain where the OpenID Connect provider makes its keys available. It is always a 40-character string. You must provide at least one thumbprint when creating an IAM OIDC provider. For example, assume that the OIDC provider is server.example.com and the provider stores its keys at https://keys.server.example.com/openid-connect. In that case, the thumbprint string would be the hex-encoded SHA-1 hash value of the certificate used by https://keys.server.example.com. For more information about obtaining the OIDC provider thumbprint, see [Obtaining the thumbprint for an OpenID Connect provider](https://docs.aws.amazon.com/IAM/latest/UserGuide/identity-providers-oidc-obtain-thumbprint.html) in the IAM user Guide.
    /// This member is required.
    public var thumbprintList: [Swift.String]?
    /// The URL of the identity provider. The URL must begin with https:// and should correspond to the iss claim in the provider's OpenID Connect ID tokens. Per the OIDC standard, path components are allowed but query parameters are not. Typically the URL consists of only a hostname, like https://server.example.org or https://example.com. The URL should not contain a port number. You cannot register the same provider multiple times in a single Amazon Web Services account. If you try to submit a URL that has already been used for an OpenID Connect provider in the Amazon Web Services account, you will get an error.
    /// This member is required.
    public var url: Swift.String?

    public init(
        clientIDList: [Swift.String]? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        thumbprintList: [Swift.String]? = nil,
        url: Swift.String? = nil
    )
    {
        self.clientIDList = clientIDList
        self.tags = tags
        self.thumbprintList = thumbprintList
        self.url = url
    }
}

extension CreateOpenIDConnectProviderOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateOpenIDConnectProviderOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreateOpenIDConnectProviderResult"]
            var value = CreateOpenIDConnectProviderOutput()
            value.openIDConnectProviderArn = try reader["OpenIDConnectProviderArn"].readIfPresent()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [CreateOpenIDConnectProvider] request.
public struct CreateOpenIDConnectProviderOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new IAM OpenID Connect provider that is created. For more information, see [OpenIDConnectProviderListEntry].
    public var openIDConnectProviderArn: Swift.String?
    /// A list of tags that are attached to the new IAM OIDC provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        openIDConnectProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.tags = tags
    }
}

enum CreateOpenIDConnectProviderOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreatePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case path = "Path"
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("CreatePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreatePolicyInput {

    static func urlPathProvider(_ value: CreatePolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct CreatePolicyInput: Swift.Equatable {
    /// A friendly description of the policy. Typically used to store information about the permissions defined in the policy. For example, "Grants access to production DynamoDB tables." The policy description is immutable. After a value is assigned, it cannot be changed.
    public var description: Swift.String?
    /// The path for the policy. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters. You cannot use an asterisk (*) in the path name.
    public var path: Swift.String?
    /// The JSON policy document that you want to use as the content for the new policy. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). To learn more about JSON policy grammar, see [Grammar of the IAM JSON policy language](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_grammar.html) in the IAM User Guide. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The friendly name of the policy. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    /// This member is required.
    public var policyName: Swift.String?
    /// A list of tags that you want to attach to the new IAM customer managed policy. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        path: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.path = path
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.tags = tags
    }
}

extension CreatePolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreatePolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreatePolicyResult"]
            var value = CreatePolicyOutput()
            value.policy = try reader["Policy"].readIfPresent(readingClosure: IAMClientTypes.Policy.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [CreatePolicy] request.
public struct CreatePolicyOutput: Swift.Equatable {
    /// A structure containing details about the new policy.
    public var policy: IAMClientTypes.Policy?

    public init(
        policy: IAMClientTypes.Policy? = nil
    )
    {
        self.policy = policy
    }
}

enum CreatePolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreatePolicyVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case policyDocument = "PolicyDocument"
        case setAsDefault = "SetAsDefault"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let setAsDefault = setAsDefault {
            try container.encode(setAsDefault, forKey: ClientRuntime.Key("SetAsDefault"))
        }
        try container.encode("CreatePolicyVersion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreatePolicyVersionInput {

    static func urlPathProvider(_ value: CreatePolicyVersionInput) -> Swift.String? {
        return "/"
    }
}

public struct CreatePolicyVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy to which you want to add a new version. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The JSON policy document that you want to use as the content for this new version of the policy. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// Specifies whether to set this version as the policy's default version. When this parameter is true, the new policy version becomes the operative version. That is, it becomes the version that is in effect for the IAM users, groups, and roles that the policy is attached to. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    public var setAsDefault: Swift.Bool?

    public init(
        policyArn: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        setAsDefault: Swift.Bool? = nil
    )
    {
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.setAsDefault = setAsDefault
    }
}

extension CreatePolicyVersionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreatePolicyVersionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreatePolicyVersionResult"]
            var value = CreatePolicyVersionOutput()
            value.policyVersion = try reader["PolicyVersion"].readIfPresent(readingClosure: IAMClientTypes.PolicyVersion.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [CreatePolicyVersion] request.
public struct CreatePolicyVersionOutput: Swift.Equatable {
    /// A structure containing details about the new policy version.
    public var policyVersion: IAMClientTypes.PolicyVersion?

    public init(
        policyVersion: IAMClientTypes.PolicyVersion? = nil
    )
    {
        self.policyVersion = policyVersion
    }
}

enum CreatePolicyVersionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
        case description = "Description"
        case maxSessionDuration = "MaxSessionDuration"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case roleName = "RoleName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let assumeRolePolicyDocument = assumeRolePolicyDocument {
            try container.encode(assumeRolePolicyDocument, forKey: ClientRuntime.Key("AssumeRolePolicyDocument"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let maxSessionDuration = maxSessionDuration {
            try container.encode(maxSessionDuration, forKey: ClientRuntime.Key("MaxSessionDuration"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("CreateRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateRoleInput {

    static func urlPathProvider(_ value: CreateRoleInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateRoleInput: Swift.Equatable {
    /// The trust relationship policy document that grants an entity permission to assume the role. In IAM, you must provide a JSON policy that has been converted to a string. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// Upon success, the response includes the same trust policy in JSON format.
    /// This member is required.
    public var assumeRolePolicyDocument: Swift.String?
    /// A description of the role.
    public var description: Swift.String?
    /// The maximum session duration (in seconds) that you want to set for the specified role. If you do not specify a value for this setting, the default value of one hour is applied. This setting can have a value from 1 hour to 12 hours. Anyone who assumes the role from the CLI or API can use the DurationSeconds API parameter or the duration-seconds CLI parameter to request a longer session. The MaxSessionDuration setting determines the maximum duration that can be requested using the DurationSeconds parameter. If users don't specify a value for the DurationSeconds parameter, their security credentials are valid for one hour by default. This applies when you use the AssumeRole* API operations or the assume-role* CLI operations but does not apply when you use those operations to create a console URL. For more information, see [Using IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html) in the IAM User Guide.
    public var maxSessionDuration: Swift.Int?
    /// The path to the role. For more information about paths, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// The ARN of the managed policy that is used to set the permissions boundary for the role. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    public var permissionsBoundary: Swift.String?
    /// The name of the role to create. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource". This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?
    /// A list of tags that you want to attach to the new role. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        assumeRolePolicyDocument: Swift.String? = nil,
        description: Swift.String? = nil,
        maxSessionDuration: Swift.Int? = nil,
        path: Swift.String? = nil,
        permissionsBoundary: Swift.String? = nil,
        roleName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.assumeRolePolicyDocument = assumeRolePolicyDocument
        self.description = description
        self.maxSessionDuration = maxSessionDuration
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.roleName = roleName
        self.tags = tags
    }
}

extension CreateRoleOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateRoleOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreateRoleResult"]
            var value = CreateRoleOutput()
            value.role = try reader["Role"].readIfPresent(readingClosure: IAMClientTypes.Role.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [CreateRole] request.
public struct CreateRoleOutput: Swift.Equatable {
    /// A structure containing details about the new role.
    /// This member is required.
    public var role: IAMClientTypes.Role?

    public init(
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

enum CreateRoleOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateSAMLProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case samlMetadataDocument = "SAMLMetadataDocument"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let samlMetadataDocument = samlMetadataDocument {
            try container.encode(samlMetadataDocument, forKey: ClientRuntime.Key("SAMLMetadataDocument"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("CreateSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateSAMLProviderInput {

    static func urlPathProvider(_ value: CreateSAMLProviderInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateSAMLProviderInput: Swift.Equatable {
    /// The name of the provider to create. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var name: Swift.String?
    /// An XML document generated by an identity provider (IdP) that supports SAML 2.0. The document includes the issuer's name, expiration information, and keys that can be used to validate the SAML authentication response (assertions) that are received from the IdP. You must generate the metadata document using the identity management software that is used as your organization's IdP. For more information, see [About SAML 2.0-based federation](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_saml.html) in the IAM User Guide
    /// This member is required.
    public var samlMetadataDocument: Swift.String?
    /// A list of tags that you want to attach to the new IAM SAML provider. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        name: Swift.String? = nil,
        samlMetadataDocument: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.name = name
        self.samlMetadataDocument = samlMetadataDocument
        self.tags = tags
    }
}

extension CreateSAMLProviderOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateSAMLProviderOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreateSAMLProviderResult"]
            var value = CreateSAMLProviderOutput()
            value.samlProviderArn = try reader["SAMLProviderArn"].readIfPresent()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [CreateSAMLProvider] request.
public struct CreateSAMLProviderOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new SAML provider resource in IAM.
    public var samlProviderArn: Swift.String?
    /// A list of tags that are attached to the new IAM SAML provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        samlProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
        self.tags = tags
    }
}

enum CreateSAMLProviderOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateServiceLinkedRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsServiceName = "AWSServiceName"
        case customSuffix = "CustomSuffix"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let awsServiceName = awsServiceName {
            try container.encode(awsServiceName, forKey: ClientRuntime.Key("AWSServiceName"))
        }
        if let customSuffix = customSuffix {
            try container.encode(customSuffix, forKey: ClientRuntime.Key("CustomSuffix"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        try container.encode("CreateServiceLinkedRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateServiceLinkedRoleInput {

    static func urlPathProvider(_ value: CreateServiceLinkedRoleInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateServiceLinkedRoleInput: Swift.Equatable {
    /// The service principal for the Amazon Web Services service to which this role is attached. You use a string similar to a URL but without the http:// in front. For example: elasticbeanstalk.amazonaws.com. Service principals are unique and case-sensitive. To find the exact service principal for your service-linked role, see [Amazon Web Services services that work with IAM](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html) in the IAM User Guide. Look for the services that have Yes in the Service-Linked Role column. Choose the Yes link to view the service-linked role documentation for that service.
    /// This member is required.
    public var awsServiceName: Swift.String?
    /// A string that you provide, which is combined with the service-provided prefix to form the complete role name. If you make multiple requests for the same service, then you must supply a different CustomSuffix for each request. Otherwise the request fails with a duplicate role name error. For example, you could add -1 or -debug to the suffix. Some services do not support the CustomSuffix parameter. If you provide an optional suffix and the operation fails, try the operation again without the suffix.
    public var customSuffix: Swift.String?
    /// The description of the role.
    public var description: Swift.String?

    public init(
        awsServiceName: Swift.String? = nil,
        customSuffix: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.awsServiceName = awsServiceName
        self.customSuffix = customSuffix
        self.description = description
    }
}

extension CreateServiceLinkedRoleOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateServiceLinkedRoleOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreateServiceLinkedRoleResult"]
            var value = CreateServiceLinkedRoleOutput()
            value.role = try reader["Role"].readIfPresent(readingClosure: IAMClientTypes.Role.readingClosure)
            return value
        }
    }
}

public struct CreateServiceLinkedRoleOutput: Swift.Equatable {
    /// A [Role] object that contains details about the newly created role.
    public var role: IAMClientTypes.Role?

    public init(
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

enum CreateServiceLinkedRoleOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateServiceSpecificCredentialInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName = "ServiceName"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("CreateServiceSpecificCredential", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateServiceSpecificCredentialInput {

    static func urlPathProvider(_ value: CreateServiceSpecificCredentialInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateServiceSpecificCredentialInput: Swift.Equatable {
    /// The name of the Amazon Web Services service that is to be associated with the credentials. The service you specify here is the only service that can be accessed using these credentials.
    /// This member is required.
    public var serviceName: Swift.String?
    /// The name of the IAM user that is to be associated with the credentials. The new service-specific credentials have the same permissions as the associated user except that they can be used only to access the specified service. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serviceName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceName = serviceName
        self.userName = userName
    }
}

extension CreateServiceSpecificCredentialOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateServiceSpecificCredentialOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreateServiceSpecificCredentialResult"]
            var value = CreateServiceSpecificCredentialOutput()
            value.serviceSpecificCredential = try reader["ServiceSpecificCredential"].readIfPresent(readingClosure: IAMClientTypes.ServiceSpecificCredential.readingClosure)
            return value
        }
    }
}

public struct CreateServiceSpecificCredentialOutput: Swift.Equatable {
    /// A structure that contains information about the newly created service-specific credential. This is the only time that the password for this credential set is available. It cannot be recovered later. Instead, you must reset the password with [ResetServiceSpecificCredential].
    public var serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential?

    public init(
        serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential? = nil
    )
    {
        self.serviceSpecificCredential = serviceSpecificCredential
    }
}

enum CreateServiceSpecificCredentialOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotSupportedService": return try await ServiceNotSupportedException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("CreateUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateUserInput {

    static func urlPathProvider(_ value: CreateUserInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The path for the user name. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// The ARN of the managed policy that is used to set the permissions boundary for the user. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    public var permissionsBoundary: Swift.String?
    /// A list of tags that you want to attach to the new user. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?
    /// The name of the user to create. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    /// This member is required.
    public var userName: Swift.String?

    public init(
        path: Swift.String? = nil,
        permissionsBoundary: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.tags = tags
        self.userName = userName
    }
}

extension CreateUserOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateUserOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreateUserResult"]
            var value = CreateUserOutput()
            value.user = try reader["User"].readIfPresent(readingClosure: IAMClientTypes.User.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [CreateUser] request.
public struct CreateUserOutput: Swift.Equatable {
    /// A structure with details about the new IAM user.
    public var user: IAMClientTypes.User?

    public init(
        user: IAMClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

enum CreateUserOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateVirtualMFADeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "Path"
        case tags = "Tags"
        case virtualMFADeviceName = "VirtualMFADeviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let virtualMFADeviceName = virtualMFADeviceName {
            try container.encode(virtualMFADeviceName, forKey: ClientRuntime.Key("VirtualMFADeviceName"))
        }
        try container.encode("CreateVirtualMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateVirtualMFADeviceInput {

    static func urlPathProvider(_ value: CreateVirtualMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateVirtualMFADeviceInput: Swift.Equatable {
    /// The path for the virtual MFA device. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// A list of tags that you want to attach to the new IAM virtual MFA device. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?
    /// The name of the virtual MFA device, which must be unique. Use with path to uniquely identify a virtual MFA device. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var virtualMFADeviceName: Swift.String?

    public init(
        path: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        virtualMFADeviceName: Swift.String? = nil
    )
    {
        self.path = path
        self.tags = tags
        self.virtualMFADeviceName = virtualMFADeviceName
    }
}

extension CreateVirtualMFADeviceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateVirtualMFADeviceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreateVirtualMFADeviceResult"]
            var value = CreateVirtualMFADeviceOutput()
            value.virtualMFADevice = try reader["VirtualMFADevice"].readIfPresent(readingClosure: IAMClientTypes.VirtualMFADevice.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [CreateVirtualMFADevice] request.
public struct CreateVirtualMFADeviceOutput: Swift.Equatable {
    /// A structure containing details about the new virtual MFA device.
    /// This member is required.
    public var virtualMFADevice: IAMClientTypes.VirtualMFADevice?

    public init(
        virtualMFADevice: IAMClientTypes.VirtualMFADevice? = nil
    )
    {
        self.virtualMFADevice = virtualMFADevice
    }
}

enum CreateVirtualMFADeviceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CredentialReportExpiredException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = CredentialReportExpiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the most recent credential report has expired. To generate a new credential report, use [GenerateCredentialReport]. For more information about credential report expiration, see [Getting credential reports](https://docs.aws.amazon.com/IAM/latest/UserGuide/credential-reports.html) in the IAM User Guide.
public struct CredentialReportExpiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReportExpired" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CredentialReportNotPresentException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = CredentialReportNotPresentException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the credential report does not exist. To generate a credential report, use [GenerateCredentialReport].
public struct CredentialReportNotPresentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReportNotPresent" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CredentialReportNotReadyException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = CredentialReportNotReadyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the credential report is still being generated.
public struct CredentialReportNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReportInProgress" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DeactivateMFADeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeactivateMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeactivateMFADeviceInput {

    static func urlPathProvider(_ value: DeactivateMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

public struct DeactivateMFADeviceInput: Swift.Equatable {
    /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: =,.@:/-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The name of the user whose MFA device you want to deactivate. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

extension DeactivateMFADeviceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeactivateMFADeviceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeactivateMFADeviceOutput()
        }
    }
}

public struct DeactivateMFADeviceOutput: Swift.Equatable {

    public init() { }
}

enum DeactivateMFADeviceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EntityTemporarilyUnmodifiable": return try await EntityTemporarilyUnmodifiableException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteAccessKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteAccessKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteAccessKeyInput {

    static func urlPathProvider(_ value: DeleteAccessKeyInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteAccessKeyInput: Swift.Equatable {
    /// The access key ID for the access key ID and secret access key you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var accessKeyId: Swift.String?
    /// The name of the user whose access key pair you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        accessKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.userName = userName
    }
}

extension DeleteAccessKeyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteAccessKeyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteAccessKeyOutput()
        }
    }
}

public struct DeleteAccessKeyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessKeyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteAccountAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAlias = "AccountAlias"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountAlias = accountAlias {
            try container.encode(accountAlias, forKey: ClientRuntime.Key("AccountAlias"))
        }
        try container.encode("DeleteAccountAlias", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteAccountAliasInput {

    static func urlPathProvider(_ value: DeleteAccountAliasInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteAccountAliasInput: Swift.Equatable {
    /// The name of the account alias to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have two dashes in a row.
    /// This member is required.
    public var accountAlias: Swift.String?

    public init(
        accountAlias: Swift.String? = nil
    )
    {
        self.accountAlias = accountAlias
    }
}

extension DeleteAccountAliasOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteAccountAliasOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteAccountAliasOutput()
        }
    }
}

public struct DeleteAccountAliasOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccountAliasOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteAccountPasswordPolicyInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("DeleteAccountPasswordPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteAccountPasswordPolicyInput {

    static func urlPathProvider(_ value: DeleteAccountPasswordPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteAccountPasswordPolicyInput: Swift.Equatable {

    public init() { }
}

extension DeleteAccountPasswordPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteAccountPasswordPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteAccountPasswordPolicyOutput()
        }
    }
}

public struct DeleteAccountPasswordPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccountPasswordPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteConflictException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = DeleteConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because it attempted to delete a resource that has attached subordinate entities. The error message describes these entities.
public struct DeleteConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeleteConflict" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DeleteGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        try container.encode("DeleteGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteGroupInput {

    static func urlPathProvider(_ value: DeleteGroupInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteGroupInput: Swift.Equatable {
    /// The name of the IAM group to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?

    public init(
        groupName: Swift.String? = nil
    )
    {
        self.groupName = groupName
    }
}

extension DeleteGroupOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteGroupOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteGroupOutput()
        }
    }
}

public struct DeleteGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGroupOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "DeleteConflict": return try await DeleteConflictException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteGroupPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        try container.encode("DeleteGroupPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteGroupPolicyInput {

    static func urlPathProvider(_ value: DeleteGroupPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteGroupPolicyInput: Swift.Equatable {
    /// The name (friendly name, not ARN) identifying the group that the policy is embedded in. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name identifying the policy document to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyName = policyName
    }
}

extension DeleteGroupPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteGroupPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteGroupPolicyOutput()
        }
    }
}

public struct DeleteGroupPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGroupPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteInstanceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        try container.encode("DeleteInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteInstanceProfileInput {

    static func urlPathProvider(_ value: DeleteInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteInstanceProfileInput: Swift.Equatable {
    /// The name of the instance profile to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?

    public init(
        instanceProfileName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
    }
}

extension DeleteInstanceProfileOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteInstanceProfileOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteInstanceProfileOutput()
        }
    }
}

public struct DeleteInstanceProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteInstanceProfileOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "DeleteConflict": return try await DeleteConflictException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteLoginProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteLoginProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteLoginProfileInput {

    static func urlPathProvider(_ value: DeleteLoginProfileInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteLoginProfileInput: Swift.Equatable {
    /// The name of the user whose password you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

extension DeleteLoginProfileOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteLoginProfileOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteLoginProfileOutput()
        }
    }
}

public struct DeleteLoginProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLoginProfileOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "EntityTemporarilyUnmodifiable": return try await EntityTemporarilyUnmodifiableException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteOpenIDConnectProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        try container.encode("DeleteOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteOpenIDConnectProviderInput {

    static func urlPathProvider(_ value: DeleteOpenIDConnectProviderInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteOpenIDConnectProviderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM OpenID Connect provider resource object to delete. You can get a list of OpenID Connect provider resource ARNs by using the [ListOpenIDConnectProviders] operation.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init(
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

extension DeleteOpenIDConnectProviderOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteOpenIDConnectProviderOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteOpenIDConnectProviderOutput()
        }
    }
}

public struct DeleteOpenIDConnectProviderOutput: Swift.Equatable {

    public init() { }
}

enum DeleteOpenIDConnectProviderOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeletePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("DeletePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeletePolicyInput {

    static func urlPathProvider(_ value: DeletePolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct DeletePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to delete. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        policyArn: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

extension DeletePolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeletePolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeletePolicyOutput()
        }
    }
}

public struct DeletePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeletePolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "DeleteConflict": return try await DeleteConflictException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeletePolicyVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
        try container.encode("DeletePolicyVersion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeletePolicyVersionInput {

    static func urlPathProvider(_ value: DeletePolicyVersionInput) -> Swift.String? {
        return "/"
    }
}

public struct DeletePolicyVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy from which you want to delete a version. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The policy version to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consists of the lowercase letter 'v' followed by one or two digits, and optionally followed by a period '.' and a string of letters and digits. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.versionId = versionId
    }
}

extension DeletePolicyVersionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeletePolicyVersionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeletePolicyVersionOutput()
        }
    }
}

public struct DeletePolicyVersionOutput: Swift.Equatable {

    public init() { }
}

enum DeletePolicyVersionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "DeleteConflict": return try await DeleteConflictException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("DeleteRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteRoleInput {

    static func urlPathProvider(_ value: DeleteRoleInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteRoleInput: Swift.Equatable {
    /// The name of the role to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

extension DeleteRoleOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteRoleOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteRoleOutput()
        }
    }
}

public struct DeleteRoleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRoleOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DeleteConflict": return try await DeleteConflictException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnmodifiableEntity": return try await UnmodifiableEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteRolePermissionsBoundaryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("DeleteRolePermissionsBoundary", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteRolePermissionsBoundaryInput {

    static func urlPathProvider(_ value: DeleteRolePermissionsBoundaryInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteRolePermissionsBoundaryInput: Swift.Equatable {
    /// The name (friendly name, not ARN) of the IAM role from which you want to remove the permissions boundary.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

extension DeleteRolePermissionsBoundaryOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteRolePermissionsBoundaryOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteRolePermissionsBoundaryOutput()
        }
    }
}

public struct DeleteRolePermissionsBoundaryOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRolePermissionsBoundaryOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnmodifiableEntity": return try await UnmodifiableEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteRolePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("DeleteRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteRolePolicyInput {

    static func urlPathProvider(_ value: DeleteRolePolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteRolePolicyInput: Swift.Equatable {
    /// The name of the inline policy to delete from the specified IAM role. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name (friendly name, not ARN) identifying the role that the policy is embedded in. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.roleName = roleName
    }
}

extension DeleteRolePolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteRolePolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteRolePolicyOutput()
        }
    }
}

public struct DeleteRolePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRolePolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnmodifiableEntity": return try await UnmodifiableEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteSAMLProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        try container.encode("DeleteSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteSAMLProviderInput {

    static func urlPathProvider(_ value: DeleteSAMLProviderInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteSAMLProviderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the SAML provider to delete.
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init(
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
    }
}

extension DeleteSAMLProviderOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteSAMLProviderOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteSAMLProviderOutput()
        }
    }
}

public struct DeleteSAMLProviderOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSAMLProviderOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteSSHPublicKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKeyId = "SSHPublicKeyId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sshPublicKeyId = sshPublicKeyId {
            try container.encode(sshPublicKeyId, forKey: ClientRuntime.Key("SSHPublicKeyId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteSSHPublicKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteSSHPublicKeyInput {

    static func urlPathProvider(_ value: DeleteSSHPublicKeyInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteSSHPublicKeyInput: Swift.Equatable {
    /// The unique identifier for the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// The name of the IAM user associated with the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

extension DeleteSSHPublicKeyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteSSHPublicKeyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteSSHPublicKeyOutput()
        }
    }
}

public struct DeleteSSHPublicKeyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSSHPublicKeyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteServerCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificateName = "ServerCertificateName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        try container.encode("DeleteServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteServerCertificateInput {

    static func urlPathProvider(_ value: DeleteServerCertificateInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteServerCertificateInput: Swift.Equatable {
    /// The name of the server certificate you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init(
        serverCertificateName: Swift.String? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
    }
}

extension DeleteServerCertificateOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteServerCertificateOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteServerCertificateOutput()
        }
    }
}

public struct DeleteServerCertificateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteServerCertificateOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "DeleteConflict": return try await DeleteConflictException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteServiceLinkedRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("DeleteServiceLinkedRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteServiceLinkedRoleInput {

    static func urlPathProvider(_ value: DeleteServiceLinkedRoleInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteServiceLinkedRoleInput: Swift.Equatable {
    /// The name of the service-linked role to be deleted.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

extension DeleteServiceLinkedRoleOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteServiceLinkedRoleOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DeleteServiceLinkedRoleResult"]
            var value = DeleteServiceLinkedRoleOutput()
            value.deletionTaskId = try reader["DeletionTaskId"].readIfPresent()
            return value
        }
    }
}

public struct DeleteServiceLinkedRoleOutput: Swift.Equatable {
    /// The deletion task identifier that you can use to check the status of the deletion. This identifier is returned in the format task/aws-service-role///.
    /// This member is required.
    public var deletionTaskId: Swift.String?

    public init(
        deletionTaskId: Swift.String? = nil
    )
    {
        self.deletionTaskId = deletionTaskId
    }
}

enum DeleteServiceLinkedRoleOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteServiceSpecificCredentialInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: ClientRuntime.Key("ServiceSpecificCredentialId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteServiceSpecificCredential", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteServiceSpecificCredentialInput {

    static func urlPathProvider(_ value: DeleteServiceSpecificCredentialInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteServiceSpecificCredentialInput: Swift.Equatable {
    /// The unique identifier of the service-specific credential. You can get this value by calling [ListServiceSpecificCredentials]. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var serviceSpecificCredentialId: Swift.String?
    /// The name of the IAM user associated with the service-specific credential. If this value is not specified, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        serviceSpecificCredentialId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.userName = userName
    }
}

extension DeleteServiceSpecificCredentialOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteServiceSpecificCredentialOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteServiceSpecificCredentialOutput()
        }
    }
}

public struct DeleteServiceSpecificCredentialOutput: Swift.Equatable {

    public init() { }
}

enum DeleteServiceSpecificCredentialOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteSigningCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateId = certificateId {
            try container.encode(certificateId, forKey: ClientRuntime.Key("CertificateId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteSigningCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteSigningCertificateInput {

    static func urlPathProvider(_ value: DeleteSigningCertificateInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteSigningCertificateInput: Swift.Equatable {
    /// The ID of the signing certificate to delete. The format of this parameter, as described by its [regex](http://wikipedia.org/wiki/regex) pattern, is a string of characters that can be upper- or lower-cased letters or digits.
    /// This member is required.
    public var certificateId: Swift.String?
    /// The name of the user the signing certificate belongs to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        certificateId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
        self.userName = userName
    }
}

extension DeleteSigningCertificateOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteSigningCertificateOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteSigningCertificateOutput()
        }
    }
}

public struct DeleteSigningCertificateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSigningCertificateOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteUserInput {

    static func urlPathProvider(_ value: DeleteUserInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The name of the user to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

extension DeleteUserOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteUserOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteUserOutput()
        }
    }
}

public struct DeleteUserOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DeleteConflict": return try await DeleteConflictException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteUserPermissionsBoundaryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteUserPermissionsBoundary", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteUserPermissionsBoundaryInput {

    static func urlPathProvider(_ value: DeleteUserPermissionsBoundaryInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteUserPermissionsBoundaryInput: Swift.Equatable {
    /// The name (friendly name, not ARN) of the IAM user from which you want to remove the permissions boundary.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

extension DeleteUserPermissionsBoundaryOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteUserPermissionsBoundaryOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteUserPermissionsBoundaryOutput()
        }
    }
}

public struct DeleteUserPermissionsBoundaryOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserPermissionsBoundaryOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteUserPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteUserPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteUserPolicyInput {

    static func urlPathProvider(_ value: DeleteUserPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteUserPolicyInput: Swift.Equatable {
    /// The name identifying the policy document to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name (friendly name, not ARN) identifying the user that the policy is embedded in. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.userName = userName
    }
}

extension DeleteUserPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteUserPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteUserPolicyOutput()
        }
    }
}

public struct DeleteUserPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteVirtualMFADeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serialNumber = "SerialNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        try container.encode("DeleteVirtualMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteVirtualMFADeviceInput {

    static func urlPathProvider(_ value: DeleteVirtualMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteVirtualMFADeviceInput: Swift.Equatable {
    /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: =,.@:/-
    /// This member is required.
    public var serialNumber: Swift.String?

    public init(
        serialNumber: Swift.String? = nil
    )
    {
        self.serialNumber = serialNumber
    }
}

extension DeleteVirtualMFADeviceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteVirtualMFADeviceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteVirtualMFADeviceOutput()
        }
    }
}

public struct DeleteVirtualMFADeviceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVirtualMFADeviceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DeleteConflict": return try await DeleteConflictException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension IAMClientTypes.DeletionTaskFailureReasonType: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "Reason"
        case roleUsageList = "RoleUsageList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let reason = reason {
            try container.encode(reason, forKey: ClientRuntime.Key("Reason"))
        }
        if let roleUsageList = roleUsageList {
            if !roleUsageList.isEmpty {
                var roleUsageListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RoleUsageList"))
                for (index0, roleusagetype0) in roleUsageList.enumerated() {
                    try roleUsageListContainer.encode(roleusagetype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var roleUsageListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RoleUsageList"))
                try roleUsageListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.DeletionTaskFailureReasonType, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.DeletionTaskFailureReasonType()
            value.reason = try reader["Reason"].readIfPresent()
            value.roleUsageList = try reader["RoleUsageList"].readListIfPresent(memberReadingClosure: IAMClientTypes.RoleUsageType.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension IAMClientTypes {
    /// The reason that the service-linked role deletion failed. This data type is used as a response element in the [GetServiceLinkedRoleDeletionStatus] operation.
    public struct DeletionTaskFailureReasonType: Swift.Equatable {
        /// A short description of the reason that the service-linked role deletion failed.
        public var reason: Swift.String?
        /// A list of objects that contains details about the service-linked role deletion failure, if that information is returned by the service. If the service-linked role has active sessions or if any resources that were used by the role have not been deleted from the linked service, the role can't be deleted. This parameter includes a list of the resources that are associated with the role and the Region in which the resources are being used.
        public var roleUsageList: [IAMClientTypes.RoleUsageType]?

        public init(
            reason: Swift.String? = nil,
            roleUsageList: [IAMClientTypes.RoleUsageType]? = nil
        )
        {
            self.reason = reason
            self.roleUsageList = roleUsageList
        }
    }

}

extension IAMClientTypes {
    public enum DeletionTaskStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case notStarted
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeletionTaskStatusType] {
            return [
                .failed,
                .inProgress,
                .notStarted,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeletionTaskStatusType(rawValue: rawValue) ?? DeletionTaskStatusType.sdkUnknown(rawValue)
        }
    }
}

extension DetachGroupPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("DetachGroupPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DetachGroupPolicyInput {

    static func urlPathProvider(_ value: DetachGroupPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct DetachGroupPolicyInput: Swift.Equatable {
    /// The name (friendly name, not ARN) of the IAM group to detach the policy from. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM policy you want to detach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyArn = policyArn
    }
}

extension DetachGroupPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DetachGroupPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DetachGroupPolicyOutput()
        }
    }
}

public struct DetachGroupPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DetachGroupPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DetachRolePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("DetachRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DetachRolePolicyInput {

    static func urlPathProvider(_ value: DetachRolePolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct DetachRolePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to detach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the IAM role to detach the policy from. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.roleName = roleName
    }
}

extension DetachRolePolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DetachRolePolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DetachRolePolicyOutput()
        }
    }
}

public struct DetachRolePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DetachRolePolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnmodifiableEntity": return try await UnmodifiableEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DetachUserPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DetachUserPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DetachUserPolicyInput {

    static func urlPathProvider(_ value: DetachUserPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct DetachUserPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to detach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the IAM user to detach the policy from. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.userName = userName
    }
}

extension DetachUserPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DetachUserPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DetachUserPolicyOutput()
        }
    }
}

public struct DetachUserPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DetachUserPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DuplicateCertificateException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = DuplicateCertificateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the same certificate is associated with an IAM user in the account.
public struct DuplicateCertificateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateCertificate" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DuplicateSSHPublicKeyException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = DuplicateSSHPublicKeyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the SSH public key is already associated with the specified IAM user.
public struct DuplicateSSHPublicKeyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateSSHPublicKey" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension EnableMFADeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationCode1 = "AuthenticationCode1"
        case authenticationCode2 = "AuthenticationCode2"
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authenticationCode1 = authenticationCode1 {
            try container.encode(authenticationCode1, forKey: ClientRuntime.Key("AuthenticationCode1"))
        }
        if let authenticationCode2 = authenticationCode2 {
            try container.encode(authenticationCode2, forKey: ClientRuntime.Key("AuthenticationCode2"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("EnableMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension EnableMFADeviceInput {

    static func urlPathProvider(_ value: EnableMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

public struct EnableMFADeviceInput: Swift.Equatable {
    /// An authentication code emitted by the device. The format for this parameter is a string of six digits. Submit your request immediately after generating the authentication codes. If you generate the codes and then wait too long to submit the request, the MFA device successfully associates with the user but the MFA device becomes out of sync. This happens because time-based one-time passwords (TOTP) expire after a short period of time. If this happens, you can [resync the device](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html).
    /// This member is required.
    public var authenticationCode1: Swift.String?
    /// A subsequent authentication code emitted by the device. The format for this parameter is a string of six digits. Submit your request immediately after generating the authentication codes. If you generate the codes and then wait too long to submit the request, the MFA device successfully associates with the user but the MFA device becomes out of sync. This happens because time-based one-time passwords (TOTP) expire after a short period of time. If this happens, you can [resync the device](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html).
    /// This member is required.
    public var authenticationCode2: Swift.String?
    /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: =,.@:/-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The name of the IAM user for whom you want to enable the MFA device. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        authenticationCode1: Swift.String? = nil,
        authenticationCode2: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationCode1 = authenticationCode1
        self.authenticationCode2 = authenticationCode2
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

extension EnableMFADeviceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<EnableMFADeviceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return EnableMFADeviceOutput()
        }
    }
}

public struct EnableMFADeviceOutput: Swift.Equatable {

    public init() { }
}

enum EnableMFADeviceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EntityTemporarilyUnmodifiable": return try await EntityTemporarilyUnmodifiableException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidAuthenticationCode": return try await InvalidAuthenticationCodeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension IAMClientTypes {
    public enum EncodingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pem
        case ssh
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingType] {
            return [
                .pem,
                .ssh,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pem: return "PEM"
            case .ssh: return "SSH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncodingType(rawValue: rawValue) ?? EncodingType.sdkUnknown(rawValue)
        }
    }
}

extension EntityAlreadyExistsException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = EntityAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because it attempted to create a resource that already exists.
public struct EntityAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IAMClientTypes.EntityDetails: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityInfo = "EntityInfo"
        case lastAuthenticated = "LastAuthenticated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let entityInfo = entityInfo {
            try container.encode(entityInfo, forKey: ClientRuntime.Key("EntityInfo"))
        }
        if let lastAuthenticated = lastAuthenticated {
            try container.encodeTimestamp(lastAuthenticated, format: .dateTime, forKey: ClientRuntime.Key("LastAuthenticated"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.EntityDetails, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.EntityDetails()
            value.entityInfo = try reader["EntityInfo"].readIfPresent(readingClosure: IAMClientTypes.EntityInfo.readingClosure)
            value.lastAuthenticated = try reader["LastAuthenticated"].readTimestampIfPresent(format: .dateTime)
            return value
        }
    }
}

extension IAMClientTypes {
    /// An object that contains details about when the IAM entities (users or roles) were last used in an attempt to access the specified Amazon Web Services service. This data type is a response element in the [GetServiceLastAccessedDetailsWithEntities] operation.
    public struct EntityDetails: Swift.Equatable {
        /// The EntityInfo object that contains details about the entity (user or role).
        /// This member is required.
        public var entityInfo: IAMClientTypes.EntityInfo?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the authenticated entity last attempted to access Amazon Web Services. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticated: ClientRuntime.Date?

        public init(
            entityInfo: IAMClientTypes.EntityInfo? = nil,
            lastAuthenticated: ClientRuntime.Date? = nil
        )
        {
            self.entityInfo = entityInfo
            self.lastAuthenticated = lastAuthenticated
        }
    }

}

extension IAMClientTypes.EntityInfo: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
        case path = "Path"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.EntityInfo, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.EntityInfo()
            value.arn = try reader["Arn"].readIfPresent()
            value.name = try reader["Name"].readIfPresent()
            value.type = try reader["Type"].readIfPresent()
            value.id = try reader["Id"].readIfPresent()
            value.path = try reader["Path"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains details about the specified entity (user or role). This data type is an element of the [EntityDetails] object.
    public struct EntityInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        /// This member is required.
        public var arn: Swift.String?
        /// The identifier of the entity (user or role).
        /// This member is required.
        public var id: Swift.String?
        /// The name of the entity (user or role).
        /// This member is required.
        public var name: Swift.String?
        /// The path to the entity (user or role). For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The type of entity (user or role).
        /// This member is required.
        public var type: IAMClientTypes.PolicyOwnerEntityType?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            type: IAMClientTypes.PolicyOwnerEntityType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
            self.path = path
            self.type = type
        }
    }

}

extension EntityTemporarilyUnmodifiableException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = EntityTemporarilyUnmodifiableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because it referenced an entity that is temporarily unmodifiable, such as a user name that was deleted and then recreated. The error indicates that the request is likely to succeed if you try again after waiting several minutes. The error message describes the entity.
public struct EntityTemporarilyUnmodifiableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityTemporarilyUnmodifiable" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IAMClientTypes {
    public enum EntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsmanagedpolicy
        case group
        case localmanagedpolicy
        case role
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .awsmanagedpolicy,
                .group,
                .localmanagedpolicy,
                .role,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsmanagedpolicy: return "AWSManagedPolicy"
            case .group: return "Group"
            case .localmanagedpolicy: return "LocalManagedPolicy"
            case .role: return "Role"
            case .user: return "User"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.ErrorDetails: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let code = code {
            try container.encode(code, forKey: ClientRuntime.Key("Code"))
        }
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.ErrorDetails, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.ErrorDetails()
            value.message = try reader["Message"].readIfPresent()
            value.code = try reader["Code"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about the reason that the operation failed. This data type is used as a response element in the [GetOrganizationsAccessReport], [GetServiceLastAccessedDetails], and [GetServiceLastAccessedDetailsWithEntities] operations.
    public struct ErrorDetails: Swift.Equatable {
        /// The error code associated with the operation failure.
        /// This member is required.
        public var code: Swift.String?
        /// Detailed information about the reason that the operation failed.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IAMClientTypes.EvaluationResult: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evalActionName = "EvalActionName"
        case evalDecision = "EvalDecision"
        case evalDecisionDetails = "EvalDecisionDetails"
        case evalResourceName = "EvalResourceName"
        case matchedStatements = "MatchedStatements"
        case missingContextValues = "MissingContextValues"
        case organizationsDecisionDetail = "OrganizationsDecisionDetail"
        case permissionsBoundaryDecisionDetail = "PermissionsBoundaryDecisionDetail"
        case resourceSpecificResults = "ResourceSpecificResults"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let evalActionName = evalActionName {
            try container.encode(evalActionName, forKey: ClientRuntime.Key("EvalActionName"))
        }
        if let evalDecision = evalDecision {
            try container.encode(evalDecision, forKey: ClientRuntime.Key("EvalDecision"))
        }
        if let evalDecisionDetails = evalDecisionDetails {
            var evalDecisionDetailsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EvalDecisionDetails"))
            for (index0, element0) in evalDecisionDetails.sorted(by: { $0.key < $1.key }).enumerated() {
                let evaldecisionsourcetypeKey0 = element0.key
                let policyevaluationdecisiontypeValue0 = element0.value
                var entryContainer0 = evalDecisionDetailsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(evaldecisionsourcetypeKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(policyevaluationdecisiontypeValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let evalResourceName = evalResourceName {
            try container.encode(evalResourceName, forKey: ClientRuntime.Key("EvalResourceName"))
        }
        if let matchedStatements = matchedStatements {
            if !matchedStatements.isEmpty {
                var matchedStatementsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MatchedStatements"))
                for (index0, statement0) in matchedStatements.enumerated() {
                    try matchedStatementsContainer.encode(statement0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var matchedStatementsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MatchedStatements"))
                try matchedStatementsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let missingContextValues = missingContextValues {
            if !missingContextValues.isEmpty {
                var missingContextValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MissingContextValues"))
                for (index0, contextkeynametype0) in missingContextValues.enumerated() {
                    try missingContextValuesContainer.encode(contextkeynametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var missingContextValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MissingContextValues"))
                try missingContextValuesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let organizationsDecisionDetail = organizationsDecisionDetail {
            try container.encode(organizationsDecisionDetail, forKey: ClientRuntime.Key("OrganizationsDecisionDetail"))
        }
        if let permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail {
            try container.encode(permissionsBoundaryDecisionDetail, forKey: ClientRuntime.Key("PermissionsBoundaryDecisionDetail"))
        }
        if let resourceSpecificResults = resourceSpecificResults {
            if !resourceSpecificResults.isEmpty {
                var resourceSpecificResultsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceSpecificResults"))
                for (index0, resourcespecificresult0) in resourceSpecificResults.enumerated() {
                    try resourceSpecificResultsContainer.encode(resourcespecificresult0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var resourceSpecificResultsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceSpecificResults"))
                try resourceSpecificResultsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.EvaluationResult, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.EvaluationResult()
            value.evalActionName = try reader["EvalActionName"].readIfPresent()
            value.evalResourceName = try reader["EvalResourceName"].readIfPresent()
            value.evalDecision = try reader["EvalDecision"].readIfPresent()
            value.matchedStatements = try reader["MatchedStatements"].readListIfPresent(memberReadingClosure: IAMClientTypes.Statement.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.missingContextValues = try reader["MissingContextValues"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.organizationsDecisionDetail = try reader["OrganizationsDecisionDetail"].readIfPresent(readingClosure: IAMClientTypes.OrganizationsDecisionDetail.readingClosure)
            value.permissionsBoundaryDecisionDetail = try reader["PermissionsBoundaryDecisionDetail"].readIfPresent(readingClosure: IAMClientTypes.PermissionsBoundaryDecisionDetail.readingClosure)
            value.evalDecisionDetails = try reader["EvalDecisionDetails"].readMapIfPresent(valueReadingClosure: IAMClientTypes.PolicyEvaluationDecisionType.readingClosure, keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            value.resourceSpecificResults = try reader["ResourceSpecificResults"].readListIfPresent(memberReadingClosure: IAMClientTypes.ResourceSpecificResult.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains the results of a simulation. This data type is used by the return parameter of [SimulateCustomPolicy] and [SimulatePrincipalPolicy].
    public struct EvaluationResult: Swift.Equatable {
        /// The name of the API operation tested on the indicated resource.
        /// This member is required.
        public var evalActionName: Swift.String?
        /// The result of the simulation.
        /// This member is required.
        public var evalDecision: IAMClientTypes.PolicyEvaluationDecisionType?
        /// Additional details about the results of the cross-account evaluation decision. This parameter is populated for only cross-account simulations. It contains a brief summary of how each policy type contributes to the final evaluation decision. If the simulation evaluates policies within the same account and includes a resource ARN, then the parameter is present but the response is empty. If the simulation evaluates policies within the same account and specifies all resources (*), then the parameter is not returned. When you make a cross-account request, Amazon Web Services evaluates the request in the trusting account and the trusted account. The request is allowed only if both evaluations return true. For more information about how policies are evaluated, see [Evaluating policies within a single account](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic.html#policy-eval-basics). If an Organizations SCP included in the evaluation denies access, the simulation ends. In this case, policy evaluation does not proceed any further and this parameter is not returned.
        public var evalDecisionDetails: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]?
        /// The ARN of the resource that the indicated API operation was tested on.
        public var evalResourceName: Swift.String?
        /// A list of the statements in the input policies that determine the result for this scenario. Remember that even if multiple statements allow the operation on the resource, if only one statement denies that operation, then the explicit deny overrides any allow. In addition, the deny statement is the only entry included in the result.
        public var matchedStatements: [IAMClientTypes.Statement]?
        /// A list of context keys that are required by the included input policies but that were not provided by one of the input parameters. This list is used when the resource in a simulation is "*", either explicitly, or when the ResourceArns parameter blank. If you include a list of resources, then any missing context values are instead included under the ResourceSpecificResults section. To discover the context keys used by a set of policies, you can call [GetContextKeysForCustomPolicy] or [GetContextKeysForPrincipalPolicy].
        public var missingContextValues: [Swift.String]?
        /// A structure that details how Organizations and its service control policies affect the results of the simulation. Only applies if the simulated user's account is part of an organization.
        public var organizationsDecisionDetail: IAMClientTypes.OrganizationsDecisionDetail?
        /// Contains information about the effect that a permissions boundary has on a policy simulation when the boundary is applied to an IAM entity.
        public var permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail?
        /// The individual results of the simulation of the API operation specified in EvalActionName on each resource.
        public var resourceSpecificResults: [IAMClientTypes.ResourceSpecificResult]?

        public init(
            evalActionName: Swift.String? = nil,
            evalDecision: IAMClientTypes.PolicyEvaluationDecisionType? = nil,
            evalDecisionDetails: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]? = nil,
            evalResourceName: Swift.String? = nil,
            matchedStatements: [IAMClientTypes.Statement]? = nil,
            missingContextValues: [Swift.String]? = nil,
            organizationsDecisionDetail: IAMClientTypes.OrganizationsDecisionDetail? = nil,
            permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail? = nil,
            resourceSpecificResults: [IAMClientTypes.ResourceSpecificResult]? = nil
        )
        {
            self.evalActionName = evalActionName
            self.evalDecision = evalDecision
            self.evalDecisionDetails = evalDecisionDetails
            self.evalResourceName = evalResourceName
            self.matchedStatements = matchedStatements
            self.missingContextValues = missingContextValues
            self.organizationsDecisionDetail = organizationsDecisionDetail
            self.permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail
            self.resourceSpecificResults = resourceSpecificResults
        }
    }

}

extension GenerateCredentialReportInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GenerateCredentialReport", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GenerateCredentialReportInput {

    static func urlPathProvider(_ value: GenerateCredentialReportInput) -> Swift.String? {
        return "/"
    }
}

public struct GenerateCredentialReportInput: Swift.Equatable {

    public init() { }
}

extension GenerateCredentialReportOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GenerateCredentialReportOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GenerateCredentialReportResult"]
            var value = GenerateCredentialReportOutput()
            value.description = try reader["Description"].readIfPresent()
            value.state = try reader["State"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [GenerateCredentialReport] request.
public struct GenerateCredentialReportOutput: Swift.Equatable {
    /// Information about the credential report.
    public var description: Swift.String?
    /// Information about the state of the credential report.
    public var state: IAMClientTypes.ReportStateType?

    public init(
        description: Swift.String? = nil,
        state: IAMClientTypes.ReportStateType? = nil
    )
    {
        self.description = description
        self.state = state
    }
}

enum GenerateCredentialReportOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GenerateOrganizationsAccessReportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityPath = "EntityPath"
        case organizationsPolicyId = "OrganizationsPolicyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let entityPath = entityPath {
            try container.encode(entityPath, forKey: ClientRuntime.Key("EntityPath"))
        }
        if let organizationsPolicyId = organizationsPolicyId {
            try container.encode(organizationsPolicyId, forKey: ClientRuntime.Key("OrganizationsPolicyId"))
        }
        try container.encode("GenerateOrganizationsAccessReport", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GenerateOrganizationsAccessReportInput {

    static func urlPathProvider(_ value: GenerateOrganizationsAccessReportInput) -> Swift.String? {
        return "/"
    }
}

public struct GenerateOrganizationsAccessReportInput: Swift.Equatable {
    /// The path of the Organizations entity (root, OU, or account). You can build an entity path using the known structure of your organization. For example, assume that your account ID is 123456789012 and its parent OU ID is ou-rge0-awsabcde. The organization root ID is r-f6g7h8i9j0example and your organization ID is o-a1b2c3d4e5. Your entity path is o-a1b2c3d4e5/r-f6g7h8i9j0example/ou-rge0-awsabcde/123456789012.
    /// This member is required.
    public var entityPath: Swift.String?
    /// The identifier of the Organizations service control policy (SCP). This parameter is optional. This ID is used to generate information about when an account principal that is limited by the SCP attempted to access an Amazon Web Services service.
    public var organizationsPolicyId: Swift.String?

    public init(
        entityPath: Swift.String? = nil,
        organizationsPolicyId: Swift.String? = nil
    )
    {
        self.entityPath = entityPath
        self.organizationsPolicyId = organizationsPolicyId
    }
}

extension GenerateOrganizationsAccessReportOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GenerateOrganizationsAccessReportOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GenerateOrganizationsAccessReportResult"]
            var value = GenerateOrganizationsAccessReportOutput()
            value.jobId = try reader["JobId"].readIfPresent()
            return value
        }
    }
}

public struct GenerateOrganizationsAccessReportOutput: Swift.Equatable {
    /// The job identifier that you can use in the [GetOrganizationsAccessReport] operation.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

enum GenerateOrganizationsAccessReportOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ReportGenerationLimitExceeded": return try await ReportGenerationLimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GenerateServiceLastAccessedDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case granularity = "Granularity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let granularity = granularity {
            try container.encode(granularity, forKey: ClientRuntime.Key("Granularity"))
        }
        try container.encode("GenerateServiceLastAccessedDetails", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GenerateServiceLastAccessedDetailsInput {

    static func urlPathProvider(_ value: GenerateServiceLastAccessedDetailsInput) -> Swift.String? {
        return "/"
    }
}

public struct GenerateServiceLastAccessedDetailsInput: Swift.Equatable {
    /// The ARN of the IAM resource (user, group, role, or managed policy) used to generate information about when the resource was last used in an attempt to access an Amazon Web Services service.
    /// This member is required.
    public var arn: Swift.String?
    /// The level of detail that you want to generate. You can specify whether you want to generate information about the last attempt to access services or actions. If you specify service-level granularity, this operation generates only service data. If you specify action-level granularity, it generates service and action data. If you don't include this optional parameter, the operation generates service data.
    public var granularity: IAMClientTypes.AccessAdvisorUsageGranularityType?

    public init(
        arn: Swift.String? = nil,
        granularity: IAMClientTypes.AccessAdvisorUsageGranularityType? = nil
    )
    {
        self.arn = arn
        self.granularity = granularity
    }
}

extension GenerateServiceLastAccessedDetailsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GenerateServiceLastAccessedDetailsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GenerateServiceLastAccessedDetailsResult"]
            var value = GenerateServiceLastAccessedDetailsOutput()
            value.jobId = try reader["JobId"].readIfPresent()
            return value
        }
    }
}

public struct GenerateServiceLastAccessedDetailsOutput: Swift.Equatable {
    /// The JobId that you can use in the [GetServiceLastAccessedDetails] or [GetServiceLastAccessedDetailsWithEntities] operations. The JobId returned by GenerateServiceLastAccessedDetail must be used by the same role within a session, or by the same user when used to call GetServiceLastAccessedDetail.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

enum GenerateServiceLastAccessedDetailsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetAccessKeyLastUsedInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        try container.encode("GetAccessKeyLastUsed", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetAccessKeyLastUsedInput {

    static func urlPathProvider(_ value: GetAccessKeyLastUsedInput) -> Swift.String? {
        return "/"
    }
}

public struct GetAccessKeyLastUsedInput: Swift.Equatable {
    /// The identifier of an access key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var accessKeyId: Swift.String?

    public init(
        accessKeyId: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
    }
}

extension GetAccessKeyLastUsedOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccessKeyLastUsedOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetAccessKeyLastUsedResult"]
            var value = GetAccessKeyLastUsedOutput()
            value.accessKeyLastUsed = try reader["AccessKeyLastUsed"].readIfPresent(readingClosure: IAMClientTypes.AccessKeyLastUsed.readingClosure)
            value.userName = try reader["UserName"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [GetAccessKeyLastUsed] request. It is also returned as a member of the [AccessKeyMetaData] structure returned by the [ListAccessKeys] action.
public struct GetAccessKeyLastUsedOutput: Swift.Equatable {
    /// Contains information about the last time the access key was used.
    public var accessKeyLastUsed: IAMClientTypes.AccessKeyLastUsed?
    /// The name of the IAM user that owns this access key.
    public var userName: Swift.String?

    public init(
        accessKeyLastUsed: IAMClientTypes.AccessKeyLastUsed? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessKeyLastUsed = accessKeyLastUsed
        self.userName = userName
    }
}

enum GetAccessKeyLastUsedOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetAccountAuthorizationDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filter = filter {
            if !filter.isEmpty {
                var filterContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filter"))
                for (index0, entitytype0) in filter.enumerated() {
                    try filterContainer.encode(entitytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var filterContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filter"))
                try filterContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("GetAccountAuthorizationDetails", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetAccountAuthorizationDetailsInput {

    static func urlPathProvider(_ value: GetAccountAuthorizationDetailsInput) -> Swift.String? {
        return "/"
    }
}

public struct GetAccountAuthorizationDetailsInput: Swift.Equatable {
    /// A list of entity types used to filter the results. Only the entities that match the types you specify are included in the output. Use the value LocalManagedPolicy to include customer managed policies. The format for this parameter is a comma-separated (if more than one) list of strings. Each string value in the list must be one of the valid values listed below.
    public var filter: [IAMClientTypes.EntityType]?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        filter: [IAMClientTypes.EntityType]? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.filter = filter
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension GetAccountAuthorizationDetailsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccountAuthorizationDetailsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetAccountAuthorizationDetailsResult"]
            var value = GetAccountAuthorizationDetailsOutput()
            value.groupDetailList = try reader["GroupDetailList"].readListIfPresent(memberReadingClosure: IAMClientTypes.GroupDetail.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.policies = try reader["Policies"].readListIfPresent(memberReadingClosure: IAMClientTypes.ManagedPolicyDetail.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.roleDetailList = try reader["RoleDetailList"].readListIfPresent(memberReadingClosure: IAMClientTypes.RoleDetail.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.userDetailList = try reader["UserDetailList"].readListIfPresent(memberReadingClosure: IAMClientTypes.UserDetail.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [GetAccountAuthorizationDetails] request.
public struct GetAccountAuthorizationDetailsOutput: Swift.Equatable {
    /// A list containing information about IAM groups.
    public var groupDetailList: [IAMClientTypes.GroupDetail]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list containing information about managed policies.
    public var policies: [IAMClientTypes.ManagedPolicyDetail]?
    /// A list containing information about IAM roles.
    public var roleDetailList: [IAMClientTypes.RoleDetail]?
    /// A list containing information about IAM users.
    public var userDetailList: [IAMClientTypes.UserDetail]?

    public init(
        groupDetailList: [IAMClientTypes.GroupDetail]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policies: [IAMClientTypes.ManagedPolicyDetail]? = nil,
        roleDetailList: [IAMClientTypes.RoleDetail]? = nil,
        userDetailList: [IAMClientTypes.UserDetail]? = nil
    )
    {
        self.groupDetailList = groupDetailList
        self.isTruncated = isTruncated
        self.marker = marker
        self.policies = policies
        self.roleDetailList = roleDetailList
        self.userDetailList = userDetailList
    }
}

enum GetAccountAuthorizationDetailsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetAccountPasswordPolicyInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GetAccountPasswordPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetAccountPasswordPolicyInput {

    static func urlPathProvider(_ value: GetAccountPasswordPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct GetAccountPasswordPolicyInput: Swift.Equatable {

    public init() { }
}

extension GetAccountPasswordPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccountPasswordPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetAccountPasswordPolicyResult"]
            var value = GetAccountPasswordPolicyOutput()
            value.passwordPolicy = try reader["PasswordPolicy"].readIfPresent(readingClosure: IAMClientTypes.PasswordPolicy.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [GetAccountPasswordPolicy] request.
public struct GetAccountPasswordPolicyOutput: Swift.Equatable {
    /// A structure that contains details about the account's password policy.
    /// This member is required.
    public var passwordPolicy: IAMClientTypes.PasswordPolicy?

    public init(
        passwordPolicy: IAMClientTypes.PasswordPolicy? = nil
    )
    {
        self.passwordPolicy = passwordPolicy
    }
}

enum GetAccountPasswordPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetAccountSummaryInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GetAccountSummary", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetAccountSummaryInput {

    static func urlPathProvider(_ value: GetAccountSummaryInput) -> Swift.String? {
        return "/"
    }
}

public struct GetAccountSummaryInput: Swift.Equatable {

    public init() { }
}

extension GetAccountSummaryOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccountSummaryOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetAccountSummaryResult"]
            var value = GetAccountSummaryOutput()
            value.summaryMap = try reader["SummaryMap"].readMapIfPresent(valueReadingClosure: Swift.Int.readingClosure, keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [GetAccountSummary] request.
public struct GetAccountSummaryOutput: Swift.Equatable {
    /// A set of key–value pairs containing information about IAM entity usage and IAM quotas.
    public var summaryMap: [Swift.String:Swift.Int]?

    public init(
        summaryMap: [Swift.String:Swift.Int]? = nil
    )
    {
        self.summaryMap = summaryMap
    }
}

enum GetAccountSummaryOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetContextKeysForCustomPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyInputList = "PolicyInputList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyInputList = policyInputList {
            if !policyInputList.isEmpty {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                for (index0, policydocumenttype0) in policyInputList.enumerated() {
                    try policyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                try policyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("GetContextKeysForCustomPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetContextKeysForCustomPolicyInput {

    static func urlPathProvider(_ value: GetContextKeysForCustomPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct GetContextKeysForCustomPolicyInput: Swift.Equatable {
    /// A list of policies for which you want the list of context keys referenced in those policies. Each document is specified as a string containing the complete, valid JSON text of an IAM policy. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyInputList: [Swift.String]?

    public init(
        policyInputList: [Swift.String]? = nil
    )
    {
        self.policyInputList = policyInputList
    }
}

extension GetContextKeysForCustomPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetContextKeysForCustomPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetContextKeysForCustomPolicyResult"]
            var value = GetContextKeysForCustomPolicyOutput()
            value.contextKeyNames = try reader["ContextKeyNames"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [GetContextKeysForPrincipalPolicy] or [GetContextKeysForCustomPolicy] request.
public struct GetContextKeysForCustomPolicyOutput: Swift.Equatable {
    /// The list of context keys that are referenced in the input policies.
    public var contextKeyNames: [Swift.String]?

    public init(
        contextKeyNames: [Swift.String]? = nil
    )
    {
        self.contextKeyNames = contextKeyNames
    }
}

enum GetContextKeysForCustomPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetContextKeysForPrincipalPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyInputList = "PolicyInputList"
        case policySourceArn = "PolicySourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyInputList = policyInputList {
            if !policyInputList.isEmpty {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                for (index0, policydocumenttype0) in policyInputList.enumerated() {
                    try policyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                try policyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policySourceArn = policySourceArn {
            try container.encode(policySourceArn, forKey: ClientRuntime.Key("PolicySourceArn"))
        }
        try container.encode("GetContextKeysForPrincipalPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetContextKeysForPrincipalPolicyInput {

    static func urlPathProvider(_ value: GetContextKeysForPrincipalPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct GetContextKeysForPrincipalPolicyInput: Swift.Equatable {
    /// An optional list of additional policies for which you want the list of context keys that are referenced. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var policyInputList: [Swift.String]?
    /// The ARN of a user, group, or role whose policies contain the context keys that you want listed. If you specify a user, the list includes context keys that are found in all policies that are attached to the user. The list also includes all groups that the user is a member of. If you pick a group or a role, then it includes only those context keys that are found in policies attached to that entity. Note that all parameters are shown in unencoded form here for clarity, but must be URL encoded to be included as a part of a real HTML request. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policySourceArn: Swift.String?

    public init(
        policyInputList: [Swift.String]? = nil,
        policySourceArn: Swift.String? = nil
    )
    {
        self.policyInputList = policyInputList
        self.policySourceArn = policySourceArn
    }
}

extension GetContextKeysForPrincipalPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetContextKeysForPrincipalPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetContextKeysForPrincipalPolicyResult"]
            var value = GetContextKeysForPrincipalPolicyOutput()
            value.contextKeyNames = try reader["ContextKeyNames"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [GetContextKeysForPrincipalPolicy] or [GetContextKeysForCustomPolicy] request.
public struct GetContextKeysForPrincipalPolicyOutput: Swift.Equatable {
    /// The list of context keys that are referenced in the input policies.
    public var contextKeyNames: [Swift.String]?

    public init(
        contextKeyNames: [Swift.String]? = nil
    )
    {
        self.contextKeyNames = contextKeyNames
    }
}

enum GetContextKeysForPrincipalPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetCredentialReportInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GetCredentialReport", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetCredentialReportInput {

    static func urlPathProvider(_ value: GetCredentialReportInput) -> Swift.String? {
        return "/"
    }
}

public struct GetCredentialReportInput: Swift.Equatable {

    public init() { }
}

extension GetCredentialReportOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetCredentialReportOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetCredentialReportResult"]
            var value = GetCredentialReportOutput()
            value.content = try reader["Content"].readIfPresent()
            value.generatedTime = try reader["GeneratedTime"].readTimestampIfPresent(format: .dateTime)
            value.reportFormat = try reader["ReportFormat"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [GetCredentialReport] request.
public struct GetCredentialReportOutput: Swift.Equatable {
    /// Contains the credential report. The report is Base64-encoded.
    public var content: ClientRuntime.Data?
    /// The date and time when the credential report was created, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601).
    public var generatedTime: ClientRuntime.Date?
    /// The format (MIME type) of the credential report.
    public var reportFormat: IAMClientTypes.ReportFormatType?

    public init(
        content: ClientRuntime.Data? = nil,
        generatedTime: ClientRuntime.Date? = nil,
        reportFormat: IAMClientTypes.ReportFormatType? = nil
    )
    {
        self.content = content
        self.generatedTime = generatedTime
        self.reportFormat = reportFormat
    }
}

enum GetCredentialReportOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ReportExpired": return try await CredentialReportExpiredException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ReportNotPresent": return try await CredentialReportNotPresentException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ReportInProgress": return try await CredentialReportNotReadyException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("GetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetGroupInput {

    static func urlPathProvider(_ value: GetGroupInput) -> Swift.String? {
        return "/"
    }
}

public struct GetGroupInput: Swift.Equatable {
    /// The name of the group. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        groupName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.groupName = groupName
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension GetGroupOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetGroupOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetGroupResult"]
            var value = GetGroupOutput()
            value.group = try reader["Group"].readIfPresent(readingClosure: IAMClientTypes.Group.readingClosure)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.users = try reader["Users"].readListIfPresent(memberReadingClosure: IAMClientTypes.User.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [GetGroup] request.
public struct GetGroupOutput: Swift.Equatable {
    /// A structure that contains details about the group.
    /// This member is required.
    public var group: IAMClientTypes.Group?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of users in the group.
    /// This member is required.
    public var users: [IAMClientTypes.User]?

    public init(
        group: IAMClientTypes.Group? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        users: [IAMClientTypes.User]? = nil
    )
    {
        self.group = group
        self.isTruncated = isTruncated
        self.marker = marker
        self.users = users
    }
}

enum GetGroupOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetGroupPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        try container.encode("GetGroupPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetGroupPolicyInput {

    static func urlPathProvider(_ value: GetGroupPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct GetGroupPolicyInput: Swift.Equatable {
    /// The name of the group the policy is associated with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the policy document to get. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyName = policyName
    }
}

extension GetGroupPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetGroupPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetGroupPolicyResult"]
            var value = GetGroupPolicyOutput()
            value.groupName = try reader["GroupName"].readIfPresent()
            value.policyDocument = try reader["PolicyDocument"].readIfPresent()
            value.policyName = try reader["PolicyName"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [GetGroupPolicy] request.
public struct GetGroupPolicyOutput: Swift.Equatable {
    /// The group the policy is associated with.
    /// This member is required.
    public var groupName: Swift.String?
    /// The policy document. IAM stores policies in JSON format. However, resources that were created using CloudFormation templates can be formatted in YAML. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyDocument = policyDocument
        self.policyName = policyName
    }
}

enum GetGroupPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetInstanceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        try container.encode("GetInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetInstanceProfileInput {

    static func urlPathProvider(_ value: GetInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

public struct GetInstanceProfileInput: Swift.Equatable {
    /// The name of the instance profile to get information about. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?

    public init(
        instanceProfileName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
    }
}

extension GetInstanceProfileOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetInstanceProfileOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetInstanceProfileResult"]
            var value = GetInstanceProfileOutput()
            value.instanceProfile = try reader["InstanceProfile"].readIfPresent(readingClosure: IAMClientTypes.InstanceProfile.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [GetInstanceProfile] request.
public struct GetInstanceProfileOutput: Swift.Equatable {
    /// A structure containing details about the instance profile.
    /// This member is required.
    public var instanceProfile: IAMClientTypes.InstanceProfile?

    public init(
        instanceProfile: IAMClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

enum GetInstanceProfileOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetLoginProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("GetLoginProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetLoginProfileInput {

    static func urlPathProvider(_ value: GetLoginProfileInput) -> Swift.String? {
        return "/"
    }
}

public struct GetLoginProfileInput: Swift.Equatable {
    /// The name of the user whose login profile you want to retrieve. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

extension GetLoginProfileOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetLoginProfileOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetLoginProfileResult"]
            var value = GetLoginProfileOutput()
            value.loginProfile = try reader["LoginProfile"].readIfPresent(readingClosure: IAMClientTypes.LoginProfile.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [GetLoginProfile] request.
public struct GetLoginProfileOutput: Swift.Equatable {
    /// A structure containing the user name and the profile creation date for the user.
    /// This member is required.
    public var loginProfile: IAMClientTypes.LoginProfile?

    public init(
        loginProfile: IAMClientTypes.LoginProfile? = nil
    )
    {
        self.loginProfile = loginProfile
    }
}

enum GetLoginProfileOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetMFADeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("GetMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetMFADeviceInput {

    static func urlPathProvider(_ value: GetMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

public struct GetMFADeviceInput: Swift.Equatable {
    /// Serial number that uniquely identifies the MFA device. For this API, we only accept FIDO security key [ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html).
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The friendly name identifying the user.
    public var userName: Swift.String?

    public init(
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

extension GetMFADeviceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetMFADeviceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetMFADeviceResult"]
            var value = GetMFADeviceOutput()
            value.certifications = try reader["Certifications"].readMapIfPresent(valueReadingClosure: Swift.String.readingClosure, keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            value.enableDate = try reader["EnableDate"].readTimestampIfPresent(format: .dateTime)
            value.serialNumber = try reader["SerialNumber"].readIfPresent()
            value.userName = try reader["UserName"].readIfPresent()
            return value
        }
    }
}

public struct GetMFADeviceOutput: Swift.Equatable {
    /// The certifications of a specified user's MFA device. We currently provide FIPS-140-2, FIPS-140-3, and FIDO certification levels obtained from [ FIDO Alliance Metadata Service (MDS)](https://fidoalliance.org/metadata/).
    public var certifications: [Swift.String:Swift.String]?
    /// The date that a specified user's MFA device was first enabled.
    public var enableDate: ClientRuntime.Date?
    /// Serial number that uniquely identifies the MFA device. For this API, we only accept FIDO security key [ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html).
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The friendly name identifying the user.
    public var userName: Swift.String?

    public init(
        certifications: [Swift.String:Swift.String]? = nil,
        enableDate: ClientRuntime.Date? = nil,
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.certifications = certifications
        self.enableDate = enableDate
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

enum GetMFADeviceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetOpenIDConnectProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        try container.encode("GetOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetOpenIDConnectProviderInput {

    static func urlPathProvider(_ value: GetOpenIDConnectProviderInput) -> Swift.String? {
        return "/"
    }
}

public struct GetOpenIDConnectProviderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the OIDC provider resource object in IAM to get information for. You can get a list of OIDC provider resource ARNs by using the [ListOpenIDConnectProviders] operation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init(
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

extension GetOpenIDConnectProviderOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetOpenIDConnectProviderOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetOpenIDConnectProviderResult"]
            var value = GetOpenIDConnectProviderOutput()
            value.clientIDList = try reader["ClientIDList"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.thumbprintList = try reader["ThumbprintList"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.url = try reader["Url"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [GetOpenIDConnectProvider] request.
public struct GetOpenIDConnectProviderOutput: Swift.Equatable {
    /// A list of client IDs (also known as audiences) that are associated with the specified IAM OIDC provider resource object. For more information, see [CreateOpenIDConnectProvider].
    public var clientIDList: [Swift.String]?
    /// The date and time when the IAM OIDC provider resource object was created in the Amazon Web Services account.
    public var createDate: ClientRuntime.Date?
    /// A list of tags that are attached to the specified IAM OIDC provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?
    /// A list of certificate thumbprints that are associated with the specified IAM OIDC provider resource object. For more information, see [CreateOpenIDConnectProvider].
    public var thumbprintList: [Swift.String]?
    /// The URL that the IAM OIDC provider resource object is associated with. For more information, see [CreateOpenIDConnectProvider].
    public var url: Swift.String?

    public init(
        clientIDList: [Swift.String]? = nil,
        createDate: ClientRuntime.Date? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        thumbprintList: [Swift.String]? = nil,
        url: Swift.String? = nil
    )
    {
        self.clientIDList = clientIDList
        self.createDate = createDate
        self.tags = tags
        self.thumbprintList = thumbprintList
        self.url = url
    }
}

enum GetOpenIDConnectProviderOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetOrganizationsAccessReportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case sortKey = "SortKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let jobId = jobId {
            try container.encode(jobId, forKey: ClientRuntime.Key("JobId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let sortKey = sortKey {
            try container.encode(sortKey, forKey: ClientRuntime.Key("SortKey"))
        }
        try container.encode("GetOrganizationsAccessReport", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetOrganizationsAccessReportInput {

    static func urlPathProvider(_ value: GetOrganizationsAccessReportInput) -> Swift.String? {
        return "/"
    }
}

public struct GetOrganizationsAccessReportInput: Swift.Equatable {
    /// The identifier of the request generated by the [GenerateOrganizationsAccessReport] operation.
    /// This member is required.
    public var jobId: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The key that is used to sort the results. If you choose the namespace key, the results are returned in alphabetical order. If you choose the time key, the results are sorted numerically by the date and time.
    public var sortKey: IAMClientTypes.SortKeyType?

    public init(
        jobId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        sortKey: IAMClientTypes.SortKeyType? = nil
    )
    {
        self.jobId = jobId
        self.marker = marker
        self.maxItems = maxItems
        self.sortKey = sortKey
    }
}

extension GetOrganizationsAccessReportOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetOrganizationsAccessReportOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetOrganizationsAccessReportResult"]
            var value = GetOrganizationsAccessReportOutput()
            value.accessDetails = try reader["AccessDetails"].readListIfPresent(memberReadingClosure: IAMClientTypes.AccessDetail.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.errorDetails = try reader["ErrorDetails"].readIfPresent(readingClosure: IAMClientTypes.ErrorDetails.readingClosure)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.jobCompletionDate = try reader["JobCompletionDate"].readTimestampIfPresent(format: .dateTime)
            value.jobCreationDate = try reader["JobCreationDate"].readTimestampIfPresent(format: .dateTime)
            value.jobStatus = try reader["JobStatus"].readIfPresent()
            value.marker = try reader["Marker"].readIfPresent()
            value.numberOfServicesAccessible = try reader["NumberOfServicesAccessible"].readIfPresent()
            value.numberOfServicesNotAccessed = try reader["NumberOfServicesNotAccessed"].readIfPresent()
            return value
        }
    }
}

public struct GetOrganizationsAccessReportOutput: Swift.Equatable {
    /// An object that contains details about the most recent attempt to access the service.
    public var accessDetails: [IAMClientTypes.AccessDetail]?
    /// Contains information about the reason that the operation failed. This data type is used as a response element in the [GetOrganizationsAccessReport], [GetServiceLastAccessedDetails], and [GetServiceLastAccessedDetailsWithEntities] operations.
    public var errorDetails: IAMClientTypes.ErrorDetails?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the generated report job was completed or failed. This field is null if the job is still in progress, as indicated by a job status value of IN_PROGRESS.
    public var jobCompletionDate: ClientRuntime.Date?
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the report job was created.
    /// This member is required.
    public var jobCreationDate: ClientRuntime.Date?
    /// The status of the job.
    /// This member is required.
    public var jobStatus: IAMClientTypes.JobStatusType?
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The number of services that the applicable SCPs allow account principals to access.
    public var numberOfServicesAccessible: Swift.Int?
    /// The number of services that account principals are allowed but did not attempt to access.
    public var numberOfServicesNotAccessed: Swift.Int?

    public init(
        accessDetails: [IAMClientTypes.AccessDetail]? = nil,
        errorDetails: IAMClientTypes.ErrorDetails? = nil,
        isTruncated: Swift.Bool = false,
        jobCompletionDate: ClientRuntime.Date? = nil,
        jobCreationDate: ClientRuntime.Date? = nil,
        jobStatus: IAMClientTypes.JobStatusType? = nil,
        marker: Swift.String? = nil,
        numberOfServicesAccessible: Swift.Int? = nil,
        numberOfServicesNotAccessed: Swift.Int? = nil
    )
    {
        self.accessDetails = accessDetails
        self.errorDetails = errorDetails
        self.isTruncated = isTruncated
        self.jobCompletionDate = jobCompletionDate
        self.jobCreationDate = jobCreationDate
        self.jobStatus = jobStatus
        self.marker = marker
        self.numberOfServicesAccessible = numberOfServicesAccessible
        self.numberOfServicesNotAccessed = numberOfServicesNotAccessed
    }
}

enum GetOrganizationsAccessReportOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("GetPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetPolicyInput {

    static func urlPathProvider(_ value: GetPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct GetPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the managed policy that you want information about. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        policyArn: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

extension GetPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetPolicyResult"]
            var value = GetPolicyOutput()
            value.policy = try reader["Policy"].readIfPresent(readingClosure: IAMClientTypes.Policy.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [GetPolicy] request.
public struct GetPolicyOutput: Swift.Equatable {
    /// A structure containing details about the policy.
    public var policy: IAMClientTypes.Policy?

    public init(
        policy: IAMClientTypes.Policy? = nil
    )
    {
        self.policy = policy
    }
}

enum GetPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetPolicyVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
        try container.encode("GetPolicyVersion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetPolicyVersionInput {

    static func urlPathProvider(_ value: GetPolicyVersionInput) -> Swift.String? {
        return "/"
    }
}

public struct GetPolicyVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the managed policy that you want information about. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// Identifies the policy version to retrieve. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consists of the lowercase letter 'v' followed by one or two digits, and optionally followed by a period '.' and a string of letters and digits.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.versionId = versionId
    }
}

extension GetPolicyVersionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetPolicyVersionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetPolicyVersionResult"]
            var value = GetPolicyVersionOutput()
            value.policyVersion = try reader["PolicyVersion"].readIfPresent(readingClosure: IAMClientTypes.PolicyVersion.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [GetPolicyVersion] request.
public struct GetPolicyVersionOutput: Swift.Equatable {
    /// A structure containing details about the policy version.
    public var policyVersion: IAMClientTypes.PolicyVersion?

    public init(
        policyVersion: IAMClientTypes.PolicyVersion? = nil
    )
    {
        self.policyVersion = policyVersion
    }
}

enum GetPolicyVersionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("GetRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetRoleInput {

    static func urlPathProvider(_ value: GetRoleInput) -> Swift.String? {
        return "/"
    }
}

public struct GetRoleInput: Swift.Equatable {
    /// The name of the IAM role to get information about. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

extension GetRoleOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetRoleOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetRoleResult"]
            var value = GetRoleOutput()
            value.role = try reader["Role"].readIfPresent(readingClosure: IAMClientTypes.Role.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [GetRole] request.
public struct GetRoleOutput: Swift.Equatable {
    /// A structure containing details about the IAM role.
    /// This member is required.
    public var role: IAMClientTypes.Role?

    public init(
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

enum GetRoleOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetRolePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("GetRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetRolePolicyInput {

    static func urlPathProvider(_ value: GetRolePolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct GetRolePolicyInput: Swift.Equatable {
    /// The name of the policy document to get. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the role associated with the policy. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.roleName = roleName
    }
}

extension GetRolePolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetRolePolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetRolePolicyResult"]
            var value = GetRolePolicyOutput()
            value.policyDocument = try reader["PolicyDocument"].readIfPresent()
            value.policyName = try reader["PolicyName"].readIfPresent()
            value.roleName = try reader["RoleName"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [GetRolePolicy] request.
public struct GetRolePolicyOutput: Swift.Equatable {
    /// The policy document. IAM stores policies in JSON format. However, resources that were created using CloudFormation templates can be formatted in YAML. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?
    /// The role the policy is associated with.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.roleName = roleName
    }
}

enum GetRolePolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetSAMLProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        try container.encode("GetSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetSAMLProviderInput {

    static func urlPathProvider(_ value: GetSAMLProviderInput) -> Swift.String? {
        return "/"
    }
}

public struct GetSAMLProviderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the SAML provider resource object in IAM to get information about. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init(
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
    }
}

extension GetSAMLProviderOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetSAMLProviderOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetSAMLProviderResult"]
            var value = GetSAMLProviderOutput()
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            value.samlMetadataDocument = try reader["SAMLMetadataDocument"].readIfPresent()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.validUntil = try reader["ValidUntil"].readTimestampIfPresent(format: .dateTime)
            return value
        }
    }
}

/// Contains the response to a successful [GetSAMLProvider] request.
public struct GetSAMLProviderOutput: Swift.Equatable {
    /// The date and time when the SAML provider was created.
    public var createDate: ClientRuntime.Date?
    /// The XML metadata document that includes information about an identity provider.
    public var samlMetadataDocument: Swift.String?
    /// A list of tags that are attached to the specified IAM SAML provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?
    /// The expiration date and time for the SAML provider.
    public var validUntil: ClientRuntime.Date?

    public init(
        createDate: ClientRuntime.Date? = nil,
        samlMetadataDocument: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        validUntil: ClientRuntime.Date? = nil
    )
    {
        self.createDate = createDate
        self.samlMetadataDocument = samlMetadataDocument
        self.tags = tags
        self.validUntil = validUntil
    }
}

enum GetSAMLProviderOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetSSHPublicKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encoding = "Encoding"
        case sshPublicKeyId = "SSHPublicKeyId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let encoding = encoding {
            try container.encode(encoding, forKey: ClientRuntime.Key("Encoding"))
        }
        if let sshPublicKeyId = sshPublicKeyId {
            try container.encode(sshPublicKeyId, forKey: ClientRuntime.Key("SSHPublicKeyId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("GetSSHPublicKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetSSHPublicKeyInput {

    static func urlPathProvider(_ value: GetSSHPublicKeyInput) -> Swift.String? {
        return "/"
    }
}

public struct GetSSHPublicKeyInput: Swift.Equatable {
    /// Specifies the public key encoding format to use in the response. To retrieve the public key in ssh-rsa format, use SSH. To retrieve the public key in PEM format, use PEM.
    /// This member is required.
    public var encoding: IAMClientTypes.EncodingType?
    /// The unique identifier for the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// The name of the IAM user associated with the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        encoding: IAMClientTypes.EncodingType? = nil,
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.encoding = encoding
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

extension GetSSHPublicKeyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetSSHPublicKeyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetSSHPublicKeyResult"]
            var value = GetSSHPublicKeyOutput()
            value.sshPublicKey = try reader["SSHPublicKey"].readIfPresent(readingClosure: IAMClientTypes.SSHPublicKey.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [GetSSHPublicKey] request.
public struct GetSSHPublicKeyOutput: Swift.Equatable {
    /// A structure containing details about the SSH public key.
    public var sshPublicKey: IAMClientTypes.SSHPublicKey?

    public init(
        sshPublicKey: IAMClientTypes.SSHPublicKey? = nil
    )
    {
        self.sshPublicKey = sshPublicKey
    }
}

enum GetSSHPublicKeyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnrecognizedPublicKeyEncoding": return try await UnrecognizedPublicKeyEncodingException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetServerCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificateName = "ServerCertificateName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        try container.encode("GetServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetServerCertificateInput {

    static func urlPathProvider(_ value: GetServerCertificateInput) -> Swift.String? {
        return "/"
    }
}

public struct GetServerCertificateInput: Swift.Equatable {
    /// The name of the server certificate you want to retrieve information about. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init(
        serverCertificateName: Swift.String? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
    }
}

extension GetServerCertificateOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetServerCertificateOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetServerCertificateResult"]
            var value = GetServerCertificateOutput()
            value.serverCertificate = try reader["ServerCertificate"].readIfPresent(readingClosure: IAMClientTypes.ServerCertificate.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [GetServerCertificate] request.
public struct GetServerCertificateOutput: Swift.Equatable {
    /// A structure containing details about the server certificate.
    /// This member is required.
    public var serverCertificate: IAMClientTypes.ServerCertificate?

    public init(
        serverCertificate: IAMClientTypes.ServerCertificate? = nil
    )
    {
        self.serverCertificate = serverCertificate
    }
}

enum GetServerCertificateOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetServiceLastAccessedDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let jobId = jobId {
            try container.encode(jobId, forKey: ClientRuntime.Key("JobId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("GetServiceLastAccessedDetails", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetServiceLastAccessedDetailsInput {

    static func urlPathProvider(_ value: GetServiceLastAccessedDetailsInput) -> Swift.String? {
        return "/"
    }
}

public struct GetServiceLastAccessedDetailsInput: Swift.Equatable {
    /// The ID of the request generated by the [GenerateServiceLastAccessedDetails] operation. The JobId returned by GenerateServiceLastAccessedDetail must be used by the same role within a session, or by the same user when used to call GetServiceLastAccessedDetail.
    /// This member is required.
    public var jobId: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        jobId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.jobId = jobId
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension GetServiceLastAccessedDetailsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetServiceLastAccessedDetailsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetServiceLastAccessedDetailsResult"]
            var value = GetServiceLastAccessedDetailsOutput()
            value.error = try reader["Error"].readIfPresent(readingClosure: IAMClientTypes.ErrorDetails.readingClosure)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.jobCompletionDate = try reader["JobCompletionDate"].readTimestampIfPresent(format: .dateTime)
            value.jobCreationDate = try reader["JobCreationDate"].readTimestampIfPresent(format: .dateTime)
            value.jobStatus = try reader["JobStatus"].readIfPresent()
            value.jobType = try reader["JobType"].readIfPresent()
            value.marker = try reader["Marker"].readIfPresent()
            value.servicesLastAccessed = try reader["ServicesLastAccessed"].readListIfPresent(memberReadingClosure: IAMClientTypes.ServiceLastAccessed.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct GetServiceLastAccessedDetailsOutput: Swift.Equatable {
    /// An object that contains details about the reason the operation failed.
    public var error: IAMClientTypes.ErrorDetails?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the generated report job was completed or failed. This field is null if the job is still in progress, as indicated by a job status value of IN_PROGRESS.
    /// This member is required.
    public var jobCompletionDate: ClientRuntime.Date?
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the report job was created.
    /// This member is required.
    public var jobCreationDate: ClientRuntime.Date?
    /// The status of the job.
    /// This member is required.
    public var jobStatus: IAMClientTypes.JobStatusType?
    /// The type of job. Service jobs return information about when each service was last accessed. Action jobs also include information about when tracked actions within the service were last accessed.
    public var jobType: IAMClientTypes.AccessAdvisorUsageGranularityType?
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A ServiceLastAccessed object that contains details about the most recent attempt to access the service.
    /// This member is required.
    public var servicesLastAccessed: [IAMClientTypes.ServiceLastAccessed]?

    public init(
        error: IAMClientTypes.ErrorDetails? = nil,
        isTruncated: Swift.Bool = false,
        jobCompletionDate: ClientRuntime.Date? = nil,
        jobCreationDate: ClientRuntime.Date? = nil,
        jobStatus: IAMClientTypes.JobStatusType? = nil,
        jobType: IAMClientTypes.AccessAdvisorUsageGranularityType? = nil,
        marker: Swift.String? = nil,
        servicesLastAccessed: [IAMClientTypes.ServiceLastAccessed]? = nil
    )
    {
        self.error = error
        self.isTruncated = isTruncated
        self.jobCompletionDate = jobCompletionDate
        self.jobCreationDate = jobCreationDate
        self.jobStatus = jobStatus
        self.jobType = jobType
        self.marker = marker
        self.servicesLastAccessed = servicesLastAccessed
    }
}

enum GetServiceLastAccessedDetailsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetServiceLastAccessedDetailsWithEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case serviceNamespace = "ServiceNamespace"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let jobId = jobId {
            try container.encode(jobId, forKey: ClientRuntime.Key("JobId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: ClientRuntime.Key("ServiceNamespace"))
        }
        try container.encode("GetServiceLastAccessedDetailsWithEntities", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetServiceLastAccessedDetailsWithEntitiesInput {

    static func urlPathProvider(_ value: GetServiceLastAccessedDetailsWithEntitiesInput) -> Swift.String? {
        return "/"
    }
}

public struct GetServiceLastAccessedDetailsWithEntitiesInput: Swift.Equatable {
    /// The ID of the request generated by the GenerateServiceLastAccessedDetails operation.
    /// This member is required.
    public var jobId: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The service namespace for an Amazon Web Services service. Provide the service namespace to learn when the IAM entity last attempted to access the specified service. To learn the service namespace for a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the IAM User Guide. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
    /// This member is required.
    public var serviceNamespace: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        serviceNamespace: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.marker = marker
        self.maxItems = maxItems
        self.serviceNamespace = serviceNamespace
    }
}

extension GetServiceLastAccessedDetailsWithEntitiesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetServiceLastAccessedDetailsWithEntitiesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetServiceLastAccessedDetailsWithEntitiesResult"]
            var value = GetServiceLastAccessedDetailsWithEntitiesOutput()
            value.entityDetailsList = try reader["EntityDetailsList"].readListIfPresent(memberReadingClosure: IAMClientTypes.EntityDetails.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.error = try reader["Error"].readIfPresent(readingClosure: IAMClientTypes.ErrorDetails.readingClosure)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.jobCompletionDate = try reader["JobCompletionDate"].readTimestampIfPresent(format: .dateTime)
            value.jobCreationDate = try reader["JobCreationDate"].readTimestampIfPresent(format: .dateTime)
            value.jobStatus = try reader["JobStatus"].readIfPresent()
            value.marker = try reader["Marker"].readIfPresent()
            return value
        }
    }
}

public struct GetServiceLastAccessedDetailsWithEntitiesOutput: Swift.Equatable {
    /// An EntityDetailsList object that contains details about when an IAM entity (user or role) used group or policy permissions in an attempt to access the specified Amazon Web Services service.
    /// This member is required.
    public var entityDetailsList: [IAMClientTypes.EntityDetails]?
    /// An object that contains details about the reason the operation failed.
    public var error: IAMClientTypes.ErrorDetails?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the generated report job was completed or failed. This field is null if the job is still in progress, as indicated by a job status value of IN_PROGRESS.
    /// This member is required.
    public var jobCompletionDate: ClientRuntime.Date?
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the report job was created.
    /// This member is required.
    public var jobCreationDate: ClientRuntime.Date?
    /// The status of the job.
    /// This member is required.
    public var jobStatus: IAMClientTypes.JobStatusType?
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        entityDetailsList: [IAMClientTypes.EntityDetails]? = nil,
        error: IAMClientTypes.ErrorDetails? = nil,
        isTruncated: Swift.Bool = false,
        jobCompletionDate: ClientRuntime.Date? = nil,
        jobCreationDate: ClientRuntime.Date? = nil,
        jobStatus: IAMClientTypes.JobStatusType? = nil,
        marker: Swift.String? = nil
    )
    {
        self.entityDetailsList = entityDetailsList
        self.error = error
        self.isTruncated = isTruncated
        self.jobCompletionDate = jobCompletionDate
        self.jobCreationDate = jobCreationDate
        self.jobStatus = jobStatus
        self.marker = marker
    }
}

enum GetServiceLastAccessedDetailsWithEntitiesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetServiceLinkedRoleDeletionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionTaskId = "DeletionTaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deletionTaskId = deletionTaskId {
            try container.encode(deletionTaskId, forKey: ClientRuntime.Key("DeletionTaskId"))
        }
        try container.encode("GetServiceLinkedRoleDeletionStatus", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetServiceLinkedRoleDeletionStatusInput {

    static func urlPathProvider(_ value: GetServiceLinkedRoleDeletionStatusInput) -> Swift.String? {
        return "/"
    }
}

public struct GetServiceLinkedRoleDeletionStatusInput: Swift.Equatable {
    /// The deletion task identifier. This identifier is returned by the [DeleteServiceLinkedRole] operation in the format task/aws-service-role///.
    /// This member is required.
    public var deletionTaskId: Swift.String?

    public init(
        deletionTaskId: Swift.String? = nil
    )
    {
        self.deletionTaskId = deletionTaskId
    }
}

extension GetServiceLinkedRoleDeletionStatusOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetServiceLinkedRoleDeletionStatusOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetServiceLinkedRoleDeletionStatusResult"]
            var value = GetServiceLinkedRoleDeletionStatusOutput()
            value.reason = try reader["Reason"].readIfPresent(readingClosure: IAMClientTypes.DeletionTaskFailureReasonType.readingClosure)
            value.status = try reader["Status"].readIfPresent()
            return value
        }
    }
}

public struct GetServiceLinkedRoleDeletionStatusOutput: Swift.Equatable {
    /// An object that contains details about the reason the deletion failed.
    public var reason: IAMClientTypes.DeletionTaskFailureReasonType?
    /// The status of the deletion.
    /// This member is required.
    public var status: IAMClientTypes.DeletionTaskStatusType?

    public init(
        reason: IAMClientTypes.DeletionTaskFailureReasonType? = nil,
        status: IAMClientTypes.DeletionTaskStatusType? = nil
    )
    {
        self.reason = reason
        self.status = status
    }
}

enum GetServiceLinkedRoleDeletionStatusOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("GetUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetUserInput {

    static func urlPathProvider(_ value: GetUserInput) -> Swift.String? {
        return "/"
    }
}

public struct GetUserInput: Swift.Equatable {
    /// The name of the user to get information about. This parameter is optional. If it is not included, it defaults to the user making the request. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

extension GetUserOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetUserOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetUserResult"]
            var value = GetUserOutput()
            value.user = try reader["User"].readIfPresent(readingClosure: IAMClientTypes.User.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [GetUser] request.
public struct GetUserOutput: Swift.Equatable {
    /// A structure containing details about the IAM user. Due to a service issue, password last used data does not include password use from May 3, 2018 22:50 PDT to May 23, 2018 14:08 PDT. This affects [last sign-in](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_finding-unused.html) dates shown in the IAM console and password last used dates in the [IAM credential report](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_getting-report.html), and returned by this operation. If users signed in during the affected time, the password last used date that is returned is the date the user last signed in before May 3, 2018. For users that signed in after May 23, 2018 14:08 PDT, the returned password last used date is accurate. You can use password last used information to identify unused credentials for deletion. For example, you might delete users who did not sign in to Amazon Web Services in the last 90 days. In cases like this, we recommend that you adjust your evaluation window to include dates after May 23, 2018. Alternatively, if your users use access keys to access Amazon Web Services programmatically you can refer to access key last used information because it is accurate for all dates.
    /// This member is required.
    public var user: IAMClientTypes.User?

    public init(
        user: IAMClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

enum GetUserOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetUserPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("GetUserPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetUserPolicyInput {

    static func urlPathProvider(_ value: GetUserPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct GetUserPolicyInput: Swift.Equatable {
    /// The name of the policy document to get. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the user who the policy is associated with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.userName = userName
    }
}

extension GetUserPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetUserPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetUserPolicyResult"]
            var value = GetUserPolicyOutput()
            value.policyDocument = try reader["PolicyDocument"].readIfPresent()
            value.policyName = try reader["PolicyName"].readIfPresent()
            value.userName = try reader["UserName"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [GetUserPolicy] request.
public struct GetUserPolicyOutput: Swift.Equatable {
    /// The policy document. IAM stores policies in JSON format. However, resources that were created using CloudFormation templates can be formatted in YAML. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?
    /// The user the policy is associated with.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.userName = userName
    }
}

enum GetUserPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension IAMClientTypes {
    public enum GlobalEndpointTokenVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case v1token
        case v2token
        case sdkUnknown(Swift.String)

        public static var allCases: [GlobalEndpointTokenVersion] {
            return [
                .v1token,
                .v2token,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .v1token: return "v1Token"
            case .v2token: return "v2Token"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GlobalEndpointTokenVersion(rawValue: rawValue) ?? GlobalEndpointTokenVersion.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.Group: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let groupId = groupId {
            try container.encode(groupId, forKey: ClientRuntime.Key("GroupId"))
        }
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.Group, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.Group()
            value.path = try reader["Path"].readIfPresent()
            value.groupName = try reader["GroupName"].readIfPresent()
            value.groupId = try reader["GroupId"].readIfPresent()
            value.arn = try reader["Arn"].readIfPresent()
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM group entity. This data type is used as a response element in the following operations:
    ///
    /// * [CreateGroup]
    ///
    /// * [GetGroup]
    ///
    /// * [ListGroups]
    public struct Group: Swift.Equatable {
        /// The Amazon Resource Name (ARN) specifying the group. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the group was created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// The stable and unique string identifying the group. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var groupId: Swift.String?
        /// The friendly name that identifies the group.
        /// This member is required.
        public var groupName: Swift.String?
        /// The path to the group. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.groupId = groupId
            self.groupName = groupName
            self.path = path
        }
    }

}

extension IAMClientTypes.GroupDetail: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case groupPolicyList = "GroupPolicyList"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let attachedManagedPolicies = attachedManagedPolicies {
            if !attachedManagedPolicies.isEmpty {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                for (index0, attachedpolicy0) in attachedManagedPolicies.enumerated() {
                    try attachedManagedPoliciesContainer.encode(attachedpolicy0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                try attachedManagedPoliciesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let groupId = groupId {
            try container.encode(groupId, forKey: ClientRuntime.Key("GroupId"))
        }
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let groupPolicyList = groupPolicyList {
            if !groupPolicyList.isEmpty {
                var groupPolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupPolicyList"))
                for (index0, policydetail0) in groupPolicyList.enumerated() {
                    try groupPolicyListContainer.encode(policydetail0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var groupPolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupPolicyList"))
                try groupPolicyListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.GroupDetail, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.GroupDetail()
            value.path = try reader["Path"].readIfPresent()
            value.groupName = try reader["GroupName"].readIfPresent()
            value.groupId = try reader["GroupId"].readIfPresent()
            value.arn = try reader["Arn"].readIfPresent()
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            value.groupPolicyList = try reader["GroupPolicyList"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyDetail.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.attachedManagedPolicies = try reader["AttachedManagedPolicies"].readListIfPresent(memberReadingClosure: IAMClientTypes.AttachedPolicy.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM group, including all of the group's policies. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct GroupDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// A list of the managed policies attached to the group.
        public var attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the group was created.
        public var createDate: ClientRuntime.Date?
        /// The stable and unique string identifying the group. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var groupId: Swift.String?
        /// The friendly name that identifies the group.
        public var groupName: Swift.String?
        /// A list of the inline policies embedded in the group.
        public var groupPolicyList: [IAMClientTypes.PolicyDetail]?
        /// The path to the group. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?

        public init(
            arn: Swift.String? = nil,
            attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
            createDate: ClientRuntime.Date? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            groupPolicyList: [IAMClientTypes.PolicyDetail]? = nil,
            path: Swift.String? = nil
        )
        {
            self.arn = arn
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupId = groupId
            self.groupName = groupName
            self.groupPolicyList = groupPolicyList
            self.path = path
        }
    }

}

public enum IAMClientTypes {}

extension IAMClientTypes.InstanceProfile: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case instanceProfileId = "InstanceProfileId"
        case instanceProfileName = "InstanceProfileName"
        case path = "Path"
        case roles = "Roles"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let instanceProfileId = instanceProfileId {
            try container.encode(instanceProfileId, forKey: ClientRuntime.Key("InstanceProfileId"))
        }
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let roles = roles {
            if !roles.isEmpty {
                var rolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Roles"))
                for (index0, role0) in roles.enumerated() {
                    try rolesContainer.encode(role0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var rolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Roles"))
                try rolesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.InstanceProfile, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.InstanceProfile()
            value.path = try reader["Path"].readIfPresent()
            value.instanceProfileName = try reader["InstanceProfileName"].readIfPresent()
            value.instanceProfileId = try reader["InstanceProfileId"].readIfPresent()
            value.arn = try reader["Arn"].readIfPresent()
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            value.roles = try reader["Roles"].readListIfPresent(memberReadingClosure: IAMClientTypes.Role.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an instance profile. This data type is used as a response element in the following operations:
    ///
    /// * [CreateInstanceProfile]
    ///
    /// * [GetInstanceProfile]
    ///
    /// * [ListInstanceProfiles]
    ///
    /// * [ListInstanceProfilesForRole]
    public struct InstanceProfile: Swift.Equatable {
        /// The Amazon Resource Name (ARN) specifying the instance profile. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date when the instance profile was created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// The stable and unique string identifying the instance profile. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var instanceProfileId: Swift.String?
        /// The name identifying the instance profile.
        /// This member is required.
        public var instanceProfileName: Swift.String?
        /// The path to the instance profile. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?
        /// The role associated with the instance profile.
        /// This member is required.
        public var roles: [IAMClientTypes.Role]?
        /// A list of tags that are attached to the instance profile. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init(
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            instanceProfileId: Swift.String? = nil,
            instanceProfileName: Swift.String? = nil,
            path: Swift.String? = nil,
            roles: [IAMClientTypes.Role]? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.instanceProfileId = instanceProfileId
            self.instanceProfileName = instanceProfileName
            self.path = path
            self.roles = roles
            self.tags = tags
        }
    }

}

extension InvalidAuthenticationCodeException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidAuthenticationCodeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the authentication code was not recognized. The error message describes the specific error.
public struct InvalidAuthenticationCodeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAuthenticationCode" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidCertificateException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidCertificateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the certificate is invalid.
public struct InvalidCertificateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCertificate" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidInputException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidInputException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because an invalid or out-of-range value was supplied for an input parameter.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInput" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidPublicKeyException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidPublicKeyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the public key is malformed or otherwise invalid.
public struct InvalidPublicKeyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPublicKey" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidUserTypeException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidUserTypeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the type of user for the transaction was incorrect.
public struct InvalidUserTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidUserType" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IAMClientTypes {
    public enum JobStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatusType] {
            return [
                .completed,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatusType(rawValue: rawValue) ?? JobStatusType.sdkUnknown(rawValue)
        }
    }
}

extension KeyPairMismatchException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = KeyPairMismatchException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the public key certificate and the private key do not match.
public struct KeyPairMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KeyPairMismatch" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LimitExceededException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because it attempted to create resources beyond the current Amazon Web Services account limits. The error message describes the limit exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ListAccessKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListAccessKeys", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListAccessKeysInput {

    static func urlPathProvider(_ value: ListAccessKeysInput) -> Swift.String? {
        return "/"
    }
}

public struct ListAccessKeysInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension ListAccessKeysOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListAccessKeysOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListAccessKeysResult"]
            var value = ListAccessKeysOutput()
            value.accessKeyMetadata = try reader["AccessKeyMetadata"].readListIfPresent(memberReadingClosure: IAMClientTypes.AccessKeyMetadata.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [ListAccessKeys] request.
public struct ListAccessKeysOutput: Swift.Equatable {
    /// A list of objects containing metadata about the access keys.
    /// This member is required.
    public var accessKeyMetadata: [IAMClientTypes.AccessKeyMetadata]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        accessKeyMetadata: [IAMClientTypes.AccessKeyMetadata]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.accessKeyMetadata = accessKeyMetadata
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

enum ListAccessKeysOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListAccountAliasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("ListAccountAliases", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListAccountAliasesInput {

    static func urlPathProvider(_ value: ListAccountAliasesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListAccountAliasesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListAccountAliasesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListAccountAliasesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListAccountAliasesResult"]
            var value = ListAccountAliasesOutput()
            value.accountAliases = try reader["AccountAliases"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [ListAccountAliases] request.
public struct ListAccountAliasesOutput: Swift.Equatable {
    /// A list of aliases associated with the account. Amazon Web Services supports only one alias per account.
    /// This member is required.
    public var accountAliases: [Swift.String]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        accountAliases: [Swift.String]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.accountAliases = accountAliases
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

enum ListAccountAliasesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListAttachedGroupPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListAttachedGroupPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListAttachedGroupPoliciesInput {

    static func urlPathProvider(_ value: ListAttachedGroupPoliciesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListAttachedGroupPoliciesInput: Swift.Equatable {
    /// The name (friendly name, not ARN) of the group to list attached policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

extension ListAttachedGroupPoliciesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListAttachedGroupPoliciesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListAttachedGroupPoliciesResult"]
            var value = ListAttachedGroupPoliciesOutput()
            value.attachedPolicies = try reader["AttachedPolicies"].readListIfPresent(memberReadingClosure: IAMClientTypes.AttachedPolicy.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [ListAttachedGroupPolicies] request.
public struct ListAttachedGroupPoliciesOutput: Swift.Equatable {
    /// A list of the attached policies.
    public var attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        attachedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.attachedPolicies = attachedPolicies
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

enum ListAttachedGroupPoliciesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListAttachedRolePoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("ListAttachedRolePolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListAttachedRolePoliciesInput {

    static func urlPathProvider(_ value: ListAttachedRolePoliciesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListAttachedRolePoliciesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The name (friendly name, not ARN) of the role to list attached policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
        self.roleName = roleName
    }
}

extension ListAttachedRolePoliciesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListAttachedRolePoliciesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListAttachedRolePoliciesResult"]
            var value = ListAttachedRolePoliciesOutput()
            value.attachedPolicies = try reader["AttachedPolicies"].readListIfPresent(memberReadingClosure: IAMClientTypes.AttachedPolicy.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [ListAttachedRolePolicies] request.
public struct ListAttachedRolePoliciesOutput: Swift.Equatable {
    /// A list of the attached policies.
    public var attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        attachedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.attachedPolicies = attachedPolicies
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

enum ListAttachedRolePoliciesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListAttachedUserPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListAttachedUserPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListAttachedUserPoliciesInput {

    static func urlPathProvider(_ value: ListAttachedUserPoliciesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListAttachedUserPoliciesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The name (friendly name, not ARN) of the user to list attached policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
        self.userName = userName
    }
}

extension ListAttachedUserPoliciesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListAttachedUserPoliciesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListAttachedUserPoliciesResult"]
            var value = ListAttachedUserPoliciesOutput()
            value.attachedPolicies = try reader["AttachedPolicies"].readListIfPresent(memberReadingClosure: IAMClientTypes.AttachedPolicy.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [ListAttachedUserPolicies] request.
public struct ListAttachedUserPoliciesOutput: Swift.Equatable {
    /// A list of the attached policies.
    public var attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        attachedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.attachedPolicies = attachedPolicies
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

enum ListAttachedUserPoliciesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListEntitiesForPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityFilter = "EntityFilter"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
        case policyArn = "PolicyArn"
        case policyUsageFilter = "PolicyUsageFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let entityFilter = entityFilter {
            try container.encode(entityFilter, forKey: ClientRuntime.Key("EntityFilter"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let policyUsageFilter = policyUsageFilter {
            try container.encode(policyUsageFilter, forKey: ClientRuntime.Key("PolicyUsageFilter"))
        }
        try container.encode("ListEntitiesForPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListEntitiesForPolicyInput {

    static func urlPathProvider(_ value: ListEntitiesForPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct ListEntitiesForPolicyInput: Swift.Equatable {
    /// The entity type to use for filtering the results. For example, when EntityFilter is Role, only the roles that are attached to the specified policy are returned. This parameter is optional. If it is not included, all attached entities (users, groups, and roles) are returned. The argument for this parameter must be one of the valid values listed below.
    public var entityFilter: IAMClientTypes.EntityType?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all entities. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM policy for which you want the versions. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The policy usage method to use for filtering the results. To list only permissions policies, set PolicyUsageFilter to PermissionsPolicy. To list only the policies used to set permissions boundaries, set the value to PermissionsBoundary. This parameter is optional. If it is not included, all policies are returned.
    public var policyUsageFilter: IAMClientTypes.PolicyUsageType?

    public init(
        entityFilter: IAMClientTypes.EntityType? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        policyUsageFilter: IAMClientTypes.PolicyUsageType? = nil
    )
    {
        self.entityFilter = entityFilter
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
        self.policyArn = policyArn
        self.policyUsageFilter = policyUsageFilter
    }
}

extension ListEntitiesForPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListEntitiesForPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListEntitiesForPolicyResult"]
            var value = ListEntitiesForPolicyOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.policyGroups = try reader["PolicyGroups"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyGroup.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.policyRoles = try reader["PolicyRoles"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyRole.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.policyUsers = try reader["PolicyUsers"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyUser.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [ListEntitiesForPolicy] request.
public struct ListEntitiesForPolicyOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of IAM groups that the policy is attached to.
    public var policyGroups: [IAMClientTypes.PolicyGroup]?
    /// A list of IAM roles that the policy is attached to.
    public var policyRoles: [IAMClientTypes.PolicyRole]?
    /// A list of IAM users that the policy is attached to.
    public var policyUsers: [IAMClientTypes.PolicyUser]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyGroups: [IAMClientTypes.PolicyGroup]? = nil,
        policyRoles: [IAMClientTypes.PolicyRole]? = nil,
        policyUsers: [IAMClientTypes.PolicyUser]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyGroups = policyGroups
        self.policyRoles = policyRoles
        self.policyUsers = policyUsers
    }
}

enum ListEntitiesForPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListGroupPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("ListGroupPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListGroupPoliciesInput {

    static func urlPathProvider(_ value: ListGroupPoliciesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListGroupPoliciesInput: Swift.Equatable {
    /// The name of the group to list policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        groupName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.groupName = groupName
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListGroupPoliciesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListGroupPoliciesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListGroupPoliciesResult"]
            var value = ListGroupPoliciesOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.policyNames = try reader["PolicyNames"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [ListGroupPolicies] request.
public struct ListGroupPoliciesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy names. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyNames = policyNames
    }
}

enum ListGroupPoliciesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListGroupsForUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListGroupsForUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListGroupsForUserInput {

    static func urlPathProvider(_ value: ListGroupsForUserInput) -> Swift.String? {
        return "/"
    }
}

public struct ListGroupsForUserInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user to list groups for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension ListGroupsForUserOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListGroupsForUserOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListGroupsForUserResult"]
            var value = ListGroupsForUserOutput()
            value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: IAMClientTypes.Group.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [ListGroupsForUser] request.
public struct ListGroupsForUserOutput: Swift.Equatable {
    /// A list of groups.
    /// This member is required.
    public var groups: [IAMClientTypes.Group]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        groups: [IAMClientTypes.Group]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.groups = groups
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

enum ListGroupsForUserOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListGroupsInput {

    static func urlPathProvider(_ value: ListGroupsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListGroupsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example, the prefix /division_abc/subdivision_xyz/ gets all groups whose path starts with /division_abc/subdivision_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all groups. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

extension ListGroupsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListGroupsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListGroupsResult"]
            var value = ListGroupsOutput()
            value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: IAMClientTypes.Group.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [ListGroups] request.
public struct ListGroupsOutput: Swift.Equatable {
    /// A list of groups.
    /// This member is required.
    public var groups: [IAMClientTypes.Group]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        groups: [IAMClientTypes.Group]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.groups = groups
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

enum ListGroupsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListInstanceProfileTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("ListInstanceProfileTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListInstanceProfileTagsInput {

    static func urlPathProvider(_ value: ListInstanceProfileTagsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListInstanceProfileTagsInput: Swift.Equatable {
    /// The name of the IAM instance profile whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        instanceProfileName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListInstanceProfileTagsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListInstanceProfileTagsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListInstanceProfileTagsResult"]
            var value = ListInstanceProfileTagsOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct ListInstanceProfileTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the IAM instance profile. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

enum ListInstanceProfileTagsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListInstanceProfilesForRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("ListInstanceProfilesForRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListInstanceProfilesForRoleInput {

    static func urlPathProvider(_ value: ListInstanceProfilesForRoleInput) -> Swift.String? {
        return "/"
    }
}

public struct ListInstanceProfilesForRoleInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the role to list instance profiles for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.roleName = roleName
    }
}

extension ListInstanceProfilesForRoleOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListInstanceProfilesForRoleOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListInstanceProfilesForRoleResult"]
            var value = ListInstanceProfilesForRoleOutput()
            value.instanceProfiles = try reader["InstanceProfiles"].readListIfPresent(memberReadingClosure: IAMClientTypes.InstanceProfile.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [ListInstanceProfilesForRole] request.
public struct ListInstanceProfilesForRoleOutput: Swift.Equatable {
    /// A list of instance profiles.
    /// This member is required.
    public var instanceProfiles: [IAMClientTypes.InstanceProfile]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        instanceProfiles: [IAMClientTypes.InstanceProfile]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

enum ListInstanceProfilesForRoleOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListInstanceProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListInstanceProfiles", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListInstanceProfilesInput {

    static func urlPathProvider(_ value: ListInstanceProfilesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListInstanceProfilesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example, the prefix /application_abc/component_xyz/ gets all instance profiles whose path starts with /application_abc/component_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all instance profiles. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

extension ListInstanceProfilesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListInstanceProfilesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListInstanceProfilesResult"]
            var value = ListInstanceProfilesOutput()
            value.instanceProfiles = try reader["InstanceProfiles"].readListIfPresent(memberReadingClosure: IAMClientTypes.InstanceProfile.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [ListInstanceProfiles] request.
public struct ListInstanceProfilesOutput: Swift.Equatable {
    /// A list of instance profiles.
    /// This member is required.
    public var instanceProfiles: [IAMClientTypes.InstanceProfile]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        instanceProfiles: [IAMClientTypes.InstanceProfile]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

enum ListInstanceProfilesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListMFADeviceTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case serialNumber = "SerialNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        try container.encode("ListMFADeviceTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListMFADeviceTagsInput {

    static func urlPathProvider(_ value: ListMFADeviceTagsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListMFADeviceTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The unique identifier for the IAM virtual MFA device whose tags you want to see. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        serialNumber: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.serialNumber = serialNumber
    }
}

extension ListMFADeviceTagsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListMFADeviceTagsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListMFADeviceTagsResult"]
            var value = ListMFADeviceTagsOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct ListMFADeviceTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the virtual MFA device. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

enum ListMFADeviceTagsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListMFADevicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListMFADevices", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListMFADevicesInput {

    static func urlPathProvider(_ value: ListMFADevicesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListMFADevicesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user whose MFA devices you want to list. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension ListMFADevicesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListMFADevicesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListMFADevicesResult"]
            var value = ListMFADevicesOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.mfaDevices = try reader["MFADevices"].readListIfPresent(memberReadingClosure: IAMClientTypes.MFADevice.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.marker = try reader["Marker"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [ListMFADevices] request.
public struct ListMFADevicesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of MFA devices.
    /// This member is required.
    public var mfaDevices: [IAMClientTypes.MFADevice]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        mfaDevices: [IAMClientTypes.MFADevice]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.mfaDevices = mfaDevices
    }
}

enum ListMFADevicesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListOpenIDConnectProviderTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        try container.encode("ListOpenIDConnectProviderTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListOpenIDConnectProviderTagsInput {

    static func urlPathProvider(_ value: ListOpenIDConnectProviderTagsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListOpenIDConnectProviderTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The ARN of the OpenID Connect (OIDC) identity provider whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

extension ListOpenIDConnectProviderTagsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListOpenIDConnectProviderTagsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListOpenIDConnectProviderTagsResult"]
            var value = ListOpenIDConnectProviderTagsOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct ListOpenIDConnectProviderTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the OpenID Connect (OIDC) identity provider. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

enum ListOpenIDConnectProviderTagsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListOpenIDConnectProvidersInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("ListOpenIDConnectProviders", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListOpenIDConnectProvidersInput {

    static func urlPathProvider(_ value: ListOpenIDConnectProvidersInput) -> Swift.String? {
        return "/"
    }
}

public struct ListOpenIDConnectProvidersInput: Swift.Equatable {

    public init() { }
}

extension ListOpenIDConnectProvidersOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListOpenIDConnectProvidersOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListOpenIDConnectProvidersResult"]
            var value = ListOpenIDConnectProvidersOutput()
            value.openIDConnectProviderList = try reader["OpenIDConnectProviderList"].readListIfPresent(memberReadingClosure: IAMClientTypes.OpenIDConnectProviderListEntry.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [ListOpenIDConnectProviders] request.
public struct ListOpenIDConnectProvidersOutput: Swift.Equatable {
    /// The list of IAM OIDC provider resource objects defined in the Amazon Web Services account.
    public var openIDConnectProviderList: [IAMClientTypes.OpenIDConnectProviderListEntry]?

    public init(
        openIDConnectProviderList: [IAMClientTypes.OpenIDConnectProviderListEntry]? = nil
    )
    {
        self.openIDConnectProviderList = openIDConnectProviderList
    }
}

enum ListOpenIDConnectProvidersOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension IAMClientTypes.ListPoliciesGrantingServiceAccessEntry: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policies = "Policies"
        case serviceNamespace = "ServiceNamespace"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policies = policies {
            if !policies.isEmpty {
                var policiesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Policies"))
                for (index0, policygrantingserviceaccess0) in policies.enumerated() {
                    try policiesContainer.encode(policygrantingserviceaccess0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policiesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Policies"))
                try policiesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: ClientRuntime.Key("ServiceNamespace"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.ListPoliciesGrantingServiceAccessEntry, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.ListPoliciesGrantingServiceAccessEntry()
            value.serviceNamespace = try reader["ServiceNamespace"].readIfPresent()
            value.policies = try reader["Policies"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyGrantingServiceAccess.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains details about the permissions policies that are attached to the specified identity (user, group, or role). This data type is used as a response element in the [ListPoliciesGrantingServiceAccess] operation.
    public struct ListPoliciesGrantingServiceAccessEntry: Swift.Equatable {
        /// The PoliciesGrantingServiceAccess object that contains details about the policy.
        public var policies: [IAMClientTypes.PolicyGrantingServiceAccess]?
        /// The namespace of the service that was accessed. To learn the service namespace of a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the Service Authorization Reference. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
        public var serviceNamespace: Swift.String?

        public init(
            policies: [IAMClientTypes.PolicyGrantingServiceAccess]? = nil,
            serviceNamespace: Swift.String? = nil
        )
        {
            self.policies = policies
            self.serviceNamespace = serviceNamespace
        }
    }

}

extension ListPoliciesGrantingServiceAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case marker = "Marker"
        case serviceNamespaces = "ServiceNamespaces"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let serviceNamespaces = serviceNamespaces {
            if !serviceNamespaces.isEmpty {
                var serviceNamespacesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ServiceNamespaces"))
                for (index0, servicenamespacetype0) in serviceNamespaces.enumerated() {
                    try serviceNamespacesContainer.encode(servicenamespacetype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var serviceNamespacesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ServiceNamespaces"))
                try serviceNamespacesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("ListPoliciesGrantingServiceAccess", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPoliciesGrantingServiceAccessInput {

    static func urlPathProvider(_ value: ListPoliciesGrantingServiceAccessInput) -> Swift.String? {
        return "/"
    }
}

public struct ListPoliciesGrantingServiceAccessInput: Swift.Equatable {
    /// The ARN of the IAM identity (user, group, or role) whose policies you want to list.
    /// This member is required.
    public var arn: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// The service namespace for the Amazon Web Services services whose policies you want to list. To learn the service namespace for a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the IAM User Guide. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
    /// This member is required.
    public var serviceNamespaces: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        marker: Swift.String? = nil,
        serviceNamespaces: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.marker = marker
        self.serviceNamespaces = serviceNamespaces
    }
}

extension ListPoliciesGrantingServiceAccessOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListPoliciesGrantingServiceAccessOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListPoliciesGrantingServiceAccessResult"]
            var value = ListPoliciesGrantingServiceAccessOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.policiesGrantingServiceAccess = try reader["PoliciesGrantingServiceAccess"].readListIfPresent(memberReadingClosure: IAMClientTypes.ListPoliciesGrantingServiceAccessEntry.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct ListPoliciesGrantingServiceAccessOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A ListPoliciesGrantingServiceAccess object that contains details about the permissions policies attached to the specified identity (user, group, or role).
    /// This member is required.
    public var policiesGrantingServiceAccess: [IAMClientTypes.ListPoliciesGrantingServiceAccessEntry]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policiesGrantingServiceAccess: [IAMClientTypes.ListPoliciesGrantingServiceAccessEntry]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policiesGrantingServiceAccess = policiesGrantingServiceAccess
    }
}

enum ListPoliciesGrantingServiceAccessOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case onlyAttached = "OnlyAttached"
        case pathPrefix = "PathPrefix"
        case policyUsageFilter = "PolicyUsageFilter"
        case scope = "Scope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let onlyAttached = onlyAttached {
            try container.encode(onlyAttached, forKey: ClientRuntime.Key("OnlyAttached"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        if let policyUsageFilter = policyUsageFilter {
            try container.encode(policyUsageFilter, forKey: ClientRuntime.Key("PolicyUsageFilter"))
        }
        if let scope = scope {
            try container.encode(scope, forKey: ClientRuntime.Key("Scope"))
        }
        try container.encode("ListPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPoliciesInput {

    static func urlPathProvider(_ value: ListPoliciesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListPoliciesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// A flag to filter the results to only the attached policies. When OnlyAttached is true, the returned list contains only the policies that are attached to an IAM user, group, or role. When OnlyAttached is false, or when the parameter is not included, all policies are returned.
    public var onlyAttached: Swift.Bool?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The policy usage method to use for filtering the results. To list only permissions policies, set PolicyUsageFilter to PermissionsPolicy. To list only the policies used to set permissions boundaries, set the value to PermissionsBoundary. This parameter is optional. If it is not included, all policies are returned.
    public var policyUsageFilter: IAMClientTypes.PolicyUsageType?
    /// The scope to use for filtering the results. To list only Amazon Web Services managed policies, set Scope to AWS. To list only the customer managed policies in your Amazon Web Services account, set Scope to Local. This parameter is optional. If it is not included, or if it is set to All, all policies are returned.
    public var scope: IAMClientTypes.PolicyScopeType?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        onlyAttached: Swift.Bool? = nil,
        pathPrefix: Swift.String? = nil,
        policyUsageFilter: IAMClientTypes.PolicyUsageType? = nil,
        scope: IAMClientTypes.PolicyScopeType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.onlyAttached = onlyAttached
        self.pathPrefix = pathPrefix
        self.policyUsageFilter = policyUsageFilter
        self.scope = scope
    }
}

extension ListPoliciesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListPoliciesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListPoliciesResult"]
            var value = ListPoliciesOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.policies = try reader["Policies"].readListIfPresent(memberReadingClosure: IAMClientTypes.Policy.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [ListPolicies] request.
public struct ListPoliciesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policies.
    public var policies: [IAMClientTypes.Policy]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policies: [IAMClientTypes.Policy]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policies = policies
    }
}

enum ListPoliciesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListPolicyTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("ListPolicyTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPolicyTagsInput {

    static func urlPathProvider(_ value: ListPolicyTagsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListPolicyTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The ARN of the IAM customer managed policy whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.policyArn = policyArn
    }
}

extension ListPolicyTagsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListPolicyTagsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListPolicyTagsResult"]
            var value = ListPolicyTagsOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct ListPolicyTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the IAM customer managed policy. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

enum ListPolicyTagsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListPolicyVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("ListPolicyVersions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPolicyVersionsInput {

    static func urlPathProvider(_ value: ListPolicyVersionsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListPolicyVersionsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The Amazon Resource Name (ARN) of the IAM policy for which you want the versions. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.policyArn = policyArn
    }
}

extension ListPolicyVersionsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListPolicyVersionsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListPolicyVersionsResult"]
            var value = ListPolicyVersionsOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyVersion.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [ListPolicyVersions] request.
public struct ListPolicyVersionsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy versions. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    public var versions: [IAMClientTypes.PolicyVersion]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        versions: [IAMClientTypes.PolicyVersion]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.versions = versions
    }
}

enum ListPolicyVersionsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListRolePoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("ListRolePolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListRolePoliciesInput {

    static func urlPathProvider(_ value: ListRolePoliciesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListRolePoliciesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the role to list policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.roleName = roleName
    }
}

extension ListRolePoliciesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListRolePoliciesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListRolePoliciesResult"]
            var value = ListRolePoliciesOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.policyNames = try reader["PolicyNames"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [ListRolePolicies] request.
public struct ListRolePoliciesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy names.
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyNames = policyNames
    }
}

enum ListRolePoliciesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListRoleTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("ListRoleTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListRoleTagsInput {

    static func urlPathProvider(_ value: ListRoleTagsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListRoleTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM role for which you want to see the list of tags. This parameter accepts (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.roleName = roleName
    }
}

extension ListRoleTagsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListRoleTagsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListRoleTagsResult"]
            var value = ListRoleTagsOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct ListRoleTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the role. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

enum ListRoleTagsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListRolesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListRoles", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListRolesInput {

    static func urlPathProvider(_ value: ListRolesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListRolesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example, the prefix /application_abc/component_xyz/ gets all roles whose path starts with /application_abc/component_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all roles. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

extension ListRolesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListRolesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListRolesResult"]
            var value = ListRolesOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.roles = try reader["Roles"].readListIfPresent(memberReadingClosure: IAMClientTypes.Role.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [ListRoles] request.
public struct ListRolesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of roles.
    /// This member is required.
    public var roles: [IAMClientTypes.Role]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        roles: [IAMClientTypes.Role]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.roles = roles
    }
}

enum ListRolesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListSAMLProviderTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case samlProviderArn = "SAMLProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        try container.encode("ListSAMLProviderTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSAMLProviderTagsInput {

    static func urlPathProvider(_ value: ListSAMLProviderTagsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListSAMLProviderTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The ARN of the Security Assertion Markup Language (SAML) identity provider whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        samlProviderArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.samlProviderArn = samlProviderArn
    }
}

extension ListSAMLProviderTagsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListSAMLProviderTagsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListSAMLProviderTagsResult"]
            var value = ListSAMLProviderTagsOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct ListSAMLProviderTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the Security Assertion Markup Language (SAML) identity provider. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

enum ListSAMLProviderTagsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListSAMLProvidersInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("ListSAMLProviders", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSAMLProvidersInput {

    static func urlPathProvider(_ value: ListSAMLProvidersInput) -> Swift.String? {
        return "/"
    }
}

public struct ListSAMLProvidersInput: Swift.Equatable {

    public init() { }
}

extension ListSAMLProvidersOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListSAMLProvidersOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListSAMLProvidersResult"]
            var value = ListSAMLProvidersOutput()
            value.samlProviderList = try reader["SAMLProviderList"].readListIfPresent(memberReadingClosure: IAMClientTypes.SAMLProviderListEntry.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [ListSAMLProviders] request.
public struct ListSAMLProvidersOutput: Swift.Equatable {
    /// The list of SAML provider resource objects defined in IAM for this Amazon Web Services account.
    public var samlProviderList: [IAMClientTypes.SAMLProviderListEntry]?

    public init(
        samlProviderList: [IAMClientTypes.SAMLProviderListEntry]? = nil
    )
    {
        self.samlProviderList = samlProviderList
    }
}

enum ListSAMLProvidersOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListSSHPublicKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListSSHPublicKeys", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSSHPublicKeysInput {

    static func urlPathProvider(_ value: ListSSHPublicKeysInput) -> Swift.String? {
        return "/"
    }
}

public struct ListSSHPublicKeysInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM user to list SSH public keys for. If none is specified, the UserName field is determined implicitly based on the Amazon Web Services access key used to sign the request. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension ListSSHPublicKeysOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListSSHPublicKeysOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListSSHPublicKeysResult"]
            var value = ListSSHPublicKeysOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.sshPublicKeys = try reader["SSHPublicKeys"].readListIfPresent(memberReadingClosure: IAMClientTypes.SSHPublicKeyMetadata.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [ListSSHPublicKeys] request.
public struct ListSSHPublicKeysOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of the SSH public keys assigned to IAM user.
    public var sshPublicKeys: [IAMClientTypes.SSHPublicKeyMetadata]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        sshPublicKeys: [IAMClientTypes.SSHPublicKeyMetadata]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.sshPublicKeys = sshPublicKeys
    }
}

enum ListSSHPublicKeysOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListServerCertificateTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case serverCertificateName = "ServerCertificateName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        try container.encode("ListServerCertificateTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListServerCertificateTagsInput {

    static func urlPathProvider(_ value: ListServerCertificateTagsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListServerCertificateTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM server certificate whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        serverCertificateName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.serverCertificateName = serverCertificateName
    }
}

extension ListServerCertificateTagsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListServerCertificateTagsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListServerCertificateTagsResult"]
            var value = ListServerCertificateTagsOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct ListServerCertificateTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the IAM server certificate. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

enum ListServerCertificateTagsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListServerCertificatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListServerCertificates", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListServerCertificatesInput {

    static func urlPathProvider(_ value: ListServerCertificatesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListServerCertificatesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example: /company/servercerts would get all server certificates for which the path starts with /company/servercerts. This parameter is optional. If it is not included, it defaults to a slash (/), listing all server certificates. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

extension ListServerCertificatesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListServerCertificatesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListServerCertificatesResult"]
            var value = ListServerCertificatesOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.serverCertificateMetadataList = try reader["ServerCertificateMetadataList"].readListIfPresent(memberReadingClosure: IAMClientTypes.ServerCertificateMetadata.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [ListServerCertificates] request.
public struct ListServerCertificatesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of server certificates.
    /// This member is required.
    public var serverCertificateMetadataList: [IAMClientTypes.ServerCertificateMetadata]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        serverCertificateMetadataList: [IAMClientTypes.ServerCertificateMetadata]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.serverCertificateMetadataList = serverCertificateMetadataList
    }
}

enum ListServerCertificatesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListServiceSpecificCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName = "ServiceName"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListServiceSpecificCredentials", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListServiceSpecificCredentialsInput {

    static func urlPathProvider(_ value: ListServiceSpecificCredentialsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListServiceSpecificCredentialsInput: Swift.Equatable {
    /// Filters the returned results to only those for the specified Amazon Web Services service. If not specified, then Amazon Web Services returns service-specific credentials for all services.
    public var serviceName: Swift.String?
    /// The name of the user whose service-specific credentials you want information about. If this value is not specified, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        serviceName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceName = serviceName
        self.userName = userName
    }
}

extension ListServiceSpecificCredentialsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListServiceSpecificCredentialsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListServiceSpecificCredentialsResult"]
            var value = ListServiceSpecificCredentialsOutput()
            value.serviceSpecificCredentials = try reader["ServiceSpecificCredentials"].readListIfPresent(memberReadingClosure: IAMClientTypes.ServiceSpecificCredentialMetadata.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct ListServiceSpecificCredentialsOutput: Swift.Equatable {
    /// A list of structures that each contain details about a service-specific credential.
    public var serviceSpecificCredentials: [IAMClientTypes.ServiceSpecificCredentialMetadata]?

    public init(
        serviceSpecificCredentials: [IAMClientTypes.ServiceSpecificCredentialMetadata]? = nil
    )
    {
        self.serviceSpecificCredentials = serviceSpecificCredentials
    }
}

enum ListServiceSpecificCredentialsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotSupportedService": return try await ServiceNotSupportedException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListSigningCertificatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListSigningCertificates", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSigningCertificatesInput {

    static func urlPathProvider(_ value: ListSigningCertificatesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListSigningCertificatesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM user whose signing certificates you want to examine. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension ListSigningCertificatesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListSigningCertificatesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListSigningCertificatesResult"]
            var value = ListSigningCertificatesOutput()
            value.certificates = try reader["Certificates"].readListIfPresent(memberReadingClosure: IAMClientTypes.SigningCertificate.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [ListSigningCertificates] request.
public struct ListSigningCertificatesOutput: Swift.Equatable {
    /// A list of the user's signing certificate information.
    /// This member is required.
    public var certificates: [IAMClientTypes.SigningCertificate]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        certificates: [IAMClientTypes.SigningCertificate]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

enum ListSigningCertificatesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListUserPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListUserPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListUserPoliciesInput {

    static func urlPathProvider(_ value: ListUserPoliciesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListUserPoliciesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user to list policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension ListUserPoliciesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListUserPoliciesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListUserPoliciesResult"]
            var value = ListUserPoliciesOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.policyNames = try reader["PolicyNames"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [ListUserPolicies] request.
public struct ListUserPoliciesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy names.
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyNames = policyNames
    }
}

enum ListUserPoliciesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListUserTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListUserTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListUserTagsInput {

    static func urlPathProvider(_ value: ListUserTagsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListUserTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM user whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

extension ListUserTagsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListUserTagsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListUserTagsResult"]
            var value = ListUserTagsOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct ListUserTagsOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the user. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

enum ListUserTagsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListUsers", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListUsersInput {

    static func urlPathProvider(_ value: ListUsersInput) -> Swift.String? {
        return "/"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example: /division_abc/subdivision_xyz/, which would get all user names whose path starts with /division_abc/subdivision_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all user names. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

extension ListUsersOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListUsersOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListUsersResult"]
            var value = ListUsersOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.users = try reader["Users"].readListIfPresent(memberReadingClosure: IAMClientTypes.User.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [ListUsers] request.
public struct ListUsersOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of users.
    /// This member is required.
    public var users: [IAMClientTypes.User]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        users: [IAMClientTypes.User]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.users = users
    }
}

enum ListUsersOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListVirtualMFADevicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentStatus = "AssignmentStatus"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let assignmentStatus = assignmentStatus {
            try container.encode(assignmentStatus, forKey: ClientRuntime.Key("AssignmentStatus"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("ListVirtualMFADevices", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListVirtualMFADevicesInput {

    static func urlPathProvider(_ value: ListVirtualMFADevicesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListVirtualMFADevicesInput: Swift.Equatable {
    /// The status (Unassigned or Assigned) of the devices to list. If you do not specify an AssignmentStatus, the operation defaults to Any, which lists both assigned and unassigned virtual MFA devices.,
    public var assignmentStatus: IAMClientTypes.AssignmentStatusType?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init(
        assignmentStatus: IAMClientTypes.AssignmentStatusType? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.assignmentStatus = assignmentStatus
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListVirtualMFADevicesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListVirtualMFADevicesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListVirtualMFADevicesResult"]
            var value = ListVirtualMFADevicesOutput()
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            value.virtualMFADevices = try reader["VirtualMFADevices"].readListIfPresent(memberReadingClosure: IAMClientTypes.VirtualMFADevice.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [ListVirtualMFADevices] request.
public struct ListVirtualMFADevicesOutput: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of virtual MFA devices in the current account that match the AssignmentStatus value that was passed in the request.
    /// This member is required.
    public var virtualMFADevices: [IAMClientTypes.VirtualMFADevice]?

    public init(
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        virtualMFADevices: [IAMClientTypes.VirtualMFADevice]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.virtualMFADevices = virtualMFADevices
    }
}

enum ListVirtualMFADevicesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension IAMClientTypes.LoginProfile: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case passwordResetRequired = "PasswordResetRequired"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if passwordResetRequired != false {
            try container.encode(passwordResetRequired, forKey: ClientRuntime.Key("PasswordResetRequired"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.LoginProfile, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.LoginProfile()
            value.userName = try reader["UserName"].readIfPresent()
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            value.passwordResetRequired = try reader["PasswordResetRequired"].readIfPresent() ?? false
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains the user name and password create date for a user. This data type is used as a response element in the [CreateLoginProfile] and [GetLoginProfile] operations.
    public struct LoginProfile: Swift.Equatable {
        /// The date when the password for the user was created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// Specifies whether the user is required to set a new password on next sign-in.
        public var passwordResetRequired: Swift.Bool
        /// The name of the user, which can be used for signing in to the Amazon Web Services Management Console.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            createDate: ClientRuntime.Date? = nil,
            passwordResetRequired: Swift.Bool = false,
            userName: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.passwordResetRequired = passwordResetRequired
            self.userName = userName
        }
    }

}

extension IAMClientTypes.MFADevice: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableDate = "EnableDate"
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enableDate = enableDate {
            try container.encodeTimestamp(enableDate, format: .dateTime, forKey: ClientRuntime.Key("EnableDate"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.MFADevice, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.MFADevice()
            value.userName = try reader["UserName"].readIfPresent()
            value.serialNumber = try reader["SerialNumber"].readIfPresent()
            value.enableDate = try reader["EnableDate"].readTimestampIfPresent(format: .dateTime)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an MFA device. This data type is used as a response element in the [ListMFADevices] operation.
    public struct MFADevice: Swift.Equatable {
        /// The date when the MFA device was enabled for the user.
        /// This member is required.
        public var enableDate: ClientRuntime.Date?
        /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN.
        /// This member is required.
        public var serialNumber: Swift.String?
        /// The user with whom the MFA device is associated.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            enableDate: ClientRuntime.Date? = nil,
            serialNumber: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.enableDate = enableDate
            self.serialNumber = serialNumber
            self.userName = userName
        }
    }

}

extension MalformedCertificateException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = MalformedCertificateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the certificate was malformed or expired. The error message describes the specific error.
public struct MalformedCertificateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MalformedCertificate" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MalformedPolicyDocumentException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = MalformedPolicyDocumentException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the policy document was malformed. The error message describes the specific error.
public struct MalformedPolicyDocumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MalformedPolicyDocument" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IAMClientTypes.ManagedPolicyDetail: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case attachmentCount = "AttachmentCount"
        case createDate = "CreateDate"
        case defaultVersionId = "DefaultVersionId"
        case description = "Description"
        case isAttachable = "IsAttachable"
        case path = "Path"
        case permissionsBoundaryUsageCount = "PermissionsBoundaryUsageCount"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case policyVersionList = "PolicyVersionList"
        case updateDate = "UpdateDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let attachmentCount = attachmentCount {
            try container.encode(attachmentCount, forKey: ClientRuntime.Key("AttachmentCount"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let defaultVersionId = defaultVersionId {
            try container.encode(defaultVersionId, forKey: ClientRuntime.Key("DefaultVersionId"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if isAttachable != false {
            try container.encode(isAttachable, forKey: ClientRuntime.Key("IsAttachable"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundaryUsageCount = permissionsBoundaryUsageCount {
            try container.encode(permissionsBoundaryUsageCount, forKey: ClientRuntime.Key("PermissionsBoundaryUsageCount"))
        }
        if let policyId = policyId {
            try container.encode(policyId, forKey: ClientRuntime.Key("PolicyId"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let policyVersionList = policyVersionList {
            if !policyVersionList.isEmpty {
                var policyVersionListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyVersionList"))
                for (index0, policyversion0) in policyVersionList.enumerated() {
                    try policyVersionListContainer.encode(policyversion0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyVersionListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyVersionList"))
                try policyVersionListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let updateDate = updateDate {
            try container.encodeTimestamp(updateDate, format: .dateTime, forKey: ClientRuntime.Key("UpdateDate"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.ManagedPolicyDetail, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.ManagedPolicyDetail()
            value.policyName = try reader["PolicyName"].readIfPresent()
            value.policyId = try reader["PolicyId"].readIfPresent()
            value.arn = try reader["Arn"].readIfPresent()
            value.path = try reader["Path"].readIfPresent()
            value.defaultVersionId = try reader["DefaultVersionId"].readIfPresent()
            value.attachmentCount = try reader["AttachmentCount"].readIfPresent()
            value.permissionsBoundaryUsageCount = try reader["PermissionsBoundaryUsageCount"].readIfPresent()
            value.isAttachable = try reader["IsAttachable"].readIfPresent() ?? false
            value.description = try reader["Description"].readIfPresent()
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            value.updateDate = try reader["UpdateDate"].readTimestampIfPresent(format: .dateTime)
            value.policyVersionList = try reader["PolicyVersionList"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyVersion.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a managed policy, including the policy's ARN, versions, and the number of principal entities (users, groups, and roles) that the policy is attached to. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation. For more information about managed policies, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct ManagedPolicyDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The number of principal entities (users, groups, and roles) that the policy is attached to.
        public var attachmentCount: Swift.Int?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was created.
        public var createDate: ClientRuntime.Date?
        /// The identifier for the version of the policy that is set as the default (operative) version. For more information about policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
        public var defaultVersionId: Swift.String?
        /// A friendly description of the policy.
        public var description: Swift.String?
        /// Specifies whether the policy can be attached to an IAM user, group, or role.
        public var isAttachable: Swift.Bool
        /// The path to the policy. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The number of entities (users and roles) for which the policy is used as the permissions boundary. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundaryUsageCount: Swift.Int?
        /// The stable and unique string identifying the policy. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var policyId: Swift.String?
        /// The friendly name (not ARN) identifying the policy.
        public var policyName: Swift.String?
        /// A list containing information about the versions of the policy.
        public var policyVersionList: [IAMClientTypes.PolicyVersion]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was last updated. When a policy has only one version, this field contains the date and time when the policy was created. When a policy has more than one version, this field contains the date and time when the most recent policy version was created.
        public var updateDate: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            attachmentCount: Swift.Int? = nil,
            createDate: ClientRuntime.Date? = nil,
            defaultVersionId: Swift.String? = nil,
            description: Swift.String? = nil,
            isAttachable: Swift.Bool = false,
            path: Swift.String? = nil,
            permissionsBoundaryUsageCount: Swift.Int? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyVersionList: [IAMClientTypes.PolicyVersion]? = nil,
            updateDate: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.attachmentCount = attachmentCount
            self.createDate = createDate
            self.defaultVersionId = defaultVersionId
            self.description = description
            self.isAttachable = isAttachable
            self.path = path
            self.permissionsBoundaryUsageCount = permissionsBoundaryUsageCount
            self.policyId = policyId
            self.policyName = policyName
            self.policyVersionList = policyVersionList
            self.updateDate = updateDate
        }
    }

}

extension NoSuchEntityException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchEntityException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because it referenced a resource entity that does not exist. The error message describes the resource.
public struct NoSuchEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchEntity" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IAMClientTypes.OpenIDConnectProviderListEntry: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.OpenIDConnectProviderListEntry, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.OpenIDConnectProviderListEntry()
            value.arn = try reader["Arn"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains the Amazon Resource Name (ARN) for an IAM OpenID Connect provider.
    public struct OpenIDConnectProviderListEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension IAMClientTypes.OrganizationsDecisionDetail: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedByOrganizations = "AllowedByOrganizations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowedByOrganizations != false {
            try container.encode(allowedByOrganizations, forKey: ClientRuntime.Key("AllowedByOrganizations"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.OrganizationsDecisionDetail, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.OrganizationsDecisionDetail()
            value.allowedByOrganizations = try reader["AllowedByOrganizations"].readIfPresent() ?? false
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about the effect that Organizations has on a policy simulation.
    public struct OrganizationsDecisionDetail: Swift.Equatable {
        /// Specifies whether the simulated operation is allowed by the Organizations service control policies that impact the simulated user's account.
        public var allowedByOrganizations: Swift.Bool

        public init(
            allowedByOrganizations: Swift.Bool = false
        )
        {
            self.allowedByOrganizations = allowedByOrganizations
        }
    }

}

extension IAMClientTypes.PasswordPolicy: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUsersToChangePassword = "AllowUsersToChangePassword"
        case expirePasswords = "ExpirePasswords"
        case hardExpiry = "HardExpiry"
        case maxPasswordAge = "MaxPasswordAge"
        case minimumPasswordLength = "MinimumPasswordLength"
        case passwordReusePrevention = "PasswordReusePrevention"
        case requireLowercaseCharacters = "RequireLowercaseCharacters"
        case requireNumbers = "RequireNumbers"
        case requireSymbols = "RequireSymbols"
        case requireUppercaseCharacters = "RequireUppercaseCharacters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowUsersToChangePassword != false {
            try container.encode(allowUsersToChangePassword, forKey: ClientRuntime.Key("AllowUsersToChangePassword"))
        }
        if expirePasswords != false {
            try container.encode(expirePasswords, forKey: ClientRuntime.Key("ExpirePasswords"))
        }
        if let hardExpiry = hardExpiry {
            try container.encode(hardExpiry, forKey: ClientRuntime.Key("HardExpiry"))
        }
        if let maxPasswordAge = maxPasswordAge {
            try container.encode(maxPasswordAge, forKey: ClientRuntime.Key("MaxPasswordAge"))
        }
        if let minimumPasswordLength = minimumPasswordLength {
            try container.encode(minimumPasswordLength, forKey: ClientRuntime.Key("MinimumPasswordLength"))
        }
        if let passwordReusePrevention = passwordReusePrevention {
            try container.encode(passwordReusePrevention, forKey: ClientRuntime.Key("PasswordReusePrevention"))
        }
        if requireLowercaseCharacters != false {
            try container.encode(requireLowercaseCharacters, forKey: ClientRuntime.Key("RequireLowercaseCharacters"))
        }
        if requireNumbers != false {
            try container.encode(requireNumbers, forKey: ClientRuntime.Key("RequireNumbers"))
        }
        if requireSymbols != false {
            try container.encode(requireSymbols, forKey: ClientRuntime.Key("RequireSymbols"))
        }
        if requireUppercaseCharacters != false {
            try container.encode(requireUppercaseCharacters, forKey: ClientRuntime.Key("RequireUppercaseCharacters"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.PasswordPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.PasswordPolicy()
            value.minimumPasswordLength = try reader["MinimumPasswordLength"].readIfPresent()
            value.requireSymbols = try reader["RequireSymbols"].readIfPresent() ?? false
            value.requireNumbers = try reader["RequireNumbers"].readIfPresent() ?? false
            value.requireUppercaseCharacters = try reader["RequireUppercaseCharacters"].readIfPresent() ?? false
            value.requireLowercaseCharacters = try reader["RequireLowercaseCharacters"].readIfPresent() ?? false
            value.allowUsersToChangePassword = try reader["AllowUsersToChangePassword"].readIfPresent() ?? false
            value.expirePasswords = try reader["ExpirePasswords"].readIfPresent() ?? false
            value.maxPasswordAge = try reader["MaxPasswordAge"].readIfPresent()
            value.passwordReusePrevention = try reader["PasswordReusePrevention"].readIfPresent()
            value.hardExpiry = try reader["HardExpiry"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about the account password policy. This data type is used as a response element in the [GetAccountPasswordPolicy] operation.
    public struct PasswordPolicy: Swift.Equatable {
        /// Specifies whether IAM users are allowed to change their own password. Gives IAM users permissions to iam:ChangePassword for only their user and to the iam:GetAccountPasswordPolicy action. This option does not attach a permissions policy to each user, rather the permissions are applied at the account-level for all users by IAM.
        public var allowUsersToChangePassword: Swift.Bool
        /// Indicates whether passwords in the account expire. Returns true if MaxPasswordAge contains a value greater than 0. Returns false if MaxPasswordAge is 0 or not present.
        public var expirePasswords: Swift.Bool
        /// Specifies whether IAM users are prevented from setting a new password via the Amazon Web Services Management Console after their password has expired. The IAM user cannot access the console until an administrator resets the password. IAM users with iam:ChangePassword permission and active access keys can reset their own expired console password using the CLI or API.
        public var hardExpiry: Swift.Bool?
        /// The number of days that an IAM user password is valid.
        public var maxPasswordAge: Swift.Int?
        /// Minimum length to require for IAM user passwords.
        public var minimumPasswordLength: Swift.Int?
        /// Specifies the number of previous passwords that IAM users are prevented from reusing.
        public var passwordReusePrevention: Swift.Int?
        /// Specifies whether IAM user passwords must contain at least one lowercase character (a to z).
        public var requireLowercaseCharacters: Swift.Bool
        /// Specifies whether IAM user passwords must contain at least one numeric character (0 to 9).
        public var requireNumbers: Swift.Bool
        /// Specifies whether IAM user passwords must contain at least one of the following symbols: ! @ # $ % ^ & * ( ) _ + - = [ ] { } | '
        public var requireSymbols: Swift.Bool
        /// Specifies whether IAM user passwords must contain at least one uppercase character (A to Z).
        public var requireUppercaseCharacters: Swift.Bool

        public init(
            allowUsersToChangePassword: Swift.Bool = false,
            expirePasswords: Swift.Bool = false,
            hardExpiry: Swift.Bool? = nil,
            maxPasswordAge: Swift.Int? = nil,
            minimumPasswordLength: Swift.Int? = nil,
            passwordReusePrevention: Swift.Int? = nil,
            requireLowercaseCharacters: Swift.Bool = false,
            requireNumbers: Swift.Bool = false,
            requireSymbols: Swift.Bool = false,
            requireUppercaseCharacters: Swift.Bool = false
        )
        {
            self.allowUsersToChangePassword = allowUsersToChangePassword
            self.expirePasswords = expirePasswords
            self.hardExpiry = hardExpiry
            self.maxPasswordAge = maxPasswordAge
            self.minimumPasswordLength = minimumPasswordLength
            self.passwordReusePrevention = passwordReusePrevention
            self.requireLowercaseCharacters = requireLowercaseCharacters
            self.requireNumbers = requireNumbers
            self.requireSymbols = requireSymbols
            self.requireUppercaseCharacters = requireUppercaseCharacters
        }
    }

}

extension PasswordPolicyViolationException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = PasswordPolicyViolationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the provided password did not meet the requirements imposed by the account password policy.
public struct PasswordPolicyViolationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PasswordPolicyViolation" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IAMClientTypes {
    public enum PermissionsBoundaryAttachmentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case policy
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionsBoundaryAttachmentType] {
            return [
                .policy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .policy: return "PermissionsBoundaryPolicy"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionsBoundaryAttachmentType(rawValue: rawValue) ?? PermissionsBoundaryAttachmentType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.PermissionsBoundaryDecisionDetail: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedByPermissionsBoundary = "AllowedByPermissionsBoundary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowedByPermissionsBoundary != false {
            try container.encode(allowedByPermissionsBoundary, forKey: ClientRuntime.Key("AllowedByPermissionsBoundary"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.PermissionsBoundaryDecisionDetail, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.PermissionsBoundaryDecisionDetail()
            value.allowedByPermissionsBoundary = try reader["AllowedByPermissionsBoundary"].readIfPresent() ?? false
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about the effect that a permissions boundary has on a policy simulation when the boundary is applied to an IAM entity.
    public struct PermissionsBoundaryDecisionDetail: Swift.Equatable {
        /// Specifies whether an action is allowed by a permissions boundary that is applied to an IAM entity (user or role). A value of true means that the permissions boundary does not deny the action. This means that the policy includes an Allow statement that matches the request. In this case, if an identity-based policy also allows the action, the request is allowed. A value of false means that either the requested action is not allowed (implicitly denied) or that the action is explicitly denied by the permissions boundary. In both of these cases, the action is not allowed, regardless of the identity-based policy.
        public var allowedByPermissionsBoundary: Swift.Bool

        public init(
            allowedByPermissionsBoundary: Swift.Bool = false
        )
        {
            self.allowedByPermissionsBoundary = allowedByPermissionsBoundary
        }
    }

}

extension IAMClientTypes.Policy: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case attachmentCount = "AttachmentCount"
        case createDate = "CreateDate"
        case defaultVersionId = "DefaultVersionId"
        case description = "Description"
        case isAttachable = "IsAttachable"
        case path = "Path"
        case permissionsBoundaryUsageCount = "PermissionsBoundaryUsageCount"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case tags = "Tags"
        case updateDate = "UpdateDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let attachmentCount = attachmentCount {
            try container.encode(attachmentCount, forKey: ClientRuntime.Key("AttachmentCount"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let defaultVersionId = defaultVersionId {
            try container.encode(defaultVersionId, forKey: ClientRuntime.Key("DefaultVersionId"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if isAttachable != false {
            try container.encode(isAttachable, forKey: ClientRuntime.Key("IsAttachable"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundaryUsageCount = permissionsBoundaryUsageCount {
            try container.encode(permissionsBoundaryUsageCount, forKey: ClientRuntime.Key("PermissionsBoundaryUsageCount"))
        }
        if let policyId = policyId {
            try container.encode(policyId, forKey: ClientRuntime.Key("PolicyId"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let updateDate = updateDate {
            try container.encodeTimestamp(updateDate, format: .dateTime, forKey: ClientRuntime.Key("UpdateDate"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.Policy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.Policy()
            value.policyName = try reader["PolicyName"].readIfPresent()
            value.policyId = try reader["PolicyId"].readIfPresent()
            value.arn = try reader["Arn"].readIfPresent()
            value.path = try reader["Path"].readIfPresent()
            value.defaultVersionId = try reader["DefaultVersionId"].readIfPresent()
            value.attachmentCount = try reader["AttachmentCount"].readIfPresent()
            value.permissionsBoundaryUsageCount = try reader["PermissionsBoundaryUsageCount"].readIfPresent()
            value.isAttachable = try reader["IsAttachable"].readIfPresent() ?? false
            value.description = try reader["Description"].readIfPresent()
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            value.updateDate = try reader["UpdateDate"].readTimestampIfPresent(format: .dateTime)
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a managed policy. This data type is used as a response element in the [CreatePolicy], [GetPolicy], and [ListPolicies] operations. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct Policy: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The number of entities (users, groups, and roles) that the policy is attached to.
        public var attachmentCount: Swift.Int?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was created.
        public var createDate: ClientRuntime.Date?
        /// The identifier for the version of the policy that is set as the default version.
        public var defaultVersionId: Swift.String?
        /// A friendly description of the policy. This element is included in the response to the [GetPolicy] operation. It is not included in the response to the [ListPolicies] operation.
        public var description: Swift.String?
        /// Specifies whether the policy can be attached to an IAM user, group, or role.
        public var isAttachable: Swift.Bool
        /// The path to the policy. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The number of entities (users and roles) for which the policy is used to set the permissions boundary. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundaryUsageCount: Swift.Int?
        /// The stable and unique string identifying the policy. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var policyId: Swift.String?
        /// The friendly name (not ARN) identifying the policy.
        public var policyName: Swift.String?
        /// A list of tags that are attached to the instance profile. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was last updated. When a policy has only one version, this field contains the date and time when the policy was created. When a policy has more than one version, this field contains the date and time when the most recent policy version was created.
        public var updateDate: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            attachmentCount: Swift.Int? = nil,
            createDate: ClientRuntime.Date? = nil,
            defaultVersionId: Swift.String? = nil,
            description: Swift.String? = nil,
            isAttachable: Swift.Bool = false,
            path: Swift.String? = nil,
            permissionsBoundaryUsageCount: Swift.Int? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            updateDate: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.attachmentCount = attachmentCount
            self.createDate = createDate
            self.defaultVersionId = defaultVersionId
            self.description = description
            self.isAttachable = isAttachable
            self.path = path
            self.permissionsBoundaryUsageCount = permissionsBoundaryUsageCount
            self.policyId = policyId
            self.policyName = policyName
            self.tags = tags
            self.updateDate = updateDate
        }
    }

}

extension IAMClientTypes.PolicyDetail: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.PolicyDetail, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.PolicyDetail()
            value.policyName = try reader["PolicyName"].readIfPresent()
            value.policyDocument = try reader["PolicyDocument"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM policy, including the policy document. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct PolicyDetail: Swift.Equatable {
        /// The policy document.
        public var policyDocument: Swift.String?
        /// The name of the policy.
        public var policyName: Swift.String?

        public init(
            policyDocument: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.policyDocument = policyDocument
            self.policyName = policyName
        }
    }

}

extension IAMClientTypes {
    public enum PolicyEvaluationDecisionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allowed
        case explicitDeny
        case implicitDeny
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyEvaluationDecisionType] {
            return [
                .allowed,
                .explicitDeny,
                .implicitDeny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allowed: return "allowed"
            case .explicitDeny: return "explicitDeny"
            case .implicitDeny: return "implicitDeny"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyEvaluationDecisionType(rawValue: rawValue) ?? PolicyEvaluationDecisionType.sdkUnknown(rawValue)
        }
    }
}

extension PolicyEvaluationException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = PolicyEvaluationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request failed because a provided policy could not be successfully evaluated. An additional detailed message indicates the source of the failure.
public struct PolicyEvaluationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyEvaluation" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IAMClientTypes.PolicyGrantingServiceAccess: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityName = "EntityName"
        case entityType = "EntityType"
        case policyArn = "PolicyArn"
        case policyName = "PolicyName"
        case policyType = "PolicyType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let entityName = entityName {
            try container.encode(entityName, forKey: ClientRuntime.Key("EntityName"))
        }
        if let entityType = entityType {
            try container.encode(entityType, forKey: ClientRuntime.Key("EntityType"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let policyType = policyType {
            try container.encode(policyType, forKey: ClientRuntime.Key("PolicyType"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.PolicyGrantingServiceAccess, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.PolicyGrantingServiceAccess()
            value.policyName = try reader["PolicyName"].readIfPresent()
            value.policyType = try reader["PolicyType"].readIfPresent()
            value.policyArn = try reader["PolicyArn"].readIfPresent()
            value.entityType = try reader["EntityType"].readIfPresent()
            value.entityName = try reader["EntityName"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains details about the permissions policies that are attached to the specified identity (user, group, or role). This data type is an element of the [ListPoliciesGrantingServiceAccessEntry] object.
    public struct PolicyGrantingServiceAccess: Swift.Equatable {
        /// The name of the entity (user or role) to which the inline policy is attached. This field is null for managed policies. For more information about these policy types, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html) in the IAM User Guide.
        public var entityName: Swift.String?
        /// The type of entity (user or role) that used the policy to access the service to which the inline policy is attached. This field is null for managed policies. For more information about these policy types, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html) in the IAM User Guide.
        public var entityType: IAMClientTypes.PolicyOwnerEntityType?
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var policyArn: Swift.String?
        /// The policy name.
        /// This member is required.
        public var policyName: Swift.String?
        /// The policy type. For more information about these policy types, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html) in the IAM User Guide.
        /// This member is required.
        public var policyType: IAMClientTypes.PolicyType?

        public init(
            entityName: Swift.String? = nil,
            entityType: IAMClientTypes.PolicyOwnerEntityType? = nil,
            policyArn: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyType: IAMClientTypes.PolicyType? = nil
        )
        {
            self.entityName = entityName
            self.entityType = entityType
            self.policyArn = policyArn
            self.policyName = policyName
            self.policyType = policyType
        }
    }

}

extension IAMClientTypes.PolicyGroup: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupId = groupId {
            try container.encode(groupId, forKey: ClientRuntime.Key("GroupId"))
        }
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.PolicyGroup, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.PolicyGroup()
            value.groupName = try reader["GroupName"].readIfPresent()
            value.groupId = try reader["GroupId"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a group that a managed policy is attached to. This data type is used as a response element in the [ListEntitiesForPolicy] operation. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyGroup: Swift.Equatable {
        /// The stable and unique string identifying the group. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        public var groupId: Swift.String?
        /// The name (friendly name, not ARN) identifying the group.
        public var groupName: Swift.String?

        public init(
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }

}

extension PolicyNotAttachableException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = PolicyNotAttachableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request failed because Amazon Web Services service role policies can only be attached to the service-linked role for that service.
public struct PolicyNotAttachableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyNotAttachable" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IAMClientTypes {
    public enum PolicyOwnerEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case role
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyOwnerEntityType] {
            return [
                .group,
                .role,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .role: return "ROLE"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyOwnerEntityType(rawValue: rawValue) ?? PolicyOwnerEntityType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.PolicyRole: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleId = "RoleId"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleId = roleId {
            try container.encode(roleId, forKey: ClientRuntime.Key("RoleId"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.PolicyRole, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.PolicyRole()
            value.roleName = try reader["RoleName"].readIfPresent()
            value.roleId = try reader["RoleId"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a role that a managed policy is attached to. This data type is used as a response element in the [ListEntitiesForPolicy] operation. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyRole: Swift.Equatable {
        /// The stable and unique string identifying the role. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        public var roleId: Swift.String?
        /// The name (friendly name, not ARN) identifying the role.
        public var roleName: Swift.String?

        public init(
            roleId: Swift.String? = nil,
            roleName: Swift.String? = nil
        )
        {
            self.roleId = roleId
            self.roleName = roleName
        }
    }

}

extension IAMClientTypes {
    public enum PolicyScopeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aws
        case all
        case local
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyScopeType] {
            return [
                .aws,
                .all,
                .local,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .all: return "All"
            case .local: return "Local"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyScopeType(rawValue: rawValue) ?? PolicyScopeType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes {
    public enum PolicySourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsManaged
        case group
        case `none`
        case resource
        case role
        case user
        case userManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicySourceType] {
            return [
                .awsManaged,
                .group,
                .none,
                .resource,
                .role,
                .user,
                .userManaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsManaged: return "aws-managed"
            case .group: return "group"
            case .none: return "none"
            case .resource: return "resource"
            case .role: return "role"
            case .user: return "user"
            case .userManaged: return "user-managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicySourceType(rawValue: rawValue) ?? PolicySourceType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes {
    public enum PolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inline
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyType] {
            return [
                .inline,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inline: return "INLINE"
            case .managed: return "MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyType(rawValue: rawValue) ?? PolicyType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes {
    /// The policy usage type that indicates whether the policy is used as a permissions policy or as the permissions boundary for an entity. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
    public enum PolicyUsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case permissionsboundary
        case permissionspolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyUsageType] {
            return [
                .permissionsboundary,
                .permissionspolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .permissionsboundary: return "PermissionsBoundary"
            case .permissionspolicy: return "PermissionsPolicy"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyUsageType(rawValue: rawValue) ?? PolicyUsageType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.PolicyUser: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId = "UserId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userId = userId {
            try container.encode(userId, forKey: ClientRuntime.Key("UserId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.PolicyUser, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.PolicyUser()
            value.userName = try reader["UserName"].readIfPresent()
            value.userId = try reader["UserId"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a user that a managed policy is attached to. This data type is used as a response element in the [ListEntitiesForPolicy] operation. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyUser: Swift.Equatable {
        /// The stable and unique string identifying the user. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        public var userId: Swift.String?
        /// The name (friendly name, not ARN) identifying the user.
        public var userName: Swift.String?

        public init(
            userId: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.userId = userId
            self.userName = userName
        }
    }

}

extension IAMClientTypes.PolicyVersion: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case document = "Document"
        case isDefaultVersion = "IsDefaultVersion"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let document = document {
            try container.encode(document, forKey: ClientRuntime.Key("Document"))
        }
        if isDefaultVersion != false {
            try container.encode(isDefaultVersion, forKey: ClientRuntime.Key("IsDefaultVersion"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.PolicyVersion, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.PolicyVersion()
            value.document = try reader["Document"].readIfPresent()
            value.versionId = try reader["VersionId"].readIfPresent()
            value.isDefaultVersion = try reader["IsDefaultVersion"].readIfPresent() ?? false
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a version of a managed policy. This data type is used as a response element in the [CreatePolicyVersion], [GetPolicyVersion], [ListPolicyVersions], and [GetAccountAuthorizationDetails] operations. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyVersion: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy version was created.
        public var createDate: ClientRuntime.Date?
        /// The policy document. The policy document is returned in the response to the [GetPolicyVersion] and [GetAccountAuthorizationDetails] operations. It is not returned in the response to the [CreatePolicyVersion] or [ListPolicyVersions] operations. The policy document returned in this structure is URL-encoded compliant with [RFC 3986](https://tools.ietf.org/html/rfc3986). You can use a URL decoding method to convert the policy back to plain JSON text. For example, if you use Java, you can use the decode method of the java.net.URLDecoder utility class in the Java SDK. Other languages and SDKs provide similar functionality.
        public var document: Swift.String?
        /// Specifies whether the policy version is set as the policy's default version.
        public var isDefaultVersion: Swift.Bool
        /// The identifier for the policy version. Policy version identifiers always begin with v (always lowercase). When a policy is created, the first policy version is v1.
        public var versionId: Swift.String?

        public init(
            createDate: ClientRuntime.Date? = nil,
            document: Swift.String? = nil,
            isDefaultVersion: Swift.Bool = false,
            versionId: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.document = document
            self.isDefaultVersion = isDefaultVersion
            self.versionId = versionId
        }
    }

}

extension IAMClientTypes.Position: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column = "Column"
        case line = "Line"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if column != 0 {
            try container.encode(column, forKey: ClientRuntime.Key("Column"))
        }
        if line != 0 {
            try container.encode(line, forKey: ClientRuntime.Key("Line"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.Position, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.Position()
            value.line = try reader["Line"].readIfPresent() ?? 0
            value.column = try reader["Column"].readIfPresent() ?? 0
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains the row and column of a location of a Statement element in a policy document. This data type is used as a member of the [Statement] type.
    public struct Position: Swift.Equatable {
        /// The column in the line containing the specified position in the document.
        public var column: Swift.Int
        /// The line containing the specified position in the document.
        public var line: Swift.Int

        public init(
            column: Swift.Int = 0,
            line: Swift.Int = 0
        )
        {
            self.column = column
            self.line = line
        }
    }

}

extension PutGroupPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        try container.encode("PutGroupPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutGroupPolicyInput {

    static func urlPathProvider(_ value: PutGroupPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct PutGroupPolicyInput: Swift.Equatable {
    /// The name of the group to associate the policy with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-.
    /// This member is required.
    public var groupName: Swift.String?
    /// The policy document. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy document. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyDocument = policyDocument
        self.policyName = policyName
    }
}

extension PutGroupPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutGroupPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutGroupPolicyOutput()
        }
    }
}

public struct PutGroupPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutGroupPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension PutRolePermissionsBoundaryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionsBoundary = "PermissionsBoundary"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("PutRolePermissionsBoundary", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutRolePermissionsBoundaryInput {

    static func urlPathProvider(_ value: PutRolePermissionsBoundaryInput) -> Swift.String? {
        return "/"
    }
}

public struct PutRolePermissionsBoundaryInput: Swift.Equatable {
    /// The ARN of the managed policy that is used to set the permissions boundary for the role. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    /// This member is required.
    public var permissionsBoundary: Swift.String?
    /// The name (friendly name, not ARN) of the IAM role for which you want to set the permissions boundary.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        permissionsBoundary: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.permissionsBoundary = permissionsBoundary
        self.roleName = roleName
    }
}

extension PutRolePermissionsBoundaryOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutRolePermissionsBoundaryOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutRolePermissionsBoundaryOutput()
        }
    }
}

public struct PutRolePermissionsBoundaryOutput: Swift.Equatable {

    public init() { }
}

enum PutRolePermissionsBoundaryOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PolicyNotAttachable": return try await PolicyNotAttachableException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnmodifiableEntity": return try await UnmodifiableEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension PutRolePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("PutRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutRolePolicyInput {

    static func urlPathProvider(_ value: PutRolePolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct PutRolePolicyInput: Swift.Equatable {
    /// The policy document. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy document. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the role to associate the policy with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.roleName = roleName
    }
}

extension PutRolePolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutRolePolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutRolePolicyOutput()
        }
    }
}

public struct PutRolePolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutRolePolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnmodifiableEntity": return try await UnmodifiableEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension PutUserPermissionsBoundaryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionsBoundary = "PermissionsBoundary"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("PutUserPermissionsBoundary", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutUserPermissionsBoundaryInput {

    static func urlPathProvider(_ value: PutUserPermissionsBoundaryInput) -> Swift.String? {
        return "/"
    }
}

public struct PutUserPermissionsBoundaryInput: Swift.Equatable {
    /// The ARN of the managed policy that is used to set the permissions boundary for the user. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    /// This member is required.
    public var permissionsBoundary: Swift.String?
    /// The name (friendly name, not ARN) of the IAM user for which you want to set the permissions boundary.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        permissionsBoundary: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.permissionsBoundary = permissionsBoundary
        self.userName = userName
    }
}

extension PutUserPermissionsBoundaryOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutUserPermissionsBoundaryOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutUserPermissionsBoundaryOutput()
        }
    }
}

public struct PutUserPermissionsBoundaryOutput: Swift.Equatable {

    public init() { }
}

enum PutUserPermissionsBoundaryOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PolicyNotAttachable": return try await PolicyNotAttachableException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension PutUserPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("PutUserPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutUserPolicyInput {

    static func urlPathProvider(_ value: PutUserPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct PutUserPolicyInput: Swift.Equatable {
    /// The policy document. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy document. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the user to associate the policy with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.userName = userName
    }
}

extension PutUserPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutUserPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutUserPolicyOutput()
        }
    }
}

public struct PutUserPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutUserPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension RemoveClientIDFromOpenIDConnectProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientID = "ClientID"
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clientID = clientID {
            try container.encode(clientID, forKey: ClientRuntime.Key("ClientID"))
        }
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        try container.encode("RemoveClientIDFromOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveClientIDFromOpenIDConnectProviderInput {

    static func urlPathProvider(_ value: RemoveClientIDFromOpenIDConnectProviderInput) -> Swift.String? {
        return "/"
    }
}

public struct RemoveClientIDFromOpenIDConnectProviderInput: Swift.Equatable {
    /// The client ID (also known as audience) to remove from the IAM OIDC provider resource. For more information about client IDs, see [CreateOpenIDConnectProvider].
    /// This member is required.
    public var clientID: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM OIDC provider resource to remove the client ID from. You can get a list of OIDC provider ARNs by using the [ListOpenIDConnectProviders] operation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init(
        clientID: Swift.String? = nil,
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.clientID = clientID
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

extension RemoveClientIDFromOpenIDConnectProviderOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<RemoveClientIDFromOpenIDConnectProviderOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return RemoveClientIDFromOpenIDConnectProviderOutput()
        }
    }
}

public struct RemoveClientIDFromOpenIDConnectProviderOutput: Swift.Equatable {

    public init() { }
}

enum RemoveClientIDFromOpenIDConnectProviderOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension RemoveRoleFromInstanceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("RemoveRoleFromInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveRoleFromInstanceProfileInput {

    static func urlPathProvider(_ value: RemoveRoleFromInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

public struct RemoveRoleFromInstanceProfileInput: Swift.Equatable {
    /// The name of the instance profile to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The name of the role to remove. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        instanceProfileName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.roleName = roleName
    }
}

extension RemoveRoleFromInstanceProfileOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<RemoveRoleFromInstanceProfileOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return RemoveRoleFromInstanceProfileOutput()
        }
    }
}

public struct RemoveRoleFromInstanceProfileOutput: Swift.Equatable {

    public init() { }
}

enum RemoveRoleFromInstanceProfileOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnmodifiableEntity": return try await UnmodifiableEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension RemoveUserFromGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("RemoveUserFromGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveUserFromGroupInput {

    static func urlPathProvider(_ value: RemoveUserFromGroupInput) -> Swift.String? {
        return "/"
    }
}

public struct RemoveUserFromGroupInput: Swift.Equatable {
    /// The name of the group to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the user to remove. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.userName = userName
    }
}

extension RemoveUserFromGroupOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<RemoveUserFromGroupOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return RemoveUserFromGroupOutput()
        }
    }
}

public struct RemoveUserFromGroupOutput: Swift.Equatable {

    public init() { }
}

enum RemoveUserFromGroupOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension IAMClientTypes {
    public enum ReportFormatType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case textCsv
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFormatType] {
            return [
                .textCsv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .textCsv: return "text/csv"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFormatType(rawValue: rawValue) ?? ReportFormatType.sdkUnknown(rawValue)
        }
    }
}

extension ReportGenerationLimitExceededException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ReportGenerationLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request failed because the maximum number of concurrent requests for this account are already running.
public struct ReportGenerationLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReportGenerationLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IAMClientTypes {
    public enum ReportStateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case inprogress
        case started
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportStateType] {
            return [
                .complete,
                .inprogress,
                .started,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .inprogress: return "INPROGRESS"
            case .started: return "STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportStateType(rawValue: rawValue) ?? ReportStateType.sdkUnknown(rawValue)
        }
    }
}

extension ResetServiceSpecificCredentialInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: ClientRuntime.Key("ServiceSpecificCredentialId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ResetServiceSpecificCredential", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ResetServiceSpecificCredentialInput {

    static func urlPathProvider(_ value: ResetServiceSpecificCredentialInput) -> Swift.String? {
        return "/"
    }
}

public struct ResetServiceSpecificCredentialInput: Swift.Equatable {
    /// The unique identifier of the service-specific credential. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var serviceSpecificCredentialId: Swift.String?
    /// The name of the IAM user associated with the service-specific credential. If this value is not specified, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        serviceSpecificCredentialId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.userName = userName
    }
}

extension ResetServiceSpecificCredentialOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ResetServiceSpecificCredentialOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ResetServiceSpecificCredentialResult"]
            var value = ResetServiceSpecificCredentialOutput()
            value.serviceSpecificCredential = try reader["ServiceSpecificCredential"].readIfPresent(readingClosure: IAMClientTypes.ServiceSpecificCredential.readingClosure)
            return value
        }
    }
}

public struct ResetServiceSpecificCredentialOutput: Swift.Equatable {
    /// A structure with details about the updated service-specific credential, including the new password. This is the only time that you can access the password. You cannot recover the password later, but you can reset it again.
    public var serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential?

    public init(
        serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential? = nil
    )
    {
        self.serviceSpecificCredential = serviceSpecificCredential
    }
}

enum ResetServiceSpecificCredentialOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension IAMClientTypes.ResourceSpecificResult: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evalDecisionDetails = "EvalDecisionDetails"
        case evalResourceDecision = "EvalResourceDecision"
        case evalResourceName = "EvalResourceName"
        case matchedStatements = "MatchedStatements"
        case missingContextValues = "MissingContextValues"
        case permissionsBoundaryDecisionDetail = "PermissionsBoundaryDecisionDetail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let evalDecisionDetails = evalDecisionDetails {
            var evalDecisionDetailsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EvalDecisionDetails"))
            for (index0, element0) in evalDecisionDetails.sorted(by: { $0.key < $1.key }).enumerated() {
                let evaldecisionsourcetypeKey0 = element0.key
                let policyevaluationdecisiontypeValue0 = element0.value
                var entryContainer0 = evalDecisionDetailsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(evaldecisionsourcetypeKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(policyevaluationdecisiontypeValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let evalResourceDecision = evalResourceDecision {
            try container.encode(evalResourceDecision, forKey: ClientRuntime.Key("EvalResourceDecision"))
        }
        if let evalResourceName = evalResourceName {
            try container.encode(evalResourceName, forKey: ClientRuntime.Key("EvalResourceName"))
        }
        if let matchedStatements = matchedStatements {
            if !matchedStatements.isEmpty {
                var matchedStatementsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MatchedStatements"))
                for (index0, statement0) in matchedStatements.enumerated() {
                    try matchedStatementsContainer.encode(statement0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var matchedStatementsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MatchedStatements"))
                try matchedStatementsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let missingContextValues = missingContextValues {
            if !missingContextValues.isEmpty {
                var missingContextValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MissingContextValues"))
                for (index0, contextkeynametype0) in missingContextValues.enumerated() {
                    try missingContextValuesContainer.encode(contextkeynametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var missingContextValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MissingContextValues"))
                try missingContextValuesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail {
            try container.encode(permissionsBoundaryDecisionDetail, forKey: ClientRuntime.Key("PermissionsBoundaryDecisionDetail"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.ResourceSpecificResult, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.ResourceSpecificResult()
            value.evalResourceName = try reader["EvalResourceName"].readIfPresent()
            value.evalResourceDecision = try reader["EvalResourceDecision"].readIfPresent()
            value.matchedStatements = try reader["MatchedStatements"].readListIfPresent(memberReadingClosure: IAMClientTypes.Statement.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.missingContextValues = try reader["MissingContextValues"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.evalDecisionDetails = try reader["EvalDecisionDetails"].readMapIfPresent(valueReadingClosure: IAMClientTypes.PolicyEvaluationDecisionType.readingClosure, keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            value.permissionsBoundaryDecisionDetail = try reader["PermissionsBoundaryDecisionDetail"].readIfPresent(readingClosure: IAMClientTypes.PermissionsBoundaryDecisionDetail.readingClosure)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains the result of the simulation of a single API operation call on a single resource. This data type is used by a member of the [EvaluationResult] data type.
    public struct ResourceSpecificResult: Swift.Equatable {
        /// Additional details about the results of the evaluation decision on a single resource. This parameter is returned only for cross-account simulations. This parameter explains how each policy type contributes to the resource-specific evaluation decision.
        public var evalDecisionDetails: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]?
        /// The result of the simulation of the simulated API operation on the resource specified in EvalResourceName.
        /// This member is required.
        public var evalResourceDecision: IAMClientTypes.PolicyEvaluationDecisionType?
        /// The name of the simulated resource, in Amazon Resource Name (ARN) format.
        /// This member is required.
        public var evalResourceName: Swift.String?
        /// A list of the statements in the input policies that determine the result for this part of the simulation. Remember that even if multiple statements allow the operation on the resource, if any statement denies that operation, then the explicit deny overrides any allow. In addition, the deny statement is the only entry included in the result.
        public var matchedStatements: [IAMClientTypes.Statement]?
        /// A list of context keys that are required by the included input policies but that were not provided by one of the input parameters. This list is used when a list of ARNs is included in the ResourceArns parameter instead of "*". If you do not specify individual resources, by setting ResourceArns to "*" or by not including the ResourceArns parameter, then any missing context values are instead included under the EvaluationResults section. To discover the context keys used by a set of policies, you can call [GetContextKeysForCustomPolicy] or [GetContextKeysForPrincipalPolicy].
        public var missingContextValues: [Swift.String]?
        /// Contains information about the effect that a permissions boundary has on a policy simulation when that boundary is applied to an IAM entity.
        public var permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail?

        public init(
            evalDecisionDetails: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]? = nil,
            evalResourceDecision: IAMClientTypes.PolicyEvaluationDecisionType? = nil,
            evalResourceName: Swift.String? = nil,
            matchedStatements: [IAMClientTypes.Statement]? = nil,
            missingContextValues: [Swift.String]? = nil,
            permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail? = nil
        )
        {
            self.evalDecisionDetails = evalDecisionDetails
            self.evalResourceDecision = evalResourceDecision
            self.evalResourceName = evalResourceName
            self.matchedStatements = matchedStatements
            self.missingContextValues = missingContextValues
            self.permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail
        }
    }

}

extension ResyncMFADeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationCode1 = "AuthenticationCode1"
        case authenticationCode2 = "AuthenticationCode2"
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authenticationCode1 = authenticationCode1 {
            try container.encode(authenticationCode1, forKey: ClientRuntime.Key("AuthenticationCode1"))
        }
        if let authenticationCode2 = authenticationCode2 {
            try container.encode(authenticationCode2, forKey: ClientRuntime.Key("AuthenticationCode2"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ResyncMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ResyncMFADeviceInput {

    static func urlPathProvider(_ value: ResyncMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

public struct ResyncMFADeviceInput: Swift.Equatable {
    /// An authentication code emitted by the device. The format for this parameter is a sequence of six digits.
    /// This member is required.
    public var authenticationCode1: Swift.String?
    /// A subsequent authentication code emitted by the device. The format for this parameter is a sequence of six digits.
    /// This member is required.
    public var authenticationCode2: Swift.String?
    /// Serial number that uniquely identifies the MFA device. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The name of the user whose MFA device you want to resynchronize. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        authenticationCode1: Swift.String? = nil,
        authenticationCode2: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationCode1 = authenticationCode1
        self.authenticationCode2 = authenticationCode2
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

extension ResyncMFADeviceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ResyncMFADeviceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return ResyncMFADeviceOutput()
        }
    }
}

public struct ResyncMFADeviceOutput: Swift.Equatable {

    public init() { }
}

enum ResyncMFADeviceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidAuthenticationCode": return try await InvalidAuthenticationCodeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension IAMClientTypes.Role: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
        case createDate = "CreateDate"
        case description = "Description"
        case maxSessionDuration = "MaxSessionDuration"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case roleId = "RoleId"
        case roleLastUsed = "RoleLastUsed"
        case roleName = "RoleName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let assumeRolePolicyDocument = assumeRolePolicyDocument {
            try container.encode(assumeRolePolicyDocument, forKey: ClientRuntime.Key("AssumeRolePolicyDocument"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let maxSessionDuration = maxSessionDuration {
            try container.encode(maxSessionDuration, forKey: ClientRuntime.Key("MaxSessionDuration"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let roleId = roleId {
            try container.encode(roleId, forKey: ClientRuntime.Key("RoleId"))
        }
        if let roleLastUsed = roleLastUsed {
            try container.encode(roleLastUsed, forKey: ClientRuntime.Key("RoleLastUsed"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.Role, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.Role()
            value.path = try reader["Path"].readIfPresent()
            value.roleName = try reader["RoleName"].readIfPresent()
            value.roleId = try reader["RoleId"].readIfPresent()
            value.arn = try reader["Arn"].readIfPresent()
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            value.assumeRolePolicyDocument = try reader["AssumeRolePolicyDocument"].readIfPresent()
            value.description = try reader["Description"].readIfPresent()
            value.maxSessionDuration = try reader["MaxSessionDuration"].readIfPresent()
            value.permissionsBoundary = try reader["PermissionsBoundary"].readIfPresent(readingClosure: IAMClientTypes.AttachedPermissionsBoundary.readingClosure)
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.roleLastUsed = try reader["RoleLastUsed"].readIfPresent(readingClosure: IAMClientTypes.RoleLastUsed.readingClosure)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM role. This structure is returned as a response element in several API operations that interact with roles.
    public struct Role: Swift.Equatable {
        /// The Amazon Resource Name (ARN) specifying the role. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The policy that grants an entity permission to assume the role.
        public var assumeRolePolicyDocument: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the role was created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// A description of the role that you provide.
        public var description: Swift.String?
        /// The maximum session duration (in seconds) for the specified role. Anyone who uses the CLI, or API to assume the role can specify the duration using the optional DurationSeconds API parameter or duration-seconds CLI parameter.
        public var maxSessionDuration: Swift.Int?
        /// The path to the role. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?
        /// The ARN of the policy used to set the permissions boundary for the role. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// The stable and unique string identifying the role. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var roleId: Swift.String?
        /// Contains information about the last time that an IAM role was used. This includes the date and time and the Region in which the role was last used. Activity is only reported for the trailing 400 days. This period can be shorter if your Region began supporting these features within the last year. The role might have been used more than 400 days ago. For more information, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM user Guide.
        public var roleLastUsed: IAMClientTypes.RoleLastUsed?
        /// The friendly name that identifies the role.
        /// This member is required.
        public var roleName: Swift.String?
        /// A list of tags that are attached to the role. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init(
            arn: Swift.String? = nil,
            assumeRolePolicyDocument: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            maxSessionDuration: Swift.Int? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            roleId: Swift.String? = nil,
            roleLastUsed: IAMClientTypes.RoleLastUsed? = nil,
            roleName: Swift.String? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.arn = arn
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.createDate = createDate
            self.description = description
            self.maxSessionDuration = maxSessionDuration
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.roleId = roleId
            self.roleLastUsed = roleLastUsed
            self.roleName = roleName
            self.tags = tags
        }
    }

}

extension IAMClientTypes.RoleDetail: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case instanceProfileList = "InstanceProfileList"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case roleId = "RoleId"
        case roleLastUsed = "RoleLastUsed"
        case roleName = "RoleName"
        case rolePolicyList = "RolePolicyList"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let assumeRolePolicyDocument = assumeRolePolicyDocument {
            try container.encode(assumeRolePolicyDocument, forKey: ClientRuntime.Key("AssumeRolePolicyDocument"))
        }
        if let attachedManagedPolicies = attachedManagedPolicies {
            if !attachedManagedPolicies.isEmpty {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                for (index0, attachedpolicy0) in attachedManagedPolicies.enumerated() {
                    try attachedManagedPoliciesContainer.encode(attachedpolicy0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                try attachedManagedPoliciesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let instanceProfileList = instanceProfileList {
            if !instanceProfileList.isEmpty {
                var instanceProfileListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("InstanceProfileList"))
                for (index0, instanceprofile0) in instanceProfileList.enumerated() {
                    try instanceProfileListContainer.encode(instanceprofile0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var instanceProfileListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("InstanceProfileList"))
                try instanceProfileListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let roleId = roleId {
            try container.encode(roleId, forKey: ClientRuntime.Key("RoleId"))
        }
        if let roleLastUsed = roleLastUsed {
            try container.encode(roleLastUsed, forKey: ClientRuntime.Key("RoleLastUsed"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        if let rolePolicyList = rolePolicyList {
            if !rolePolicyList.isEmpty {
                var rolePolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RolePolicyList"))
                for (index0, policydetail0) in rolePolicyList.enumerated() {
                    try rolePolicyListContainer.encode(policydetail0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var rolePolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RolePolicyList"))
                try rolePolicyListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.RoleDetail, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.RoleDetail()
            value.path = try reader["Path"].readIfPresent()
            value.roleName = try reader["RoleName"].readIfPresent()
            value.roleId = try reader["RoleId"].readIfPresent()
            value.arn = try reader["Arn"].readIfPresent()
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            value.assumeRolePolicyDocument = try reader["AssumeRolePolicyDocument"].readIfPresent()
            value.instanceProfileList = try reader["InstanceProfileList"].readListIfPresent(memberReadingClosure: IAMClientTypes.InstanceProfile.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.rolePolicyList = try reader["RolePolicyList"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyDetail.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.attachedManagedPolicies = try reader["AttachedManagedPolicies"].readListIfPresent(memberReadingClosure: IAMClientTypes.AttachedPolicy.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.permissionsBoundary = try reader["PermissionsBoundary"].readIfPresent(readingClosure: IAMClientTypes.AttachedPermissionsBoundary.readingClosure)
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.roleLastUsed = try reader["RoleLastUsed"].readIfPresent(readingClosure: IAMClientTypes.RoleLastUsed.readingClosure)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM role, including all of the role's policies. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct RoleDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The trust policy that grants permission to assume the role.
        public var assumeRolePolicyDocument: Swift.String?
        /// A list of managed policies attached to the role. These policies are the role's access (permissions) policies.
        public var attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the role was created.
        public var createDate: ClientRuntime.Date?
        /// A list of instance profiles that contain this role.
        public var instanceProfileList: [IAMClientTypes.InstanceProfile]?
        /// The path to the role. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The ARN of the policy used to set the permissions boundary for the role. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// The stable and unique string identifying the role. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var roleId: Swift.String?
        /// Contains information about the last time that an IAM role was used. This includes the date and time and the Region in which the role was last used. Activity is only reported for the trailing 400 days. This period can be shorter if your Region began supporting these features within the last year. The role might have been used more than 400 days ago. For more information, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM User Guide.
        public var roleLastUsed: IAMClientTypes.RoleLastUsed?
        /// The friendly name that identifies the role.
        public var roleName: Swift.String?
        /// A list of inline policies embedded in the role. These policies are the role's access (permissions) policies.
        public var rolePolicyList: [IAMClientTypes.PolicyDetail]?
        /// A list of tags that are attached to the role. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init(
            arn: Swift.String? = nil,
            assumeRolePolicyDocument: Swift.String? = nil,
            attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
            createDate: ClientRuntime.Date? = nil,
            instanceProfileList: [IAMClientTypes.InstanceProfile]? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            roleId: Swift.String? = nil,
            roleLastUsed: IAMClientTypes.RoleLastUsed? = nil,
            roleName: Swift.String? = nil,
            rolePolicyList: [IAMClientTypes.PolicyDetail]? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.arn = arn
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.instanceProfileList = instanceProfileList
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.roleId = roleId
            self.roleLastUsed = roleLastUsed
            self.roleName = roleName
            self.rolePolicyList = rolePolicyList
            self.tags = tags
        }
    }

}

extension IAMClientTypes.RoleLastUsed: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUsedDate = "LastUsedDate"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let lastUsedDate = lastUsedDate {
            try container.encodeTimestamp(lastUsedDate, format: .dateTime, forKey: ClientRuntime.Key("LastUsedDate"))
        }
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.RoleLastUsed, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.RoleLastUsed()
            value.lastUsedDate = try reader["LastUsedDate"].readTimestampIfPresent(format: .dateTime)
            value.region = try reader["Region"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about the last time that an IAM role was used. This includes the date and time and the Region in which the role was last used. Activity is only reported for the trailing 400 days. This period can be shorter if your Region began supporting these features within the last year. The role might have been used more than 400 days ago. For more information, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM user Guide. This data type is returned as a response element in the [GetRole] and [GetAccountAuthorizationDetails] operations.
    public struct RoleLastUsed: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601) that the role was last used. This field is null if the role has not been used within the IAM tracking period. For more information about the tracking period, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM User Guide.
        public var lastUsedDate: ClientRuntime.Date?
        /// The name of the Amazon Web Services Region in which the role was last used.
        public var region: Swift.String?

        public init(
            lastUsedDate: ClientRuntime.Date? = nil,
            region: Swift.String? = nil
        )
        {
            self.lastUsedDate = lastUsedDate
            self.region = region
        }
    }

}

extension IAMClientTypes.RoleUsageType: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case region = "Region"
        case resources = "Resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
        if let resources = resources {
            if !resources.isEmpty {
                var resourcesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Resources"))
                for (index0, arntype0) in resources.enumerated() {
                    try resourcesContainer.encode(arntype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var resourcesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Resources"))
                try resourcesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.RoleUsageType, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.RoleUsageType()
            value.region = try reader["Region"].readIfPresent()
            value.resources = try reader["Resources"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension IAMClientTypes {
    /// An object that contains details about how a service-linked role is used, if that information is returned by the service. This data type is used as a response element in the [GetServiceLinkedRoleDeletionStatus] operation.
    public struct RoleUsageType: Swift.Equatable {
        /// The name of the Region where the service-linked role is being used.
        public var region: Swift.String?
        /// The name of the resource that is using the service-linked role.
        public var resources: [Swift.String]?

        public init(
            region: Swift.String? = nil,
            resources: [Swift.String]? = nil
        )
        {
            self.region = region
            self.resources = resources
        }
    }

}

extension IAMClientTypes.SAMLProviderListEntry: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case validUntil = "ValidUntil"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let validUntil = validUntil {
            try container.encodeTimestamp(validUntil, format: .dateTime, forKey: ClientRuntime.Key("ValidUntil"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.SAMLProviderListEntry, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.SAMLProviderListEntry()
            value.arn = try reader["Arn"].readIfPresent()
            value.validUntil = try reader["ValidUntil"].readTimestampIfPresent(format: .dateTime)
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains the list of SAML providers for this account.
    public struct SAMLProviderListEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the SAML provider.
        public var arn: Swift.String?
        /// The date and time when the SAML provider was created.
        public var createDate: ClientRuntime.Date?
        /// The expiration date and time for the SAML provider.
        public var validUntil: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            validUntil: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.validUntil = validUntil
        }
    }

}

extension IAMClientTypes.SSHPublicKey: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fingerprint = "Fingerprint"
        case sshPublicKeyBody = "SSHPublicKeyBody"
        case sshPublicKeyId = "SSHPublicKeyId"
        case status = "Status"
        case uploadDate = "UploadDate"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let fingerprint = fingerprint {
            try container.encode(fingerprint, forKey: ClientRuntime.Key("Fingerprint"))
        }
        if let sshPublicKeyBody = sshPublicKeyBody {
            try container.encode(sshPublicKeyBody, forKey: ClientRuntime.Key("SSHPublicKeyBody"))
        }
        if let sshPublicKeyId = sshPublicKeyId {
            try container.encode(sshPublicKeyId, forKey: ClientRuntime.Key("SSHPublicKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let uploadDate = uploadDate {
            try container.encodeTimestamp(uploadDate, format: .dateTime, forKey: ClientRuntime.Key("UploadDate"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.SSHPublicKey, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.SSHPublicKey()
            value.userName = try reader["UserName"].readIfPresent()
            value.sshPublicKeyId = try reader["SSHPublicKeyId"].readIfPresent()
            value.fingerprint = try reader["Fingerprint"].readIfPresent()
            value.sshPublicKeyBody = try reader["SSHPublicKeyBody"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.uploadDate = try reader["UploadDate"].readTimestampIfPresent(format: .dateTime)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an SSH public key. This data type is used as a response element in the [GetSSHPublicKey] and [UploadSSHPublicKey] operations.
    public struct SSHPublicKey: Swift.Equatable {
        /// The MD5 message digest of the SSH public key.
        /// This member is required.
        public var fingerprint: Swift.String?
        /// The SSH public key.
        /// This member is required.
        public var sshPublicKeyBody: Swift.String?
        /// The unique identifier for the SSH public key.
        /// This member is required.
        public var sshPublicKeyId: Swift.String?
        /// The status of the SSH public key. Active means that the key can be used for authentication with an CodeCommit repository. Inactive means that the key cannot be used.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the SSH public key was uploaded.
        public var uploadDate: ClientRuntime.Date?
        /// The name of the IAM user associated with the SSH public key.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            fingerprint: Swift.String? = nil,
            sshPublicKeyBody: Swift.String? = nil,
            sshPublicKeyId: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            uploadDate: ClientRuntime.Date? = nil,
            userName: Swift.String? = nil
        )
        {
            self.fingerprint = fingerprint
            self.sshPublicKeyBody = sshPublicKeyBody
            self.sshPublicKeyId = sshPublicKeyId
            self.status = status
            self.uploadDate = uploadDate
            self.userName = userName
        }
    }

}

extension IAMClientTypes.SSHPublicKeyMetadata: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKeyId = "SSHPublicKeyId"
        case status = "Status"
        case uploadDate = "UploadDate"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sshPublicKeyId = sshPublicKeyId {
            try container.encode(sshPublicKeyId, forKey: ClientRuntime.Key("SSHPublicKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let uploadDate = uploadDate {
            try container.encodeTimestamp(uploadDate, format: .dateTime, forKey: ClientRuntime.Key("UploadDate"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.SSHPublicKeyMetadata, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.SSHPublicKeyMetadata()
            value.userName = try reader["UserName"].readIfPresent()
            value.sshPublicKeyId = try reader["SSHPublicKeyId"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.uploadDate = try reader["UploadDate"].readTimestampIfPresent(format: .dateTime)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an SSH public key, without the key's body or fingerprint. This data type is used as a response element in the [ListSSHPublicKeys] operation.
    public struct SSHPublicKeyMetadata: Swift.Equatable {
        /// The unique identifier for the SSH public key.
        /// This member is required.
        public var sshPublicKeyId: Swift.String?
        /// The status of the SSH public key. Active means that the key can be used for authentication with an CodeCommit repository. Inactive means that the key cannot be used.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the SSH public key was uploaded.
        /// This member is required.
        public var uploadDate: ClientRuntime.Date?
        /// The name of the IAM user associated with the SSH public key.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            sshPublicKeyId: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            uploadDate: ClientRuntime.Date? = nil,
            userName: Swift.String? = nil
        )
        {
            self.sshPublicKeyId = sshPublicKeyId
            self.status = status
            self.uploadDate = uploadDate
            self.userName = userName
        }
    }

}

extension IAMClientTypes.ServerCertificate: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBody = "CertificateBody"
        case certificateChain = "CertificateChain"
        case serverCertificateMetadata = "ServerCertificateMetadata"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: ClientRuntime.Key("CertificateBody"))
        }
        if let certificateChain = certificateChain {
            try container.encode(certificateChain, forKey: ClientRuntime.Key("CertificateChain"))
        }
        if let serverCertificateMetadata = serverCertificateMetadata {
            try container.encode(serverCertificateMetadata, forKey: ClientRuntime.Key("ServerCertificateMetadata"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.ServerCertificate, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.ServerCertificate()
            value.serverCertificateMetadata = try reader["ServerCertificateMetadata"].readIfPresent(readingClosure: IAMClientTypes.ServerCertificateMetadata.readingClosure)
            value.certificateBody = try reader["CertificateBody"].readIfPresent()
            value.certificateChain = try reader["CertificateChain"].readIfPresent()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a server certificate. This data type is used as a response element in the [GetServerCertificate] operation.
    public struct ServerCertificate: Swift.Equatable {
        /// The contents of the public key certificate.
        /// This member is required.
        public var certificateBody: Swift.String?
        /// The contents of the public key certificate chain.
        public var certificateChain: Swift.String?
        /// The meta information of the server certificate, such as its name, path, ID, and ARN.
        /// This member is required.
        public var serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata?
        /// A list of tags that are attached to the server certificate. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init(
            certificateBody: Swift.String? = nil,
            certificateChain: Swift.String? = nil,
            serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.certificateBody = certificateBody
            self.certificateChain = certificateChain
            self.serverCertificateMetadata = serverCertificateMetadata
            self.tags = tags
        }
    }

}

extension IAMClientTypes.ServerCertificateMetadata: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case expiration = "Expiration"
        case path = "Path"
        case serverCertificateId = "ServerCertificateId"
        case serverCertificateName = "ServerCertificateName"
        case uploadDate = "UploadDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let expiration = expiration {
            try container.encodeTimestamp(expiration, format: .dateTime, forKey: ClientRuntime.Key("Expiration"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let serverCertificateId = serverCertificateId {
            try container.encode(serverCertificateId, forKey: ClientRuntime.Key("ServerCertificateId"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        if let uploadDate = uploadDate {
            try container.encodeTimestamp(uploadDate, format: .dateTime, forKey: ClientRuntime.Key("UploadDate"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.ServerCertificateMetadata, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.ServerCertificateMetadata()
            value.path = try reader["Path"].readIfPresent()
            value.serverCertificateName = try reader["ServerCertificateName"].readIfPresent()
            value.serverCertificateId = try reader["ServerCertificateId"].readIfPresent()
            value.arn = try reader["Arn"].readIfPresent()
            value.uploadDate = try reader["UploadDate"].readTimestampIfPresent(format: .dateTime)
            value.expiration = try reader["Expiration"].readTimestampIfPresent(format: .dateTime)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a server certificate without its certificate body, certificate chain, and private key. This data type is used as a response element in the [UploadServerCertificate] and [ListServerCertificates] operations.
    public struct ServerCertificateMetadata: Swift.Equatable {
        /// The Amazon Resource Name (ARN) specifying the server certificate. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date on which the certificate is set to expire.
        public var expiration: ClientRuntime.Date?
        /// The path to the server certificate. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?
        /// The stable and unique string identifying the server certificate. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var serverCertificateId: Swift.String?
        /// The name that identifies the server certificate.
        /// This member is required.
        public var serverCertificateName: Swift.String?
        /// The date when the server certificate was uploaded.
        public var uploadDate: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            expiration: ClientRuntime.Date? = nil,
            path: Swift.String? = nil,
            serverCertificateId: Swift.String? = nil,
            serverCertificateName: Swift.String? = nil,
            uploadDate: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.expiration = expiration
            self.path = path
            self.serverCertificateId = serverCertificateId
            self.serverCertificateName = serverCertificateName
            self.uploadDate = uploadDate
        }
    }

}

extension ServiceFailureException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ServiceFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct ServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceFailure" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IAMClientTypes.ServiceLastAccessed: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastAuthenticated = "LastAuthenticated"
        case lastAuthenticatedEntity = "LastAuthenticatedEntity"
        case lastAuthenticatedRegion = "LastAuthenticatedRegion"
        case serviceName = "ServiceName"
        case serviceNamespace = "ServiceNamespace"
        case totalAuthenticatedEntities = "TotalAuthenticatedEntities"
        case trackedActionsLastAccessed = "TrackedActionsLastAccessed"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let lastAuthenticated = lastAuthenticated {
            try container.encodeTimestamp(lastAuthenticated, format: .dateTime, forKey: ClientRuntime.Key("LastAuthenticated"))
        }
        if let lastAuthenticatedEntity = lastAuthenticatedEntity {
            try container.encode(lastAuthenticatedEntity, forKey: ClientRuntime.Key("LastAuthenticatedEntity"))
        }
        if let lastAuthenticatedRegion = lastAuthenticatedRegion {
            try container.encode(lastAuthenticatedRegion, forKey: ClientRuntime.Key("LastAuthenticatedRegion"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: ClientRuntime.Key("ServiceNamespace"))
        }
        if let totalAuthenticatedEntities = totalAuthenticatedEntities {
            try container.encode(totalAuthenticatedEntities, forKey: ClientRuntime.Key("TotalAuthenticatedEntities"))
        }
        if let trackedActionsLastAccessed = trackedActionsLastAccessed {
            if !trackedActionsLastAccessed.isEmpty {
                var trackedActionsLastAccessedContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TrackedActionsLastAccessed"))
                for (index0, trackedactionlastaccessed0) in trackedActionsLastAccessed.enumerated() {
                    try trackedActionsLastAccessedContainer.encode(trackedactionlastaccessed0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var trackedActionsLastAccessedContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TrackedActionsLastAccessed"))
                try trackedActionsLastAccessedContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.ServiceLastAccessed, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.ServiceLastAccessed()
            value.serviceName = try reader["ServiceName"].readIfPresent()
            value.lastAuthenticated = try reader["LastAuthenticated"].readTimestampIfPresent(format: .dateTime)
            value.serviceNamespace = try reader["ServiceNamespace"].readIfPresent()
            value.lastAuthenticatedEntity = try reader["LastAuthenticatedEntity"].readIfPresent()
            value.lastAuthenticatedRegion = try reader["LastAuthenticatedRegion"].readIfPresent()
            value.totalAuthenticatedEntities = try reader["TotalAuthenticatedEntities"].readIfPresent()
            value.trackedActionsLastAccessed = try reader["TrackedActionsLastAccessed"].readListIfPresent(memberReadingClosure: IAMClientTypes.TrackedActionLastAccessed.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains details about the most recent attempt to access the service. This data type is used as a response element in the [GetServiceLastAccessedDetails] operation.
    public struct ServiceLastAccessed: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when an authenticated entity most recently attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticated: ClientRuntime.Date?
        /// The ARN of the authenticated entity (user or role) that last attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticatedEntity: Swift.String?
        /// The Region from which the authenticated entity (user or role) last attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticatedRegion: Swift.String?
        /// The name of the service in which access was attempted.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The namespace of the service in which access was attempted. To learn the service namespace of a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the Service Authorization Reference. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services Service Namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
        /// This member is required.
        public var serviceNamespace: Swift.String?
        /// The total number of authenticated principals (root user, IAM users, or IAM roles) that have attempted to access the service. This field is null if no principals attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var totalAuthenticatedEntities: Swift.Int?
        /// An object that contains details about the most recent attempt to access a tracked action within the service. This field is null if there no tracked actions or if the principal did not use the tracked actions within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period). This field is also null if the report was generated at the service level and not the action level. For more information, see the Granularity field in [GenerateServiceLastAccessedDetails].
        public var trackedActionsLastAccessed: [IAMClientTypes.TrackedActionLastAccessed]?

        public init(
            lastAuthenticated: ClientRuntime.Date? = nil,
            lastAuthenticatedEntity: Swift.String? = nil,
            lastAuthenticatedRegion: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceNamespace: Swift.String? = nil,
            totalAuthenticatedEntities: Swift.Int? = nil,
            trackedActionsLastAccessed: [IAMClientTypes.TrackedActionLastAccessed]? = nil
        )
        {
            self.lastAuthenticated = lastAuthenticated
            self.lastAuthenticatedEntity = lastAuthenticatedEntity
            self.lastAuthenticatedRegion = lastAuthenticatedRegion
            self.serviceName = serviceName
            self.serviceNamespace = serviceNamespace
            self.totalAuthenticatedEntities = totalAuthenticatedEntities
            self.trackedActionsLastAccessed = trackedActionsLastAccessed
        }
    }

}

extension ServiceNotSupportedException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ServiceNotSupportedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified service does not support service-specific credentials.
public struct ServiceNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotSupportedService" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IAMClientTypes.ServiceSpecificCredential: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case serviceName = "ServiceName"
        case servicePassword = "ServicePassword"
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case serviceUserName = "ServiceUserName"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let servicePassword = servicePassword {
            try container.encode(servicePassword, forKey: ClientRuntime.Key("ServicePassword"))
        }
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: ClientRuntime.Key("ServiceSpecificCredentialId"))
        }
        if let serviceUserName = serviceUserName {
            try container.encode(serviceUserName, forKey: ClientRuntime.Key("ServiceUserName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.ServiceSpecificCredential, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.ServiceSpecificCredential()
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            value.serviceName = try reader["ServiceName"].readIfPresent()
            value.serviceUserName = try reader["ServiceUserName"].readIfPresent()
            value.servicePassword = try reader["ServicePassword"].readIfPresent()
            value.serviceSpecificCredentialId = try reader["ServiceSpecificCredentialId"].readIfPresent()
            value.userName = try reader["UserName"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes.ServiceSpecificCredential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceSpecificCredential(createDate: \(Swift.String(describing: createDate)), serviceName: \(Swift.String(describing: serviceName)), serviceSpecificCredentialId: \(Swift.String(describing: serviceSpecificCredentialId)), serviceUserName: \(Swift.String(describing: serviceUserName)), status: \(Swift.String(describing: status)), userName: \(Swift.String(describing: userName)), servicePassword: \"CONTENT_REDACTED\")"}
}

extension IAMClientTypes {
    /// Contains the details of a service-specific credential.
    public struct ServiceSpecificCredential: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the service-specific credential were created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// The name of the service associated with the service-specific credential.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The generated password for the service-specific credential.
        /// This member is required.
        public var servicePassword: Swift.String?
        /// The unique identifier for the service-specific credential.
        /// This member is required.
        public var serviceSpecificCredentialId: Swift.String?
        /// The generated user name for the service-specific credential. This value is generated by combining the IAM user's name combined with the ID number of the Amazon Web Services account, as in jane-at-123456789012, for example. This value cannot be configured by the user.
        /// This member is required.
        public var serviceUserName: Swift.String?
        /// The status of the service-specific credential. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user associated with the service-specific credential.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            createDate: ClientRuntime.Date? = nil,
            serviceName: Swift.String? = nil,
            servicePassword: Swift.String? = nil,
            serviceSpecificCredentialId: Swift.String? = nil,
            serviceUserName: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.serviceName = serviceName
            self.servicePassword = servicePassword
            self.serviceSpecificCredentialId = serviceSpecificCredentialId
            self.serviceUserName = serviceUserName
            self.status = status
            self.userName = userName
        }
    }

}

extension IAMClientTypes.ServiceSpecificCredentialMetadata: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case serviceName = "ServiceName"
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case serviceUserName = "ServiceUserName"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: ClientRuntime.Key("ServiceSpecificCredentialId"))
        }
        if let serviceUserName = serviceUserName {
            try container.encode(serviceUserName, forKey: ClientRuntime.Key("ServiceUserName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.ServiceSpecificCredentialMetadata, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.ServiceSpecificCredentialMetadata()
            value.userName = try reader["UserName"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.serviceUserName = try reader["ServiceUserName"].readIfPresent()
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            value.serviceSpecificCredentialId = try reader["ServiceSpecificCredentialId"].readIfPresent()
            value.serviceName = try reader["ServiceName"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains additional details about a service-specific credential.
    public struct ServiceSpecificCredentialMetadata: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the service-specific credential were created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// The name of the service associated with the service-specific credential.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The unique identifier for the service-specific credential.
        /// This member is required.
        public var serviceSpecificCredentialId: Swift.String?
        /// The generated user name for the service-specific credential.
        /// This member is required.
        public var serviceUserName: Swift.String?
        /// The status of the service-specific credential. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user associated with the service-specific credential.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            createDate: ClientRuntime.Date? = nil,
            serviceName: Swift.String? = nil,
            serviceSpecificCredentialId: Swift.String? = nil,
            serviceUserName: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.serviceName = serviceName
            self.serviceSpecificCredentialId = serviceSpecificCredentialId
            self.serviceUserName = serviceUserName
            self.status = status
            self.userName = userName
        }
    }

}

extension SetDefaultPolicyVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
        try container.encode("SetDefaultPolicyVersion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetDefaultPolicyVersionInput {

    static func urlPathProvider(_ value: SetDefaultPolicyVersionInput) -> Swift.String? {
        return "/"
    }
}

public struct SetDefaultPolicyVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy whose default version you want to set. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The version of the policy to set as the default (operative) version. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.versionId = versionId
    }
}

extension SetDefaultPolicyVersionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<SetDefaultPolicyVersionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return SetDefaultPolicyVersionOutput()
        }
    }
}

public struct SetDefaultPolicyVersionOutput: Swift.Equatable {

    public init() { }
}

enum SetDefaultPolicyVersionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension SetSecurityTokenServicePreferencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalEndpointTokenVersion = "GlobalEndpointTokenVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let globalEndpointTokenVersion = globalEndpointTokenVersion {
            try container.encode(globalEndpointTokenVersion, forKey: ClientRuntime.Key("GlobalEndpointTokenVersion"))
        }
        try container.encode("SetSecurityTokenServicePreferences", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetSecurityTokenServicePreferencesInput {

    static func urlPathProvider(_ value: SetSecurityTokenServicePreferencesInput) -> Swift.String? {
        return "/"
    }
}

public struct SetSecurityTokenServicePreferencesInput: Swift.Equatable {
    /// The version of the global endpoint token. Version 1 tokens are valid only in Amazon Web Services Regions that are available by default. These tokens do not work in manually enabled Regions, such as Asia Pacific (Hong Kong). Version 2 tokens are valid in all Regions. However, version 2 tokens are longer and might affect systems where you temporarily store tokens. For information, see [Activating and deactivating STS in an Amazon Web Services Region](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html) in the IAM User Guide.
    /// This member is required.
    public var globalEndpointTokenVersion: IAMClientTypes.GlobalEndpointTokenVersion?

    public init(
        globalEndpointTokenVersion: IAMClientTypes.GlobalEndpointTokenVersion? = nil
    )
    {
        self.globalEndpointTokenVersion = globalEndpointTokenVersion
    }
}

extension SetSecurityTokenServicePreferencesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<SetSecurityTokenServicePreferencesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return SetSecurityTokenServicePreferencesOutput()
        }
    }
}

public struct SetSecurityTokenServicePreferencesOutput: Swift.Equatable {

    public init() { }
}

enum SetSecurityTokenServicePreferencesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension IAMClientTypes.SigningCertificate: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBody = "CertificateBody"
        case certificateId = "CertificateId"
        case status = "Status"
        case uploadDate = "UploadDate"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: ClientRuntime.Key("CertificateBody"))
        }
        if let certificateId = certificateId {
            try container.encode(certificateId, forKey: ClientRuntime.Key("CertificateId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let uploadDate = uploadDate {
            try container.encodeTimestamp(uploadDate, format: .dateTime, forKey: ClientRuntime.Key("UploadDate"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.SigningCertificate, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.SigningCertificate()
            value.userName = try reader["UserName"].readIfPresent()
            value.certificateId = try reader["CertificateId"].readIfPresent()
            value.certificateBody = try reader["CertificateBody"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.uploadDate = try reader["UploadDate"].readTimestampIfPresent(format: .dateTime)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an X.509 signing certificate. This data type is used as a response element in the [UploadSigningCertificate] and [ListSigningCertificates] operations.
    public struct SigningCertificate: Swift.Equatable {
        /// The contents of the signing certificate.
        /// This member is required.
        public var certificateBody: Swift.String?
        /// The ID for the signing certificate.
        /// This member is required.
        public var certificateId: Swift.String?
        /// The status of the signing certificate. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The date when the signing certificate was uploaded.
        public var uploadDate: ClientRuntime.Date?
        /// The name of the user the signing certificate is associated with.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            certificateBody: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            uploadDate: ClientRuntime.Date? = nil,
            userName: Swift.String? = nil
        )
        {
            self.certificateBody = certificateBody
            self.certificateId = certificateId
            self.status = status
            self.uploadDate = uploadDate
            self.userName = userName
        }
    }

}

extension SimulateCustomPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionNames = "ActionNames"
        case callerArn = "CallerArn"
        case contextEntries = "ContextEntries"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case permissionsBoundaryPolicyInputList = "PermissionsBoundaryPolicyInputList"
        case policyInputList = "PolicyInputList"
        case resourceArns = "ResourceArns"
        case resourceHandlingOption = "ResourceHandlingOption"
        case resourceOwner = "ResourceOwner"
        case resourcePolicy = "ResourcePolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let actionNames = actionNames {
            if !actionNames.isEmpty {
                var actionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionNames"))
                for (index0, actionnametype0) in actionNames.enumerated() {
                    try actionNamesContainer.encode(actionnametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var actionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionNames"))
                try actionNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let callerArn = callerArn {
            try container.encode(callerArn, forKey: ClientRuntime.Key("CallerArn"))
        }
        if let contextEntries = contextEntries {
            if !contextEntries.isEmpty {
                var contextEntriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextEntries"))
                for (index0, contextentry0) in contextEntries.enumerated() {
                    try contextEntriesContainer.encode(contextentry0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var contextEntriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextEntries"))
                try contextEntriesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList {
            if !permissionsBoundaryPolicyInputList.isEmpty {
                var permissionsBoundaryPolicyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PermissionsBoundaryPolicyInputList"))
                for (index0, policydocumenttype0) in permissionsBoundaryPolicyInputList.enumerated() {
                    try permissionsBoundaryPolicyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var permissionsBoundaryPolicyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PermissionsBoundaryPolicyInputList"))
                try permissionsBoundaryPolicyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policyInputList = policyInputList {
            if !policyInputList.isEmpty {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                for (index0, policydocumenttype0) in policyInputList.enumerated() {
                    try policyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                try policyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let resourceArns = resourceArns {
            if !resourceArns.isEmpty {
                var resourceArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceArns"))
                for (index0, resourcenametype0) in resourceArns.enumerated() {
                    try resourceArnsContainer.encode(resourcenametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var resourceArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceArns"))
                try resourceArnsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let resourceHandlingOption = resourceHandlingOption {
            try container.encode(resourceHandlingOption, forKey: ClientRuntime.Key("ResourceHandlingOption"))
        }
        if let resourceOwner = resourceOwner {
            try container.encode(resourceOwner, forKey: ClientRuntime.Key("ResourceOwner"))
        }
        if let resourcePolicy = resourcePolicy {
            try container.encode(resourcePolicy, forKey: ClientRuntime.Key("ResourcePolicy"))
        }
        try container.encode("SimulateCustomPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension SimulateCustomPolicyInput {

    static func urlPathProvider(_ value: SimulateCustomPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct SimulateCustomPolicyInput: Swift.Equatable {
    /// A list of names of API operations to evaluate in the simulation. Each operation is evaluated against each resource. Each operation must include the service identifier, such as iam:CreateUser. This operation does not support using wildcards (*) in an action name.
    /// This member is required.
    public var actionNames: [Swift.String]?
    /// The ARN of the IAM user that you want to use as the simulated caller of the API operations. CallerArn is required if you include a ResourcePolicy so that the policy's Principal element has a value to use in evaluating the policy. You can specify only the ARN of an IAM user. You cannot specify the ARN of an assumed role, federated user, or a service principal.
    public var callerArn: Swift.String?
    /// A list of context keys and corresponding values for the simulation to use. Whenever a context key is evaluated in one of the simulated IAM permissions policies, the corresponding value is supplied.
    public var contextEntries: [IAMClientTypes.ContextEntry]?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The IAM permissions boundary policy to simulate. The permissions boundary sets the maximum permissions that an IAM entity can have. You can input only one permissions boundary when you pass a policy to this operation. For more information about permissions boundaries, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. The policy input is specified as a string that contains the complete, valid JSON text of a permissions boundary policy. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var permissionsBoundaryPolicyInputList: [Swift.String]?
    /// A list of policy documents to include in the simulation. Each document is specified as a string containing the complete, valid JSON text of an IAM policy. Do not include any resource-based policies in this parameter. Any resource-based policy must be submitted with the ResourcePolicy parameter. The policies cannot be "scope-down" policies, such as you could include in a call to [GetFederationToken](https://docs.aws.amazon.com/IAM/latest/APIReference/API_GetFederationToken.html) or one of the [AssumeRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_AssumeRole.html) API operations. In other words, do not use policies designed to restrict what a user can do while using the temporary credentials. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyInputList: [Swift.String]?
    /// A list of ARNs of Amazon Web Services resources to include in the simulation. If this parameter is not provided, then the value defaults to * (all resources). Each API in the ActionNames parameter is evaluated for each resource in this list. The simulation determines the access result (allowed or denied) of each combination and reports it in the response. You can simulate resources that don't exist in your account. The simulation does not automatically retrieve policies for the specified resources. If you want to include a resource policy in the simulation, then you must include the policy as a string in the ResourcePolicy parameter. If you include a ResourcePolicy, then it must be applicable to all of the resources included in the simulation or you receive an invalid input error. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. Simulation of resource-based policies isn't supported for IAM roles.
    public var resourceArns: [Swift.String]?
    /// Specifies the type of simulation to run. Different API operations that support resource-based policies require different combinations of resources. By specifying the type of simulation to run, you enable the policy simulator to enforce the presence of the required resources to ensure reliable simulation results. If your simulation does not match one of the following scenarios, then you can omit this parameter. The following list shows each of the supported scenario values and the resources that you must define to run the simulation. Each of the EC2 scenarios requires that you specify instance, image, and security group resources. If your scenario includes an EBS volume, then you must specify that volume as a resource. If the EC2 scenario includes VPC, then you must supply the network interface resource. If it includes an IP subnet, then you must specify the subnet resource. For more information on the EC2 scenario options, see [Supported platforms](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html) in the Amazon EC2 User Guide.
    ///
    /// * EC2-VPC-InstanceStore instance, image, security group, network interface
    ///
    /// * EC2-VPC-InstanceStore-Subnet instance, image, security group, network interface, subnet
    ///
    /// * EC2-VPC-EBS instance, image, security group, network interface, volume
    ///
    /// * EC2-VPC-EBS-Subnet instance, image, security group, network interface, subnet, volume
    public var resourceHandlingOption: Swift.String?
    /// An ARN representing the Amazon Web Services account ID that specifies the owner of any simulated resource that does not identify its owner in the resource ARN. Examples of resource ARNs include an S3 bucket or object. If ResourceOwner is specified, it is also used as the account owner of any ResourcePolicy included in the simulation. If the ResourceOwner parameter is not specified, then the owner of the resources and the resource policy defaults to the account of the identity provided in CallerArn. This parameter is required only if you specify a resource-based policy and account that owns the resource is different from the account that owns the simulated calling user CallerArn. The ARN for an account uses the following syntax: arn:aws:iam::AWS-account-ID:root. For example, to represent the account with the 112233445566 ID, use the following ARN: arn:aws:iam::112233445566-ID:root.
    public var resourceOwner: Swift.String?
    /// A resource-based policy to include in the simulation provided as a string. Each resource in the simulation is treated as if it had this policy attached. You can include only one resource-based policy in a simulation. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// Simulation of resource-based policies isn't supported for IAM roles.
    public var resourcePolicy: Swift.String?

    public init(
        actionNames: [Swift.String]? = nil,
        callerArn: Swift.String? = nil,
        contextEntries: [IAMClientTypes.ContextEntry]? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        permissionsBoundaryPolicyInputList: [Swift.String]? = nil,
        policyInputList: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceHandlingOption: Swift.String? = nil,
        resourceOwner: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.actionNames = actionNames
        self.callerArn = callerArn
        self.contextEntries = contextEntries
        self.marker = marker
        self.maxItems = maxItems
        self.permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList
        self.policyInputList = policyInputList
        self.resourceArns = resourceArns
        self.resourceHandlingOption = resourceHandlingOption
        self.resourceOwner = resourceOwner
        self.resourcePolicy = resourcePolicy
    }
}

extension SimulateCustomPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<SimulateCustomPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["SimulateCustomPolicyResult"]
            var value = SimulateCustomPolicyOutput()
            value.evaluationResults = try reader["EvaluationResults"].readListIfPresent(memberReadingClosure: IAMClientTypes.EvaluationResult.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [SimulatePrincipalPolicy] or [SimulateCustomPolicy] request.
public struct SimulateCustomPolicyOutput: Swift.Equatable {
    /// The results of the simulation.
    public var evaluationResults: [IAMClientTypes.EvaluationResult]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        evaluationResults: [IAMClientTypes.EvaluationResult]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

enum SimulateCustomPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PolicyEvaluation": return try await PolicyEvaluationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension SimulatePrincipalPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionNames = "ActionNames"
        case callerArn = "CallerArn"
        case contextEntries = "ContextEntries"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case permissionsBoundaryPolicyInputList = "PermissionsBoundaryPolicyInputList"
        case policyInputList = "PolicyInputList"
        case policySourceArn = "PolicySourceArn"
        case resourceArns = "ResourceArns"
        case resourceHandlingOption = "ResourceHandlingOption"
        case resourceOwner = "ResourceOwner"
        case resourcePolicy = "ResourcePolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let actionNames = actionNames {
            if !actionNames.isEmpty {
                var actionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionNames"))
                for (index0, actionnametype0) in actionNames.enumerated() {
                    try actionNamesContainer.encode(actionnametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var actionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionNames"))
                try actionNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let callerArn = callerArn {
            try container.encode(callerArn, forKey: ClientRuntime.Key("CallerArn"))
        }
        if let contextEntries = contextEntries {
            if !contextEntries.isEmpty {
                var contextEntriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextEntries"))
                for (index0, contextentry0) in contextEntries.enumerated() {
                    try contextEntriesContainer.encode(contextentry0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var contextEntriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextEntries"))
                try contextEntriesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList {
            if !permissionsBoundaryPolicyInputList.isEmpty {
                var permissionsBoundaryPolicyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PermissionsBoundaryPolicyInputList"))
                for (index0, policydocumenttype0) in permissionsBoundaryPolicyInputList.enumerated() {
                    try permissionsBoundaryPolicyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var permissionsBoundaryPolicyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PermissionsBoundaryPolicyInputList"))
                try permissionsBoundaryPolicyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policyInputList = policyInputList {
            if !policyInputList.isEmpty {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                for (index0, policydocumenttype0) in policyInputList.enumerated() {
                    try policyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                try policyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policySourceArn = policySourceArn {
            try container.encode(policySourceArn, forKey: ClientRuntime.Key("PolicySourceArn"))
        }
        if let resourceArns = resourceArns {
            if !resourceArns.isEmpty {
                var resourceArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceArns"))
                for (index0, resourcenametype0) in resourceArns.enumerated() {
                    try resourceArnsContainer.encode(resourcenametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var resourceArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceArns"))
                try resourceArnsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let resourceHandlingOption = resourceHandlingOption {
            try container.encode(resourceHandlingOption, forKey: ClientRuntime.Key("ResourceHandlingOption"))
        }
        if let resourceOwner = resourceOwner {
            try container.encode(resourceOwner, forKey: ClientRuntime.Key("ResourceOwner"))
        }
        if let resourcePolicy = resourcePolicy {
            try container.encode(resourcePolicy, forKey: ClientRuntime.Key("ResourcePolicy"))
        }
        try container.encode("SimulatePrincipalPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension SimulatePrincipalPolicyInput {

    static func urlPathProvider(_ value: SimulatePrincipalPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct SimulatePrincipalPolicyInput: Swift.Equatable {
    /// A list of names of API operations to evaluate in the simulation. Each operation is evaluated for each resource. Each operation must include the service identifier, such as iam:CreateUser.
    /// This member is required.
    public var actionNames: [Swift.String]?
    /// The ARN of the IAM user that you want to specify as the simulated caller of the API operations. If you do not specify a CallerArn, it defaults to the ARN of the user that you specify in PolicySourceArn, if you specified a user. If you include both a PolicySourceArn (for example, arn:aws:iam::123456789012:user/David) and a CallerArn (for example, arn:aws:iam::123456789012:user/Bob), the result is that you simulate calling the API operations as Bob, as if Bob had David's policies. You can specify only the ARN of an IAM user. You cannot specify the ARN of an assumed role, federated user, or a service principal. CallerArn is required if you include a ResourcePolicy and the PolicySourceArn is not the ARN for an IAM user. This is required so that the resource-based policy's Principal element has a value to use in evaluating the policy. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    public var callerArn: Swift.String?
    /// A list of context keys and corresponding values for the simulation to use. Whenever a context key is evaluated in one of the simulated IAM permissions policies, the corresponding value is supplied.
    public var contextEntries: [IAMClientTypes.ContextEntry]?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The IAM permissions boundary policy to simulate. The permissions boundary sets the maximum permissions that the entity can have. You can input only one permissions boundary when you pass a policy to this operation. An IAM entity can only have one permissions boundary in effect at a time. For example, if a permissions boundary is attached to an entity and you pass in a different permissions boundary policy using this parameter, then the new permissions boundary policy is used for the simulation. For more information about permissions boundaries, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. The policy input is specified as a string containing the complete, valid JSON text of a permissions boundary policy. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var permissionsBoundaryPolicyInputList: [Swift.String]?
    /// An optional list of additional policy documents to include in the simulation. Each document is specified as a string containing the complete, valid JSON text of an IAM policy. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var policyInputList: [Swift.String]?
    /// The Amazon Resource Name (ARN) of a user, group, or role whose policies you want to include in the simulation. If you specify a user, group, or role, the simulation includes all policies that are associated with that entity. If you specify a user, the simulation also includes all policies that are attached to any groups the user belongs to. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policySourceArn: Swift.String?
    /// A list of ARNs of Amazon Web Services resources to include in the simulation. If this parameter is not provided, then the value defaults to * (all resources). Each API in the ActionNames parameter is evaluated for each resource in this list. The simulation determines the access result (allowed or denied) of each combination and reports it in the response. You can simulate resources that don't exist in your account. The simulation does not automatically retrieve policies for the specified resources. If you want to include a resource policy in the simulation, then you must include the policy as a string in the ResourcePolicy parameter. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. Simulation of resource-based policies isn't supported for IAM roles.
    public var resourceArns: [Swift.String]?
    /// Specifies the type of simulation to run. Different API operations that support resource-based policies require different combinations of resources. By specifying the type of simulation to run, you enable the policy simulator to enforce the presence of the required resources to ensure reliable simulation results. If your simulation does not match one of the following scenarios, then you can omit this parameter. The following list shows each of the supported scenario values and the resources that you must define to run the simulation. Each of the EC2 scenarios requires that you specify instance, image, and security group resources. If your scenario includes an EBS volume, then you must specify that volume as a resource. If the EC2 scenario includes VPC, then you must supply the network interface resource. If it includes an IP subnet, then you must specify the subnet resource. For more information on the EC2 scenario options, see [Supported platforms](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html) in the Amazon EC2 User Guide.
    ///
    /// * EC2-VPC-InstanceStore instance, image, security group, network interface
    ///
    /// * EC2-VPC-InstanceStore-Subnet instance, image, security group, network interface, subnet
    ///
    /// * EC2-VPC-EBS instance, image, security group, network interface, volume
    ///
    /// * EC2-VPC-EBS-Subnet instance, image, security group, network interface, subnet, volume
    public var resourceHandlingOption: Swift.String?
    /// An Amazon Web Services account ID that specifies the owner of any simulated resource that does not identify its owner in the resource ARN. Examples of resource ARNs include an S3 bucket or object. If ResourceOwner is specified, it is also used as the account owner of any ResourcePolicy included in the simulation. If the ResourceOwner parameter is not specified, then the owner of the resources and the resource policy defaults to the account of the identity provided in CallerArn. This parameter is required only if you specify a resource-based policy and account that owns the resource is different from the account that owns the simulated calling user CallerArn.
    public var resourceOwner: Swift.String?
    /// A resource-based policy to include in the simulation provided as a string. Each resource in the simulation is treated as if it had this policy attached. You can include only one resource-based policy in a simulation. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// Simulation of resource-based policies isn't supported for IAM roles.
    public var resourcePolicy: Swift.String?

    public init(
        actionNames: [Swift.String]? = nil,
        callerArn: Swift.String? = nil,
        contextEntries: [IAMClientTypes.ContextEntry]? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        permissionsBoundaryPolicyInputList: [Swift.String]? = nil,
        policyInputList: [Swift.String]? = nil,
        policySourceArn: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceHandlingOption: Swift.String? = nil,
        resourceOwner: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.actionNames = actionNames
        self.callerArn = callerArn
        self.contextEntries = contextEntries
        self.marker = marker
        self.maxItems = maxItems
        self.permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList
        self.policyInputList = policyInputList
        self.policySourceArn = policySourceArn
        self.resourceArns = resourceArns
        self.resourceHandlingOption = resourceHandlingOption
        self.resourceOwner = resourceOwner
        self.resourcePolicy = resourcePolicy
    }
}

extension SimulatePrincipalPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<SimulatePrincipalPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["SimulatePrincipalPolicyResult"]
            var value = SimulatePrincipalPolicyOutput()
            value.evaluationResults = try reader["EvaluationResults"].readListIfPresent(memberReadingClosure: IAMClientTypes.EvaluationResult.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
            value.marker = try reader["Marker"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [SimulatePrincipalPolicy] or [SimulateCustomPolicy] request.
public struct SimulatePrincipalPolicyOutput: Swift.Equatable {
    /// The results of the simulation.
    public var evaluationResults: [IAMClientTypes.EvaluationResult]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init(
        evaluationResults: [IAMClientTypes.EvaluationResult]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

enum SimulatePrincipalPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PolicyEvaluation": return try await PolicyEvaluationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension IAMClientTypes {
    public enum SortKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lastAuthenticatedTimeAscending
        case lastAuthenticatedTimeDescending
        case serviceNamespaceAscending
        case serviceNamespaceDescending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortKeyType] {
            return [
                .lastAuthenticatedTimeAscending,
                .lastAuthenticatedTimeDescending,
                .serviceNamespaceAscending,
                .serviceNamespaceDescending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lastAuthenticatedTimeAscending: return "LAST_AUTHENTICATED_TIME_ASCENDING"
            case .lastAuthenticatedTimeDescending: return "LAST_AUTHENTICATED_TIME_DESCENDING"
            case .serviceNamespaceAscending: return "SERVICE_NAMESPACE_ASCENDING"
            case .serviceNamespaceDescending: return "SERVICE_NAMESPACE_DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortKeyType(rawValue: rawValue) ?? SortKeyType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.Statement: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endPosition = "EndPosition"
        case sourcePolicyId = "SourcePolicyId"
        case sourcePolicyType = "SourcePolicyType"
        case startPosition = "StartPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endPosition = endPosition {
            try container.encode(endPosition, forKey: ClientRuntime.Key("EndPosition"))
        }
        if let sourcePolicyId = sourcePolicyId {
            try container.encode(sourcePolicyId, forKey: ClientRuntime.Key("SourcePolicyId"))
        }
        if let sourcePolicyType = sourcePolicyType {
            try container.encode(sourcePolicyType, forKey: ClientRuntime.Key("SourcePolicyType"))
        }
        if let startPosition = startPosition {
            try container.encode(startPosition, forKey: ClientRuntime.Key("StartPosition"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.Statement, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.Statement()
            value.sourcePolicyId = try reader["SourcePolicyId"].readIfPresent()
            value.sourcePolicyType = try reader["SourcePolicyType"].readIfPresent()
            value.startPosition = try reader["StartPosition"].readIfPresent(readingClosure: IAMClientTypes.Position.readingClosure)
            value.endPosition = try reader["EndPosition"].readIfPresent(readingClosure: IAMClientTypes.Position.readingClosure)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains a reference to a Statement element in a policy document that determines the result of the simulation. This data type is used by the MatchedStatements member of the [EvaluationResult] type.
    public struct Statement: Swift.Equatable {
        /// The row and column of the end of a Statement in an IAM policy.
        public var endPosition: IAMClientTypes.Position?
        /// The identifier of the policy that was provided as an input.
        public var sourcePolicyId: Swift.String?
        /// The type of the policy.
        public var sourcePolicyType: IAMClientTypes.PolicySourceType?
        /// The row and column of the beginning of the Statement in an IAM policy.
        public var startPosition: IAMClientTypes.Position?

        public init(
            endPosition: IAMClientTypes.Position? = nil,
            sourcePolicyId: Swift.String? = nil,
            sourcePolicyType: IAMClientTypes.PolicySourceType? = nil,
            startPosition: IAMClientTypes.Position? = nil
        )
        {
            self.endPosition = endPosition
            self.sourcePolicyId = sourcePolicyId
            self.sourcePolicyType = sourcePolicyType
            self.startPosition = startPosition
        }
    }

}

extension IAMClientTypes {
    public enum StatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusType] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusType(rawValue: rawValue) ?? StatusType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes {
    public enum SummaryKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accesskeysperuserquota
        case accountaccesskeyspresent
        case accountmfaenabled
        case accountsigningcertificatespresent
        case attachedpoliciespergroupquota
        case attachedpoliciesperrolequota
        case attachedpoliciesperuserquota
        case globalendpointtokenversion
        case grouppolicysizequota
        case groups
        case groupsperuserquota
        case groupsquota
        case mfadevices
        case mfadevicesinuse
        case policies
        case policiesquota
        case policysizequota
        case policyversionsinuse
        case policyversionsinusequota
        case servercertificates
        case servercertificatesquota
        case signingcertificatesperuserquota
        case userpolicysizequota
        case users
        case usersquota
        case versionsperpolicyquota
        case sdkUnknown(Swift.String)

        public static var allCases: [SummaryKeyType] {
            return [
                .accesskeysperuserquota,
                .accountaccesskeyspresent,
                .accountmfaenabled,
                .accountsigningcertificatespresent,
                .attachedpoliciespergroupquota,
                .attachedpoliciesperrolequota,
                .attachedpoliciesperuserquota,
                .globalendpointtokenversion,
                .grouppolicysizequota,
                .groups,
                .groupsperuserquota,
                .groupsquota,
                .mfadevices,
                .mfadevicesinuse,
                .policies,
                .policiesquota,
                .policysizequota,
                .policyversionsinuse,
                .policyversionsinusequota,
                .servercertificates,
                .servercertificatesquota,
                .signingcertificatesperuserquota,
                .userpolicysizequota,
                .users,
                .usersquota,
                .versionsperpolicyquota,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accesskeysperuserquota: return "AccessKeysPerUserQuota"
            case .accountaccesskeyspresent: return "AccountAccessKeysPresent"
            case .accountmfaenabled: return "AccountMFAEnabled"
            case .accountsigningcertificatespresent: return "AccountSigningCertificatesPresent"
            case .attachedpoliciespergroupquota: return "AttachedPoliciesPerGroupQuota"
            case .attachedpoliciesperrolequota: return "AttachedPoliciesPerRoleQuota"
            case .attachedpoliciesperuserquota: return "AttachedPoliciesPerUserQuota"
            case .globalendpointtokenversion: return "GlobalEndpointTokenVersion"
            case .grouppolicysizequota: return "GroupPolicySizeQuota"
            case .groups: return "Groups"
            case .groupsperuserquota: return "GroupsPerUserQuota"
            case .groupsquota: return "GroupsQuota"
            case .mfadevices: return "MFADevices"
            case .mfadevicesinuse: return "MFADevicesInUse"
            case .policies: return "Policies"
            case .policiesquota: return "PoliciesQuota"
            case .policysizequota: return "PolicySizeQuota"
            case .policyversionsinuse: return "PolicyVersionsInUse"
            case .policyversionsinusequota: return "PolicyVersionsInUseQuota"
            case .servercertificates: return "ServerCertificates"
            case .servercertificatesquota: return "ServerCertificatesQuota"
            case .signingcertificatesperuserquota: return "SigningCertificatesPerUserQuota"
            case .userpolicysizequota: return "UserPolicySizeQuota"
            case .users: return "Users"
            case .usersquota: return "UsersQuota"
            case .versionsperpolicyquota: return "VersionsPerPolicyQuota"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SummaryKeyType(rawValue: rawValue) ?? SummaryKeyType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.Tag: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.Tag, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.Tag()
            value.key = try reader["Key"].readIfPresent()
            value.value = try reader["Value"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// A structure that represents user-provided metadata that can be associated with an IAM resource. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public struct Tag: Swift.Equatable {
        /// The key name that can be used to look up or retrieve the associated value. For example, Department or Cost Center are common choices.
        /// This member is required.
        public var key: Swift.String?
        /// The value associated with this tag. For example, tags with a key name of Department could have values such as Human Resources, Accounting, and Support. Tags with a key name of Cost Center might have values that consist of the number associated with the different cost centers in your company. Typically, many resources have tags with the same key name but with different values. Amazon Web Services always interprets the tag Value as a single string. If you need to store an array, you can store comma-separated values in the string. However, you must interpret the value in your code.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagInstanceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagInstanceProfileInput {

    static func urlPathProvider(_ value: TagInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

public struct TagInstanceProfileInput: Swift.Equatable {
    /// The name of the IAM instance profile to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The list of tags that you want to attach to the IAM instance profile. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        instanceProfileName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.tags = tags
    }
}

extension TagInstanceProfileOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<TagInstanceProfileOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return TagInstanceProfileOutput()
        }
    }
}

public struct TagInstanceProfileOutput: Swift.Equatable {

    public init() { }
}

enum TagInstanceProfileOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension TagMFADeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serialNumber = "SerialNumber"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagMFADeviceInput {

    static func urlPathProvider(_ value: TagMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

public struct TagMFADeviceInput: Swift.Equatable {
    /// The unique identifier for the IAM virtual MFA device to which you want to add tags. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The list of tags that you want to attach to the IAM virtual MFA device. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        serialNumber: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.serialNumber = serialNumber
        self.tags = tags
    }
}

extension TagMFADeviceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<TagMFADeviceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return TagMFADeviceOutput()
        }
    }
}

public struct TagMFADeviceOutput: Swift.Equatable {

    public init() { }
}

enum TagMFADeviceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension TagOpenIDConnectProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagOpenIDConnectProviderInput {

    static func urlPathProvider(_ value: TagOpenIDConnectProviderInput) -> Swift.String? {
        return "/"
    }
}

public struct TagOpenIDConnectProviderInput: Swift.Equatable {
    /// The ARN of the OIDC identity provider in IAM to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?
    /// The list of tags that you want to attach to the OIDC identity provider in IAM. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        openIDConnectProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.tags = tags
    }
}

extension TagOpenIDConnectProviderOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<TagOpenIDConnectProviderOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return TagOpenIDConnectProviderOutput()
        }
    }
}

public struct TagOpenIDConnectProviderOutput: Swift.Equatable {

    public init() { }
}

enum TagOpenIDConnectProviderOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension TagPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagPolicyInput {

    static func urlPathProvider(_ value: TagPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct TagPolicyInput: Swift.Equatable {
    /// The ARN of the IAM customer managed policy to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyArn: Swift.String?
    /// The list of tags that you want to attach to the IAM customer managed policy. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        policyArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.policyArn = policyArn
        self.tags = tags
    }
}

extension TagPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<TagPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return TagPolicyOutput()
        }
    }
}

public struct TagPolicyOutput: Swift.Equatable {

    public init() { }
}

enum TagPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension TagRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagRoleInput {

    static func urlPathProvider(_ value: TagRoleInput) -> Swift.String? {
        return "/"
    }
}

public struct TagRoleInput: Swift.Equatable {
    /// The name of the IAM role to which you want to add tags. This parameter accepts (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?
    /// The list of tags that you want to attach to the IAM role. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        roleName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.roleName = roleName
        self.tags = tags
    }
}

extension TagRoleOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<TagRoleOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return TagRoleOutput()
        }
    }
}

public struct TagRoleOutput: Swift.Equatable {

    public init() { }
}

enum TagRoleOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension TagSAMLProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagSAMLProviderInput {

    static func urlPathProvider(_ value: TagSAMLProviderInput) -> Swift.String? {
        return "/"
    }
}

public struct TagSAMLProviderInput: Swift.Equatable {
    /// The ARN of the SAML identity provider in IAM to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var samlProviderArn: Swift.String?
    /// The list of tags that you want to attach to the SAML identity provider in IAM. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        samlProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
        self.tags = tags
    }
}

extension TagSAMLProviderOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<TagSAMLProviderOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return TagSAMLProviderOutput()
        }
    }
}

public struct TagSAMLProviderOutput: Swift.Equatable {

    public init() { }
}

enum TagSAMLProviderOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension TagServerCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificateName = "ServerCertificateName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagServerCertificateInput {

    static func urlPathProvider(_ value: TagServerCertificateInput) -> Swift.String? {
        return "/"
    }
}

public struct TagServerCertificateInput: Swift.Equatable {
    /// The name of the IAM server certificate to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?
    /// The list of tags that you want to attach to the IAM server certificate. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        serverCertificateName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
        self.tags = tags
    }
}

extension TagServerCertificateOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<TagServerCertificateOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return TagServerCertificateOutput()
        }
    }
}

public struct TagServerCertificateOutput: Swift.Equatable {

    public init() { }
}

enum TagServerCertificateOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension TagUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("TagUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagUserInput {

    static func urlPathProvider(_ value: TagUserInput) -> Swift.String? {
        return "/"
    }
}

public struct TagUserInput: Swift.Equatable {
    /// The list of tags that you want to attach to the IAM user. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?
    /// The name of the IAM user to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        tags: [IAMClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.tags = tags
        self.userName = userName
    }
}

extension TagUserOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<TagUserOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return TagUserOutput()
        }
    }
}

public struct TagUserOutput: Swift.Equatable {

    public init() { }
}

enum TagUserOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension IAMClientTypes.TrackedActionLastAccessed: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionName = "ActionName"
        case lastAccessedEntity = "LastAccessedEntity"
        case lastAccessedRegion = "LastAccessedRegion"
        case lastAccessedTime = "LastAccessedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let actionName = actionName {
            try container.encode(actionName, forKey: ClientRuntime.Key("ActionName"))
        }
        if let lastAccessedEntity = lastAccessedEntity {
            try container.encode(lastAccessedEntity, forKey: ClientRuntime.Key("LastAccessedEntity"))
        }
        if let lastAccessedRegion = lastAccessedRegion {
            try container.encode(lastAccessedRegion, forKey: ClientRuntime.Key("LastAccessedRegion"))
        }
        if let lastAccessedTime = lastAccessedTime {
            try container.encodeTimestamp(lastAccessedTime, format: .dateTime, forKey: ClientRuntime.Key("LastAccessedTime"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.TrackedActionLastAccessed, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.TrackedActionLastAccessed()
            value.actionName = try reader["ActionName"].readIfPresent()
            value.lastAccessedEntity = try reader["LastAccessedEntity"].readIfPresent()
            value.lastAccessedTime = try reader["LastAccessedTime"].readTimestampIfPresent(format: .dateTime)
            value.lastAccessedRegion = try reader["LastAccessedRegion"].readIfPresent()
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains details about the most recent attempt to access an action within the service. This data type is used as a response element in the [GetServiceLastAccessedDetails] operation.
    public struct TrackedActionLastAccessed: Swift.Equatable {
        /// The name of the tracked action to which access was attempted. Tracked actions are actions that report activity to IAM.
        public var actionName: Swift.String?
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var lastAccessedEntity: Swift.String?
        /// The Region from which the authenticated entity (user or role) last attempted to access the tracked action. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAccessedRegion: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when an authenticated entity most recently attempted to access the tracked service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAccessedTime: ClientRuntime.Date?

        public init(
            actionName: Swift.String? = nil,
            lastAccessedEntity: Swift.String? = nil,
            lastAccessedRegion: Swift.String? = nil,
            lastAccessedTime: ClientRuntime.Date? = nil
        )
        {
            self.actionName = actionName
            self.lastAccessedEntity = lastAccessedEntity
            self.lastAccessedRegion = lastAccessedRegion
            self.lastAccessedTime = lastAccessedTime
        }
    }

}

extension UnmodifiableEntityException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = UnmodifiableEntityException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because service-linked roles are protected Amazon Web Services resources. Only the service that depends on the service-linked role can modify or delete the role on your behalf. The error message includes the name of the service that depends on this service-linked role. You must request the change through that service.
public struct UnmodifiableEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnmodifiableEntity" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UnrecognizedPublicKeyEncodingException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = UnrecognizedPublicKeyEncodingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the public key encoding format is unsupported or unrecognized.
public struct UnrecognizedPublicKeyEncodingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnrecognizedPublicKeyEncoding" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UntagInstanceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagInstanceProfileInput {

    static func urlPathProvider(_ value: UntagInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

public struct UntagInstanceProfileInput: Swift.Equatable {
    /// The name of the IAM instance profile from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified instance profile.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        instanceProfileName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.tagKeys = tagKeys
    }
}

extension UntagInstanceProfileOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UntagInstanceProfileOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UntagInstanceProfileOutput()
        }
    }
}

public struct UntagInstanceProfileOutput: Swift.Equatable {

    public init() { }
}

enum UntagInstanceProfileOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UntagMFADeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serialNumber = "SerialNumber"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagMFADeviceInput {

    static func urlPathProvider(_ value: UntagMFADeviceInput) -> Swift.String? {
        return "/"
    }
}

public struct UntagMFADeviceInput: Swift.Equatable {
    /// The unique identifier for the IAM virtual MFA device from which you want to remove tags. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified instance profile.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        serialNumber: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.serialNumber = serialNumber
        self.tagKeys = tagKeys
    }
}

extension UntagMFADeviceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UntagMFADeviceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UntagMFADeviceOutput()
        }
    }
}

public struct UntagMFADeviceOutput: Swift.Equatable {

    public init() { }
}

enum UntagMFADeviceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UntagOpenIDConnectProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagOpenIDConnectProviderInput {

    static func urlPathProvider(_ value: UntagOpenIDConnectProviderInput) -> Swift.String? {
        return "/"
    }
}

public struct UntagOpenIDConnectProviderInput: Swift.Equatable {
    /// The ARN of the OIDC provider in IAM from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified OIDC provider.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        openIDConnectProviderArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.tagKeys = tagKeys
    }
}

extension UntagOpenIDConnectProviderOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UntagOpenIDConnectProviderOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UntagOpenIDConnectProviderOutput()
        }
    }
}

public struct UntagOpenIDConnectProviderOutput: Swift.Equatable {

    public init() { }
}

enum UntagOpenIDConnectProviderOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UntagPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagPolicyInput {

    static func urlPathProvider(_ value: UntagPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct UntagPolicyInput: Swift.Equatable {
    /// The ARN of the IAM customer managed policy from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyArn: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified policy.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        policyArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.policyArn = policyArn
        self.tagKeys = tagKeys
    }
}

extension UntagPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UntagPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UntagPolicyOutput()
        }
    }
}

public struct UntagPolicyOutput: Swift.Equatable {

    public init() { }
}

enum UntagPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UntagRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagRoleInput {

    static func urlPathProvider(_ value: UntagRoleInput) -> Swift.String? {
        return "/"
    }
}

public struct UntagRoleInput: Swift.Equatable {
    /// The name of the IAM role from which you want to remove tags. This parameter accepts (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified role.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        roleName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.roleName = roleName
        self.tagKeys = tagKeys
    }
}

extension UntagRoleOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UntagRoleOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UntagRoleOutput()
        }
    }
}

public struct UntagRoleOutput: Swift.Equatable {

    public init() { }
}

enum UntagRoleOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UntagSAMLProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagSAMLProviderInput {

    static func urlPathProvider(_ value: UntagSAMLProviderInput) -> Swift.String? {
        return "/"
    }
}

public struct UntagSAMLProviderInput: Swift.Equatable {
    /// The ARN of the SAML identity provider in IAM from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var samlProviderArn: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified SAML identity provider.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        samlProviderArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
        self.tagKeys = tagKeys
    }
}

extension UntagSAMLProviderOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UntagSAMLProviderOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UntagSAMLProviderOutput()
        }
    }
}

public struct UntagSAMLProviderOutput: Swift.Equatable {

    public init() { }
}

enum UntagSAMLProviderOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UntagServerCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificateName = "ServerCertificateName"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagServerCertificateInput {

    static func urlPathProvider(_ value: UntagServerCertificateInput) -> Swift.String? {
        return "/"
    }
}

public struct UntagServerCertificateInput: Swift.Equatable {
    /// The name of the IAM server certificate from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified IAM server certificate.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        serverCertificateName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
        self.tagKeys = tagKeys
    }
}

extension UntagServerCertificateOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UntagServerCertificateOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UntagServerCertificateOutput()
        }
    }
}

public struct UntagServerCertificateOutput: Swift.Equatable {

    public init() { }
}

enum UntagServerCertificateOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UntagUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UntagUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagUserInput {

    static func urlPathProvider(_ value: UntagUserInput) -> Swift.String? {
        return "/"
    }
}

public struct UntagUserInput: Swift.Equatable {
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified user.
    /// This member is required.
    public var tagKeys: [Swift.String]?
    /// The name of the IAM user from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        tagKeys: [Swift.String]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.tagKeys = tagKeys
        self.userName = userName
    }
}

extension UntagUserOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UntagUserOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UntagUserOutput()
        }
    }
}

public struct UntagUserOutput: Swift.Equatable {

    public init() { }
}

enum UntagUserOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateAccessKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateAccessKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateAccessKeyInput {

    static func urlPathProvider(_ value: UpdateAccessKeyInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateAccessKeyInput: Swift.Equatable {
    /// The access key ID of the secret access key you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var accessKeyId: Swift.String?
    /// The status you want to assign to the secret access key. Active means that the key can be used for programmatic calls to Amazon Web Services, while Inactive means that the key cannot be used.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the user whose key you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        accessKeyId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.status = status
        self.userName = userName
    }
}

extension UpdateAccessKeyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateAccessKeyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UpdateAccessKeyOutput()
        }
    }
}

public struct UpdateAccessKeyOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAccessKeyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateAccountPasswordPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUsersToChangePassword = "AllowUsersToChangePassword"
        case hardExpiry = "HardExpiry"
        case maxPasswordAge = "MaxPasswordAge"
        case minimumPasswordLength = "MinimumPasswordLength"
        case passwordReusePrevention = "PasswordReusePrevention"
        case requireLowercaseCharacters = "RequireLowercaseCharacters"
        case requireNumbers = "RequireNumbers"
        case requireSymbols = "RequireSymbols"
        case requireUppercaseCharacters = "RequireUppercaseCharacters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowUsersToChangePassword = allowUsersToChangePassword {
            try container.encode(allowUsersToChangePassword, forKey: ClientRuntime.Key("AllowUsersToChangePassword"))
        }
        if let hardExpiry = hardExpiry {
            try container.encode(hardExpiry, forKey: ClientRuntime.Key("HardExpiry"))
        }
        if let maxPasswordAge = maxPasswordAge {
            try container.encode(maxPasswordAge, forKey: ClientRuntime.Key("MaxPasswordAge"))
        }
        if let minimumPasswordLength = minimumPasswordLength {
            try container.encode(minimumPasswordLength, forKey: ClientRuntime.Key("MinimumPasswordLength"))
        }
        if let passwordReusePrevention = passwordReusePrevention {
            try container.encode(passwordReusePrevention, forKey: ClientRuntime.Key("PasswordReusePrevention"))
        }
        if let requireLowercaseCharacters = requireLowercaseCharacters {
            try container.encode(requireLowercaseCharacters, forKey: ClientRuntime.Key("RequireLowercaseCharacters"))
        }
        if let requireNumbers = requireNumbers {
            try container.encode(requireNumbers, forKey: ClientRuntime.Key("RequireNumbers"))
        }
        if let requireSymbols = requireSymbols {
            try container.encode(requireSymbols, forKey: ClientRuntime.Key("RequireSymbols"))
        }
        if let requireUppercaseCharacters = requireUppercaseCharacters {
            try container.encode(requireUppercaseCharacters, forKey: ClientRuntime.Key("RequireUppercaseCharacters"))
        }
        try container.encode("UpdateAccountPasswordPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateAccountPasswordPolicyInput {

    static func urlPathProvider(_ value: UpdateAccountPasswordPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateAccountPasswordPolicyInput: Swift.Equatable {
    /// Allows all IAM users in your account to use the Amazon Web Services Management Console to change their own passwords. For more information, see [Permitting IAM users to change their own passwords](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_passwords_enable-user-change.html) in the IAM User Guide. If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that IAM users in the account do not automatically have permissions to change their own password.
    public var allowUsersToChangePassword: Swift.Bool?
    /// Prevents IAM users who are accessing the account via the Amazon Web Services Management Console from setting a new console password after their password has expired. The IAM user cannot access the console until an administrator resets the password. If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that IAM users can change their passwords after they expire and continue to sign in as the user. In the Amazon Web Services Management Console, the custom password policy option Allow users to change their own password gives IAM users permissions to iam:ChangePassword for only their user and to the iam:GetAccountPasswordPolicy action. This option does not attach a permissions policy to each user, rather the permissions are applied at the account-level for all users by IAM. IAM users with iam:ChangePassword permission and active access keys can reset their own expired console password using the CLI or API.
    public var hardExpiry: Swift.Bool?
    /// The number of days that an IAM user password is valid. If you do not specify a value for this parameter, then the operation uses the default value of 0. The result is that IAM user passwords never expire.
    public var maxPasswordAge: Swift.Int?
    /// The minimum number of characters allowed in an IAM user password. If you do not specify a value for this parameter, then the operation uses the default value of 6.
    public var minimumPasswordLength: Swift.Int?
    /// Specifies the number of previous passwords that IAM users are prevented from reusing. If you do not specify a value for this parameter, then the operation uses the default value of 0. The result is that IAM users are not prevented from reusing previous passwords.
    public var passwordReusePrevention: Swift.Int?
    /// Specifies whether IAM user passwords must contain at least one lowercase character from the ISO basic Latin alphabet (a to z). If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one lowercase character.
    public var requireLowercaseCharacters: Swift.Bool?
    /// Specifies whether IAM user passwords must contain at least one numeric character (0 to 9). If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one numeric character.
    public var requireNumbers: Swift.Bool?
    /// Specifies whether IAM user passwords must contain at least one of the following non-alphanumeric characters: ! @ # $ % ^ & * ( ) _ + - = [ ] { } | ' If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one symbol character.
    public var requireSymbols: Swift.Bool?
    /// Specifies whether IAM user passwords must contain at least one uppercase character from the ISO basic Latin alphabet (A to Z). If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one uppercase character.
    public var requireUppercaseCharacters: Swift.Bool?

    public init(
        allowUsersToChangePassword: Swift.Bool? = nil,
        hardExpiry: Swift.Bool? = nil,
        maxPasswordAge: Swift.Int? = nil,
        minimumPasswordLength: Swift.Int? = nil,
        passwordReusePrevention: Swift.Int? = nil,
        requireLowercaseCharacters: Swift.Bool? = nil,
        requireNumbers: Swift.Bool? = nil,
        requireSymbols: Swift.Bool? = nil,
        requireUppercaseCharacters: Swift.Bool? = nil
    )
    {
        self.allowUsersToChangePassword = allowUsersToChangePassword
        self.hardExpiry = hardExpiry
        self.maxPasswordAge = maxPasswordAge
        self.minimumPasswordLength = minimumPasswordLength
        self.passwordReusePrevention = passwordReusePrevention
        self.requireLowercaseCharacters = requireLowercaseCharacters
        self.requireNumbers = requireNumbers
        self.requireSymbols = requireSymbols
        self.requireUppercaseCharacters = requireUppercaseCharacters
    }
}

extension UpdateAccountPasswordPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateAccountPasswordPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UpdateAccountPasswordPolicyOutput()
        }
    }
}

public struct UpdateAccountPasswordPolicyOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAccountPasswordPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateAssumeRolePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("UpdateAssumeRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateAssumeRolePolicyInput {

    static func urlPathProvider(_ value: UpdateAssumeRolePolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateAssumeRolePolicyInput: Swift.Equatable {
    /// The policy that grants an entity permission to assume the role. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the role to update with the new policy. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.roleName = roleName
    }
}

extension UpdateAssumeRolePolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateAssumeRolePolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UpdateAssumeRolePolicyOutput()
        }
    }
}

public struct UpdateAssumeRolePolicyOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAssumeRolePolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "MalformedPolicyDocument": return try await MalformedPolicyDocumentException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnmodifiableEntity": return try await UnmodifiableEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case newGroupName = "NewGroupName"
        case newPath = "NewPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let newGroupName = newGroupName {
            try container.encode(newGroupName, forKey: ClientRuntime.Key("NewGroupName"))
        }
        if let newPath = newPath {
            try container.encode(newPath, forKey: ClientRuntime.Key("NewPath"))
        }
        try container.encode("UpdateGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateGroupInput {

    static func urlPathProvider(_ value: UpdateGroupInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateGroupInput: Swift.Equatable {
    /// Name of the IAM group to update. If you're changing the name of the group, this is the original name. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// New name for the IAM group. Only include this if changing the group's name. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    public var newGroupName: Swift.String?
    /// New path for the IAM group. Only include this if changing the group's path. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var newPath: Swift.String?

    public init(
        groupName: Swift.String? = nil,
        newGroupName: Swift.String? = nil,
        newPath: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.newGroupName = newGroupName
        self.newPath = newPath
    }
}

extension UpdateGroupOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateGroupOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UpdateGroupOutput()
        }
    }
}

public struct UpdateGroupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateGroupOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateLoginProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLoginProfileInput(passwordResetRequired: \(Swift.String(describing: passwordResetRequired)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

extension UpdateLoginProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case passwordResetRequired = "PasswordResetRequired"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let password = password {
            try container.encode(password, forKey: ClientRuntime.Key("Password"))
        }
        if let passwordResetRequired = passwordResetRequired {
            try container.encode(passwordResetRequired, forKey: ClientRuntime.Key("PasswordResetRequired"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateLoginProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateLoginProfileInput {

    static func urlPathProvider(_ value: UpdateLoginProfileInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateLoginProfileInput: Swift.Equatable {
    /// The new password for the specified IAM user. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// However, the format can be further restricted by the account administrator by setting a password policy on the Amazon Web Services account. For more information, see [UpdateAccountPasswordPolicy].
    public var password: Swift.String?
    /// Allows this new password to be used only once by requiring the specified IAM user to set a new password on next sign-in.
    public var passwordResetRequired: Swift.Bool?
    /// The name of the user whose password you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        password: Swift.String? = nil,
        passwordResetRequired: Swift.Bool? = nil,
        userName: Swift.String? = nil
    )
    {
        self.password = password
        self.passwordResetRequired = passwordResetRequired
        self.userName = userName
    }
}

extension UpdateLoginProfileOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateLoginProfileOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UpdateLoginProfileOutput()
        }
    }
}

public struct UpdateLoginProfileOutput: Swift.Equatable {

    public init() { }
}

enum UpdateLoginProfileOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "EntityTemporarilyUnmodifiable": return try await EntityTemporarilyUnmodifiableException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PasswordPolicyViolation": return try await PasswordPolicyViolationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateOpenIDConnectProviderThumbprintInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
        case thumbprintList = "ThumbprintList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        if let thumbprintList = thumbprintList {
            if !thumbprintList.isEmpty {
                var thumbprintListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ThumbprintList"))
                for (index0, thumbprinttype0) in thumbprintList.enumerated() {
                    try thumbprintListContainer.encode(thumbprinttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var thumbprintListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ThumbprintList"))
                try thumbprintListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UpdateOpenIDConnectProviderThumbprint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateOpenIDConnectProviderThumbprintInput {

    static func urlPathProvider(_ value: UpdateOpenIDConnectProviderThumbprintInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateOpenIDConnectProviderThumbprintInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM OIDC provider resource object for which you want to update the thumbprint. You can get a list of OIDC provider ARNs by using the [ListOpenIDConnectProviders] operation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?
    /// A list of certificate thumbprints that are associated with the specified IAM OpenID Connect provider. For more information, see [CreateOpenIDConnectProvider].
    /// This member is required.
    public var thumbprintList: [Swift.String]?

    public init(
        openIDConnectProviderArn: Swift.String? = nil,
        thumbprintList: [Swift.String]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.thumbprintList = thumbprintList
    }
}

extension UpdateOpenIDConnectProviderThumbprintOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateOpenIDConnectProviderThumbprintOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UpdateOpenIDConnectProviderThumbprintOutput()
        }
    }
}

public struct UpdateOpenIDConnectProviderThumbprintOutput: Swift.Equatable {

    public init() { }
}

enum UpdateOpenIDConnectProviderThumbprintOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateRoleDescriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("UpdateRoleDescription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateRoleDescriptionInput {

    static func urlPathProvider(_ value: UpdateRoleDescriptionInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateRoleDescriptionInput: Swift.Equatable {
    /// The new description that you want to apply to the specified role.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the role that you want to modify.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        description: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.description = description
        self.roleName = roleName
    }
}

extension UpdateRoleDescriptionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateRoleDescriptionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["UpdateRoleDescriptionResult"]
            var value = UpdateRoleDescriptionOutput()
            value.role = try reader["Role"].readIfPresent(readingClosure: IAMClientTypes.Role.readingClosure)
            return value
        }
    }
}

public struct UpdateRoleDescriptionOutput: Swift.Equatable {
    /// A structure that contains details about the modified role.
    public var role: IAMClientTypes.Role?

    public init(
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

enum UpdateRoleDescriptionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnmodifiableEntity": return try await UnmodifiableEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case maxSessionDuration = "MaxSessionDuration"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let maxSessionDuration = maxSessionDuration {
            try container.encode(maxSessionDuration, forKey: ClientRuntime.Key("MaxSessionDuration"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("UpdateRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateRoleInput {

    static func urlPathProvider(_ value: UpdateRoleInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateRoleInput: Swift.Equatable {
    /// The new description that you want to apply to the specified role.
    public var description: Swift.String?
    /// The maximum session duration (in seconds) that you want to set for the specified role. If you do not specify a value for this setting, the default value of one hour is applied. This setting can have a value from 1 hour to 12 hours. Anyone who assumes the role from the CLI or API can use the DurationSeconds API parameter or the duration-seconds CLI parameter to request a longer session. The MaxSessionDuration setting determines the maximum duration that can be requested using the DurationSeconds parameter. If users don't specify a value for the DurationSeconds parameter, their security credentials are valid for one hour by default. This applies when you use the AssumeRole* API operations or the assume-role* CLI operations but does not apply when you use those operations to create a console URL. For more information, see [Using IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html) in the IAM User Guide.
    public var maxSessionDuration: Swift.Int?
    /// The name of the role that you want to modify.
    /// This member is required.
    public var roleName: Swift.String?

    public init(
        description: Swift.String? = nil,
        maxSessionDuration: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.description = description
        self.maxSessionDuration = maxSessionDuration
        self.roleName = roleName
    }
}

extension UpdateRoleOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateRoleOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UpdateRoleOutput()
        }
    }
}

public struct UpdateRoleOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRoleOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnmodifiableEntity": return try await UnmodifiableEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateSAMLProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlMetadataDocument = "SAMLMetadataDocument"
        case samlProviderArn = "SAMLProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let samlMetadataDocument = samlMetadataDocument {
            try container.encode(samlMetadataDocument, forKey: ClientRuntime.Key("SAMLMetadataDocument"))
        }
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        try container.encode("UpdateSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateSAMLProviderInput {

    static func urlPathProvider(_ value: UpdateSAMLProviderInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateSAMLProviderInput: Swift.Equatable {
    /// An XML document generated by an identity provider (IdP) that supports SAML 2.0. The document includes the issuer's name, expiration information, and keys that can be used to validate the SAML authentication response (assertions) that are received from the IdP. You must generate the metadata document using the identity management software that is used as your organization's IdP.
    /// This member is required.
    public var samlMetadataDocument: Swift.String?
    /// The Amazon Resource Name (ARN) of the SAML provider to update. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init(
        samlMetadataDocument: Swift.String? = nil,
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlMetadataDocument = samlMetadataDocument
        self.samlProviderArn = samlProviderArn
    }
}

extension UpdateSAMLProviderOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateSAMLProviderOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["UpdateSAMLProviderResult"]
            var value = UpdateSAMLProviderOutput()
            value.samlProviderArn = try reader["SAMLProviderArn"].readIfPresent()
            return value
        }
    }
}

/// Contains the response to a successful [UpdateSAMLProvider] request.
public struct UpdateSAMLProviderOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the SAML provider that was updated.
    public var samlProviderArn: Swift.String?

    public init(
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
    }
}

enum UpdateSAMLProviderOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateSSHPublicKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKeyId = "SSHPublicKeyId"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sshPublicKeyId = sshPublicKeyId {
            try container.encode(sshPublicKeyId, forKey: ClientRuntime.Key("SSHPublicKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateSSHPublicKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateSSHPublicKeyInput {

    static func urlPathProvider(_ value: UpdateSSHPublicKeyInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateSSHPublicKeyInput: Swift.Equatable {
    /// The unique identifier for the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// The status to assign to the SSH public key. Active means that the key can be used for authentication with an CodeCommit repository. Inactive means that the key cannot be used.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the IAM user associated with the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        sshPublicKeyId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.sshPublicKeyId = sshPublicKeyId
        self.status = status
        self.userName = userName
    }
}

extension UpdateSSHPublicKeyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateSSHPublicKeyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UpdateSSHPublicKeyOutput()
        }
    }
}

public struct UpdateSSHPublicKeyOutput: Swift.Equatable {

    public init() { }
}

enum UpdateSSHPublicKeyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateServerCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newPath = "NewPath"
        case newServerCertificateName = "NewServerCertificateName"
        case serverCertificateName = "ServerCertificateName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let newPath = newPath {
            try container.encode(newPath, forKey: ClientRuntime.Key("NewPath"))
        }
        if let newServerCertificateName = newServerCertificateName {
            try container.encode(newServerCertificateName, forKey: ClientRuntime.Key("NewServerCertificateName"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        try container.encode("UpdateServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateServerCertificateInput {

    static func urlPathProvider(_ value: UpdateServerCertificateInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateServerCertificateInput: Swift.Equatable {
    /// The new path for the server certificate. Include this only if you are updating the server certificate's path. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var newPath: Swift.String?
    /// The new name for the server certificate. Include this only if you are updating the server certificate's name. The name of the certificate cannot contain any spaces. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var newServerCertificateName: Swift.String?
    /// The name of the server certificate that you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init(
        newPath: Swift.String? = nil,
        newServerCertificateName: Swift.String? = nil,
        serverCertificateName: Swift.String? = nil
    )
    {
        self.newPath = newPath
        self.newServerCertificateName = newServerCertificateName
        self.serverCertificateName = serverCertificateName
    }
}

extension UpdateServerCertificateOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateServerCertificateOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UpdateServerCertificateOutput()
        }
    }
}

public struct UpdateServerCertificateOutput: Swift.Equatable {

    public init() { }
}

enum UpdateServerCertificateOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateServiceSpecificCredentialInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: ClientRuntime.Key("ServiceSpecificCredentialId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateServiceSpecificCredential", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateServiceSpecificCredentialInput {

    static func urlPathProvider(_ value: UpdateServiceSpecificCredentialInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateServiceSpecificCredentialInput: Swift.Equatable {
    /// The unique identifier of the service-specific credential. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var serviceSpecificCredentialId: Swift.String?
    /// The status to be assigned to the service-specific credential.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the IAM user associated with the service-specific credential. If you do not specify this value, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        serviceSpecificCredentialId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.status = status
        self.userName = userName
    }
}

extension UpdateServiceSpecificCredentialOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateServiceSpecificCredentialOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UpdateServiceSpecificCredentialOutput()
        }
    }
}

public struct UpdateServiceSpecificCredentialOutput: Swift.Equatable {

    public init() { }
}

enum UpdateServiceSpecificCredentialOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateSigningCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateId = certificateId {
            try container.encode(certificateId, forKey: ClientRuntime.Key("CertificateId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateSigningCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateSigningCertificateInput {

    static func urlPathProvider(_ value: UpdateSigningCertificateInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateSigningCertificateInput: Swift.Equatable {
    /// The ID of the signing certificate you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var certificateId: Swift.String?
    /// The status you want to assign to the certificate. Active means that the certificate can be used for programmatic calls to Amazon Web Services Inactive means that the certificate cannot be used.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the IAM user the signing certificate belongs to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        certificateId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
        self.status = status
        self.userName = userName
    }
}

extension UpdateSigningCertificateOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateSigningCertificateOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UpdateSigningCertificateOutput()
        }
    }
}

public struct UpdateSigningCertificateOutput: Swift.Equatable {

    public init() { }
}

enum UpdateSigningCertificateOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newPath = "NewPath"
        case newUserName = "NewUserName"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let newPath = newPath {
            try container.encode(newPath, forKey: ClientRuntime.Key("NewPath"))
        }
        if let newUserName = newUserName {
            try container.encode(newUserName, forKey: ClientRuntime.Key("NewUserName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateUserInput {

    static func urlPathProvider(_ value: UpdateUserInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// New path for the IAM user. Include this parameter only if you're changing the user's path. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var newPath: Swift.String?
    /// New name for the user. Include this parameter only if you're changing the user's name. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    public var newUserName: Swift.String?
    /// Name of the user to update. If you're changing the name of the user, this is the original user name. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        newPath: Swift.String? = nil,
        newUserName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.newPath = newPath
        self.newUserName = newUserName
        self.userName = userName
    }
}

extension UpdateUserOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateUserOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UpdateUserOutput()
        }
    }
}

public struct UpdateUserOutput: Swift.Equatable {

    public init() { }
}

enum UpdateUserOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EntityTemporarilyUnmodifiable": return try await EntityTemporarilyUnmodifiableException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UploadSSHPublicKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKeyBody = "SSHPublicKeyBody"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sshPublicKeyBody = sshPublicKeyBody {
            try container.encode(sshPublicKeyBody, forKey: ClientRuntime.Key("SSHPublicKeyBody"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UploadSSHPublicKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UploadSSHPublicKeyInput {

    static func urlPathProvider(_ value: UploadSSHPublicKeyInput) -> Swift.String? {
        return "/"
    }
}

public struct UploadSSHPublicKeyInput: Swift.Equatable {
    /// The SSH public key. The public key must be encoded in ssh-rsa format or PEM format. The minimum bit-length of the public key is 2048 bits. For example, you can generate a 2048-bit key, and the resulting PEM file is 1679 bytes long. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var sshPublicKeyBody: Swift.String?
    /// The name of the IAM user to associate the SSH public key with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init(
        sshPublicKeyBody: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.sshPublicKeyBody = sshPublicKeyBody
        self.userName = userName
    }
}

extension UploadSSHPublicKeyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UploadSSHPublicKeyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["UploadSSHPublicKeyResult"]
            var value = UploadSSHPublicKeyOutput()
            value.sshPublicKey = try reader["SSHPublicKey"].readIfPresent(readingClosure: IAMClientTypes.SSHPublicKey.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [UploadSSHPublicKey] request.
public struct UploadSSHPublicKeyOutput: Swift.Equatable {
    /// Contains information about the SSH public key.
    public var sshPublicKey: IAMClientTypes.SSHPublicKey?

    public init(
        sshPublicKey: IAMClientTypes.SSHPublicKey? = nil
    )
    {
        self.sshPublicKey = sshPublicKey
    }
}

enum UploadSSHPublicKeyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "DuplicateSSHPublicKey": return try await DuplicateSSHPublicKeyException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidPublicKey": return try await InvalidPublicKeyException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnrecognizedPublicKeyEncoding": return try await UnrecognizedPublicKeyEncodingException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UploadServerCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadServerCertificateInput(certificateBody: \(Swift.String(describing: certificateBody)), certificateChain: \(Swift.String(describing: certificateChain)), path: \(Swift.String(describing: path)), serverCertificateName: \(Swift.String(describing: serverCertificateName)), tags: \(Swift.String(describing: tags)), privateKey: \"CONTENT_REDACTED\")"}
}

extension UploadServerCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBody = "CertificateBody"
        case certificateChain = "CertificateChain"
        case path = "Path"
        case privateKey = "PrivateKey"
        case serverCertificateName = "ServerCertificateName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: ClientRuntime.Key("CertificateBody"))
        }
        if let certificateChain = certificateChain {
            try container.encode(certificateChain, forKey: ClientRuntime.Key("CertificateChain"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let privateKey = privateKey {
            try container.encode(privateKey, forKey: ClientRuntime.Key("PrivateKey"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UploadServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UploadServerCertificateInput {

    static func urlPathProvider(_ value: UploadServerCertificateInput) -> Swift.String? {
        return "/"
    }
}

public struct UploadServerCertificateInput: Swift.Equatable {
    /// The contents of the public key certificate in PEM-encoded format. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var certificateBody: Swift.String?
    /// The contents of the certificate chain. This is typically a concatenation of the PEM-encoded public key certificates of the chain. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var certificateChain: Swift.String?
    /// The path for the server certificate. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters. If you are uploading a server certificate specifically for use with Amazon CloudFront distributions, you must specify a path using the path parameter. The path must begin with /cloudfront and must include a trailing slash (for example, /cloudfront/test/).
    public var path: Swift.String?
    /// The contents of the private key in PEM-encoded format. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var privateKey: Swift.String?
    /// The name for the server certificate. Do not include the path in this value. The name of the certificate cannot contain any spaces. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?
    /// A list of tags that you want to attach to the new IAM server certificate resource. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        certificateBody: Swift.String? = nil,
        certificateChain: Swift.String? = nil,
        path: Swift.String? = nil,
        privateKey: Swift.String? = nil,
        serverCertificateName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.certificateBody = certificateBody
        self.certificateChain = certificateChain
        self.path = path
        self.privateKey = privateKey
        self.serverCertificateName = serverCertificateName
        self.tags = tags
    }
}

extension UploadServerCertificateOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UploadServerCertificateOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["UploadServerCertificateResult"]
            var value = UploadServerCertificateOutput()
            value.serverCertificateMetadata = try reader["ServerCertificateMetadata"].readIfPresent(readingClosure: IAMClientTypes.ServerCertificateMetadata.readingClosure)
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the response to a successful [UploadServerCertificate] request.
public struct UploadServerCertificateOutput: Swift.Equatable {
    /// The meta information of the uploaded server certificate without its certificate body, certificate chain, and private key.
    public var serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata?
    /// A list of tags that are attached to the new IAM server certificate. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?

    public init(
        serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.serverCertificateMetadata = serverCertificateMetadata
        self.tags = tags
    }
}

enum UploadServerCertificateOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInput": return try await InvalidInputException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "KeyPairMismatch": return try await KeyPairMismatchException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "MalformedCertificate": return try await MalformedCertificateException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UploadSigningCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBody = "CertificateBody"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: ClientRuntime.Key("CertificateBody"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UploadSigningCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UploadSigningCertificateInput {

    static func urlPathProvider(_ value: UploadSigningCertificateInput) -> Swift.String? {
        return "/"
    }
}

public struct UploadSigningCertificateInput: Swift.Equatable {
    /// The contents of the signing certificate. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var certificateBody: Swift.String?
    /// The name of the user the signing certificate is for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init(
        certificateBody: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.certificateBody = certificateBody
        self.userName = userName
    }
}

extension UploadSigningCertificateOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UploadSigningCertificateOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["UploadSigningCertificateResult"]
            var value = UploadSigningCertificateOutput()
            value.certificate = try reader["Certificate"].readIfPresent(readingClosure: IAMClientTypes.SigningCertificate.readingClosure)
            return value
        }
    }
}

/// Contains the response to a successful [UploadSigningCertificate] request.
public struct UploadSigningCertificateOutput: Swift.Equatable {
    /// Information about the certificate.
    /// This member is required.
    public var certificate: IAMClientTypes.SigningCertificate?

    public init(
        certificate: IAMClientTypes.SigningCertificate? = nil
    )
    {
        self.certificate = certificate
    }
}

enum UploadSigningCertificateOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "ConcurrentModification": return try await ConcurrentModificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DuplicateCertificate": return try await DuplicateCertificateException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EntityAlreadyExists": return try await EntityAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidCertificate": return try await InvalidCertificateException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "MalformedCertificate": return try await MalformedCertificateException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NoSuchEntity": return try await NoSuchEntityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ServiceFailure": return try await ServiceFailureException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension IAMClientTypes.User: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case passwordLastUsed = "PasswordLastUsed"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case tags = "Tags"
        case userId = "UserId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let passwordLastUsed = passwordLastUsed {
            try container.encodeTimestamp(passwordLastUsed, format: .dateTime, forKey: ClientRuntime.Key("PasswordLastUsed"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userId = userId {
            try container.encode(userId, forKey: ClientRuntime.Key("UserId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.User, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.User()
            value.path = try reader["Path"].readIfPresent()
            value.userName = try reader["UserName"].readIfPresent()
            value.userId = try reader["UserId"].readIfPresent()
            value.arn = try reader["Arn"].readIfPresent()
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            value.passwordLastUsed = try reader["PasswordLastUsed"].readTimestampIfPresent(format: .dateTime)
            value.permissionsBoundary = try reader["PermissionsBoundary"].readIfPresent(readingClosure: IAMClientTypes.AttachedPermissionsBoundary.readingClosure)
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM user entity. This data type is used as a response element in the following operations:
    ///
    /// * [CreateUser]
    ///
    /// * [GetUser]
    ///
    /// * [ListUsers]
    public struct User: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the user was created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the user's password was last used to sign in to an Amazon Web Services website. For a list of Amazon Web Services websites that capture a user's last sign-in time, see the [Credential reports](https://docs.aws.amazon.com/IAM/latest/UserGuide/credential-reports.html) topic in the IAM User Guide. If a password is used more than once in a five-minute span, only the first use is returned in this field. If the field is null (no value), then it indicates that they never signed in with a password. This can be because:
        ///
        /// * The user never had a password.
        ///
        /// * A password exists but has not been used since IAM started tracking this information on October 20, 2014.
        ///
        ///
        /// A null value does not mean that the user never had a password. Also, if the user does not currently have a password but had one in the past, then this field contains the date and time the most recent password was used. This value is returned only in the [GetUser] and [ListUsers] operations.
        public var passwordLastUsed: ClientRuntime.Date?
        /// The path to the user. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. The ARN of the policy used to set the permissions boundary for the user.
        /// This member is required.
        public var path: Swift.String?
        /// For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// A list of tags that are associated with the user. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The stable and unique string identifying the user. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var userId: Swift.String?
        /// The friendly name identifying the user.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            passwordLastUsed: ClientRuntime.Date? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            userId: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.passwordLastUsed = passwordLastUsed
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.tags = tags
            self.userId = userId
            self.userName = userName
        }
    }

}

extension IAMClientTypes.UserDetail: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case groupList = "GroupList"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case tags = "Tags"
        case userId = "UserId"
        case userName = "UserName"
        case userPolicyList = "UserPolicyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let attachedManagedPolicies = attachedManagedPolicies {
            if !attachedManagedPolicies.isEmpty {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                for (index0, attachedpolicy0) in attachedManagedPolicies.enumerated() {
                    try attachedManagedPoliciesContainer.encode(attachedpolicy0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                try attachedManagedPoliciesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("CreateDate"))
        }
        if let groupList = groupList {
            if !groupList.isEmpty {
                var groupListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupList"))
                for (index0, groupnametype0) in groupList.enumerated() {
                    try groupListContainer.encode(groupnametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var groupListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupList"))
                try groupListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userId = userId {
            try container.encode(userId, forKey: ClientRuntime.Key("UserId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        if let userPolicyList = userPolicyList {
            if !userPolicyList.isEmpty {
                var userPolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("UserPolicyList"))
                for (index0, policydetail0) in userPolicyList.enumerated() {
                    try userPolicyListContainer.encode(policydetail0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var userPolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("UserPolicyList"))
                try userPolicyListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.UserDetail, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.UserDetail()
            value.path = try reader["Path"].readIfPresent()
            value.userName = try reader["UserName"].readIfPresent()
            value.userId = try reader["UserId"].readIfPresent()
            value.arn = try reader["Arn"].readIfPresent()
            value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: .dateTime)
            value.userPolicyList = try reader["UserPolicyList"].readListIfPresent(memberReadingClosure: IAMClientTypes.PolicyDetail.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.groupList = try reader["GroupList"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.attachedManagedPolicies = try reader["AttachedManagedPolicies"].readListIfPresent(memberReadingClosure: IAMClientTypes.AttachedPolicy.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.permissionsBoundary = try reader["PermissionsBoundary"].readIfPresent(readingClosure: IAMClientTypes.AttachedPermissionsBoundary.readingClosure)
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM user, including all the user's policies and all the IAM groups the user is in. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct UserDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// A list of the managed policies attached to the user.
        public var attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the user was created.
        public var createDate: ClientRuntime.Date?
        /// A list of IAM groups that the user is in.
        public var groupList: [Swift.String]?
        /// The path to the user. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The ARN of the policy used to set the permissions boundary for the user. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// A list of tags that are associated with the user. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The stable and unique string identifying the user. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var userId: Swift.String?
        /// The friendly name identifying the user.
        public var userName: Swift.String?
        /// A list of the inline policies embedded in the user.
        public var userPolicyList: [IAMClientTypes.PolicyDetail]?

        public init(
            arn: Swift.String? = nil,
            attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
            createDate: ClientRuntime.Date? = nil,
            groupList: [Swift.String]? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            userId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userPolicyList: [IAMClientTypes.PolicyDetail]? = nil
        )
        {
            self.arn = arn
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupList = groupList
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.tags = tags
            self.userId = userId
            self.userName = userName
            self.userPolicyList = userPolicyList
        }
    }

}

extension IAMClientTypes.VirtualMFADevice: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base32StringSeed = "Base32StringSeed"
        case enableDate = "EnableDate"
        case qrCodePNG = "QRCodePNG"
        case serialNumber = "SerialNumber"
        case tags = "Tags"
        case user = "User"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let base32StringSeed = base32StringSeed {
            try container.encode(base32StringSeed.base64EncodedString(), forKey: ClientRuntime.Key("Base32StringSeed"))
        }
        if let enableDate = enableDate {
            try container.encodeTimestamp(enableDate, format: .dateTime, forKey: ClientRuntime.Key("EnableDate"))
        }
        if let qrCodePNG = qrCodePNG {
            try container.encode(qrCodePNG.base64EncodedString(), forKey: ClientRuntime.Key("QRCodePNG"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let user = user {
            try container.encode(user, forKey: ClientRuntime.Key("User"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<IAMClientTypes.VirtualMFADevice, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IAMClientTypes.VirtualMFADevice()
            value.serialNumber = try reader["SerialNumber"].readIfPresent()
            value.base32StringSeed = try reader["Base32StringSeed"].readIfPresent()
            value.qrCodePNG = try reader["QRCodePNG"].readIfPresent()
            value.user = try reader["User"].readIfPresent(readingClosure: IAMClientTypes.User.readingClosure)
            value.enableDate = try reader["EnableDate"].readTimestampIfPresent(format: .dateTime)
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IAMClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension IAMClientTypes.VirtualMFADevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VirtualMFADevice(enableDate: \(Swift.String(describing: enableDate)), serialNumber: \(Swift.String(describing: serialNumber)), tags: \(Swift.String(describing: tags)), user: \(Swift.String(describing: user)), base32StringSeed: \"CONTENT_REDACTED\", qrCodePNG: \"CONTENT_REDACTED\")"}
}

extension IAMClientTypes {
    /// Contains information about a virtual MFA device.
    public struct VirtualMFADevice: Swift.Equatable {
        /// The base32 seed defined as specified in [RFC3548](https://tools.ietf.org/html/rfc3548.txt). The Base32StringSeed is base32-encoded.
        public var base32StringSeed: ClientRuntime.Data?
        /// The date and time on which the virtual MFA device was enabled.
        public var enableDate: ClientRuntime.Date?
        /// A QR code PNG image that encodes otpauth://totp/$virtualMFADeviceName@$AccountName?secret=$Base32String where $virtualMFADeviceName is one of the create call arguments. AccountName is the user name if set (otherwise, the account ID otherwise), and Base32String is the seed in base32 format. The Base32String value is base64-encoded.
        public var qrCodePNG: ClientRuntime.Data?
        /// The serial number associated with VirtualMFADevice.
        /// This member is required.
        public var serialNumber: Swift.String?
        /// A list of tags that are attached to the virtual MFA device. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The IAM user associated with this virtual MFA device.
        public var user: IAMClientTypes.User?

        public init(
            base32StringSeed: ClientRuntime.Data? = nil,
            enableDate: ClientRuntime.Date? = nil,
            qrCodePNG: ClientRuntime.Data? = nil,
            serialNumber: Swift.String? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            user: IAMClientTypes.User? = nil
        )
        {
            self.base32StringSeed = base32StringSeed
            self.enableDate = enableDate
            self.qrCodePNG = qrCodePNG
            self.serialNumber = serialNumber
            self.tags = tags
            self.user = user
        }
    }

}
