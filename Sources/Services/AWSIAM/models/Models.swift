// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IAMClientTypes {
    public enum AccessAdvisorUsageGranularityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actionLevel
        case serviceLevel
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessAdvisorUsageGranularityType] {
            return [
                .actionLevel,
                .serviceLevel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actionLevel: return "ACTION_LEVEL"
            case .serviceLevel: return "SERVICE_LEVEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessAdvisorUsageGranularityType(rawValue: rawValue) ?? AccessAdvisorUsageGranularityType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.AccessDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityPath = "EntityPath"
        case lastAuthenticatedTime = "LastAuthenticatedTime"
        case region = "Region"
        case serviceName = "ServiceName"
        case serviceNamespace = "ServiceNamespace"
        case totalAuthenticatedEntities = "TotalAuthenticatedEntities"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let entityPath = entityPath {
            try container.encode(entityPath, forKey: ClientRuntime.Key("EntityPath"))
        }
        if let lastAuthenticatedTime = lastAuthenticatedTime {
            try container.encodeTimestamp(lastAuthenticatedTime, format: .dateTime, forKey: ClientRuntime.Key("lastAuthenticatedTime"))
        }
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: ClientRuntime.Key("ServiceNamespace"))
        }
        if let totalAuthenticatedEntities = totalAuthenticatedEntities {
            try container.encode(totalAuthenticatedEntities, forKey: ClientRuntime.Key("TotalAuthenticatedEntities"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNamespace)
        serviceNamespace = serviceNamespaceDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let entityPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityPath)
        entityPath = entityPathDecoded
        let lastAuthenticatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastAuthenticatedTime)
        lastAuthenticatedTime = lastAuthenticatedTimeDecoded
        let totalAuthenticatedEntitiesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalAuthenticatedEntities)
        totalAuthenticatedEntities = totalAuthenticatedEntitiesDecoded
    }
}

extension IAMClientTypes {
    /// An object that contains details about when a principal in the reported Organizations entity last attempted to access an Amazon Web Services service. A principal can be an IAM user, an IAM role, or the Amazon Web Services account root user within the reported Organizations entity. This data type is a response element in the [GetOrganizationsAccessReport] operation.
    public struct AccessDetail: Swift.Equatable {
        /// The path of the Organizations entity (root, organizational unit, or account) from which an authenticated principal last attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no principals (IAM users, IAM roles, or root users) in the reported Organizations entity attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var entityPath: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when an authenticated principal most recently attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no principals in the reported Organizations entity attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticatedTime: ClientRuntime.Date?
        /// The Region where the last service access attempt occurred. This field is null if no principals in the reported Organizations entity attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var region: Swift.String?
        /// The name of the service in which access was attempted.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The namespace of the service in which access was attempted. To learn the service namespace of a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the Service Authorization Reference. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
        /// This member is required.
        public var serviceNamespace: Swift.String?
        /// The number of accounts with authenticated principals (root users, IAM users, and IAM roles) that attempted to access the service in the tracking period.
        public var totalAuthenticatedEntities: Swift.Int?

        public init (
            entityPath: Swift.String? = nil,
            lastAuthenticatedTime: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceNamespace: Swift.String? = nil,
            totalAuthenticatedEntities: Swift.Int? = nil
        )
        {
            self.entityPath = entityPath
            self.lastAuthenticatedTime = lastAuthenticatedTime
            self.region = region
            self.serviceName = serviceName
            self.serviceNamespace = serviceNamespace
            self.totalAuthenticatedEntities = totalAuthenticatedEntities
        }
    }

}

extension IAMClientTypes.AccessKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case createDate = "CreateDate"
        case secretAccessKey = "SecretAccessKey"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if let secretAccessKey = secretAccessKey {
            try container.encode(secretAccessKey, forKey: ClientRuntime.Key("SecretAccessKey"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension IAMClientTypes.AccessKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessKey(accessKeyId: \(Swift.String(describing: accessKeyId)), createDate: \(Swift.String(describing: createDate)), status: \(Swift.String(describing: status)), userName: \(Swift.String(describing: userName)), secretAccessKey: \"CONTENT_REDACTED\")"}
}

extension IAMClientTypes {
    /// Contains information about an Amazon Web Services access key. This data type is used as a response element in the [CreateAccessKey] and [ListAccessKeys] operations. The SecretAccessKey value is returned only in response to [CreateAccessKey]. You can get a secret access key only when you first create an access key; you cannot recover the secret access key later. If you lose a secret access key, you must create a new access key.
    public struct AccessKey: Swift.Equatable {
        /// The ID for this access key.
        /// This member is required.
        public var accessKeyId: Swift.String?
        /// The date when the access key was created.
        public var createDate: ClientRuntime.Date?
        /// The secret key used to sign requests.
        /// This member is required.
        public var secretAccessKey: Swift.String?
        /// The status of the access key. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user that the access key is associated with.
        /// This member is required.
        public var userName: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            secretAccessKey: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.createDate = createDate
            self.secretAccessKey = secretAccessKey
            self.status = status
            self.userName = userName
        }
    }

}

extension IAMClientTypes.AccessKeyLastUsed: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUsedDate = "LastUsedDate"
        case region = "Region"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let lastUsedDate = lastUsedDate {
            try container.encodeTimestamp(lastUsedDate, format: .dateTime, forKey: ClientRuntime.Key("lastUsedDate"))
        }
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUsedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUsedDate)
        lastUsedDate = lastUsedDateDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about the last time an Amazon Web Services access key was used since IAM began tracking this information on April 22, 2015. This data type is used as a response element in the [GetAccessKeyLastUsed] operation.
    public struct AccessKeyLastUsed: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the access key was most recently used. This field is null in the following situations:
        ///
        /// * The user does not have an access key.
        ///
        /// * An access key exists but has not been used since IAM began tracking this information.
        ///
        /// * There is no sign-in data associated with the user.
        /// This member is required.
        public var lastUsedDate: ClientRuntime.Date?
        /// The Amazon Web Services Region where this access key was most recently used. The value for this field is "N/A" in the following situations:
        ///
        /// * The user does not have an access key.
        ///
        /// * An access key exists but has not been used since IAM began tracking this information.
        ///
        /// * There is no sign-in data associated with the user.
        ///
        ///
        /// For more information about Amazon Web Services Regions, see [Regions and endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html) in the Amazon Web Services General Reference.
        /// This member is required.
        public var region: Swift.String?
        /// The name of the Amazon Web Services service with which this access key was most recently used. The value of this field is "N/A" in the following situations:
        ///
        /// * The user does not have an access key.
        ///
        /// * An access key exists but has not been used since IAM started tracking this information.
        ///
        /// * There is no sign-in data associated with the user.
        /// This member is required.
        public var serviceName: Swift.String?

        public init (
            lastUsedDate: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.lastUsedDate = lastUsedDate
            self.region = region
            self.serviceName = serviceName
        }
    }

}

extension IAMClientTypes.AccessKeyMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case createDate = "CreateDate"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an Amazon Web Services access key, without its secret key. This data type is used as a response element in the [ListAccessKeys] operation.
    public struct AccessKeyMetadata: Swift.Equatable {
        /// The ID for this access key.
        public var accessKeyId: Swift.String?
        /// The date when the access key was created.
        public var createDate: ClientRuntime.Date?
        /// The status of the access key. Active means that the key is valid for API calls; Inactive means it is not.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user that the key is associated with.
        public var userName: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.createDate = createDate
            self.status = status
            self.userName = userName
        }
    }

}

extension AddClientIDToOpenIDConnectProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clientID = clientID {
            try container.encode(clientID, forKey: ClientRuntime.Key("ClientID"))
        }
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        try container.encode("AddClientIDToOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddClientIDToOpenIDConnectProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddClientIDToOpenIDConnectProviderInput: Swift.Equatable {
    /// The client ID (also known as audience) to add to the IAM OpenID Connect provider resource.
    /// This member is required.
    public var clientID: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM OpenID Connect (OIDC) provider resource to add the client ID to. You can get a list of OIDC provider ARNs by using the [ListOpenIDConnectProviders] operation.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init (
        clientID: Swift.String? = nil,
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.clientID = clientID
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

struct AddClientIDToOpenIDConnectProviderInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
    let clientID: Swift.String?
}

extension AddClientIDToOpenIDConnectProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientID = "ClientID"
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
        let clientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientID)
        clientID = clientIDDecoded
    }
}

extension AddClientIDToOpenIDConnectProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddClientIDToOpenIDConnectProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddClientIDToOpenIDConnectProviderOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddClientIDToOpenIDConnectProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddClientIDToOpenIDConnectProviderOutputResponse: Swift.Equatable {

    public init () { }
}

extension AddRoleToInstanceProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("AddRoleToInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddRoleToInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddRoleToInstanceProfileInput: Swift.Equatable {
    /// The name of the instance profile to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The name of the role to add. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        instanceProfileName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.roleName = roleName
    }
}

struct AddRoleToInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
    let roleName: Swift.String?
}

extension AddRoleToInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension AddRoleToInstanceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddRoleToInstanceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntity" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddRoleToInstanceProfileOutputError: Swift.Error, Swift.Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddRoleToInstanceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddRoleToInstanceProfileOutputResponse: Swift.Equatable {

    public init () { }
}

extension AddUserToGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("AddUserToGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddUserToGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddUserToGroupInput: Swift.Equatable {
    /// The name of the group to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the user to add. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        groupName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.userName = userName
    }
}

struct AddUserToGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let userName: Swift.String?
}

extension AddUserToGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension AddUserToGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddUserToGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddUserToGroupOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddUserToGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddUserToGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension IAMClientTypes {
    public enum AssignmentStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case any
        case assigned
        case unassigned
        case sdkUnknown(Swift.String)

        public static var allCases: [AssignmentStatusType] {
            return [
                .any,
                .assigned,
                .unassigned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .any: return "Any"
            case .assigned: return "Assigned"
            case .unassigned: return "Unassigned"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssignmentStatusType(rawValue: rawValue) ?? AssignmentStatusType.sdkUnknown(rawValue)
        }
    }
}

extension AttachGroupPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("AttachGroupPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AttachGroupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AttachGroupPolicyInput: Swift.Equatable {
    /// The name (friendly name, not ARN) of the group to attach the policy to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init (
        groupName: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyArn = policyArn
    }
}

struct AttachGroupPolicyInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let policyArn: Swift.String?
}

extension AttachGroupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension AttachGroupPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AttachGroupPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotAttachable" : self = .policyNotAttachableException(try PolicyNotAttachableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AttachGroupPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case policyNotAttachableException(PolicyNotAttachableException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachGroupPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AttachGroupPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension AttachRolePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("AttachRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AttachRolePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AttachRolePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the role to attach the policy to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        policyArn: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.roleName = roleName
    }
}

struct AttachRolePolicyInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let policyArn: Swift.String?
}

extension AttachRolePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension AttachRolePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AttachRolePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotAttachable" : self = .policyNotAttachableException(try PolicyNotAttachableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntity" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AttachRolePolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case policyNotAttachableException(PolicyNotAttachableException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachRolePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AttachRolePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension AttachUserPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("AttachUserPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension AttachUserPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AttachUserPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the IAM user to attach the policy to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        policyArn: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.userName = userName
    }
}

struct AttachUserPolicyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let policyArn: Swift.String?
}

extension AttachUserPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension AttachUserPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AttachUserPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotAttachable" : self = .policyNotAttachableException(try PolicyNotAttachableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AttachUserPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case policyNotAttachableException(PolicyNotAttachableException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachUserPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AttachUserPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension IAMClientTypes.AttachedPermissionsBoundary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionsBoundaryArn = "PermissionsBoundaryArn"
        case permissionsBoundaryType = "PermissionsBoundaryType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let permissionsBoundaryArn = permissionsBoundaryArn {
            try container.encode(permissionsBoundaryArn, forKey: ClientRuntime.Key("PermissionsBoundaryArn"))
        }
        if let permissionsBoundaryType = permissionsBoundaryType {
            try container.encode(permissionsBoundaryType, forKey: ClientRuntime.Key("PermissionsBoundaryType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsBoundaryTypeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PermissionsBoundaryAttachmentType.self, forKey: .permissionsBoundaryType)
        permissionsBoundaryType = permissionsBoundaryTypeDecoded
        let permissionsBoundaryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionsBoundaryArn)
        permissionsBoundaryArn = permissionsBoundaryArnDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an attached permissions boundary. An attached permissions boundary is a managed policy that has been attached to a user or role to set the permissions boundary. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
    public struct AttachedPermissionsBoundary: Swift.Equatable {
        /// The ARN of the policy used to set the permissions boundary for the user or role.
        public var permissionsBoundaryArn: Swift.String?
        /// The permissions boundary usage type that indicates what type of IAM resource is used as the permissions boundary for an entity. This data type can only have a value of Policy.
        public var permissionsBoundaryType: IAMClientTypes.PermissionsBoundaryAttachmentType?

        public init (
            permissionsBoundaryArn: Swift.String? = nil,
            permissionsBoundaryType: IAMClientTypes.PermissionsBoundaryAttachmentType? = nil
        )
        {
            self.permissionsBoundaryArn = permissionsBoundaryArn
            self.permissionsBoundaryType = permissionsBoundaryType
        }
    }

}

extension IAMClientTypes.AttachedPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an attached policy. An attached policy is a managed policy that has been attached to a user, group, or role. This data type is used as a response element in the [ListAttachedGroupPolicies], [ListAttachedRolePolicies], [ListAttachedUserPolicies], and [GetAccountAuthorizationDetails] operations. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct AttachedPolicy: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var policyArn: Swift.String?
        /// The friendly name of the attached policy.
        public var policyName: Swift.String?

        public init (
            policyArn: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.policyArn = policyArn
            self.policyName = policyName
        }
    }

}

extension ChangePasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChangePasswordInput(newPassword: \"CONTENT_REDACTED\", oldPassword: \"CONTENT_REDACTED\")"}
}

extension ChangePasswordInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let newPassword = newPassword {
            try container.encode(newPassword, forKey: ClientRuntime.Key("NewPassword"))
        }
        if let oldPassword = oldPassword {
            try container.encode(oldPassword, forKey: ClientRuntime.Key("OldPassword"))
        }
        try container.encode("ChangePassword", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ChangePasswordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ChangePasswordInput: Swift.Equatable {
    /// The new password. The new password must conform to the Amazon Web Services account's password policy, if one exists. The [regex pattern](http://wikipedia.org/wiki/regex) that is used to validate this parameter is a string of characters. That string can include almost any printable ASCII character from the space (\u0020) through the end of the ASCII character range (\u00FF). You can also include the tab (\u0009), line feed (\u000A), and carriage return (\u000D) characters. Any of these characters are valid in a password. However, many tools, such as the Amazon Web Services Management Console, might restrict the ability to type certain characters because they have special meaning within that tool.
    /// This member is required.
    public var newPassword: Swift.String?
    /// The IAM user's current password.
    /// This member is required.
    public var oldPassword: Swift.String?

    public init (
        newPassword: Swift.String? = nil,
        oldPassword: Swift.String? = nil
    )
    {
        self.newPassword = newPassword
        self.oldPassword = oldPassword
    }
}

struct ChangePasswordInputBody: Swift.Equatable {
    let oldPassword: Swift.String?
    let newPassword: Swift.String?
}

extension ChangePasswordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newPassword = "NewPassword"
        case oldPassword = "OldPassword"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oldPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oldPassword)
        oldPassword = oldPasswordDecoded
        let newPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newPassword)
        newPassword = newPasswordDecoded
    }
}

extension ChangePasswordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ChangePasswordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityTemporarilyUnmodifiable" : self = .entityTemporarilyUnmodifiableException(try EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserType" : self = .invalidUserTypeException(try InvalidUserTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordPolicyViolation" : self = .passwordPolicyViolationException(try PasswordPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ChangePasswordOutputError: Swift.Error, Swift.Equatable {
    case entityTemporarilyUnmodifiableException(EntityTemporarilyUnmodifiableException)
    case invalidUserTypeException(InvalidUserTypeException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case passwordPolicyViolationException(PasswordPolicyViolationException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ChangePasswordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ChangePasswordOutputResponse: Swift.Equatable {

    public init () { }
}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ConcurrentModificationExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because multiple requests to change this object were submitted simultaneously. Wait a few minutes and submit your request again.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes.ContextEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextKeyName = "ContextKeyName"
        case contextKeyType = "ContextKeyType"
        case contextKeyValues = "ContextKeyValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let contextKeyName = contextKeyName {
            try container.encode(contextKeyName, forKey: ClientRuntime.Key("ContextKeyName"))
        }
        if let contextKeyType = contextKeyType {
            try container.encode(contextKeyType, forKey: ClientRuntime.Key("ContextKeyType"))
        }
        if let contextKeyValues = contextKeyValues {
            if !contextKeyValues.isEmpty {
                var contextKeyValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextKeyValues"))
                for (index0, contextkeyvaluetype0) in contextKeyValues.enumerated() {
                    try contextKeyValuesContainer.encode(contextkeyvaluetype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var contextKeyValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextKeyValues"))
                try contextKeyValuesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contextKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contextKeyName)
        contextKeyName = contextKeyNameDecoded
        if containerValues.contains(.contextKeyValues) {
            struct KeyVal0{struct member{}}
            let contextKeyValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .contextKeyValues)
            if let contextKeyValuesWrappedContainer = contextKeyValuesWrappedContainer {
                let contextKeyValuesContainer = try contextKeyValuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var contextKeyValuesBuffer:[Swift.String]? = nil
                if let contextKeyValuesContainer = contextKeyValuesContainer {
                    contextKeyValuesBuffer = [Swift.String]()
                    for stringContainer0 in contextKeyValuesContainer {
                        contextKeyValuesBuffer?.append(stringContainer0)
                    }
                }
                contextKeyValues = contextKeyValuesBuffer
            } else {
                contextKeyValues = []
            }
        } else {
            contextKeyValues = nil
        }
        let contextKeyTypeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ContextKeyTypeEnum.self, forKey: .contextKeyType)
        contextKeyType = contextKeyTypeDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about a condition context key. It includes the name of the key and specifies the value (or values, if the context key supports multiple values) to use in the simulation. This information is used when evaluating the Condition elements of the input policies. This data type is used as an input parameter to [SimulateCustomPolicy] and [SimulatePrincipalPolicy].
    public struct ContextEntry: Swift.Equatable {
        /// The full name of a condition context key, including the service prefix. For example, aws:SourceIp or s3:VersionId.
        public var contextKeyName: Swift.String?
        /// The data type of the value (or values) specified in the ContextKeyValues parameter.
        public var contextKeyType: IAMClientTypes.ContextKeyTypeEnum?
        /// The value (or values, if the condition context key supports multiple values) to provide to the simulation when the key is referenced by a Condition element in an input policy.
        public var contextKeyValues: [Swift.String]?

        public init (
            contextKeyName: Swift.String? = nil,
            contextKeyType: IAMClientTypes.ContextKeyTypeEnum? = nil,
            contextKeyValues: [Swift.String]? = nil
        )
        {
            self.contextKeyName = contextKeyName
            self.contextKeyType = contextKeyType
            self.contextKeyValues = contextKeyValues
        }
    }

}

extension IAMClientTypes {
    public enum ContextKeyTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case binary
        case binaryList
        case boolean
        case booleanList
        case date
        case dateList
        case ip
        case ipList
        case numeric
        case numericList
        case string
        case stringList
        case sdkUnknown(Swift.String)

        public static var allCases: [ContextKeyTypeEnum] {
            return [
                .binary,
                .binaryList,
                .boolean,
                .booleanList,
                .date,
                .dateList,
                .ip,
                .ipList,
                .numeric,
                .numericList,
                .string,
                .stringList,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .binary: return "binary"
            case .binaryList: return "binaryList"
            case .boolean: return "boolean"
            case .booleanList: return "booleanList"
            case .date: return "date"
            case .dateList: return "dateList"
            case .ip: return "ip"
            case .ipList: return "ipList"
            case .numeric: return "numeric"
            case .numericList: return "numericList"
            case .string: return "string"
            case .stringList: return "stringList"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContextKeyTypeEnum(rawValue: rawValue) ?? ContextKeyTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension CreateAccessKeyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("CreateAccessKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateAccessKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAccessKeyInput: Swift.Equatable {
    /// The name of the IAM user that the new key will belong to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init (
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

struct CreateAccessKeyInputBody: Swift.Equatable {
    let userName: Swift.String?
}

extension CreateAccessKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension CreateAccessKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateAccessKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAccessKeyOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAccessKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessKey = output.accessKey
        } else {
            self.accessKey = nil
        }
    }
}

/// Contains the response to a successful [CreateAccessKey] request.
public struct CreateAccessKeyOutputResponse: Swift.Equatable {
    /// A structure with details about the access key.
    /// This member is required.
    public var accessKey: IAMClientTypes.AccessKey?

    public init (
        accessKey: IAMClientTypes.AccessKey? = nil
    )
    {
        self.accessKey = accessKey
    }
}

struct CreateAccessKeyOutputResponseBody: Swift.Equatable {
    let accessKey: IAMClientTypes.AccessKey?
}

extension CreateAccessKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKey = "AccessKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateAccessKeyResult"))
        let accessKeyDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AccessKey.self, forKey: .accessKey)
        accessKey = accessKeyDecoded
    }
}

extension CreateAccountAliasInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountAlias = accountAlias {
            try container.encode(accountAlias, forKey: ClientRuntime.Key("AccountAlias"))
        }
        try container.encode("CreateAccountAlias", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateAccountAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAccountAliasInput: Swift.Equatable {
    /// The account alias to create. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have two dashes in a row.
    /// This member is required.
    public var accountAlias: Swift.String?

    public init (
        accountAlias: Swift.String? = nil
    )
    {
        self.accountAlias = accountAlias
    }
}

struct CreateAccountAliasInputBody: Swift.Equatable {
    let accountAlias: Swift.String?
}

extension CreateAccountAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAlias = "AccountAlias"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountAlias)
        accountAlias = accountAliasDecoded
    }
}

extension CreateAccountAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateAccountAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAccountAliasOutputError: Swift.Error, Swift.Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccountAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateAccountAliasOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        try container.encode("CreateGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateGroupInput: Swift.Equatable {
    /// The name of the group to create. Do not include the path in this value. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    /// This member is required.
    public var groupName: Swift.String?
    /// The path to the group. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?

    public init (
        groupName: Swift.String? = nil,
        path: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.path = path
    }
}

struct CreateGroupInputBody: Swift.Equatable {
    let path: Swift.String?
    let groupName: Swift.String?
}

extension CreateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case path = "Path"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension CreateGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGroupOutputError: Swift.Error, Swift.Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.group = output.group
        } else {
            self.group = nil
        }
    }
}

/// Contains the response to a successful [CreateGroup] request.
public struct CreateGroupOutputResponse: Swift.Equatable {
    /// A structure containing details about the new group.
    /// This member is required.
    public var group: IAMClientTypes.Group?

    public init (
        group: IAMClientTypes.Group? = nil
    )
    {
        self.group = group
    }
}

struct CreateGroupOutputResponseBody: Swift.Equatable {
    let group: IAMClientTypes.Group?
}

extension CreateGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateGroupResult"))
        let groupDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Group.self, forKey: .group)
        group = groupDecoded
    }
}

extension CreateInstanceProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("CreateInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateInstanceProfileInput: Swift.Equatable {
    /// The name of the instance profile to create. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The path to the instance profile. For more information about paths, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// A list of tags that you want to attach to the newly created IAM instance profile. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        instanceProfileName: Swift.String? = nil,
        path: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.path = path
        self.tags = tags
    }
}

struct CreateInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
    let path: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case path = "Path"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateInstanceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateInstanceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateInstanceProfileOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInstanceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateInstanceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

/// Contains the response to a successful [CreateInstanceProfile] request.
public struct CreateInstanceProfileOutputResponse: Swift.Equatable {
    /// A structure containing details about the new instance profile.
    /// This member is required.
    public var instanceProfile: IAMClientTypes.InstanceProfile?

    public init (
        instanceProfile: IAMClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct CreateInstanceProfileOutputResponseBody: Swift.Equatable {
    let instanceProfile: IAMClientTypes.InstanceProfile?
}

extension CreateInstanceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfile = "InstanceProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateInstanceProfileResult"))
        let instanceProfileDecoded = try containerValues.decodeIfPresent(IAMClientTypes.InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

extension CreateLoginProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLoginProfileInput(passwordResetRequired: \(Swift.String(describing: passwordResetRequired)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

extension CreateLoginProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let password = password {
            try container.encode(password, forKey: ClientRuntime.Key("Password"))
        }
        if let passwordResetRequired = passwordResetRequired {
            try container.encode(passwordResetRequired, forKey: ClientRuntime.Key("PasswordResetRequired"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("CreateLoginProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateLoginProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateLoginProfileInput: Swift.Equatable {
    /// The new password for the user. The [regex pattern](http://wikipedia.org/wiki/regex) that is used to validate this parameter is a string of characters. That string can include almost any printable ASCII character from the space (\u0020) through the end of the ASCII character range (\u00FF). You can also include the tab (\u0009), line feed (\u000A), and carriage return (\u000D) characters. Any of these characters are valid in a password. However, many tools, such as the Amazon Web Services Management Console, might restrict the ability to type certain characters because they have special meaning within that tool.
    /// This member is required.
    public var password: Swift.String?
    /// Specifies whether the user is required to set a new password on next sign-in.
    public var passwordResetRequired: Swift.Bool?
    /// The name of the IAM user to create a password for. The user must already exist. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        password: Swift.String? = nil,
        passwordResetRequired: Swift.Bool? = nil,
        userName: Swift.String? = nil
    )
    {
        self.password = password
        self.passwordResetRequired = passwordResetRequired
        self.userName = userName
    }
}

struct CreateLoginProfileInputBody: Swift.Equatable {
    let userName: Swift.String?
    let password: Swift.String?
    let passwordResetRequired: Swift.Bool?
}

extension CreateLoginProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case passwordResetRequired = "PasswordResetRequired"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let passwordResetRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .passwordResetRequired)
        passwordResetRequired = passwordResetRequiredDecoded
    }
}

extension CreateLoginProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateLoginProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordPolicyViolation" : self = .passwordPolicyViolationException(try PasswordPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLoginProfileOutputError: Swift.Error, Swift.Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case passwordPolicyViolationException(PasswordPolicyViolationException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLoginProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateLoginProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loginProfile = output.loginProfile
        } else {
            self.loginProfile = nil
        }
    }
}

/// Contains the response to a successful [CreateLoginProfile] request.
public struct CreateLoginProfileOutputResponse: Swift.Equatable {
    /// A structure containing the user name and password create date.
    /// This member is required.
    public var loginProfile: IAMClientTypes.LoginProfile?

    public init (
        loginProfile: IAMClientTypes.LoginProfile? = nil
    )
    {
        self.loginProfile = loginProfile
    }
}

struct CreateLoginProfileOutputResponseBody: Swift.Equatable {
    let loginProfile: IAMClientTypes.LoginProfile?
}

extension CreateLoginProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loginProfile = "LoginProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateLoginProfileResult"))
        let loginProfileDecoded = try containerValues.decodeIfPresent(IAMClientTypes.LoginProfile.self, forKey: .loginProfile)
        loginProfile = loginProfileDecoded
    }
}

extension CreateOpenIDConnectProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clientIDList = clientIDList {
            if !clientIDList.isEmpty {
                var clientIDListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClientIDList"))
                for (index0, clientidtype0) in clientIDList.enumerated() {
                    try clientIDListContainer.encode(clientidtype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var clientIDListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClientIDList"))
                try clientIDListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let thumbprintList = thumbprintList {
            if !thumbprintList.isEmpty {
                var thumbprintListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ThumbprintList"))
                for (index0, thumbprinttype0) in thumbprintList.enumerated() {
                    try thumbprintListContainer.encode(thumbprinttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var thumbprintListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ThumbprintList"))
                try thumbprintListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let url = url {
            try container.encode(url, forKey: ClientRuntime.Key("Url"))
        }
        try container.encode("CreateOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateOpenIDConnectProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateOpenIDConnectProviderInput: Swift.Equatable {
    /// Provides a list of client IDs, also known as audiences. When a mobile or web app registers with an OpenID Connect provider, they establish a value that identifies the application. This is the value that's sent as the client_id parameter on OAuth requests. You can register multiple client IDs with the same provider. For example, you might have multiple applications that use the same OIDC provider. You cannot register more than 100 client IDs with a single IAM OIDC provider. There is no defined format for a client ID. The CreateOpenIDConnectProviderRequest operation accepts client IDs up to 255 characters long.
    public var clientIDList: [Swift.String]?
    /// A list of tags that you want to attach to the new IAM OpenID Connect (OIDC) provider. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?
    /// A list of server certificate thumbprints for the OpenID Connect (OIDC) identity provider's server certificates. Typically this list includes only one entry. However, IAM lets you have up to five thumbprints for an OIDC provider. This lets you maintain multiple thumbprints if the identity provider is rotating certificates. The server certificate thumbprint is the hex-encoded SHA-1 hash value of the X.509 certificate used by the domain where the OpenID Connect provider makes its keys available. It is always a 40-character string. You must provide at least one thumbprint when creating an IAM OIDC provider. For example, assume that the OIDC provider is server.example.com and the provider stores its keys at https://keys.server.example.com/openid-connect. In that case, the thumbprint string would be the hex-encoded SHA-1 hash value of the certificate used by https://keys.server.example.com. For more information about obtaining the OIDC provider thumbprint, see [Obtaining the thumbprint for an OpenID Connect provider](https://docs.aws.amazon.com/IAM/latest/UserGuide/identity-providers-oidc-obtain-thumbprint.html) in the IAM User Guide.
    /// This member is required.
    public var thumbprintList: [Swift.String]?
    /// The URL of the identity provider. The URL must begin with https:// and should correspond to the iss claim in the provider's OpenID Connect ID tokens. Per the OIDC standard, path components are allowed but query parameters are not. Typically the URL consists of only a hostname, like https://server.example.org or https://example.com. The URL should not contain a port number. You cannot register the same provider multiple times in a single Amazon Web Services account. If you try to submit a URL that has already been used for an OpenID Connect provider in the Amazon Web Services account, you will get an error.
    /// This member is required.
    public var url: Swift.String?

    public init (
        clientIDList: [Swift.String]? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        thumbprintList: [Swift.String]? = nil,
        url: Swift.String? = nil
    )
    {
        self.clientIDList = clientIDList
        self.tags = tags
        self.thumbprintList = thumbprintList
        self.url = url
    }
}

struct CreateOpenIDConnectProviderInputBody: Swift.Equatable {
    let url: Swift.String?
    let clientIDList: [Swift.String]?
    let thumbprintList: [Swift.String]?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateOpenIDConnectProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIDList = "ClientIDList"
        case tags = "Tags"
        case thumbprintList = "ThumbprintList"
        case url = "Url"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        if containerValues.contains(.clientIDList) {
            struct KeyVal0{struct member{}}
            let clientIDListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .clientIDList)
            if let clientIDListWrappedContainer = clientIDListWrappedContainer {
                let clientIDListContainer = try clientIDListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var clientIDListBuffer:[Swift.String]? = nil
                if let clientIDListContainer = clientIDListContainer {
                    clientIDListBuffer = [Swift.String]()
                    for stringContainer0 in clientIDListContainer {
                        clientIDListBuffer?.append(stringContainer0)
                    }
                }
                clientIDList = clientIDListBuffer
            } else {
                clientIDList = []
            }
        } else {
            clientIDList = nil
        }
        if containerValues.contains(.thumbprintList) {
            struct KeyVal0{struct member{}}
            let thumbprintListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .thumbprintList)
            if let thumbprintListWrappedContainer = thumbprintListWrappedContainer {
                let thumbprintListContainer = try thumbprintListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var thumbprintListBuffer:[Swift.String]? = nil
                if let thumbprintListContainer = thumbprintListContainer {
                    thumbprintListBuffer = [Swift.String]()
                    for stringContainer0 in thumbprintListContainer {
                        thumbprintListBuffer?.append(stringContainer0)
                    }
                }
                thumbprintList = thumbprintListBuffer
            } else {
                thumbprintList = []
            }
        } else {
            thumbprintList = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateOpenIDConnectProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateOpenIDConnectProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateOpenIDConnectProviderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOpenIDConnectProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateOpenIDConnectProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.openIDConnectProviderArn = output.openIDConnectProviderArn
            self.tags = output.tags
        } else {
            self.openIDConnectProviderArn = nil
            self.tags = nil
        }
    }
}

/// Contains the response to a successful [CreateOpenIDConnectProvider] request.
public struct CreateOpenIDConnectProviderOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new IAM OpenID Connect provider that is created. For more information, see [OpenIDConnectProviderListEntry].
    public var openIDConnectProviderArn: Swift.String?
    /// A list of tags that are attached to the new IAM OIDC provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        openIDConnectProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.tags = tags
    }
}

struct CreateOpenIDConnectProviderOutputResponseBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateOpenIDConnectProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateOpenIDConnectProviderResult"))
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreatePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("CreatePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreatePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePolicyInput: Swift.Equatable {
    /// A friendly description of the policy. Typically used to store information about the permissions defined in the policy. For example, "Grants access to production DynamoDB tables." The policy description is immutable. After a value is assigned, it cannot be changed.
    public var description: Swift.String?
    /// The path for the policy. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters. You cannot use an asterisk (*) in the path name.
    public var path: Swift.String?
    /// The JSON policy document that you want to use as the content for the new policy. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). To learn more about JSON policy grammar, see [Grammar of the IAM JSON policy language](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_grammar.html) in the IAM User Guide. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The friendly name of the policy. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    /// This member is required.
    public var policyName: Swift.String?
    /// A list of tags that you want to attach to the new IAM customer managed policy. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        path: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.path = path
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.tags = tags
    }
}

struct CreatePolicyInputBody: Swift.Equatable {
    let policyName: Swift.String?
    let path: Swift.String?
    let policyDocument: Swift.String?
    let description: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreatePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case path = "Path"
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreatePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreatePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocument" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePolicyOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

/// Contains the response to a successful [CreatePolicy] request.
public struct CreatePolicyOutputResponse: Swift.Equatable {
    /// A structure containing details about the new policy.
    public var policy: IAMClientTypes.Policy?

    public init (
        policy: IAMClientTypes.Policy? = nil
    )
    {
        self.policy = policy
    }
}

struct CreatePolicyOutputResponseBody: Swift.Equatable {
    let policy: IAMClientTypes.Policy?
}

extension CreatePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreatePolicyResult"))
        let policyDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Policy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension CreatePolicyVersionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let setAsDefault = setAsDefault {
            try container.encode(setAsDefault, forKey: ClientRuntime.Key("SetAsDefault"))
        }
        try container.encode("CreatePolicyVersion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreatePolicyVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePolicyVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy to which you want to add a new version. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The JSON policy document that you want to use as the content for this new version of the policy. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// Specifies whether to set this version as the policy's default version. When this parameter is true, the new policy version becomes the operative version. That is, it becomes the version that is in effect for the IAM users, groups, and roles that the policy is attached to. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    public var setAsDefault: Swift.Bool?

    public init (
        policyArn: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        setAsDefault: Swift.Bool? = nil
    )
    {
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.setAsDefault = setAsDefault
    }
}

struct CreatePolicyVersionInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let policyDocument: Swift.String?
    let setAsDefault: Swift.Bool?
}

extension CreatePolicyVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case policyDocument = "PolicyDocument"
        case setAsDefault = "SetAsDefault"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let setAsDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .setAsDefault)
        setAsDefault = setAsDefaultDecoded
    }
}

extension CreatePolicyVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreatePolicyVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocument" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePolicyVersionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePolicyVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePolicyVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyVersion = output.policyVersion
        } else {
            self.policyVersion = nil
        }
    }
}

/// Contains the response to a successful [CreatePolicyVersion] request.
public struct CreatePolicyVersionOutputResponse: Swift.Equatable {
    /// A structure containing details about the new policy version.
    public var policyVersion: IAMClientTypes.PolicyVersion?

    public init (
        policyVersion: IAMClientTypes.PolicyVersion? = nil
    )
    {
        self.policyVersion = policyVersion
    }
}

struct CreatePolicyVersionOutputResponseBody: Swift.Equatable {
    let policyVersion: IAMClientTypes.PolicyVersion?
}

extension CreatePolicyVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyVersion = "PolicyVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreatePolicyVersionResult"))
        let policyVersionDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyVersion.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
    }
}

extension CreateRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let assumeRolePolicyDocument = assumeRolePolicyDocument {
            try container.encode(assumeRolePolicyDocument, forKey: ClientRuntime.Key("AssumeRolePolicyDocument"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let maxSessionDuration = maxSessionDuration {
            try container.encode(maxSessionDuration, forKey: ClientRuntime.Key("MaxSessionDuration"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("CreateRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRoleInput: Swift.Equatable {
    /// The trust relationship policy document that grants an entity permission to assume the role. In IAM, you must provide a JSON policy that has been converted to a string. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// Upon success, the response includes the same trust policy in JSON format.
    /// This member is required.
    public var assumeRolePolicyDocument: Swift.String?
    /// A description of the role.
    public var description: Swift.String?
    /// The maximum session duration (in seconds) that you want to set for the specified role. If you do not specify a value for this setting, the default value of one hour is applied. This setting can have a value from 1 hour to 12 hours. Anyone who assumes the role from the CLI or API can use the DurationSeconds API parameter or the duration-seconds CLI parameter to request a longer session. The MaxSessionDuration setting determines the maximum duration that can be requested using the DurationSeconds parameter. If users don't specify a value for the DurationSeconds parameter, their security credentials are valid for one hour by default. This applies when you use the AssumeRole* API operations or the assume-role* CLI operations but does not apply when you use those operations to create a console URL. For more information, see [Using IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html) in the IAM User Guide.
    public var maxSessionDuration: Swift.Int?
    /// The path to the role. For more information about paths, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// The ARN of the managed policy that is used to set the permissions boundary for the role. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    public var permissionsBoundary: Swift.String?
    /// The name of the role to create. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    /// This member is required.
    public var roleName: Swift.String?
    /// A list of tags that you want to attach to the new role. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        assumeRolePolicyDocument: Swift.String? = nil,
        description: Swift.String? = nil,
        maxSessionDuration: Swift.Int? = nil,
        path: Swift.String? = nil,
        permissionsBoundary: Swift.String? = nil,
        roleName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.assumeRolePolicyDocument = assumeRolePolicyDocument
        self.description = description
        self.maxSessionDuration = maxSessionDuration
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.roleName = roleName
        self.tags = tags
    }
}

struct CreateRoleInputBody: Swift.Equatable {
    let path: Swift.String?
    let roleName: Swift.String?
    let assumeRolePolicyDocument: Swift.String?
    let description: Swift.String?
    let maxSessionDuration: Swift.Int?
    let permissionsBoundary: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
        case description = "Description"
        case maxSessionDuration = "MaxSessionDuration"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case roleName = "RoleName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let assumeRolePolicyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assumeRolePolicyDocument)
        assumeRolePolicyDocument = assumeRolePolicyDocumentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let maxSessionDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSessionDuration)
        maxSessionDuration = maxSessionDurationDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocument" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRoleOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRoleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.role = output.role
        } else {
            self.role = nil
        }
    }
}

/// Contains the response to a successful [CreateRole] request.
public struct CreateRoleOutputResponse: Swift.Equatable {
    /// A structure containing details about the new role.
    /// This member is required.
    public var role: IAMClientTypes.Role?

    public init (
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

struct CreateRoleOutputResponseBody: Swift.Equatable {
    let role: IAMClientTypes.Role?
}

extension CreateRoleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateRoleResult"))
        let roleDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Role.self, forKey: .role)
        role = roleDecoded
    }
}

extension CreateSAMLProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let samlMetadataDocument = samlMetadataDocument {
            try container.encode(samlMetadataDocument, forKey: ClientRuntime.Key("SAMLMetadataDocument"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("CreateSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateSAMLProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSAMLProviderInput: Swift.Equatable {
    /// The name of the provider to create. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var name: Swift.String?
    /// An XML document generated by an identity provider (IdP) that supports SAML 2.0. The document includes the issuer's name, expiration information, and keys that can be used to validate the SAML authentication response (assertions) that are received from the IdP. You must generate the metadata document using the identity management software that is used as your organization's IdP. For more information, see [About SAML 2.0-based federation](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_saml.html) in the IAM User Guide
    /// This member is required.
    public var samlMetadataDocument: Swift.String?
    /// A list of tags that you want to attach to the new IAM SAML provider. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        name: Swift.String? = nil,
        samlMetadataDocument: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.name = name
        self.samlMetadataDocument = samlMetadataDocument
        self.tags = tags
    }
}

struct CreateSAMLProviderInputBody: Swift.Equatable {
    let samlMetadataDocument: Swift.String?
    let name: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateSAMLProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case samlMetadataDocument = "SAMLMetadataDocument"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlMetadataDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlMetadataDocument)
        samlMetadataDocument = samlMetadataDocumentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateSAMLProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateSAMLProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSAMLProviderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSAMLProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSAMLProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.samlProviderArn = output.samlProviderArn
            self.tags = output.tags
        } else {
            self.samlProviderArn = nil
            self.tags = nil
        }
    }
}

/// Contains the response to a successful [CreateSAMLProvider] request.
public struct CreateSAMLProviderOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new SAML provider resource in IAM.
    public var samlProviderArn: Swift.String?
    /// A list of tags that are attached to the new IAM SAML provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        samlProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
        self.tags = tags
    }
}

struct CreateSAMLProviderOutputResponseBody: Swift.Equatable {
    let samlProviderArn: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateSAMLProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateSAMLProviderResult"))
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateServiceLinkedRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let awsServiceName = awsServiceName {
            try container.encode(awsServiceName, forKey: ClientRuntime.Key("AWSServiceName"))
        }
        if let customSuffix = customSuffix {
            try container.encode(customSuffix, forKey: ClientRuntime.Key("CustomSuffix"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        try container.encode("CreateServiceLinkedRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateServiceLinkedRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateServiceLinkedRoleInput: Swift.Equatable {
    /// The service principal for the Amazon Web Services service to which this role is attached. You use a string similar to a URL but without the http:// in front. For example: elasticbeanstalk.amazonaws.com. Service principals are unique and case-sensitive. To find the exact service principal for your service-linked role, see [Amazon Web Services services that work with IAM](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html) in the IAM User Guide. Look for the services that have Yes in the Service-Linked Role column. Choose the Yes link to view the service-linked role documentation for that service.
    /// This member is required.
    public var awsServiceName: Swift.String?
    /// A string that you provide, which is combined with the service-provided prefix to form the complete role name. If you make multiple requests for the same service, then you must supply a different CustomSuffix for each request. Otherwise the request fails with a duplicate role name error. For example, you could add -1 or -debug to the suffix. Some services do not support the CustomSuffix parameter. If you provide an optional suffix and the operation fails, try the operation again without the suffix.
    public var customSuffix: Swift.String?
    /// The description of the role.
    public var description: Swift.String?

    public init (
        awsServiceName: Swift.String? = nil,
        customSuffix: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.awsServiceName = awsServiceName
        self.customSuffix = customSuffix
        self.description = description
    }
}

struct CreateServiceLinkedRoleInputBody: Swift.Equatable {
    let awsServiceName: Swift.String?
    let description: Swift.String?
    let customSuffix: Swift.String?
}

extension CreateServiceLinkedRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsServiceName = "AWSServiceName"
        case customSuffix = "CustomSuffix"
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsServiceName)
        awsServiceName = awsServiceNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let customSuffixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customSuffix)
        customSuffix = customSuffixDecoded
    }
}

extension CreateServiceLinkedRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateServiceLinkedRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateServiceLinkedRoleOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceLinkedRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateServiceLinkedRoleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.role = output.role
        } else {
            self.role = nil
        }
    }
}

public struct CreateServiceLinkedRoleOutputResponse: Swift.Equatable {
    /// A [Role] object that contains details about the newly created role.
    public var role: IAMClientTypes.Role?

    public init (
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

struct CreateServiceLinkedRoleOutputResponseBody: Swift.Equatable {
    let role: IAMClientTypes.Role?
}

extension CreateServiceLinkedRoleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateServiceLinkedRoleResult"))
        let roleDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Role.self, forKey: .role)
        role = roleDecoded
    }
}

extension CreateServiceSpecificCredentialInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("CreateServiceSpecificCredential", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateServiceSpecificCredentialInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateServiceSpecificCredentialInput: Swift.Equatable {
    /// The name of the Amazon Web Services service that is to be associated with the credentials. The service you specify here is the only service that can be accessed using these credentials.
    /// This member is required.
    public var serviceName: Swift.String?
    /// The name of the IAM user that is to be associated with the credentials. The new service-specific credentials have the same permissions as the associated user except that they can be used only to access the specified service. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serviceName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceName = serviceName
        self.userName = userName
    }
}

struct CreateServiceSpecificCredentialInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serviceName: Swift.String?
}

extension CreateServiceSpecificCredentialInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName = "ServiceName"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension CreateServiceSpecificCredentialOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateServiceSpecificCredentialOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotSupportedService" : self = .serviceNotSupportedException(try ServiceNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateServiceSpecificCredentialOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceNotSupportedException(ServiceNotSupportedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceSpecificCredentialOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateServiceSpecificCredentialOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceSpecificCredential = output.serviceSpecificCredential
        } else {
            self.serviceSpecificCredential = nil
        }
    }
}

public struct CreateServiceSpecificCredentialOutputResponse: Swift.Equatable {
    /// A structure that contains information about the newly created service-specific credential. This is the only time that the password for this credential set is available. It cannot be recovered later. Instead, you must reset the password with [ResetServiceSpecificCredential].
    public var serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential?

    public init (
        serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential? = nil
    )
    {
        self.serviceSpecificCredential = serviceSpecificCredential
    }
}

struct CreateServiceSpecificCredentialOutputResponseBody: Swift.Equatable {
    let serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential?
}

extension CreateServiceSpecificCredentialOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSpecificCredential = "ServiceSpecificCredential"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateServiceSpecificCredentialResult"))
        let serviceSpecificCredentialDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ServiceSpecificCredential.self, forKey: .serviceSpecificCredential)
        serviceSpecificCredential = serviceSpecificCredentialDecoded
    }
}

extension CreateUserInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("CreateUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The path for the user name. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// The ARN of the managed policy that is used to set the permissions boundary for the user. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    public var permissionsBoundary: Swift.String?
    /// A list of tags that you want to attach to the new user. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?
    /// The name of the user to create. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    /// This member is required.
    public var userName: Swift.String?

    public init (
        path: Swift.String? = nil,
        permissionsBoundary: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.path = path
        self.permissionsBoundary = permissionsBoundary
        self.tags = tags
        self.userName = userName
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let path: Swift.String?
    let userName: Swift.String?
    let permissionsBoundary: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case tags = "Tags"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

/// Contains the response to a successful [CreateUser] request.
public struct CreateUserOutputResponse: Swift.Equatable {
    /// A structure with details about the new IAM user.
    public var user: IAMClientTypes.User?

    public init (
        user: IAMClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct CreateUserOutputResponseBody: Swift.Equatable {
    let user: IAMClientTypes.User?
}

extension CreateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateUserResult"))
        let userDecoded = try containerValues.decodeIfPresent(IAMClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

extension CreateVirtualMFADeviceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let virtualMFADeviceName = virtualMFADeviceName {
            try container.encode(virtualMFADeviceName, forKey: ClientRuntime.Key("VirtualMFADeviceName"))
        }
        try container.encode("CreateVirtualMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateVirtualMFADeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateVirtualMFADeviceInput: Swift.Equatable {
    /// The path for the virtual MFA device. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var path: Swift.String?
    /// A list of tags that you want to attach to the new IAM virtual MFA device. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?
    /// The name of the virtual MFA device. Use with path to uniquely identify a virtual MFA device. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var virtualMFADeviceName: Swift.String?

    public init (
        path: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        virtualMFADeviceName: Swift.String? = nil
    )
    {
        self.path = path
        self.tags = tags
        self.virtualMFADeviceName = virtualMFADeviceName
    }
}

struct CreateVirtualMFADeviceInputBody: Swift.Equatable {
    let path: Swift.String?
    let virtualMFADeviceName: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension CreateVirtualMFADeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "Path"
        case tags = "Tags"
        case virtualMFADeviceName = "VirtualMFADeviceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let virtualMFADeviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualMFADeviceName)
        virtualMFADeviceName = virtualMFADeviceNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateVirtualMFADeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateVirtualMFADeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVirtualMFADeviceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVirtualMFADeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateVirtualMFADeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualMFADevice = output.virtualMFADevice
        } else {
            self.virtualMFADevice = nil
        }
    }
}

/// Contains the response to a successful [CreateVirtualMFADevice] request.
public struct CreateVirtualMFADeviceOutputResponse: Swift.Equatable {
    /// A structure containing details about the new virtual MFA device.
    /// This member is required.
    public var virtualMFADevice: IAMClientTypes.VirtualMFADevice?

    public init (
        virtualMFADevice: IAMClientTypes.VirtualMFADevice? = nil
    )
    {
        self.virtualMFADevice = virtualMFADevice
    }
}

struct CreateVirtualMFADeviceOutputResponseBody: Swift.Equatable {
    let virtualMFADevice: IAMClientTypes.VirtualMFADevice?
}

extension CreateVirtualMFADeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualMFADevice = "VirtualMFADevice"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateVirtualMFADeviceResult"))
        let virtualMFADeviceDecoded = try containerValues.decodeIfPresent(IAMClientTypes.VirtualMFADevice.self, forKey: .virtualMFADevice)
        virtualMFADevice = virtualMFADeviceDecoded
    }
}

extension CredentialReportExpiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<CredentialReportExpiredExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the most recent credential report has expired. To generate a new credential report, use [GenerateCredentialReport]. For more information about credential report expiration, see [Getting credential reports](https://docs.aws.amazon.com/IAM/latest/UserGuide/credential-reports.html) in the IAM User Guide.
public struct CredentialReportExpiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CredentialReportExpiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CredentialReportExpiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CredentialReportNotPresentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<CredentialReportNotPresentExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the credential report does not exist. To generate a credential report, use [GenerateCredentialReport].
public struct CredentialReportNotPresentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CredentialReportNotPresentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CredentialReportNotPresentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CredentialReportNotReadyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<CredentialReportNotReadyExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the credential report is still being generated.
public struct CredentialReportNotReadyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CredentialReportNotReadyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CredentialReportNotReadyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeactivateMFADeviceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeactivateMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeactivateMFADeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeactivateMFADeviceInput: Swift.Equatable {
    /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: =,.@:/-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The name of the user whose MFA device you want to deactivate. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

struct DeactivateMFADeviceInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serialNumber: Swift.String?
}

extension DeactivateMFADeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
    }
}

extension DeactivateMFADeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeactivateMFADeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityTemporarilyUnmodifiable" : self = .entityTemporarilyUnmodifiableException(try EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeactivateMFADeviceOutputError: Swift.Error, Swift.Equatable {
    case entityTemporarilyUnmodifiableException(EntityTemporarilyUnmodifiableException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeactivateMFADeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeactivateMFADeviceOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteAccessKeyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteAccessKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteAccessKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAccessKeyInput: Swift.Equatable {
    /// The access key ID for the access key ID and secret access key you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var accessKeyId: Swift.String?
    /// The name of the user whose access key pair you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init (
        accessKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.userName = userName
    }
}

struct DeleteAccessKeyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let accessKeyId: Swift.String?
}

extension DeleteAccessKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
    }
}

extension DeleteAccessKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteAccessKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAccessKeyOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessKeyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteAccountAliasInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountAlias = accountAlias {
            try container.encode(accountAlias, forKey: ClientRuntime.Key("AccountAlias"))
        }
        try container.encode("DeleteAccountAlias", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteAccountAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAccountAliasInput: Swift.Equatable {
    /// The name of the account alias to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have two dashes in a row.
    /// This member is required.
    public var accountAlias: Swift.String?

    public init (
        accountAlias: Swift.String? = nil
    )
    {
        self.accountAlias = accountAlias
    }
}

struct DeleteAccountAliasInputBody: Swift.Equatable {
    let accountAlias: Swift.String?
}

extension DeleteAccountAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAlias = "AccountAlias"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountAlias)
        accountAlias = accountAliasDecoded
    }
}

extension DeleteAccountAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteAccountAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAccountAliasOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccountAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccountAliasOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteAccountPasswordPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("DeleteAccountPasswordPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteAccountPasswordPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAccountPasswordPolicyInput: Swift.Equatable {

    public init () { }
}

extension DeleteAccountPasswordPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteAccountPasswordPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAccountPasswordPolicyOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccountPasswordPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccountPasswordPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<DeleteConflictExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it attempted to delete a resource that has attached subordinate entities. The error message describes these entities.
public struct DeleteConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        try container.encode("DeleteGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGroupInput: Swift.Equatable {
    /// The name of the IAM group to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?

    public init (
        groupName: Swift.String? = nil
    )
    {
        self.groupName = groupName
    }
}

struct DeleteGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
}

extension DeleteGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension DeleteGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DeleteConflict" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGroupOutputError: Swift.Error, Swift.Equatable {
    case deleteConflictException(DeleteConflictException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteGroupPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        try container.encode("DeleteGroupPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteGroupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGroupPolicyInput: Swift.Equatable {
    /// The name (friendly name, not ARN) identifying the group that the policy is embedded in. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name identifying the policy document to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?

    public init (
        groupName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyName = policyName
    }
}

struct DeleteGroupPolicyInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let policyName: Swift.String?
}

extension DeleteGroupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyName = "PolicyName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension DeleteGroupPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteGroupPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGroupPolicyOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGroupPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteInstanceProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        try container.encode("DeleteInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteInstanceProfileInput: Swift.Equatable {
    /// The name of the instance profile to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?

    public init (
        instanceProfileName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
    }
}

struct DeleteInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
}

extension DeleteInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
    }
}

extension DeleteInstanceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteInstanceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DeleteConflict" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteInstanceProfileOutputError: Swift.Error, Swift.Equatable {
    case deleteConflictException(DeleteConflictException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInstanceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInstanceProfileOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteLoginProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteLoginProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteLoginProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLoginProfileInput: Swift.Equatable {
    /// The name of the user whose password you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

struct DeleteLoginProfileInputBody: Swift.Equatable {
    let userName: Swift.String?
}

extension DeleteLoginProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteLoginProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteLoginProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityTemporarilyUnmodifiable" : self = .entityTemporarilyUnmodifiableException(try EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteLoginProfileOutputError: Swift.Error, Swift.Equatable {
    case entityTemporarilyUnmodifiableException(EntityTemporarilyUnmodifiableException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLoginProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLoginProfileOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteOpenIDConnectProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        try container.encode("DeleteOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteOpenIDConnectProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteOpenIDConnectProviderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM OpenID Connect provider resource object to delete. You can get a list of OpenID Connect provider resource ARNs by using the [ListOpenIDConnectProviders] operation.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init (
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

struct DeleteOpenIDConnectProviderInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
}

extension DeleteOpenIDConnectProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
    }
}

extension DeleteOpenIDConnectProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteOpenIDConnectProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteOpenIDConnectProviderOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOpenIDConnectProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOpenIDConnectProviderOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("DeletePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeletePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to delete. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init (
        policyArn: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

struct DeletePolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
}

extension DeletePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension DeletePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DeleteConflict" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePolicyOutputError: Swift.Error, Swift.Equatable {
    case deleteConflictException(DeleteConflictException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePolicyVersionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
        try container.encode("DeletePolicyVersion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeletePolicyVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePolicyVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy from which you want to delete a version. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The policy version to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consists of the lowercase letter 'v' followed by one or two digits, and optionally followed by a period '.' and a string of letters and digits. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    /// This member is required.
    public var versionId: Swift.String?

    public init (
        policyArn: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.versionId = versionId
    }
}

struct DeletePolicyVersionInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let versionId: Swift.String?
}

extension DeletePolicyVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension DeletePolicyVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePolicyVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DeleteConflict" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePolicyVersionOutputError: Swift.Error, Swift.Equatable {
    case deleteConflictException(DeleteConflictException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePolicyVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePolicyVersionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("DeleteRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRoleInput: Swift.Equatable {
    /// The name of the role to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

struct DeleteRoleInputBody: Swift.Equatable {
    let roleName: Swift.String?
}

extension DeleteRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension DeleteRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeleteConflict" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntity" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRoleOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case deleteConflictException(DeleteConflictException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRoleOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRolePermissionsBoundaryInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("DeleteRolePermissionsBoundary", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteRolePermissionsBoundaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRolePermissionsBoundaryInput: Swift.Equatable {
    /// The name (friendly name, not ARN) of the IAM role from which you want to remove the permissions boundary.
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

struct DeleteRolePermissionsBoundaryInputBody: Swift.Equatable {
    let roleName: Swift.String?
}

extension DeleteRolePermissionsBoundaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension DeleteRolePermissionsBoundaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteRolePermissionsBoundaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntity" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRolePermissionsBoundaryOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRolePermissionsBoundaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRolePermissionsBoundaryOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRolePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("DeleteRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteRolePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRolePolicyInput: Swift.Equatable {
    /// The name of the inline policy to delete from the specified IAM role. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name (friendly name, not ARN) identifying the role that the policy is embedded in. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.roleName = roleName
    }
}

struct DeleteRolePolicyInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let policyName: Swift.String?
}

extension DeleteRolePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension DeleteRolePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteRolePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntity" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRolePolicyOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRolePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRolePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSAMLProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        try container.encode("DeleteSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteSAMLProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSAMLProviderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the SAML provider to delete.
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init (
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
    }
}

struct DeleteSAMLProviderInputBody: Swift.Equatable {
    let samlProviderArn: Swift.String?
}

extension DeleteSAMLProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
    }
}

extension DeleteSAMLProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSAMLProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSAMLProviderOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSAMLProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSAMLProviderOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSSHPublicKeyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sshPublicKeyId = sshPublicKeyId {
            try container.encode(sshPublicKeyId, forKey: ClientRuntime.Key("SSHPublicKeyId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteSSHPublicKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteSSHPublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSSHPublicKeyInput: Swift.Equatable {
    /// The unique identifier for the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// The name of the IAM user associated with the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

struct DeleteSSHPublicKeyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let sshPublicKeyId: Swift.String?
}

extension DeleteSSHPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKeyId = "SSHPublicKeyId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
    }
}

extension DeleteSSHPublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSSHPublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSSHPublicKeyOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSSHPublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSSHPublicKeyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteServerCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        try container.encode("DeleteServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteServerCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServerCertificateInput: Swift.Equatable {
    /// The name of the server certificate you want to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init (
        serverCertificateName: Swift.String? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
    }
}

struct DeleteServerCertificateInputBody: Swift.Equatable {
    let serverCertificateName: Swift.String?
}

extension DeleteServerCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificateName = "ServerCertificateName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
    }
}

extension DeleteServerCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteServerCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DeleteConflict" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteServerCertificateOutputError: Swift.Error, Swift.Equatable {
    case deleteConflictException(DeleteConflictException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServerCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServerCertificateOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteServiceLinkedRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("DeleteServiceLinkedRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteServiceLinkedRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServiceLinkedRoleInput: Swift.Equatable {
    /// The name of the service-linked role to be deleted.
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

struct DeleteServiceLinkedRoleInputBody: Swift.Equatable {
    let roleName: Swift.String?
}

extension DeleteServiceLinkedRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension DeleteServiceLinkedRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteServiceLinkedRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteServiceLinkedRoleOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceLinkedRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteServiceLinkedRoleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deletionTaskId = output.deletionTaskId
        } else {
            self.deletionTaskId = nil
        }
    }
}

public struct DeleteServiceLinkedRoleOutputResponse: Swift.Equatable {
    /// The deletion task identifier that you can use to check the status of the deletion. This identifier is returned in the format task/aws-service-role///.
    /// This member is required.
    public var deletionTaskId: Swift.String?

    public init (
        deletionTaskId: Swift.String? = nil
    )
    {
        self.deletionTaskId = deletionTaskId
    }
}

struct DeleteServiceLinkedRoleOutputResponseBody: Swift.Equatable {
    let deletionTaskId: Swift.String?
}

extension DeleteServiceLinkedRoleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionTaskId = "DeletionTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteServiceLinkedRoleResult"))
        let deletionTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionTaskId)
        deletionTaskId = deletionTaskIdDecoded
    }
}

extension DeleteServiceSpecificCredentialInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: ClientRuntime.Key("ServiceSpecificCredentialId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteServiceSpecificCredential", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteServiceSpecificCredentialInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServiceSpecificCredentialInput: Swift.Equatable {
    /// The unique identifier of the service-specific credential. You can get this value by calling [ListServiceSpecificCredentials]. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var serviceSpecificCredentialId: Swift.String?
    /// The name of the IAM user associated with the service-specific credential. If this value is not specified, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init (
        serviceSpecificCredentialId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.userName = userName
    }
}

struct DeleteServiceSpecificCredentialInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serviceSpecificCredentialId: Swift.String?
}

extension DeleteServiceSpecificCredentialInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serviceSpecificCredentialIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceSpecificCredentialId)
        serviceSpecificCredentialId = serviceSpecificCredentialIdDecoded
    }
}

extension DeleteServiceSpecificCredentialOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteServiceSpecificCredentialOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteServiceSpecificCredentialOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceSpecificCredentialOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServiceSpecificCredentialOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSigningCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateId = certificateId {
            try container.encode(certificateId, forKey: ClientRuntime.Key("CertificateId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteSigningCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteSigningCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSigningCertificateInput: Swift.Equatable {
    /// The ID of the signing certificate to delete. The format of this parameter, as described by its [regex](http://wikipedia.org/wiki/regex) pattern, is a string of characters that can be upper- or lower-cased letters or digits.
    /// This member is required.
    public var certificateId: Swift.String?
    /// The name of the user the signing certificate belongs to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init (
        certificateId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
        self.userName = userName
    }
}

struct DeleteSigningCertificateInputBody: Swift.Equatable {
    let userName: Swift.String?
    let certificateId: Swift.String?
}

extension DeleteSigningCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

extension DeleteSigningCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSigningCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSigningCertificateOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSigningCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSigningCertificateOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteUserInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The name of the user to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    let userName: Swift.String?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeleteConflict" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case deleteConflictException(DeleteConflictException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteUserPermissionsBoundaryInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteUserPermissionsBoundary", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteUserPermissionsBoundaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserPermissionsBoundaryInput: Swift.Equatable {
    /// The name (friendly name, not ARN) of the IAM user from which you want to remove the permissions boundary.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

struct DeleteUserPermissionsBoundaryInputBody: Swift.Equatable {
    let userName: Swift.String?
}

extension DeleteUserPermissionsBoundaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteUserPermissionsBoundaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteUserPermissionsBoundaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteUserPermissionsBoundaryOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserPermissionsBoundaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserPermissionsBoundaryOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteUserPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DeleteUserPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteUserPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserPolicyInput: Swift.Equatable {
    /// The name identifying the policy document to delete. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name (friendly name, not ARN) identifying the user that the policy is embedded in. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.userName = userName
    }
}

struct DeleteUserPolicyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let policyName: Swift.String?
}

extension DeleteUserPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension DeleteUserPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteUserPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteUserPolicyOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVirtualMFADeviceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        try container.encode("DeleteVirtualMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteVirtualMFADeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVirtualMFADeviceInput: Swift.Equatable {
    /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: =,.@:/-
    /// This member is required.
    public var serialNumber: Swift.String?

    public init (
        serialNumber: Swift.String? = nil
    )
    {
        self.serialNumber = serialNumber
    }
}

struct DeleteVirtualMFADeviceInputBody: Swift.Equatable {
    let serialNumber: Swift.String?
}

extension DeleteVirtualMFADeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serialNumber = "SerialNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
    }
}

extension DeleteVirtualMFADeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteVirtualMFADeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DeleteConflict" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVirtualMFADeviceOutputError: Swift.Error, Swift.Equatable {
    case deleteConflictException(DeleteConflictException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVirtualMFADeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVirtualMFADeviceOutputResponse: Swift.Equatable {

    public init () { }
}

extension IAMClientTypes.DeletionTaskFailureReasonType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "Reason"
        case roleUsageList = "RoleUsageList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let reason = reason {
            try container.encode(reason, forKey: ClientRuntime.Key("Reason"))
        }
        if let roleUsageList = roleUsageList {
            if !roleUsageList.isEmpty {
                var roleUsageListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RoleUsageList"))
                for (index0, roleusagetype0) in roleUsageList.enumerated() {
                    try roleUsageListContainer.encode(roleusagetype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var roleUsageListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RoleUsageList"))
                try roleUsageListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        if containerValues.contains(.roleUsageList) {
            struct KeyVal0{struct member{}}
            let roleUsageListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .roleUsageList)
            if let roleUsageListWrappedContainer = roleUsageListWrappedContainer {
                let roleUsageListContainer = try roleUsageListWrappedContainer.decodeIfPresent([IAMClientTypes.RoleUsageType].self, forKey: .member)
                var roleUsageListBuffer:[IAMClientTypes.RoleUsageType]? = nil
                if let roleUsageListContainer = roleUsageListContainer {
                    roleUsageListBuffer = [IAMClientTypes.RoleUsageType]()
                    for structureContainer0 in roleUsageListContainer {
                        roleUsageListBuffer?.append(structureContainer0)
                    }
                }
                roleUsageList = roleUsageListBuffer
            } else {
                roleUsageList = []
            }
        } else {
            roleUsageList = nil
        }
    }
}

extension IAMClientTypes {
    /// The reason that the service-linked role deletion failed. This data type is used as a response element in the [GetServiceLinkedRoleDeletionStatus] operation.
    public struct DeletionTaskFailureReasonType: Swift.Equatable {
        /// A short description of the reason that the service-linked role deletion failed.
        public var reason: Swift.String?
        /// A list of objects that contains details about the service-linked role deletion failure, if that information is returned by the service. If the service-linked role has active sessions or if any resources that were used by the role have not been deleted from the linked service, the role can't be deleted. This parameter includes a list of the resources that are associated with the role and the Region in which the resources are being used.
        public var roleUsageList: [IAMClientTypes.RoleUsageType]?

        public init (
            reason: Swift.String? = nil,
            roleUsageList: [IAMClientTypes.RoleUsageType]? = nil
        )
        {
            self.reason = reason
            self.roleUsageList = roleUsageList
        }
    }

}

extension IAMClientTypes {
    public enum DeletionTaskStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case notStarted
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeletionTaskStatusType] {
            return [
                .failed,
                .inProgress,
                .notStarted,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeletionTaskStatusType(rawValue: rawValue) ?? DeletionTaskStatusType.sdkUnknown(rawValue)
        }
    }
}

extension DetachGroupPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("DetachGroupPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DetachGroupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetachGroupPolicyInput: Swift.Equatable {
    /// The name (friendly name, not ARN) of the IAM group to detach the policy from. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM policy you want to detach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init (
        groupName: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyArn = policyArn
    }
}

struct DetachGroupPolicyInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let policyArn: Swift.String?
}

extension DetachGroupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension DetachGroupPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DetachGroupPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DetachGroupPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachGroupPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DetachGroupPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DetachRolePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("DetachRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DetachRolePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetachRolePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to detach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the IAM role to detach the policy from. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        policyArn: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.roleName = roleName
    }
}

struct DetachRolePolicyInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let policyArn: Swift.String?
}

extension DetachRolePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension DetachRolePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DetachRolePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntity" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DetachRolePolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachRolePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DetachRolePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DetachUserPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("DetachUserPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension DetachUserPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetachUserPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy you want to detach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The name (friendly name, not ARN) of the IAM user to detach the policy from. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        policyArn: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.userName = userName
    }
}

struct DetachUserPolicyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let policyArn: Swift.String?
}

extension DetachUserPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension DetachUserPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DetachUserPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DetachUserPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachUserPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DetachUserPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DuplicateCertificateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<DuplicateCertificateExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the same certificate is associated with an IAM user in the account.
public struct DuplicateCertificateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateCertificateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateCertificateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateSSHPublicKeyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<DuplicateSSHPublicKeyExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the SSH public key is already associated with the specified IAM user.
public struct DuplicateSSHPublicKeyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateSSHPublicKeyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateSSHPublicKeyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EnableMFADeviceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authenticationCode1 = authenticationCode1 {
            try container.encode(authenticationCode1, forKey: ClientRuntime.Key("AuthenticationCode1"))
        }
        if let authenticationCode2 = authenticationCode2 {
            try container.encode(authenticationCode2, forKey: ClientRuntime.Key("AuthenticationCode2"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("EnableMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension EnableMFADeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EnableMFADeviceInput: Swift.Equatable {
    /// An authentication code emitted by the device. The format for this parameter is a string of six digits. Submit your request immediately after generating the authentication codes. If you generate the codes and then wait too long to submit the request, the MFA device successfully associates with the user but the MFA device becomes out of sync. This happens because time-based one-time passwords (TOTP) expire after a short period of time. If this happens, you can [resync the device](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html).
    /// This member is required.
    public var authenticationCode1: Swift.String?
    /// A subsequent authentication code emitted by the device. The format for this parameter is a string of six digits. Submit your request immediately after generating the authentication codes. If you generate the codes and then wait too long to submit the request, the MFA device successfully associates with the user but the MFA device becomes out of sync. This happens because time-based one-time passwords (TOTP) expire after a short period of time. If this happens, you can [resync the device](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html).
    /// This member is required.
    public var authenticationCode2: Swift.String?
    /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: =,.@:/-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The name of the IAM user for whom you want to enable the MFA device. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        authenticationCode1: Swift.String? = nil,
        authenticationCode2: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationCode1 = authenticationCode1
        self.authenticationCode2 = authenticationCode2
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

struct EnableMFADeviceInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serialNumber: Swift.String?
    let authenticationCode1: Swift.String?
    let authenticationCode2: Swift.String?
}

extension EnableMFADeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationCode1 = "AuthenticationCode1"
        case authenticationCode2 = "AuthenticationCode2"
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let authenticationCode1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authenticationCode1)
        authenticationCode1 = authenticationCode1Decoded
        let authenticationCode2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authenticationCode2)
        authenticationCode2 = authenticationCode2Decoded
    }
}

extension EnableMFADeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension EnableMFADeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityTemporarilyUnmodifiable" : self = .entityTemporarilyUnmodifiableException(try EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAuthenticationCode" : self = .invalidAuthenticationCodeException(try InvalidAuthenticationCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableMFADeviceOutputError: Swift.Error, Swift.Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityTemporarilyUnmodifiableException(EntityTemporarilyUnmodifiableException)
    case invalidAuthenticationCodeException(InvalidAuthenticationCodeException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableMFADeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableMFADeviceOutputResponse: Swift.Equatable {

    public init () { }
}

extension IAMClientTypes {
    public enum EncodingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pem
        case ssh
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingType] {
            return [
                .pem,
                .ssh,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pem: return "PEM"
            case .ssh: return "SSH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncodingType(rawValue: rawValue) ?? EncodingType.sdkUnknown(rawValue)
        }
    }
}

extension EntityAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<EntityAlreadyExistsExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it attempted to create a resource that already exists.
public struct EntityAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EntityAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntityAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes.EntityDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityInfo = "EntityInfo"
        case lastAuthenticated = "LastAuthenticated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let entityInfo = entityInfo {
            try container.encode(entityInfo, forKey: ClientRuntime.Key("EntityInfo"))
        }
        if let lastAuthenticated = lastAuthenticated {
            try container.encodeTimestamp(lastAuthenticated, format: .dateTime, forKey: ClientRuntime.Key("lastAuthenticated"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityInfoDecoded = try containerValues.decodeIfPresent(IAMClientTypes.EntityInfo.self, forKey: .entityInfo)
        entityInfo = entityInfoDecoded
        let lastAuthenticatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastAuthenticated)
        lastAuthenticated = lastAuthenticatedDecoded
    }
}

extension IAMClientTypes {
    /// An object that contains details about when the IAM entities (users or roles) were last used in an attempt to access the specified Amazon Web Services service. This data type is a response element in the [GetServiceLastAccessedDetailsWithEntities] operation.
    public struct EntityDetails: Swift.Equatable {
        /// The EntityInfo object that contains details about the entity (user or role).
        /// This member is required.
        public var entityInfo: IAMClientTypes.EntityInfo?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the authenticated entity last attempted to access Amazon Web Services. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticated: ClientRuntime.Date?

        public init (
            entityInfo: IAMClientTypes.EntityInfo? = nil,
            lastAuthenticated: ClientRuntime.Date? = nil
        )
        {
            self.entityInfo = entityInfo
            self.lastAuthenticated = lastAuthenticated
        }
    }

}

extension IAMClientTypes.EntityInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
        case path = "Path"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyOwnerEntityType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension IAMClientTypes {
    /// Contains details about the specified entity (user or role). This data type is an element of the [EntityDetails] object.
    public struct EntityInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        /// This member is required.
        public var arn: Swift.String?
        /// The identifier of the entity (user or role).
        /// This member is required.
        public var id: Swift.String?
        /// The name of the entity (user or role).
        /// This member is required.
        public var name: Swift.String?
        /// The path to the entity (user or role). For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The type of entity (user or role).
        /// This member is required.
        public var type: IAMClientTypes.PolicyOwnerEntityType?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            type: IAMClientTypes.PolicyOwnerEntityType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
            self.path = path
            self.type = type
        }
    }

}

extension EntityTemporarilyUnmodifiableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<EntityTemporarilyUnmodifiableExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it referenced an entity that is temporarily unmodifiable, such as a user name that was deleted and then recreated. The error indicates that the request is likely to succeed if you try again after waiting several minutes. The error message describes the entity.
public struct EntityTemporarilyUnmodifiableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EntityTemporarilyUnmodifiableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntityTemporarilyUnmodifiableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes {
    public enum EntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsmanagedpolicy
        case group
        case localmanagedpolicy
        case role
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .awsmanagedpolicy,
                .group,
                .localmanagedpolicy,
                .role,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsmanagedpolicy: return "AWSManagedPolicy"
            case .group: return "Group"
            case .localmanagedpolicy: return "LocalManagedPolicy"
            case .role: return "Role"
            case .user: return "User"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let code = code {
            try container.encode(code, forKey: ClientRuntime.Key("Code"))
        }
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about the reason that the operation failed. This data type is used as a response element in the [GetOrganizationsAccessReport], [GetServiceLastAccessedDetails], and [GetServiceLastAccessedDetailsWithEntities] operations.
    public struct ErrorDetails: Swift.Equatable {
        /// The error code associated with the operation failure.
        /// This member is required.
        public var code: Swift.String?
        /// Detailed information about the reason that the operation failed.
        /// This member is required.
        public var message: Swift.String?

        public init (
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IAMClientTypes.EvaluationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evalActionName = "EvalActionName"
        case evalDecision = "EvalDecision"
        case evalDecisionDetails = "EvalDecisionDetails"
        case evalResourceName = "EvalResourceName"
        case matchedStatements = "MatchedStatements"
        case missingContextValues = "MissingContextValues"
        case organizationsDecisionDetail = "OrganizationsDecisionDetail"
        case permissionsBoundaryDecisionDetail = "PermissionsBoundaryDecisionDetail"
        case resourceSpecificResults = "ResourceSpecificResults"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let evalActionName = evalActionName {
            try container.encode(evalActionName, forKey: ClientRuntime.Key("EvalActionName"))
        }
        if let evalDecision = evalDecision {
            try container.encode(evalDecision, forKey: ClientRuntime.Key("EvalDecision"))
        }
        if let evalDecisionDetails = evalDecisionDetails {
            var evalDecisionDetailsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EvalDecisionDetails"))
            for (index0, element0) in evalDecisionDetails.sorted(by: { $0.key < $1.key }).enumerated() {
                let evaldecisionsourcetypeKey0 = element0.key
                let policyevaluationdecisiontypeValue0 = element0.value
                var entryContainer0 = evalDecisionDetailsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(evaldecisionsourcetypeKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(policyevaluationdecisiontypeValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let evalResourceName = evalResourceName {
            try container.encode(evalResourceName, forKey: ClientRuntime.Key("EvalResourceName"))
        }
        if let matchedStatements = matchedStatements {
            if !matchedStatements.isEmpty {
                var matchedStatementsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MatchedStatements"))
                for (index0, statement0) in matchedStatements.enumerated() {
                    try matchedStatementsContainer.encode(statement0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var matchedStatementsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MatchedStatements"))
                try matchedStatementsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let missingContextValues = missingContextValues {
            if !missingContextValues.isEmpty {
                var missingContextValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MissingContextValues"))
                for (index0, contextkeynametype0) in missingContextValues.enumerated() {
                    try missingContextValuesContainer.encode(contextkeynametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var missingContextValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MissingContextValues"))
                try missingContextValuesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let organizationsDecisionDetail = organizationsDecisionDetail {
            try container.encode(organizationsDecisionDetail, forKey: ClientRuntime.Key("OrganizationsDecisionDetail"))
        }
        if let permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail {
            try container.encode(permissionsBoundaryDecisionDetail, forKey: ClientRuntime.Key("PermissionsBoundaryDecisionDetail"))
        }
        if let resourceSpecificResults = resourceSpecificResults {
            if !resourceSpecificResults.isEmpty {
                var resourceSpecificResultsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceSpecificResults"))
                for (index0, resourcespecificresult0) in resourceSpecificResults.enumerated() {
                    try resourceSpecificResultsContainer.encode(resourcespecificresult0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var resourceSpecificResultsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceSpecificResults"))
                try resourceSpecificResultsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evalActionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evalActionName)
        evalActionName = evalActionNameDecoded
        let evalResourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evalResourceName)
        evalResourceName = evalResourceNameDecoded
        let evalDecisionDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyEvaluationDecisionType.self, forKey: .evalDecision)
        evalDecision = evalDecisionDecoded
        if containerValues.contains(.matchedStatements) {
            struct KeyVal0{struct member{}}
            let matchedStatementsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .matchedStatements)
            if let matchedStatementsWrappedContainer = matchedStatementsWrappedContainer {
                let matchedStatementsContainer = try matchedStatementsWrappedContainer.decodeIfPresent([IAMClientTypes.Statement].self, forKey: .member)
                var matchedStatementsBuffer:[IAMClientTypes.Statement]? = nil
                if let matchedStatementsContainer = matchedStatementsContainer {
                    matchedStatementsBuffer = [IAMClientTypes.Statement]()
                    for structureContainer0 in matchedStatementsContainer {
                        matchedStatementsBuffer?.append(structureContainer0)
                    }
                }
                matchedStatements = matchedStatementsBuffer
            } else {
                matchedStatements = []
            }
        } else {
            matchedStatements = nil
        }
        if containerValues.contains(.missingContextValues) {
            struct KeyVal0{struct member{}}
            let missingContextValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .missingContextValues)
            if let missingContextValuesWrappedContainer = missingContextValuesWrappedContainer {
                let missingContextValuesContainer = try missingContextValuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var missingContextValuesBuffer:[Swift.String]? = nil
                if let missingContextValuesContainer = missingContextValuesContainer {
                    missingContextValuesBuffer = [Swift.String]()
                    for stringContainer0 in missingContextValuesContainer {
                        missingContextValuesBuffer?.append(stringContainer0)
                    }
                }
                missingContextValues = missingContextValuesBuffer
            } else {
                missingContextValues = []
            }
        } else {
            missingContextValues = nil
        }
        let organizationsDecisionDetailDecoded = try containerValues.decodeIfPresent(IAMClientTypes.OrganizationsDecisionDetail.self, forKey: .organizationsDecisionDetail)
        organizationsDecisionDetail = organizationsDecisionDetailDecoded
        let permissionsBoundaryDecisionDetailDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PermissionsBoundaryDecisionDetail.self, forKey: .permissionsBoundaryDecisionDetail)
        permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetailDecoded
        if containerValues.contains(.evalDecisionDetails) {
            struct KeyVal0{struct key{}; struct value{}}
            let evalDecisionDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, IAMClientTypes.PolicyEvaluationDecisionType, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .evalDecisionDetails)
            if let evalDecisionDetailsWrappedContainer = evalDecisionDetailsWrappedContainer {
                let evalDecisionDetailsContainer = try evalDecisionDetailsWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, IAMClientTypes.PolicyEvaluationDecisionType, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var evalDecisionDetailsBuffer: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]? = nil
                if let evalDecisionDetailsContainer = evalDecisionDetailsContainer {
                    evalDecisionDetailsBuffer = [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]()
                    for enumContainer0 in evalDecisionDetailsContainer {
                        evalDecisionDetailsBuffer?[enumContainer0.key] = enumContainer0.value
                    }
                }
                evalDecisionDetails = evalDecisionDetailsBuffer
            } else {
                evalDecisionDetails = [:]
            }
        } else {
            evalDecisionDetails = nil
        }
        if containerValues.contains(.resourceSpecificResults) {
            struct KeyVal0{struct member{}}
            let resourceSpecificResultsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .resourceSpecificResults)
            if let resourceSpecificResultsWrappedContainer = resourceSpecificResultsWrappedContainer {
                let resourceSpecificResultsContainer = try resourceSpecificResultsWrappedContainer.decodeIfPresent([IAMClientTypes.ResourceSpecificResult].self, forKey: .member)
                var resourceSpecificResultsBuffer:[IAMClientTypes.ResourceSpecificResult]? = nil
                if let resourceSpecificResultsContainer = resourceSpecificResultsContainer {
                    resourceSpecificResultsBuffer = [IAMClientTypes.ResourceSpecificResult]()
                    for structureContainer0 in resourceSpecificResultsContainer {
                        resourceSpecificResultsBuffer?.append(structureContainer0)
                    }
                }
                resourceSpecificResults = resourceSpecificResultsBuffer
            } else {
                resourceSpecificResults = []
            }
        } else {
            resourceSpecificResults = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains the results of a simulation. This data type is used by the return parameter of [SimulateCustomPolicy] and [SimulatePrincipalPolicy].
    public struct EvaluationResult: Swift.Equatable {
        /// The name of the API operation tested on the indicated resource.
        /// This member is required.
        public var evalActionName: Swift.String?
        /// The result of the simulation.
        /// This member is required.
        public var evalDecision: IAMClientTypes.PolicyEvaluationDecisionType?
        /// Additional details about the results of the cross-account evaluation decision. This parameter is populated for only cross-account simulations. It contains a brief summary of how each policy type contributes to the final evaluation decision. If the simulation evaluates policies within the same account and includes a resource ARN, then the parameter is present but the response is empty. If the simulation evaluates policies within the same account and specifies all resources (*), then the parameter is not returned. When you make a cross-account request, Amazon Web Services evaluates the request in the trusting account and the trusted account. The request is allowed only if both evaluations return true. For more information about how policies are evaluated, see [Evaluating policies within a single account](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic.html#policy-eval-basics). If an Organizations SCP included in the evaluation denies access, the simulation ends. In this case, policy evaluation does not proceed any further and this parameter is not returned.
        public var evalDecisionDetails: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]?
        /// The ARN of the resource that the indicated API operation was tested on.
        public var evalResourceName: Swift.String?
        /// A list of the statements in the input policies that determine the result for this scenario. Remember that even if multiple statements allow the operation on the resource, if only one statement denies that operation, then the explicit deny overrides any allow. In addition, the deny statement is the only entry included in the result.
        public var matchedStatements: [IAMClientTypes.Statement]?
        /// A list of context keys that are required by the included input policies but that were not provided by one of the input parameters. This list is used when the resource in a simulation is "*", either explicitly, or when the ResourceArns parameter blank. If you include a list of resources, then any missing context values are instead included under the ResourceSpecificResults section. To discover the context keys used by a set of policies, you can call [GetContextKeysForCustomPolicy] or [GetContextKeysForPrincipalPolicy].
        public var missingContextValues: [Swift.String]?
        /// A structure that details how Organizations and its service control policies affect the results of the simulation. Only applies if the simulated user's account is part of an organization.
        public var organizationsDecisionDetail: IAMClientTypes.OrganizationsDecisionDetail?
        /// Contains information about the effect that a permissions boundary has on a policy simulation when the boundary is applied to an IAM entity.
        public var permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail?
        /// The individual results of the simulation of the API operation specified in EvalActionName on each resource.
        public var resourceSpecificResults: [IAMClientTypes.ResourceSpecificResult]?

        public init (
            evalActionName: Swift.String? = nil,
            evalDecision: IAMClientTypes.PolicyEvaluationDecisionType? = nil,
            evalDecisionDetails: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]? = nil,
            evalResourceName: Swift.String? = nil,
            matchedStatements: [IAMClientTypes.Statement]? = nil,
            missingContextValues: [Swift.String]? = nil,
            organizationsDecisionDetail: IAMClientTypes.OrganizationsDecisionDetail? = nil,
            permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail? = nil,
            resourceSpecificResults: [IAMClientTypes.ResourceSpecificResult]? = nil
        )
        {
            self.evalActionName = evalActionName
            self.evalDecision = evalDecision
            self.evalDecisionDetails = evalDecisionDetails
            self.evalResourceName = evalResourceName
            self.matchedStatements = matchedStatements
            self.missingContextValues = missingContextValues
            self.organizationsDecisionDetail = organizationsDecisionDetail
            self.permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail
            self.resourceSpecificResults = resourceSpecificResults
        }
    }

}

extension GenerateCredentialReportInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GenerateCredentialReport", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GenerateCredentialReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GenerateCredentialReportInput: Swift.Equatable {

    public init () { }
}

extension GenerateCredentialReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GenerateCredentialReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GenerateCredentialReportOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateCredentialReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GenerateCredentialReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.state = output.state
        } else {
            self.description = nil
            self.state = nil
        }
    }
}

/// Contains the response to a successful [GenerateCredentialReport] request.
public struct GenerateCredentialReportOutputResponse: Swift.Equatable {
    /// Information about the credential report.
    public var description: Swift.String?
    /// Information about the state of the credential report.
    public var state: IAMClientTypes.ReportStateType?

    public init (
        description: Swift.String? = nil,
        state: IAMClientTypes.ReportStateType? = nil
    )
    {
        self.description = description
        self.state = state
    }
}

struct GenerateCredentialReportOutputResponseBody: Swift.Equatable {
    let state: IAMClientTypes.ReportStateType?
    let description: Swift.String?
}

extension GenerateCredentialReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GenerateCredentialReportResult"))
        let stateDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ReportStateType.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GenerateOrganizationsAccessReportInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let entityPath = entityPath {
            try container.encode(entityPath, forKey: ClientRuntime.Key("EntityPath"))
        }
        if let organizationsPolicyId = organizationsPolicyId {
            try container.encode(organizationsPolicyId, forKey: ClientRuntime.Key("OrganizationsPolicyId"))
        }
        try container.encode("GenerateOrganizationsAccessReport", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GenerateOrganizationsAccessReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GenerateOrganizationsAccessReportInput: Swift.Equatable {
    /// The path of the Organizations entity (root, OU, or account). You can build an entity path using the known structure of your organization. For example, assume that your account ID is 123456789012 and its parent OU ID is ou-rge0-awsabcde. The organization root ID is r-f6g7h8i9j0example and your organization ID is o-a1b2c3d4e5. Your entity path is o-a1b2c3d4e5/r-f6g7h8i9j0example/ou-rge0-awsabcde/123456789012.
    /// This member is required.
    public var entityPath: Swift.String?
    /// The identifier of the Organizations service control policy (SCP). This parameter is optional. This ID is used to generate information about when an account principal that is limited by the SCP attempted to access an Amazon Web Services service.
    public var organizationsPolicyId: Swift.String?

    public init (
        entityPath: Swift.String? = nil,
        organizationsPolicyId: Swift.String? = nil
    )
    {
        self.entityPath = entityPath
        self.organizationsPolicyId = organizationsPolicyId
    }
}

struct GenerateOrganizationsAccessReportInputBody: Swift.Equatable {
    let entityPath: Swift.String?
    let organizationsPolicyId: Swift.String?
}

extension GenerateOrganizationsAccessReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityPath = "EntityPath"
        case organizationsPolicyId = "OrganizationsPolicyId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityPath)
        entityPath = entityPathDecoded
        let organizationsPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationsPolicyId)
        organizationsPolicyId = organizationsPolicyIdDecoded
    }
}

extension GenerateOrganizationsAccessReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GenerateOrganizationsAccessReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ReportGenerationLimitExceeded" : self = .reportGenerationLimitExceededException(try ReportGenerationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GenerateOrganizationsAccessReportOutputError: Swift.Error, Swift.Equatable {
    case reportGenerationLimitExceededException(ReportGenerationLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateOrganizationsAccessReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GenerateOrganizationsAccessReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct GenerateOrganizationsAccessReportOutputResponse: Swift.Equatable {
    /// The job identifier that you can use in the [GetOrganizationsAccessReport] operation.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GenerateOrganizationsAccessReportOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension GenerateOrganizationsAccessReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GenerateOrganizationsAccessReportResult"))
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GenerateServiceLastAccessedDetailsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let granularity = granularity {
            try container.encode(granularity, forKey: ClientRuntime.Key("Granularity"))
        }
        try container.encode("GenerateServiceLastAccessedDetails", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GenerateServiceLastAccessedDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GenerateServiceLastAccessedDetailsInput: Swift.Equatable {
    /// The ARN of the IAM resource (user, group, role, or managed policy) used to generate information about when the resource was last used in an attempt to access an Amazon Web Services service.
    /// This member is required.
    public var arn: Swift.String?
    /// The level of detail that you want to generate. You can specify whether you want to generate information about the last attempt to access services or actions. If you specify service-level granularity, this operation generates only service data. If you specify action-level granularity, it generates service and action data. If you don't include this optional parameter, the operation generates service data.
    public var granularity: IAMClientTypes.AccessAdvisorUsageGranularityType?

    public init (
        arn: Swift.String? = nil,
        granularity: IAMClientTypes.AccessAdvisorUsageGranularityType? = nil
    )
    {
        self.arn = arn
        self.granularity = granularity
    }
}

struct GenerateServiceLastAccessedDetailsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let granularity: IAMClientTypes.AccessAdvisorUsageGranularityType?
}

extension GenerateServiceLastAccessedDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case granularity = "Granularity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AccessAdvisorUsageGranularityType.self, forKey: .granularity)
        granularity = granularityDecoded
    }
}

extension GenerateServiceLastAccessedDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GenerateServiceLastAccessedDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GenerateServiceLastAccessedDetailsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateServiceLastAccessedDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GenerateServiceLastAccessedDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct GenerateServiceLastAccessedDetailsOutputResponse: Swift.Equatable {
    /// The JobId that you can use in the [GetServiceLastAccessedDetails] or [GetServiceLastAccessedDetailsWithEntities] operations. The JobId returned by GenerateServiceLastAccessedDetail must be used by the same role within a session, or by the same user when used to call GetServiceLastAccessedDetail.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GenerateServiceLastAccessedDetailsOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension GenerateServiceLastAccessedDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GenerateServiceLastAccessedDetailsResult"))
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GetAccessKeyLastUsedInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        try container.encode("GetAccessKeyLastUsed", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetAccessKeyLastUsedInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccessKeyLastUsedInput: Swift.Equatable {
    /// The identifier of an access key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var accessKeyId: Swift.String?

    public init (
        accessKeyId: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
    }
}

struct GetAccessKeyLastUsedInputBody: Swift.Equatable {
    let accessKeyId: Swift.String?
}

extension GetAccessKeyLastUsedInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
    }
}

extension GetAccessKeyLastUsedOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccessKeyLastUsedOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAccessKeyLastUsedOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessKeyLastUsedOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAccessKeyLastUsedOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessKeyLastUsed = output.accessKeyLastUsed
            self.userName = output.userName
        } else {
            self.accessKeyLastUsed = nil
            self.userName = nil
        }
    }
}

/// Contains the response to a successful [GetAccessKeyLastUsed] request. It is also returned as a member of the [AccessKeyMetaData] structure returned by the [ListAccessKeys] action.
public struct GetAccessKeyLastUsedOutputResponse: Swift.Equatable {
    /// Contains information about the last time the access key was used.
    public var accessKeyLastUsed: IAMClientTypes.AccessKeyLastUsed?
    /// The name of the IAM user that owns this access key.
    public var userName: Swift.String?

    public init (
        accessKeyLastUsed: IAMClientTypes.AccessKeyLastUsed? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessKeyLastUsed = accessKeyLastUsed
        self.userName = userName
    }
}

struct GetAccessKeyLastUsedOutputResponseBody: Swift.Equatable {
    let userName: Swift.String?
    let accessKeyLastUsed: IAMClientTypes.AccessKeyLastUsed?
}

extension GetAccessKeyLastUsedOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyLastUsed = "AccessKeyLastUsed"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetAccessKeyLastUsedResult"))
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let accessKeyLastUsedDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AccessKeyLastUsed.self, forKey: .accessKeyLastUsed)
        accessKeyLastUsed = accessKeyLastUsedDecoded
    }
}

extension GetAccountAuthorizationDetailsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filter = filter {
            if !filter.isEmpty {
                var filterContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filter"))
                for (index0, entitytype0) in filter.enumerated() {
                    try filterContainer.encode(entitytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var filterContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filter"))
                try filterContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("GetAccountAuthorizationDetails", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetAccountAuthorizationDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccountAuthorizationDetailsInput: Swift.Equatable {
    /// A list of entity types used to filter the results. Only the entities that match the types you specify are included in the output. Use the value LocalManagedPolicy to include customer managed policies. The format for this parameter is a comma-separated (if more than one) list of strings. Each string value in the list must be one of the valid values listed below.
    public var filter: [IAMClientTypes.EntityType]?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init (
        filter: [IAMClientTypes.EntityType]? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.filter = filter
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct GetAccountAuthorizationDetailsInputBody: Swift.Equatable {
    let filter: [IAMClientTypes.EntityType]?
    let maxItems: Swift.Int?
    let marker: Swift.String?
}

extension GetAccountAuthorizationDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.filter) {
            struct KeyVal0{struct member{}}
            let filterWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .filter)
            if let filterWrappedContainer = filterWrappedContainer {
                let filterContainer = try filterWrappedContainer.decodeIfPresent([IAMClientTypes.EntityType].self, forKey: .member)
                var filterBuffer:[IAMClientTypes.EntityType]? = nil
                if let filterContainer = filterContainer {
                    filterBuffer = [IAMClientTypes.EntityType]()
                    for enumContainer0 in filterContainer {
                        filterBuffer?.append(enumContainer0)
                    }
                }
                filter = filterBuffer
            } else {
                filter = []
            }
        } else {
            filter = nil
        }
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension GetAccountAuthorizationDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccountAuthorizationDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAccountAuthorizationDetailsOutputError: Swift.Error, Swift.Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountAuthorizationDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAccountAuthorizationDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupDetailList = output.groupDetailList
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policies = output.policies
            self.roleDetailList = output.roleDetailList
            self.userDetailList = output.userDetailList
        } else {
            self.groupDetailList = nil
            self.isTruncated = false
            self.marker = nil
            self.policies = nil
            self.roleDetailList = nil
            self.userDetailList = nil
        }
    }
}

/// Contains the response to a successful [GetAccountAuthorizationDetails] request.
public struct GetAccountAuthorizationDetailsOutputResponse: Swift.Equatable {
    /// A list containing information about IAM groups.
    public var groupDetailList: [IAMClientTypes.GroupDetail]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list containing information about managed policies.
    public var policies: [IAMClientTypes.ManagedPolicyDetail]?
    /// A list containing information about IAM roles.
    public var roleDetailList: [IAMClientTypes.RoleDetail]?
    /// A list containing information about IAM users.
    public var userDetailList: [IAMClientTypes.UserDetail]?

    public init (
        groupDetailList: [IAMClientTypes.GroupDetail]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policies: [IAMClientTypes.ManagedPolicyDetail]? = nil,
        roleDetailList: [IAMClientTypes.RoleDetail]? = nil,
        userDetailList: [IAMClientTypes.UserDetail]? = nil
    )
    {
        self.groupDetailList = groupDetailList
        self.isTruncated = isTruncated
        self.marker = marker
        self.policies = policies
        self.roleDetailList = roleDetailList
        self.userDetailList = userDetailList
    }
}

struct GetAccountAuthorizationDetailsOutputResponseBody: Swift.Equatable {
    let userDetailList: [IAMClientTypes.UserDetail]?
    let groupDetailList: [IAMClientTypes.GroupDetail]?
    let roleDetailList: [IAMClientTypes.RoleDetail]?
    let policies: [IAMClientTypes.ManagedPolicyDetail]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension GetAccountAuthorizationDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupDetailList = "GroupDetailList"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policies = "Policies"
        case roleDetailList = "RoleDetailList"
        case userDetailList = "UserDetailList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetAccountAuthorizationDetailsResult"))
        if containerValues.contains(.userDetailList) {
            struct KeyVal0{struct member{}}
            let userDetailListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .userDetailList)
            if let userDetailListWrappedContainer = userDetailListWrappedContainer {
                let userDetailListContainer = try userDetailListWrappedContainer.decodeIfPresent([IAMClientTypes.UserDetail].self, forKey: .member)
                var userDetailListBuffer:[IAMClientTypes.UserDetail]? = nil
                if let userDetailListContainer = userDetailListContainer {
                    userDetailListBuffer = [IAMClientTypes.UserDetail]()
                    for structureContainer0 in userDetailListContainer {
                        userDetailListBuffer?.append(structureContainer0)
                    }
                }
                userDetailList = userDetailListBuffer
            } else {
                userDetailList = []
            }
        } else {
            userDetailList = nil
        }
        if containerValues.contains(.groupDetailList) {
            struct KeyVal0{struct member{}}
            let groupDetailListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groupDetailList)
            if let groupDetailListWrappedContainer = groupDetailListWrappedContainer {
                let groupDetailListContainer = try groupDetailListWrappedContainer.decodeIfPresent([IAMClientTypes.GroupDetail].self, forKey: .member)
                var groupDetailListBuffer:[IAMClientTypes.GroupDetail]? = nil
                if let groupDetailListContainer = groupDetailListContainer {
                    groupDetailListBuffer = [IAMClientTypes.GroupDetail]()
                    for structureContainer0 in groupDetailListContainer {
                        groupDetailListBuffer?.append(structureContainer0)
                    }
                }
                groupDetailList = groupDetailListBuffer
            } else {
                groupDetailList = []
            }
        } else {
            groupDetailList = nil
        }
        if containerValues.contains(.roleDetailList) {
            struct KeyVal0{struct member{}}
            let roleDetailListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .roleDetailList)
            if let roleDetailListWrappedContainer = roleDetailListWrappedContainer {
                let roleDetailListContainer = try roleDetailListWrappedContainer.decodeIfPresent([IAMClientTypes.RoleDetail].self, forKey: .member)
                var roleDetailListBuffer:[IAMClientTypes.RoleDetail]? = nil
                if let roleDetailListContainer = roleDetailListContainer {
                    roleDetailListBuffer = [IAMClientTypes.RoleDetail]()
                    for structureContainer0 in roleDetailListContainer {
                        roleDetailListBuffer?.append(structureContainer0)
                    }
                }
                roleDetailList = roleDetailListBuffer
            } else {
                roleDetailList = []
            }
        } else {
            roleDetailList = nil
        }
        if containerValues.contains(.policies) {
            struct KeyVal0{struct member{}}
            let policiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policies)
            if let policiesWrappedContainer = policiesWrappedContainer {
                let policiesContainer = try policiesWrappedContainer.decodeIfPresent([IAMClientTypes.ManagedPolicyDetail].self, forKey: .member)
                var policiesBuffer:[IAMClientTypes.ManagedPolicyDetail]? = nil
                if let policiesContainer = policiesContainer {
                    policiesBuffer = [IAMClientTypes.ManagedPolicyDetail]()
                    for structureContainer0 in policiesContainer {
                        policiesBuffer?.append(structureContainer0)
                    }
                }
                policies = policiesBuffer
            } else {
                policies = []
            }
        } else {
            policies = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension GetAccountPasswordPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GetAccountPasswordPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetAccountPasswordPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccountPasswordPolicyInput: Swift.Equatable {

    public init () { }
}

extension GetAccountPasswordPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccountPasswordPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAccountPasswordPolicyOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountPasswordPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAccountPasswordPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.passwordPolicy = output.passwordPolicy
        } else {
            self.passwordPolicy = nil
        }
    }
}

/// Contains the response to a successful [GetAccountPasswordPolicy] request.
public struct GetAccountPasswordPolicyOutputResponse: Swift.Equatable {
    /// A structure that contains details about the account's password policy.
    /// This member is required.
    public var passwordPolicy: IAMClientTypes.PasswordPolicy?

    public init (
        passwordPolicy: IAMClientTypes.PasswordPolicy? = nil
    )
    {
        self.passwordPolicy = passwordPolicy
    }
}

struct GetAccountPasswordPolicyOutputResponseBody: Swift.Equatable {
    let passwordPolicy: IAMClientTypes.PasswordPolicy?
}

extension GetAccountPasswordPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case passwordPolicy = "PasswordPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetAccountPasswordPolicyResult"))
        let passwordPolicyDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PasswordPolicy.self, forKey: .passwordPolicy)
        passwordPolicy = passwordPolicyDecoded
    }
}

extension GetAccountSummaryInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GetAccountSummary", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetAccountSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccountSummaryInput: Swift.Equatable {

    public init () { }
}

extension GetAccountSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccountSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAccountSummaryOutputError: Swift.Error, Swift.Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAccountSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.summaryMap = output.summaryMap
        } else {
            self.summaryMap = nil
        }
    }
}

/// Contains the response to a successful [GetAccountSummary] request.
public struct GetAccountSummaryOutputResponse: Swift.Equatable {
    /// A set of key–value pairs containing information about IAM entity usage and IAM quotas.
    public var summaryMap: [Swift.String:Swift.Int]?

    public init (
        summaryMap: [Swift.String:Swift.Int]? = nil
    )
    {
        self.summaryMap = summaryMap
    }
}

struct GetAccountSummaryOutputResponseBody: Swift.Equatable {
    let summaryMap: [Swift.String:Swift.Int]?
}

extension GetAccountSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summaryMap = "SummaryMap"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetAccountSummaryResult"))
        if containerValues.contains(.summaryMap) {
            struct KeyVal0{struct key{}; struct value{}}
            let summaryMapWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.Int, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .summaryMap)
            if let summaryMapWrappedContainer = summaryMapWrappedContainer {
                let summaryMapContainer = try summaryMapWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.Int, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var summaryMapBuffer: [Swift.String:Swift.Int]? = nil
                if let summaryMapContainer = summaryMapContainer {
                    summaryMapBuffer = [Swift.String:Swift.Int]()
                    for integerContainer0 in summaryMapContainer {
                        summaryMapBuffer?[integerContainer0.key] = integerContainer0.value
                    }
                }
                summaryMap = summaryMapBuffer
            } else {
                summaryMap = [:]
            }
        } else {
            summaryMap = nil
        }
    }
}

extension GetContextKeysForCustomPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyInputList = policyInputList {
            if !policyInputList.isEmpty {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                for (index0, policydocumenttype0) in policyInputList.enumerated() {
                    try policyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                try policyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("GetContextKeysForCustomPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetContextKeysForCustomPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetContextKeysForCustomPolicyInput: Swift.Equatable {
    /// A list of policies for which you want the list of context keys referenced in those policies. Each document is specified as a string containing the complete, valid JSON text of an IAM policy. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyInputList: [Swift.String]?

    public init (
        policyInputList: [Swift.String]? = nil
    )
    {
        self.policyInputList = policyInputList
    }
}

struct GetContextKeysForCustomPolicyInputBody: Swift.Equatable {
    let policyInputList: [Swift.String]?
}

extension GetContextKeysForCustomPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyInputList = "PolicyInputList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.policyInputList) {
            struct KeyVal0{struct member{}}
            let policyInputListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyInputList)
            if let policyInputListWrappedContainer = policyInputListWrappedContainer {
                let policyInputListContainer = try policyInputListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyInputListBuffer:[Swift.String]? = nil
                if let policyInputListContainer = policyInputListContainer {
                    policyInputListBuffer = [Swift.String]()
                    for stringContainer0 in policyInputListContainer {
                        policyInputListBuffer?.append(stringContainer0)
                    }
                }
                policyInputList = policyInputListBuffer
            } else {
                policyInputList = []
            }
        } else {
            policyInputList = nil
        }
    }
}

extension GetContextKeysForCustomPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetContextKeysForCustomPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetContextKeysForCustomPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContextKeysForCustomPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetContextKeysForCustomPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contextKeyNames = output.contextKeyNames
        } else {
            self.contextKeyNames = nil
        }
    }
}

/// Contains the response to a successful [GetContextKeysForPrincipalPolicy] or [GetContextKeysForCustomPolicy] request.
public struct GetContextKeysForCustomPolicyOutputResponse: Swift.Equatable {
    /// The list of context keys that are referenced in the input policies.
    public var contextKeyNames: [Swift.String]?

    public init (
        contextKeyNames: [Swift.String]? = nil
    )
    {
        self.contextKeyNames = contextKeyNames
    }
}

struct GetContextKeysForCustomPolicyOutputResponseBody: Swift.Equatable {
    let contextKeyNames: [Swift.String]?
}

extension GetContextKeysForCustomPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextKeyNames = "ContextKeyNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetContextKeysForCustomPolicyResult"))
        if containerValues.contains(.contextKeyNames) {
            struct KeyVal0{struct member{}}
            let contextKeyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .contextKeyNames)
            if let contextKeyNamesWrappedContainer = contextKeyNamesWrappedContainer {
                let contextKeyNamesContainer = try contextKeyNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var contextKeyNamesBuffer:[Swift.String]? = nil
                if let contextKeyNamesContainer = contextKeyNamesContainer {
                    contextKeyNamesBuffer = [Swift.String]()
                    for stringContainer0 in contextKeyNamesContainer {
                        contextKeyNamesBuffer?.append(stringContainer0)
                    }
                }
                contextKeyNames = contextKeyNamesBuffer
            } else {
                contextKeyNames = []
            }
        } else {
            contextKeyNames = nil
        }
    }
}

extension GetContextKeysForPrincipalPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyInputList = policyInputList {
            if !policyInputList.isEmpty {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                for (index0, policydocumenttype0) in policyInputList.enumerated() {
                    try policyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                try policyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policySourceArn = policySourceArn {
            try container.encode(policySourceArn, forKey: ClientRuntime.Key("PolicySourceArn"))
        }
        try container.encode("GetContextKeysForPrincipalPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetContextKeysForPrincipalPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetContextKeysForPrincipalPolicyInput: Swift.Equatable {
    /// An optional list of additional policies for which you want the list of context keys that are referenced. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var policyInputList: [Swift.String]?
    /// The ARN of a user, group, or role whose policies contain the context keys that you want listed. If you specify a user, the list includes context keys that are found in all policies that are attached to the user. The list also includes all groups that the user is a member of. If you pick a group or a role, then it includes only those context keys that are found in policies attached to that entity. Note that all parameters are shown in unencoded form here for clarity, but must be URL encoded to be included as a part of a real HTML request. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policySourceArn: Swift.String?

    public init (
        policyInputList: [Swift.String]? = nil,
        policySourceArn: Swift.String? = nil
    )
    {
        self.policyInputList = policyInputList
        self.policySourceArn = policySourceArn
    }
}

struct GetContextKeysForPrincipalPolicyInputBody: Swift.Equatable {
    let policySourceArn: Swift.String?
    let policyInputList: [Swift.String]?
}

extension GetContextKeysForPrincipalPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyInputList = "PolicyInputList"
        case policySourceArn = "PolicySourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policySourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policySourceArn)
        policySourceArn = policySourceArnDecoded
        if containerValues.contains(.policyInputList) {
            struct KeyVal0{struct member{}}
            let policyInputListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyInputList)
            if let policyInputListWrappedContainer = policyInputListWrappedContainer {
                let policyInputListContainer = try policyInputListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyInputListBuffer:[Swift.String]? = nil
                if let policyInputListContainer = policyInputListContainer {
                    policyInputListBuffer = [Swift.String]()
                    for stringContainer0 in policyInputListContainer {
                        policyInputListBuffer?.append(stringContainer0)
                    }
                }
                policyInputList = policyInputListBuffer
            } else {
                policyInputList = []
            }
        } else {
            policyInputList = nil
        }
    }
}

extension GetContextKeysForPrincipalPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetContextKeysForPrincipalPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetContextKeysForPrincipalPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContextKeysForPrincipalPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetContextKeysForPrincipalPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contextKeyNames = output.contextKeyNames
        } else {
            self.contextKeyNames = nil
        }
    }
}

/// Contains the response to a successful [GetContextKeysForPrincipalPolicy] or [GetContextKeysForCustomPolicy] request.
public struct GetContextKeysForPrincipalPolicyOutputResponse: Swift.Equatable {
    /// The list of context keys that are referenced in the input policies.
    public var contextKeyNames: [Swift.String]?

    public init (
        contextKeyNames: [Swift.String]? = nil
    )
    {
        self.contextKeyNames = contextKeyNames
    }
}

struct GetContextKeysForPrincipalPolicyOutputResponseBody: Swift.Equatable {
    let contextKeyNames: [Swift.String]?
}

extension GetContextKeysForPrincipalPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextKeyNames = "ContextKeyNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetContextKeysForPrincipalPolicyResult"))
        if containerValues.contains(.contextKeyNames) {
            struct KeyVal0{struct member{}}
            let contextKeyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .contextKeyNames)
            if let contextKeyNamesWrappedContainer = contextKeyNamesWrappedContainer {
                let contextKeyNamesContainer = try contextKeyNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var contextKeyNamesBuffer:[Swift.String]? = nil
                if let contextKeyNamesContainer = contextKeyNamesContainer {
                    contextKeyNamesBuffer = [Swift.String]()
                    for stringContainer0 in contextKeyNamesContainer {
                        contextKeyNamesBuffer?.append(stringContainer0)
                    }
                }
                contextKeyNames = contextKeyNamesBuffer
            } else {
                contextKeyNames = []
            }
        } else {
            contextKeyNames = nil
        }
    }
}

extension GetCredentialReportInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GetCredentialReport", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetCredentialReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCredentialReportInput: Swift.Equatable {

    public init () { }
}

extension GetCredentialReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCredentialReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ReportExpired" : self = .credentialReportExpiredException(try CredentialReportExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReportNotPresent" : self = .credentialReportNotPresentException(try CredentialReportNotPresentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReportInProgress" : self = .credentialReportNotReadyException(try CredentialReportNotReadyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCredentialReportOutputError: Swift.Error, Swift.Equatable {
    case credentialReportExpiredException(CredentialReportExpiredException)
    case credentialReportNotPresentException(CredentialReportNotPresentException)
    case credentialReportNotReadyException(CredentialReportNotReadyException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCredentialReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCredentialReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
            self.generatedTime = output.generatedTime
            self.reportFormat = output.reportFormat
        } else {
            self.content = nil
            self.generatedTime = nil
            self.reportFormat = nil
        }
    }
}

/// Contains the response to a successful [GetCredentialReport] request.
public struct GetCredentialReportOutputResponse: Swift.Equatable {
    /// Contains the credential report. The report is Base64-encoded.
    public var content: ClientRuntime.Data?
    /// The date and time when the credential report was created, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601).
    public var generatedTime: ClientRuntime.Date?
    /// The format (MIME type) of the credential report.
    public var reportFormat: IAMClientTypes.ReportFormatType?

    public init (
        content: ClientRuntime.Data? = nil,
        generatedTime: ClientRuntime.Date? = nil,
        reportFormat: IAMClientTypes.ReportFormatType? = nil
    )
    {
        self.content = content
        self.generatedTime = generatedTime
        self.reportFormat = reportFormat
    }
}

struct GetCredentialReportOutputResponseBody: Swift.Equatable {
    let content: ClientRuntime.Data?
    let reportFormat: IAMClientTypes.ReportFormatType?
    let generatedTime: ClientRuntime.Date?
}

extension GetCredentialReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case generatedTime = "GeneratedTime"
        case reportFormat = "ReportFormat"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetCredentialReportResult"))
        if containerValues.contains(.content) {
            do {
                let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
                content = contentDecoded
            } catch {
                content = "".data(using: .utf8)
            }
        } else {
            content = nil
        }
        let reportFormatDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ReportFormatType.self, forKey: .reportFormat)
        reportFormat = reportFormatDecoded
        let generatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .generatedTime)
        generatedTime = generatedTimeDecoded
    }
}

extension GetGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("GetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetGroupInput: Swift.Equatable {
    /// The name of the group. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init (
        groupName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.groupName = groupName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct GetGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension GetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension GetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetGroupOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.group = output.group
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.users = output.users
        } else {
            self.group = nil
            self.isTruncated = false
            self.marker = nil
            self.users = nil
        }
    }
}

/// Contains the response to a successful [GetGroup] request.
public struct GetGroupOutputResponse: Swift.Equatable {
    /// A structure that contains details about the group.
    /// This member is required.
    public var group: IAMClientTypes.Group?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of users in the group.
    /// This member is required.
    public var users: [IAMClientTypes.User]?

    public init (
        group: IAMClientTypes.Group? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        users: [IAMClientTypes.User]? = nil
    )
    {
        self.group = group
        self.isTruncated = isTruncated
        self.marker = marker
        self.users = users
    }
}

struct GetGroupOutputResponseBody: Swift.Equatable {
    let group: IAMClientTypes.Group?
    let users: [IAMClientTypes.User]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension GetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case users = "Users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetGroupResult"))
        let groupDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Group.self, forKey: .group)
        group = groupDecoded
        if containerValues.contains(.users) {
            struct KeyVal0{struct member{}}
            let usersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .users)
            if let usersWrappedContainer = usersWrappedContainer {
                let usersContainer = try usersWrappedContainer.decodeIfPresent([IAMClientTypes.User].self, forKey: .member)
                var usersBuffer:[IAMClientTypes.User]? = nil
                if let usersContainer = usersContainer {
                    usersBuffer = [IAMClientTypes.User]()
                    for structureContainer0 in usersContainer {
                        usersBuffer?.append(structureContainer0)
                    }
                }
                users = usersBuffer
            } else {
                users = []
            }
        } else {
            users = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension GetGroupPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        try container.encode("GetGroupPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetGroupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetGroupPolicyInput: Swift.Equatable {
    /// The name of the group the policy is associated with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the policy document to get. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?

    public init (
        groupName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyName = policyName
    }
}

struct GetGroupPolicyInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let policyName: Swift.String?
}

extension GetGroupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyName = "PolicyName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension GetGroupPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetGroupPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetGroupPolicyOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetGroupPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupName = output.groupName
            self.policyDocument = output.policyDocument
            self.policyName = output.policyName
        } else {
            self.groupName = nil
            self.policyDocument = nil
            self.policyName = nil
        }
    }
}

/// Contains the response to a successful [GetGroupPolicy] request.
public struct GetGroupPolicyOutputResponse: Swift.Equatable {
    /// The group the policy is associated with.
    /// This member is required.
    public var groupName: Swift.String?
    /// The policy document. IAM stores policies in JSON format. However, resources that were created using CloudFormation templates can be formatted in YAML. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?

    public init (
        groupName: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyDocument = policyDocument
        self.policyName = policyName
    }
}

struct GetGroupPolicyOutputResponseBody: Swift.Equatable {
    let groupName: Swift.String?
    let policyName: Swift.String?
    let policyDocument: Swift.String?
}

extension GetGroupPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetGroupPolicyResult"))
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension GetInstanceProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        try container.encode("GetInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetInstanceProfileInput: Swift.Equatable {
    /// The name of the instance profile to get information about. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?

    public init (
        instanceProfileName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
    }
}

struct GetInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
}

extension GetInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
    }
}

extension GetInstanceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetInstanceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

extension GetInstanceProfileOutputError: WaiterTypedError {

    /// The Smithy identifier, without namespace, for the type of this error, or `nil` if the
    /// error has no known type.
    public var waiterErrorType: String? {
        switch self {
        case .noSuchEntityException: return "NoSuchEntity"
        case .serviceFailureException: return "ServiceFailure"
        case .unknown(let error): return error.waiterErrorType
        }
    }
}

public enum GetInstanceProfileOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInstanceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetInstanceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

/// Contains the response to a successful [GetInstanceProfile] request.
public struct GetInstanceProfileOutputResponse: Swift.Equatable {
    /// A structure containing details about the instance profile.
    /// This member is required.
    public var instanceProfile: IAMClientTypes.InstanceProfile?

    public init (
        instanceProfile: IAMClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct GetInstanceProfileOutputResponseBody: Swift.Equatable {
    let instanceProfile: IAMClientTypes.InstanceProfile?
}

extension GetInstanceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfile = "InstanceProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetInstanceProfileResult"))
        let instanceProfileDecoded = try containerValues.decodeIfPresent(IAMClientTypes.InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

extension GetLoginProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("GetLoginProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetLoginProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetLoginProfileInput: Swift.Equatable {
    /// The name of the user whose login profile you want to retrieve. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

struct GetLoginProfileInputBody: Swift.Equatable {
    let userName: Swift.String?
}

extension GetLoginProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension GetLoginProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetLoginProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetLoginProfileOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLoginProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetLoginProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loginProfile = output.loginProfile
        } else {
            self.loginProfile = nil
        }
    }
}

/// Contains the response to a successful [GetLoginProfile] request.
public struct GetLoginProfileOutputResponse: Swift.Equatable {
    /// A structure containing the user name and the profile creation date for the user.
    /// This member is required.
    public var loginProfile: IAMClientTypes.LoginProfile?

    public init (
        loginProfile: IAMClientTypes.LoginProfile? = nil
    )
    {
        self.loginProfile = loginProfile
    }
}

struct GetLoginProfileOutputResponseBody: Swift.Equatable {
    let loginProfile: IAMClientTypes.LoginProfile?
}

extension GetLoginProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loginProfile = "LoginProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetLoginProfileResult"))
        let loginProfileDecoded = try containerValues.decodeIfPresent(IAMClientTypes.LoginProfile.self, forKey: .loginProfile)
        loginProfile = loginProfileDecoded
    }
}

extension GetOpenIDConnectProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        try container.encode("GetOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetOpenIDConnectProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetOpenIDConnectProviderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the OIDC provider resource object in IAM to get information for. You can get a list of OIDC provider resource ARNs by using the [ListOpenIDConnectProviders] operation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init (
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

struct GetOpenIDConnectProviderInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
}

extension GetOpenIDConnectProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
    }
}

extension GetOpenIDConnectProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetOpenIDConnectProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetOpenIDConnectProviderOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpenIDConnectProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetOpenIDConnectProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientIDList = output.clientIDList
            self.createDate = output.createDate
            self.tags = output.tags
            self.thumbprintList = output.thumbprintList
            self.url = output.url
        } else {
            self.clientIDList = nil
            self.createDate = nil
            self.tags = nil
            self.thumbprintList = nil
            self.url = nil
        }
    }
}

/// Contains the response to a successful [GetOpenIDConnectProvider] request.
public struct GetOpenIDConnectProviderOutputResponse: Swift.Equatable {
    /// A list of client IDs (also known as audiences) that are associated with the specified IAM OIDC provider resource object. For more information, see [CreateOpenIDConnectProvider].
    public var clientIDList: [Swift.String]?
    /// The date and time when the IAM OIDC provider resource object was created in the Amazon Web Services account.
    public var createDate: ClientRuntime.Date?
    /// A list of tags that are attached to the specified IAM OIDC provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?
    /// A list of certificate thumbprints that are associated with the specified IAM OIDC provider resource object. For more information, see [CreateOpenIDConnectProvider].
    public var thumbprintList: [Swift.String]?
    /// The URL that the IAM OIDC provider resource object is associated with. For more information, see [CreateOpenIDConnectProvider].
    public var url: Swift.String?

    public init (
        clientIDList: [Swift.String]? = nil,
        createDate: ClientRuntime.Date? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        thumbprintList: [Swift.String]? = nil,
        url: Swift.String? = nil
    )
    {
        self.clientIDList = clientIDList
        self.createDate = createDate
        self.tags = tags
        self.thumbprintList = thumbprintList
        self.url = url
    }
}

struct GetOpenIDConnectProviderOutputResponseBody: Swift.Equatable {
    let url: Swift.String?
    let clientIDList: [Swift.String]?
    let thumbprintList: [Swift.String]?
    let createDate: ClientRuntime.Date?
    let tags: [IAMClientTypes.Tag]?
}

extension GetOpenIDConnectProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIDList = "ClientIDList"
        case createDate = "CreateDate"
        case tags = "Tags"
        case thumbprintList = "ThumbprintList"
        case url = "Url"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetOpenIDConnectProviderResult"))
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        if containerValues.contains(.clientIDList) {
            struct KeyVal0{struct member{}}
            let clientIDListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .clientIDList)
            if let clientIDListWrappedContainer = clientIDListWrappedContainer {
                let clientIDListContainer = try clientIDListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var clientIDListBuffer:[Swift.String]? = nil
                if let clientIDListContainer = clientIDListContainer {
                    clientIDListBuffer = [Swift.String]()
                    for stringContainer0 in clientIDListContainer {
                        clientIDListBuffer?.append(stringContainer0)
                    }
                }
                clientIDList = clientIDListBuffer
            } else {
                clientIDList = []
            }
        } else {
            clientIDList = nil
        }
        if containerValues.contains(.thumbprintList) {
            struct KeyVal0{struct member{}}
            let thumbprintListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .thumbprintList)
            if let thumbprintListWrappedContainer = thumbprintListWrappedContainer {
                let thumbprintListContainer = try thumbprintListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var thumbprintListBuffer:[Swift.String]? = nil
                if let thumbprintListContainer = thumbprintListContainer {
                    thumbprintListBuffer = [Swift.String]()
                    for stringContainer0 in thumbprintListContainer {
                        thumbprintListBuffer?.append(stringContainer0)
                    }
                }
                thumbprintList = thumbprintListBuffer
            } else {
                thumbprintList = []
            }
        } else {
            thumbprintList = nil
        }
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension GetOrganizationsAccessReportInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let jobId = jobId {
            try container.encode(jobId, forKey: ClientRuntime.Key("JobId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let sortKey = sortKey {
            try container.encode(sortKey, forKey: ClientRuntime.Key("SortKey"))
        }
        try container.encode("GetOrganizationsAccessReport", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetOrganizationsAccessReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetOrganizationsAccessReportInput: Swift.Equatable {
    /// The identifier of the request generated by the [GenerateOrganizationsAccessReport] operation.
    /// This member is required.
    public var jobId: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The key that is used to sort the results. If you choose the namespace key, the results are returned in alphabetical order. If you choose the time key, the results are sorted numerically by the date and time.
    public var sortKey: IAMClientTypes.SortKeyType?

    public init (
        jobId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        sortKey: IAMClientTypes.SortKeyType? = nil
    )
    {
        self.jobId = jobId
        self.marker = marker
        self.maxItems = maxItems
        self.sortKey = sortKey
    }
}

struct GetOrganizationsAccessReportInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let maxItems: Swift.Int?
    let marker: Swift.String?
    let sortKey: IAMClientTypes.SortKeyType?
}

extension GetOrganizationsAccessReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case sortKey = "SortKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let sortKeyDecoded = try containerValues.decodeIfPresent(IAMClientTypes.SortKeyType.self, forKey: .sortKey)
        sortKey = sortKeyDecoded
    }
}

extension GetOrganizationsAccessReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetOrganizationsAccessReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetOrganizationsAccessReportOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOrganizationsAccessReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetOrganizationsAccessReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessDetails = output.accessDetails
            self.errorDetails = output.errorDetails
            self.isTruncated = output.isTruncated
            self.jobCompletionDate = output.jobCompletionDate
            self.jobCreationDate = output.jobCreationDate
            self.jobStatus = output.jobStatus
            self.marker = output.marker
            self.numberOfServicesAccessible = output.numberOfServicesAccessible
            self.numberOfServicesNotAccessed = output.numberOfServicesNotAccessed
        } else {
            self.accessDetails = nil
            self.errorDetails = nil
            self.isTruncated = false
            self.jobCompletionDate = nil
            self.jobCreationDate = nil
            self.jobStatus = nil
            self.marker = nil
            self.numberOfServicesAccessible = nil
            self.numberOfServicesNotAccessed = nil
        }
    }
}

public struct GetOrganizationsAccessReportOutputResponse: Swift.Equatable {
    /// An object that contains details about the most recent attempt to access the service.
    public var accessDetails: [IAMClientTypes.AccessDetail]?
    /// Contains information about the reason that the operation failed. This data type is used as a response element in the [GetOrganizationsAccessReport], [GetServiceLastAccessedDetails], and [GetServiceLastAccessedDetailsWithEntities] operations.
    public var errorDetails: IAMClientTypes.ErrorDetails?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the generated report job was completed or failed. This field is null if the job is still in progress, as indicated by a job status value of IN_PROGRESS.
    public var jobCompletionDate: ClientRuntime.Date?
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the report job was created.
    /// This member is required.
    public var jobCreationDate: ClientRuntime.Date?
    /// The status of the job.
    /// This member is required.
    public var jobStatus: IAMClientTypes.JobStatusType?
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The number of services that the applicable SCPs allow account principals to access.
    public var numberOfServicesAccessible: Swift.Int?
    /// The number of services that account principals are allowed but did not attempt to access.
    public var numberOfServicesNotAccessed: Swift.Int?

    public init (
        accessDetails: [IAMClientTypes.AccessDetail]? = nil,
        errorDetails: IAMClientTypes.ErrorDetails? = nil,
        isTruncated: Swift.Bool = false,
        jobCompletionDate: ClientRuntime.Date? = nil,
        jobCreationDate: ClientRuntime.Date? = nil,
        jobStatus: IAMClientTypes.JobStatusType? = nil,
        marker: Swift.String? = nil,
        numberOfServicesAccessible: Swift.Int? = nil,
        numberOfServicesNotAccessed: Swift.Int? = nil
    )
    {
        self.accessDetails = accessDetails
        self.errorDetails = errorDetails
        self.isTruncated = isTruncated
        self.jobCompletionDate = jobCompletionDate
        self.jobCreationDate = jobCreationDate
        self.jobStatus = jobStatus
        self.marker = marker
        self.numberOfServicesAccessible = numberOfServicesAccessible
        self.numberOfServicesNotAccessed = numberOfServicesNotAccessed
    }
}

struct GetOrganizationsAccessReportOutputResponseBody: Swift.Equatable {
    let jobStatus: IAMClientTypes.JobStatusType?
    let jobCreationDate: ClientRuntime.Date?
    let jobCompletionDate: ClientRuntime.Date?
    let numberOfServicesAccessible: Swift.Int?
    let numberOfServicesNotAccessed: Swift.Int?
    let accessDetails: [IAMClientTypes.AccessDetail]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
    let errorDetails: IAMClientTypes.ErrorDetails?
}

extension GetOrganizationsAccessReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessDetails = "AccessDetails"
        case errorDetails = "ErrorDetails"
        case isTruncated = "IsTruncated"
        case jobCompletionDate = "JobCompletionDate"
        case jobCreationDate = "JobCreationDate"
        case jobStatus = "JobStatus"
        case marker = "Marker"
        case numberOfServicesAccessible = "NumberOfServicesAccessible"
        case numberOfServicesNotAccessed = "NumberOfServicesNotAccessed"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetOrganizationsAccessReportResult"))
        let jobStatusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.JobStatusType.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .jobCreationDate)
        jobCreationDate = jobCreationDateDecoded
        let jobCompletionDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .jobCompletionDate)
        jobCompletionDate = jobCompletionDateDecoded
        let numberOfServicesAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfServicesAccessible)
        numberOfServicesAccessible = numberOfServicesAccessibleDecoded
        let numberOfServicesNotAccessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfServicesNotAccessed)
        numberOfServicesNotAccessed = numberOfServicesNotAccessedDecoded
        if containerValues.contains(.accessDetails) {
            struct KeyVal0{struct member{}}
            let accessDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accessDetails)
            if let accessDetailsWrappedContainer = accessDetailsWrappedContainer {
                let accessDetailsContainer = try accessDetailsWrappedContainer.decodeIfPresent([IAMClientTypes.AccessDetail].self, forKey: .member)
                var accessDetailsBuffer:[IAMClientTypes.AccessDetail]? = nil
                if let accessDetailsContainer = accessDetailsContainer {
                    accessDetailsBuffer = [IAMClientTypes.AccessDetail]()
                    for structureContainer0 in accessDetailsContainer {
                        accessDetailsBuffer?.append(structureContainer0)
                    }
                }
                accessDetails = accessDetailsBuffer
            } else {
                accessDetails = []
            }
        } else {
            accessDetails = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
    }
}

extension GetPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("GetPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the managed policy that you want information about. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init (
        policyArn: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

struct GetPolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
}

extension GetPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension GetPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

extension GetPolicyOutputError: WaiterTypedError {

    /// The Smithy identifier, without namespace, for the type of this error, or `nil` if the
    /// error has no known type.
    public var waiterErrorType: String? {
        switch self {
        case .invalidInputException: return "InvalidInput"
        case .noSuchEntityException: return "NoSuchEntity"
        case .serviceFailureException: return "ServiceFailure"
        case .unknown(let error): return error.waiterErrorType
        }
    }
}

public enum GetPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

/// Contains the response to a successful [GetPolicy] request.
public struct GetPolicyOutputResponse: Swift.Equatable {
    /// A structure containing details about the policy.
    public var policy: IAMClientTypes.Policy?

    public init (
        policy: IAMClientTypes.Policy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetPolicyOutputResponseBody: Swift.Equatable {
    let policy: IAMClientTypes.Policy?
}

extension GetPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetPolicyResult"))
        let policyDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Policy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetPolicyVersionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
        try container.encode("GetPolicyVersion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetPolicyVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPolicyVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the managed policy that you want information about. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// Identifies the policy version to retrieve. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consists of the lowercase letter 'v' followed by one or two digits, and optionally followed by a period '.' and a string of letters and digits.
    /// This member is required.
    public var versionId: Swift.String?

    public init (
        policyArn: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.versionId = versionId
    }
}

struct GetPolicyVersionInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let versionId: Swift.String?
}

extension GetPolicyVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension GetPolicyVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPolicyVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPolicyVersionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPolicyVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyVersion = output.policyVersion
        } else {
            self.policyVersion = nil
        }
    }
}

/// Contains the response to a successful [GetPolicyVersion] request.
public struct GetPolicyVersionOutputResponse: Swift.Equatable {
    /// A structure containing details about the policy version.
    public var policyVersion: IAMClientTypes.PolicyVersion?

    public init (
        policyVersion: IAMClientTypes.PolicyVersion? = nil
    )
    {
        self.policyVersion = policyVersion
    }
}

struct GetPolicyVersionOutputResponseBody: Swift.Equatable {
    let policyVersion: IAMClientTypes.PolicyVersion?
}

extension GetPolicyVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyVersion = "PolicyVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetPolicyVersionResult"))
        let policyVersionDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyVersion.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
    }
}

extension GetRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("GetRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRoleInput: Swift.Equatable {
    /// The name of the IAM role to get information about. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

struct GetRoleInputBody: Swift.Equatable {
    let roleName: Swift.String?
}

extension GetRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension GetRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

extension GetRoleOutputError: WaiterTypedError {

    /// The Smithy identifier, without namespace, for the type of this error, or `nil` if the
    /// error has no known type.
    public var waiterErrorType: String? {
        switch self {
        case .noSuchEntityException: return "NoSuchEntity"
        case .serviceFailureException: return "ServiceFailure"
        case .unknown(let error): return error.waiterErrorType
        }
    }
}

public enum GetRoleOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRoleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.role = output.role
        } else {
            self.role = nil
        }
    }
}

/// Contains the response to a successful [GetRole] request.
public struct GetRoleOutputResponse: Swift.Equatable {
    /// A structure containing details about the IAM role.
    /// This member is required.
    public var role: IAMClientTypes.Role?

    public init (
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

struct GetRoleOutputResponseBody: Swift.Equatable {
    let role: IAMClientTypes.Role?
}

extension GetRoleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetRoleResult"))
        let roleDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Role.self, forKey: .role)
        role = roleDecoded
    }
}

extension GetRolePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("GetRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetRolePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRolePolicyInput: Swift.Equatable {
    /// The name of the policy document to get. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the role associated with the policy. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.roleName = roleName
    }
}

struct GetRolePolicyInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let policyName: Swift.String?
}

extension GetRolePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension GetRolePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetRolePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRolePolicyOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRolePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRolePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyDocument = output.policyDocument
            self.policyName = output.policyName
            self.roleName = output.roleName
        } else {
            self.policyDocument = nil
            self.policyName = nil
            self.roleName = nil
        }
    }
}

/// Contains the response to a successful [GetRolePolicy] request.
public struct GetRolePolicyOutputResponse: Swift.Equatable {
    /// The policy document. IAM stores policies in JSON format. However, resources that were created using CloudFormation templates can be formatted in YAML. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?
    /// The role the policy is associated with.
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.roleName = roleName
    }
}

struct GetRolePolicyOutputResponseBody: Swift.Equatable {
    let roleName: Swift.String?
    let policyName: Swift.String?
    let policyDocument: Swift.String?
}

extension GetRolePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetRolePolicyResult"))
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension GetSAMLProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        try container.encode("GetSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetSAMLProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSAMLProviderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the SAML provider resource object in IAM to get information about. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init (
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
    }
}

struct GetSAMLProviderInputBody: Swift.Equatable {
    let samlProviderArn: Swift.String?
}

extension GetSAMLProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
    }
}

extension GetSAMLProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSAMLProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSAMLProviderOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSAMLProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSAMLProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createDate = output.createDate
            self.samlMetadataDocument = output.samlMetadataDocument
            self.tags = output.tags
            self.validUntil = output.validUntil
        } else {
            self.createDate = nil
            self.samlMetadataDocument = nil
            self.tags = nil
            self.validUntil = nil
        }
    }
}

/// Contains the response to a successful [GetSAMLProvider] request.
public struct GetSAMLProviderOutputResponse: Swift.Equatable {
    /// The date and time when the SAML provider was created.
    public var createDate: ClientRuntime.Date?
    /// The XML metadata document that includes information about an identity provider.
    public var samlMetadataDocument: Swift.String?
    /// A list of tags that are attached to the specified IAM SAML provider. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?
    /// The expiration date and time for the SAML provider.
    public var validUntil: ClientRuntime.Date?

    public init (
        createDate: ClientRuntime.Date? = nil,
        samlMetadataDocument: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil,
        validUntil: ClientRuntime.Date? = nil
    )
    {
        self.createDate = createDate
        self.samlMetadataDocument = samlMetadataDocument
        self.tags = tags
        self.validUntil = validUntil
    }
}

struct GetSAMLProviderOutputResponseBody: Swift.Equatable {
    let samlMetadataDocument: Swift.String?
    let createDate: ClientRuntime.Date?
    let validUntil: ClientRuntime.Date?
    let tags: [IAMClientTypes.Tag]?
}

extension GetSAMLProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case samlMetadataDocument = "SAMLMetadataDocument"
        case tags = "Tags"
        case validUntil = "ValidUntil"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetSAMLProviderResult"))
        let samlMetadataDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlMetadataDocument)
        samlMetadataDocument = samlMetadataDocumentDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let validUntilDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .validUntil)
        validUntil = validUntilDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension GetSSHPublicKeyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let encoding = encoding {
            try container.encode(encoding, forKey: ClientRuntime.Key("Encoding"))
        }
        if let sshPublicKeyId = sshPublicKeyId {
            try container.encode(sshPublicKeyId, forKey: ClientRuntime.Key("SSHPublicKeyId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("GetSSHPublicKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetSSHPublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSSHPublicKeyInput: Swift.Equatable {
    /// Specifies the public key encoding format to use in the response. To retrieve the public key in ssh-rsa format, use SSH. To retrieve the public key in PEM format, use PEM.
    /// This member is required.
    public var encoding: IAMClientTypes.EncodingType?
    /// The unique identifier for the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// The name of the IAM user associated with the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        encoding: IAMClientTypes.EncodingType? = nil,
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.encoding = encoding
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

struct GetSSHPublicKeyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let sshPublicKeyId: Swift.String?
    let encoding: IAMClientTypes.EncodingType?
}

extension GetSSHPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encoding = "Encoding"
        case sshPublicKeyId = "SSHPublicKeyId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let encodingDecoded = try containerValues.decodeIfPresent(IAMClientTypes.EncodingType.self, forKey: .encoding)
        encoding = encodingDecoded
    }
}

extension GetSSHPublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSSHPublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnrecognizedPublicKeyEncoding" : self = .unrecognizedPublicKeyEncodingException(try UnrecognizedPublicKeyEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSSHPublicKeyOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unrecognizedPublicKeyEncodingException(UnrecognizedPublicKeyEncodingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSSHPublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSSHPublicKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sshPublicKey = output.sshPublicKey
        } else {
            self.sshPublicKey = nil
        }
    }
}

/// Contains the response to a successful [GetSSHPublicKey] request.
public struct GetSSHPublicKeyOutputResponse: Swift.Equatable {
    /// A structure containing details about the SSH public key.
    public var sshPublicKey: IAMClientTypes.SSHPublicKey?

    public init (
        sshPublicKey: IAMClientTypes.SSHPublicKey? = nil
    )
    {
        self.sshPublicKey = sshPublicKey
    }
}

struct GetSSHPublicKeyOutputResponseBody: Swift.Equatable {
    let sshPublicKey: IAMClientTypes.SSHPublicKey?
}

extension GetSSHPublicKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKey = "SSHPublicKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetSSHPublicKeyResult"))
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(IAMClientTypes.SSHPublicKey.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension GetServerCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        try container.encode("GetServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetServerCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServerCertificateInput: Swift.Equatable {
    /// The name of the server certificate you want to retrieve information about. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init (
        serverCertificateName: Swift.String? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
    }
}

struct GetServerCertificateInputBody: Swift.Equatable {
    let serverCertificateName: Swift.String?
}

extension GetServerCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificateName = "ServerCertificateName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
    }
}

extension GetServerCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetServerCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetServerCertificateOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServerCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetServerCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverCertificate = output.serverCertificate
        } else {
            self.serverCertificate = nil
        }
    }
}

/// Contains the response to a successful [GetServerCertificate] request.
public struct GetServerCertificateOutputResponse: Swift.Equatable {
    /// A structure containing details about the server certificate.
    /// This member is required.
    public var serverCertificate: IAMClientTypes.ServerCertificate?

    public init (
        serverCertificate: IAMClientTypes.ServerCertificate? = nil
    )
    {
        self.serverCertificate = serverCertificate
    }
}

struct GetServerCertificateOutputResponseBody: Swift.Equatable {
    let serverCertificate: IAMClientTypes.ServerCertificate?
}

extension GetServerCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificate = "ServerCertificate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetServerCertificateResult"))
        let serverCertificateDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ServerCertificate.self, forKey: .serverCertificate)
        serverCertificate = serverCertificateDecoded
    }
}

extension GetServiceLastAccessedDetailsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let jobId = jobId {
            try container.encode(jobId, forKey: ClientRuntime.Key("JobId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("GetServiceLastAccessedDetails", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetServiceLastAccessedDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceLastAccessedDetailsInput: Swift.Equatable {
    /// The ID of the request generated by the [GenerateServiceLastAccessedDetails] operation. The JobId returned by GenerateServiceLastAccessedDetail must be used by the same role within a session, or by the same user when used to call GetServiceLastAccessedDetail.
    /// This member is required.
    public var jobId: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init (
        jobId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.jobId = jobId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct GetServiceLastAccessedDetailsInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let maxItems: Swift.Int?
    let marker: Swift.String?
}

extension GetServiceLastAccessedDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension GetServiceLastAccessedDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetServiceLastAccessedDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetServiceLastAccessedDetailsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceLastAccessedDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetServiceLastAccessedDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.isTruncated = output.isTruncated
            self.jobCompletionDate = output.jobCompletionDate
            self.jobCreationDate = output.jobCreationDate
            self.jobStatus = output.jobStatus
            self.jobType = output.jobType
            self.marker = output.marker
            self.servicesLastAccessed = output.servicesLastAccessed
        } else {
            self.error = nil
            self.isTruncated = false
            self.jobCompletionDate = nil
            self.jobCreationDate = nil
            self.jobStatus = nil
            self.jobType = nil
            self.marker = nil
            self.servicesLastAccessed = nil
        }
    }
}

public struct GetServiceLastAccessedDetailsOutputResponse: Swift.Equatable {
    /// An object that contains details about the reason the operation failed.
    public var error: IAMClientTypes.ErrorDetails?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the generated report job was completed or failed. This field is null if the job is still in progress, as indicated by a job status value of IN_PROGRESS.
    /// This member is required.
    public var jobCompletionDate: ClientRuntime.Date?
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the report job was created.
    /// This member is required.
    public var jobCreationDate: ClientRuntime.Date?
    /// The status of the job.
    /// This member is required.
    public var jobStatus: IAMClientTypes.JobStatusType?
    /// The type of job. Service jobs return information about when each service was last accessed. Action jobs also include information about when tracked actions within the service were last accessed.
    public var jobType: IAMClientTypes.AccessAdvisorUsageGranularityType?
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A ServiceLastAccessed object that contains details about the most recent attempt to access the service.
    /// This member is required.
    public var servicesLastAccessed: [IAMClientTypes.ServiceLastAccessed]?

    public init (
        error: IAMClientTypes.ErrorDetails? = nil,
        isTruncated: Swift.Bool = false,
        jobCompletionDate: ClientRuntime.Date? = nil,
        jobCreationDate: ClientRuntime.Date? = nil,
        jobStatus: IAMClientTypes.JobStatusType? = nil,
        jobType: IAMClientTypes.AccessAdvisorUsageGranularityType? = nil,
        marker: Swift.String? = nil,
        servicesLastAccessed: [IAMClientTypes.ServiceLastAccessed]? = nil
    )
    {
        self.error = error
        self.isTruncated = isTruncated
        self.jobCompletionDate = jobCompletionDate
        self.jobCreationDate = jobCreationDate
        self.jobStatus = jobStatus
        self.jobType = jobType
        self.marker = marker
        self.servicesLastAccessed = servicesLastAccessed
    }
}

struct GetServiceLastAccessedDetailsOutputResponseBody: Swift.Equatable {
    let jobStatus: IAMClientTypes.JobStatusType?
    let jobType: IAMClientTypes.AccessAdvisorUsageGranularityType?
    let jobCreationDate: ClientRuntime.Date?
    let servicesLastAccessed: [IAMClientTypes.ServiceLastAccessed]?
    let jobCompletionDate: ClientRuntime.Date?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
    let error: IAMClientTypes.ErrorDetails?
}

extension GetServiceLastAccessedDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case isTruncated = "IsTruncated"
        case jobCompletionDate = "JobCompletionDate"
        case jobCreationDate = "JobCreationDate"
        case jobStatus = "JobStatus"
        case jobType = "JobType"
        case marker = "Marker"
        case servicesLastAccessed = "ServicesLastAccessed"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetServiceLastAccessedDetailsResult"))
        let jobStatusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.JobStatusType.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AccessAdvisorUsageGranularityType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let jobCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .jobCreationDate)
        jobCreationDate = jobCreationDateDecoded
        if containerValues.contains(.servicesLastAccessed) {
            struct KeyVal0{struct member{}}
            let servicesLastAccessedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .servicesLastAccessed)
            if let servicesLastAccessedWrappedContainer = servicesLastAccessedWrappedContainer {
                let servicesLastAccessedContainer = try servicesLastAccessedWrappedContainer.decodeIfPresent([IAMClientTypes.ServiceLastAccessed].self, forKey: .member)
                var servicesLastAccessedBuffer:[IAMClientTypes.ServiceLastAccessed]? = nil
                if let servicesLastAccessedContainer = servicesLastAccessedContainer {
                    servicesLastAccessedBuffer = [IAMClientTypes.ServiceLastAccessed]()
                    for structureContainer0 in servicesLastAccessedContainer {
                        servicesLastAccessedBuffer?.append(structureContainer0)
                    }
                }
                servicesLastAccessed = servicesLastAccessedBuffer
            } else {
                servicesLastAccessed = []
            }
        } else {
            servicesLastAccessed = nil
        }
        let jobCompletionDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .jobCompletionDate)
        jobCompletionDate = jobCompletionDateDecoded
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension GetServiceLastAccessedDetailsWithEntitiesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let jobId = jobId {
            try container.encode(jobId, forKey: ClientRuntime.Key("JobId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: ClientRuntime.Key("ServiceNamespace"))
        }
        try container.encode("GetServiceLastAccessedDetailsWithEntities", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetServiceLastAccessedDetailsWithEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceLastAccessedDetailsWithEntitiesInput: Swift.Equatable {
    /// The ID of the request generated by the GenerateServiceLastAccessedDetails operation.
    /// This member is required.
    public var jobId: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The service namespace for an Amazon Web Services service. Provide the service namespace to learn when the IAM entity last attempted to access the specified service. To learn the service namespace for a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the IAM User Guide. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
    /// This member is required.
    public var serviceNamespace: Swift.String?

    public init (
        jobId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        serviceNamespace: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.marker = marker
        self.maxItems = maxItems
        self.serviceNamespace = serviceNamespace
    }
}

struct GetServiceLastAccessedDetailsWithEntitiesInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let serviceNamespace: Swift.String?
    let maxItems: Swift.Int?
    let marker: Swift.String?
}

extension GetServiceLastAccessedDetailsWithEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case serviceNamespace = "ServiceNamespace"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let serviceNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNamespace)
        serviceNamespace = serviceNamespaceDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension GetServiceLastAccessedDetailsWithEntitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetServiceLastAccessedDetailsWithEntitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetServiceLastAccessedDetailsWithEntitiesOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceLastAccessedDetailsWithEntitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetServiceLastAccessedDetailsWithEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entityDetailsList = output.entityDetailsList
            self.error = output.error
            self.isTruncated = output.isTruncated
            self.jobCompletionDate = output.jobCompletionDate
            self.jobCreationDate = output.jobCreationDate
            self.jobStatus = output.jobStatus
            self.marker = output.marker
        } else {
            self.entityDetailsList = nil
            self.error = nil
            self.isTruncated = false
            self.jobCompletionDate = nil
            self.jobCreationDate = nil
            self.jobStatus = nil
            self.marker = nil
        }
    }
}

public struct GetServiceLastAccessedDetailsWithEntitiesOutputResponse: Swift.Equatable {
    /// An EntityDetailsList object that contains details about when an IAM entity (user or role) used group or policy permissions in an attempt to access the specified Amazon Web Services service.
    /// This member is required.
    public var entityDetailsList: [IAMClientTypes.EntityDetails]?
    /// An object that contains details about the reason the operation failed.
    public var error: IAMClientTypes.ErrorDetails?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the generated report job was completed or failed. This field is null if the job is still in progress, as indicated by a job status value of IN_PROGRESS.
    /// This member is required.
    public var jobCompletionDate: ClientRuntime.Date?
    /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the report job was created.
    /// This member is required.
    public var jobCreationDate: ClientRuntime.Date?
    /// The status of the job.
    /// This member is required.
    public var jobStatus: IAMClientTypes.JobStatusType?
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init (
        entityDetailsList: [IAMClientTypes.EntityDetails]? = nil,
        error: IAMClientTypes.ErrorDetails? = nil,
        isTruncated: Swift.Bool = false,
        jobCompletionDate: ClientRuntime.Date? = nil,
        jobCreationDate: ClientRuntime.Date? = nil,
        jobStatus: IAMClientTypes.JobStatusType? = nil,
        marker: Swift.String? = nil
    )
    {
        self.entityDetailsList = entityDetailsList
        self.error = error
        self.isTruncated = isTruncated
        self.jobCompletionDate = jobCompletionDate
        self.jobCreationDate = jobCreationDate
        self.jobStatus = jobStatus
        self.marker = marker
    }
}

struct GetServiceLastAccessedDetailsWithEntitiesOutputResponseBody: Swift.Equatable {
    let jobStatus: IAMClientTypes.JobStatusType?
    let jobCreationDate: ClientRuntime.Date?
    let jobCompletionDate: ClientRuntime.Date?
    let entityDetailsList: [IAMClientTypes.EntityDetails]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
    let error: IAMClientTypes.ErrorDetails?
}

extension GetServiceLastAccessedDetailsWithEntitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityDetailsList = "EntityDetailsList"
        case error = "Error"
        case isTruncated = "IsTruncated"
        case jobCompletionDate = "JobCompletionDate"
        case jobCreationDate = "JobCreationDate"
        case jobStatus = "JobStatus"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetServiceLastAccessedDetailsWithEntitiesResult"))
        let jobStatusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.JobStatusType.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .jobCreationDate)
        jobCreationDate = jobCreationDateDecoded
        let jobCompletionDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .jobCompletionDate)
        jobCompletionDate = jobCompletionDateDecoded
        if containerValues.contains(.entityDetailsList) {
            struct KeyVal0{struct member{}}
            let entityDetailsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .entityDetailsList)
            if let entityDetailsListWrappedContainer = entityDetailsListWrappedContainer {
                let entityDetailsListContainer = try entityDetailsListWrappedContainer.decodeIfPresent([IAMClientTypes.EntityDetails].self, forKey: .member)
                var entityDetailsListBuffer:[IAMClientTypes.EntityDetails]? = nil
                if let entityDetailsListContainer = entityDetailsListContainer {
                    entityDetailsListBuffer = [IAMClientTypes.EntityDetails]()
                    for structureContainer0 in entityDetailsListContainer {
                        entityDetailsListBuffer?.append(structureContainer0)
                    }
                }
                entityDetailsList = entityDetailsListBuffer
            } else {
                entityDetailsList = []
            }
        } else {
            entityDetailsList = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension GetServiceLinkedRoleDeletionStatusInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deletionTaskId = deletionTaskId {
            try container.encode(deletionTaskId, forKey: ClientRuntime.Key("DeletionTaskId"))
        }
        try container.encode("GetServiceLinkedRoleDeletionStatus", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetServiceLinkedRoleDeletionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceLinkedRoleDeletionStatusInput: Swift.Equatable {
    /// The deletion task identifier. This identifier is returned by the [DeleteServiceLinkedRole] operation in the format task/aws-service-role///.
    /// This member is required.
    public var deletionTaskId: Swift.String?

    public init (
        deletionTaskId: Swift.String? = nil
    )
    {
        self.deletionTaskId = deletionTaskId
    }
}

struct GetServiceLinkedRoleDeletionStatusInputBody: Swift.Equatable {
    let deletionTaskId: Swift.String?
}

extension GetServiceLinkedRoleDeletionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionTaskId = "DeletionTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionTaskId)
        deletionTaskId = deletionTaskIdDecoded
    }
}

extension GetServiceLinkedRoleDeletionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetServiceLinkedRoleDeletionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetServiceLinkedRoleDeletionStatusOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceLinkedRoleDeletionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetServiceLinkedRoleDeletionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reason = output.reason
            self.status = output.status
        } else {
            self.reason = nil
            self.status = nil
        }
    }
}

public struct GetServiceLinkedRoleDeletionStatusOutputResponse: Swift.Equatable {
    /// An object that contains details about the reason the deletion failed.
    public var reason: IAMClientTypes.DeletionTaskFailureReasonType?
    /// The status of the deletion.
    /// This member is required.
    public var status: IAMClientTypes.DeletionTaskStatusType?

    public init (
        reason: IAMClientTypes.DeletionTaskFailureReasonType? = nil,
        status: IAMClientTypes.DeletionTaskStatusType? = nil
    )
    {
        self.reason = reason
        self.status = status
    }
}

struct GetServiceLinkedRoleDeletionStatusOutputResponseBody: Swift.Equatable {
    let status: IAMClientTypes.DeletionTaskStatusType?
    let reason: IAMClientTypes.DeletionTaskFailureReasonType?
}

extension GetServiceLinkedRoleDeletionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "Reason"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetServiceLinkedRoleDeletionStatusResult"))
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.DeletionTaskStatusType.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(IAMClientTypes.DeletionTaskFailureReasonType.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension GetUserInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("GetUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetUserInput: Swift.Equatable {
    /// The name of the user to get information about. This parameter is optional. If it is not included, it defaults to the user making the request. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init (
        userName: Swift.String? = nil
    )
    {
        self.userName = userName
    }
}

struct GetUserInputBody: Swift.Equatable {
    let userName: Swift.String?
}

extension GetUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension GetUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

extension GetUserOutputError: WaiterTypedError {

    /// The Smithy identifier, without namespace, for the type of this error, or `nil` if the
    /// error has no known type.
    public var waiterErrorType: String? {
        switch self {
        case .noSuchEntityException: return "NoSuchEntity"
        case .serviceFailureException: return "ServiceFailure"
        case .unknown(let error): return error.waiterErrorType
        }
    }
}

public enum GetUserOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

/// Contains the response to a successful [GetUser] request.
public struct GetUserOutputResponse: Swift.Equatable {
    /// A structure containing details about the IAM user. Due to a service issue, password last used data does not include password use from May 3, 2018 22:50 PDT to May 23, 2018 14:08 PDT. This affects [last sign-in](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_finding-unused.html) dates shown in the IAM console and password last used dates in the [IAM credential report](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_getting-report.html), and returned by this operation. If users signed in during the affected time, the password last used date that is returned is the date the user last signed in before May 3, 2018. For users that signed in after May 23, 2018 14:08 PDT, the returned password last used date is accurate. You can use password last used information to identify unused credentials for deletion. For example, you might delete users who did not sign in to Amazon Web Services in the last 90 days. In cases like this, we recommend that you adjust your evaluation window to include dates after May 23, 2018. Alternatively, if your users use access keys to access Amazon Web Services programmatically you can refer to access key last used information because it is accurate for all dates.
    /// This member is required.
    public var user: IAMClientTypes.User?

    public init (
        user: IAMClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct GetUserOutputResponseBody: Swift.Equatable {
    let user: IAMClientTypes.User?
}

extension GetUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetUserResult"))
        let userDecoded = try containerValues.decodeIfPresent(IAMClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

extension GetUserPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("GetUserPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetUserPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetUserPolicyInput: Swift.Equatable {
    /// The name of the policy document to get. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the user who the policy is associated with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.userName = userName
    }
}

struct GetUserPolicyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let policyName: Swift.String?
}

extension GetUserPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension GetUserPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetUserPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetUserPolicyOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetUserPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyDocument = output.policyDocument
            self.policyName = output.policyName
            self.userName = output.userName
        } else {
            self.policyDocument = nil
            self.policyName = nil
            self.userName = nil
        }
    }
}

/// Contains the response to a successful [GetUserPolicy] request.
public struct GetUserPolicyOutputResponse: Swift.Equatable {
    /// The policy document. IAM stores policies in JSON format. However, resources that were created using CloudFormation templates can be formatted in YAML. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?
    /// The user the policy is associated with.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.userName = userName
    }
}

struct GetUserPolicyOutputResponseBody: Swift.Equatable {
    let userName: Swift.String?
    let policyName: Swift.String?
    let policyDocument: Swift.String?
}

extension GetUserPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetUserPolicyResult"))
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension IAMClientTypes {
    public enum GlobalEndpointTokenVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case v1token
        case v2token
        case sdkUnknown(Swift.String)

        public static var allCases: [GlobalEndpointTokenVersion] {
            return [
                .v1token,
                .v2token,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .v1token: return "v1Token"
            case .v2token: return "v2Token"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GlobalEndpointTokenVersion(rawValue: rawValue) ?? GlobalEndpointTokenVersion.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.Group: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if let groupId = groupId {
            try container.encode(groupId, forKey: ClientRuntime.Key("GroupId"))
        }
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM group entity. This data type is used as a response element in the following operations:
    ///
    /// * [CreateGroup]
    ///
    /// * [GetGroup]
    ///
    /// * [ListGroups]
    public struct Group: Swift.Equatable {
        /// The Amazon Resource Name (ARN) specifying the group. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the group was created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// The stable and unique string identifying the group. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var groupId: Swift.String?
        /// The friendly name that identifies the group.
        /// This member is required.
        public var groupName: Swift.String?
        /// The path to the group. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.groupId = groupId
            self.groupName = groupName
            self.path = path
        }
    }

}

extension IAMClientTypes.GroupDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case groupPolicyList = "GroupPolicyList"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let attachedManagedPolicies = attachedManagedPolicies {
            if !attachedManagedPolicies.isEmpty {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                for (index0, attachedpolicy0) in attachedManagedPolicies.enumerated() {
                    try attachedManagedPoliciesContainer.encode(attachedpolicy0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                try attachedManagedPoliciesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if let groupId = groupId {
            try container.encode(groupId, forKey: ClientRuntime.Key("GroupId"))
        }
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let groupPolicyList = groupPolicyList {
            if !groupPolicyList.isEmpty {
                var groupPolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupPolicyList"))
                for (index0, policydetail0) in groupPolicyList.enumerated() {
                    try groupPolicyListContainer.encode(policydetail0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var groupPolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupPolicyList"))
                try groupPolicyListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        if containerValues.contains(.groupPolicyList) {
            struct KeyVal0{struct member{}}
            let groupPolicyListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groupPolicyList)
            if let groupPolicyListWrappedContainer = groupPolicyListWrappedContainer {
                let groupPolicyListContainer = try groupPolicyListWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyDetail].self, forKey: .member)
                var groupPolicyListBuffer:[IAMClientTypes.PolicyDetail]? = nil
                if let groupPolicyListContainer = groupPolicyListContainer {
                    groupPolicyListBuffer = [IAMClientTypes.PolicyDetail]()
                    for structureContainer0 in groupPolicyListContainer {
                        groupPolicyListBuffer?.append(structureContainer0)
                    }
                }
                groupPolicyList = groupPolicyListBuffer
            } else {
                groupPolicyList = []
            }
        } else {
            groupPolicyList = nil
        }
        if containerValues.contains(.attachedManagedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedManagedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedManagedPolicies)
            if let attachedManagedPoliciesWrappedContainer = attachedManagedPoliciesWrappedContainer {
                let attachedManagedPoliciesContainer = try attachedManagedPoliciesWrappedContainer.decodeIfPresent([IAMClientTypes.AttachedPolicy].self, forKey: .member)
                var attachedManagedPoliciesBuffer:[IAMClientTypes.AttachedPolicy]? = nil
                if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
                    attachedManagedPoliciesBuffer = [IAMClientTypes.AttachedPolicy]()
                    for structureContainer0 in attachedManagedPoliciesContainer {
                        attachedManagedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedManagedPolicies = attachedManagedPoliciesBuffer
            } else {
                attachedManagedPolicies = []
            }
        } else {
            attachedManagedPolicies = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM group, including all of the group's policies. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct GroupDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// A list of the managed policies attached to the group.
        public var attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the group was created.
        public var createDate: ClientRuntime.Date?
        /// The stable and unique string identifying the group. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var groupId: Swift.String?
        /// The friendly name that identifies the group.
        public var groupName: Swift.String?
        /// A list of the inline policies embedded in the group.
        public var groupPolicyList: [IAMClientTypes.PolicyDetail]?
        /// The path to the group. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?

        public init (
            arn: Swift.String? = nil,
            attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
            createDate: ClientRuntime.Date? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            groupPolicyList: [IAMClientTypes.PolicyDetail]? = nil,
            path: Swift.String? = nil
        )
        {
            self.arn = arn
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupId = groupId
            self.groupName = groupName
            self.groupPolicyList = groupPolicyList
            self.path = path
        }
    }

}

extension IAMClientTypes.InstanceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case instanceProfileId = "InstanceProfileId"
        case instanceProfileName = "InstanceProfileName"
        case path = "Path"
        case roles = "Roles"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if let instanceProfileId = instanceProfileId {
            try container.encode(instanceProfileId, forKey: ClientRuntime.Key("InstanceProfileId"))
        }
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let roles = roles {
            if !roles.isEmpty {
                var rolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Roles"))
                for (index0, role0) in roles.enumerated() {
                    try rolesContainer.encode(role0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var rolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Roles"))
                try rolesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let instanceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileId)
        instanceProfileId = instanceProfileIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        if containerValues.contains(.roles) {
            struct KeyVal0{struct member{}}
            let rolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .roles)
            if let rolesWrappedContainer = rolesWrappedContainer {
                let rolesContainer = try rolesWrappedContainer.decodeIfPresent([IAMClientTypes.Role].self, forKey: .member)
                var rolesBuffer:[IAMClientTypes.Role]? = nil
                if let rolesContainer = rolesContainer {
                    rolesBuffer = [IAMClientTypes.Role]()
                    for structureContainer0 in rolesContainer {
                        rolesBuffer?.append(structureContainer0)
                    }
                }
                roles = rolesBuffer
            } else {
                roles = []
            }
        } else {
            roles = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an instance profile. This data type is used as a response element in the following operations:
    ///
    /// * [CreateInstanceProfile]
    ///
    /// * [GetInstanceProfile]
    ///
    /// * [ListInstanceProfiles]
    ///
    /// * [ListInstanceProfilesForRole]
    public struct InstanceProfile: Swift.Equatable {
        /// The Amazon Resource Name (ARN) specifying the instance profile. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date when the instance profile was created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// The stable and unique string identifying the instance profile. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var instanceProfileId: Swift.String?
        /// The name identifying the instance profile.
        /// This member is required.
        public var instanceProfileName: Swift.String?
        /// The path to the instance profile. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?
        /// The role associated with the instance profile.
        /// This member is required.
        public var roles: [IAMClientTypes.Role]?
        /// A list of tags that are attached to the instance profile. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            instanceProfileId: Swift.String? = nil,
            instanceProfileName: Swift.String? = nil,
            path: Swift.String? = nil,
            roles: [IAMClientTypes.Role]? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.instanceProfileId = instanceProfileId
            self.instanceProfileName = instanceProfileName
            self.path = path
            self.roles = roles
            self.tags = tags
        }
    }

}

extension InvalidAuthenticationCodeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidAuthenticationCodeExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the authentication code was not recognized. The error message describes the specific error.
public struct InvalidAuthenticationCodeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAuthenticationCodeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAuthenticationCodeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCertificateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidCertificateExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the certificate is invalid.
public struct InvalidCertificateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCertificateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCertificateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidInputExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because an invalid or out-of-range value was supplied for an input parameter.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPublicKeyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidPublicKeyExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the public key is malformed or otherwise invalid.
public struct InvalidPublicKeyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPublicKeyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPublicKeyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUserTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidUserTypeExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the type of user for the transaction was incorrect.
public struct InvalidUserTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidUserTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidUserTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes {
    public enum JobStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatusType] {
            return [
                .completed,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatusType(rawValue: rawValue) ?? JobStatusType.sdkUnknown(rawValue)
        }
    }
}

extension KeyPairMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<KeyPairMismatchExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the public key certificate and the private key do not match.
public struct KeyPairMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KeyPairMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KeyPairMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<LimitExceededExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it attempted to create resources beyond the current Amazon Web Services account limits. The error message describes the limit exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccessKeysInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListAccessKeys", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListAccessKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccessKeysInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

struct ListAccessKeysInputBody: Swift.Equatable {
    let userName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListAccessKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListAccessKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListAccessKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAccessKeysOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAccessKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessKeyMetadata = output.accessKeyMetadata
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.accessKeyMetadata = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListAccessKeys] request.
public struct ListAccessKeysOutputResponse: Swift.Equatable {
    /// A list of objects containing metadata about the access keys.
    /// This member is required.
    public var accessKeyMetadata: [IAMClientTypes.AccessKeyMetadata]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init (
        accessKeyMetadata: [IAMClientTypes.AccessKeyMetadata]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.accessKeyMetadata = accessKeyMetadata
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListAccessKeysOutputResponseBody: Swift.Equatable {
    let accessKeyMetadata: [IAMClientTypes.AccessKeyMetadata]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListAccessKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyMetadata = "AccessKeyMetadata"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListAccessKeysResult"))
        if containerValues.contains(.accessKeyMetadata) {
            struct KeyVal0{struct member{}}
            let accessKeyMetadataWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accessKeyMetadata)
            if let accessKeyMetadataWrappedContainer = accessKeyMetadataWrappedContainer {
                let accessKeyMetadataContainer = try accessKeyMetadataWrappedContainer.decodeIfPresent([IAMClientTypes.AccessKeyMetadata].self, forKey: .member)
                var accessKeyMetadataBuffer:[IAMClientTypes.AccessKeyMetadata]? = nil
                if let accessKeyMetadataContainer = accessKeyMetadataContainer {
                    accessKeyMetadataBuffer = [IAMClientTypes.AccessKeyMetadata]()
                    for structureContainer0 in accessKeyMetadataContainer {
                        accessKeyMetadataBuffer?.append(structureContainer0)
                    }
                }
                accessKeyMetadata = accessKeyMetadataBuffer
            } else {
                accessKeyMetadata = []
            }
        } else {
            accessKeyMetadata = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListAccountAliasesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("ListAccountAliases", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListAccountAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccountAliasesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListAccountAliasesInputBody: Swift.Equatable {
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListAccountAliasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListAccountAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListAccountAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAccountAliasesOutputError: Swift.Error, Swift.Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAccountAliasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountAliases = output.accountAliases
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.accountAliases = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListAccountAliases] request.
public struct ListAccountAliasesOutputResponse: Swift.Equatable {
    /// A list of aliases associated with the account. Amazon Web Services supports only one alias per account.
    /// This member is required.
    public var accountAliases: [Swift.String]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init (
        accountAliases: [Swift.String]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.accountAliases = accountAliases
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListAccountAliasesOutputResponseBody: Swift.Equatable {
    let accountAliases: [Swift.String]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListAccountAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAliases = "AccountAliases"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListAccountAliasesResult"))
        if containerValues.contains(.accountAliases) {
            struct KeyVal0{struct member{}}
            let accountAliasesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accountAliases)
            if let accountAliasesWrappedContainer = accountAliasesWrappedContainer {
                let accountAliasesContainer = try accountAliasesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var accountAliasesBuffer:[Swift.String]? = nil
                if let accountAliasesContainer = accountAliasesContainer {
                    accountAliasesBuffer = [Swift.String]()
                    for stringContainer0 in accountAliasesContainer {
                        accountAliasesBuffer?.append(stringContainer0)
                    }
                }
                accountAliases = accountAliasesBuffer
            } else {
                accountAliases = []
            }
        } else {
            accountAliases = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListAttachedGroupPoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListAttachedGroupPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListAttachedGroupPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAttachedGroupPoliciesInput: Swift.Equatable {
    /// The name (friendly name, not ARN) of the group to list attached policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init (
        groupName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

struct ListAttachedGroupPoliciesInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListAttachedGroupPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListAttachedGroupPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListAttachedGroupPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAttachedGroupPoliciesOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttachedGroupPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAttachedGroupPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachedPolicies = output.attachedPolicies
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.attachedPolicies = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListAttachedGroupPolicies] request.
public struct ListAttachedGroupPoliciesOutputResponse: Swift.Equatable {
    /// A list of the attached policies.
    public var attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init (
        attachedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.attachedPolicies = attachedPolicies
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListAttachedGroupPoliciesOutputResponseBody: Swift.Equatable {
    let attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListAttachedGroupPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedPolicies = "AttachedPolicies"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListAttachedGroupPoliciesResult"))
        if containerValues.contains(.attachedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedPolicies)
            if let attachedPoliciesWrappedContainer = attachedPoliciesWrappedContainer {
                let attachedPoliciesContainer = try attachedPoliciesWrappedContainer.decodeIfPresent([IAMClientTypes.AttachedPolicy].self, forKey: .member)
                var attachedPoliciesBuffer:[IAMClientTypes.AttachedPolicy]? = nil
                if let attachedPoliciesContainer = attachedPoliciesContainer {
                    attachedPoliciesBuffer = [IAMClientTypes.AttachedPolicy]()
                    for structureContainer0 in attachedPoliciesContainer {
                        attachedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedPolicies = attachedPoliciesBuffer
            } else {
                attachedPolicies = []
            }
        } else {
            attachedPolicies = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListAttachedRolePoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("ListAttachedRolePolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListAttachedRolePoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAttachedRolePoliciesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The name (friendly name, not ARN) of the role to list attached policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
        self.roleName = roleName
    }
}

struct ListAttachedRolePoliciesInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListAttachedRolePoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListAttachedRolePoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListAttachedRolePoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAttachedRolePoliciesOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttachedRolePoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAttachedRolePoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachedPolicies = output.attachedPolicies
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.attachedPolicies = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListAttachedRolePolicies] request.
public struct ListAttachedRolePoliciesOutputResponse: Swift.Equatable {
    /// A list of the attached policies.
    public var attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init (
        attachedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.attachedPolicies = attachedPolicies
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListAttachedRolePoliciesOutputResponseBody: Swift.Equatable {
    let attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListAttachedRolePoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedPolicies = "AttachedPolicies"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListAttachedRolePoliciesResult"))
        if containerValues.contains(.attachedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedPolicies)
            if let attachedPoliciesWrappedContainer = attachedPoliciesWrappedContainer {
                let attachedPoliciesContainer = try attachedPoliciesWrappedContainer.decodeIfPresent([IAMClientTypes.AttachedPolicy].self, forKey: .member)
                var attachedPoliciesBuffer:[IAMClientTypes.AttachedPolicy]? = nil
                if let attachedPoliciesContainer = attachedPoliciesContainer {
                    attachedPoliciesBuffer = [IAMClientTypes.AttachedPolicy]()
                    for structureContainer0 in attachedPoliciesContainer {
                        attachedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedPolicies = attachedPoliciesBuffer
            } else {
                attachedPolicies = []
            }
        } else {
            attachedPolicies = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListAttachedUserPoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListAttachedUserPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListAttachedUserPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAttachedUserPoliciesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The name (friendly name, not ARN) of the user to list attached policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
        self.userName = userName
    }
}

struct ListAttachedUserPoliciesInputBody: Swift.Equatable {
    let userName: Swift.String?
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListAttachedUserPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListAttachedUserPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListAttachedUserPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAttachedUserPoliciesOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttachedUserPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAttachedUserPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachedPolicies = output.attachedPolicies
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.attachedPolicies = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListAttachedUserPolicies] request.
public struct ListAttachedUserPoliciesOutputResponse: Swift.Equatable {
    /// A list of the attached policies.
    public var attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init (
        attachedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.attachedPolicies = attachedPolicies
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListAttachedUserPoliciesOutputResponseBody: Swift.Equatable {
    let attachedPolicies: [IAMClientTypes.AttachedPolicy]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListAttachedUserPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedPolicies = "AttachedPolicies"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListAttachedUserPoliciesResult"))
        if containerValues.contains(.attachedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedPolicies)
            if let attachedPoliciesWrappedContainer = attachedPoliciesWrappedContainer {
                let attachedPoliciesContainer = try attachedPoliciesWrappedContainer.decodeIfPresent([IAMClientTypes.AttachedPolicy].self, forKey: .member)
                var attachedPoliciesBuffer:[IAMClientTypes.AttachedPolicy]? = nil
                if let attachedPoliciesContainer = attachedPoliciesContainer {
                    attachedPoliciesBuffer = [IAMClientTypes.AttachedPolicy]()
                    for structureContainer0 in attachedPoliciesContainer {
                        attachedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedPolicies = attachedPoliciesBuffer
            } else {
                attachedPolicies = []
            }
        } else {
            attachedPolicies = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListEntitiesForPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let entityFilter = entityFilter {
            try container.encode(entityFilter, forKey: ClientRuntime.Key("EntityFilter"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let policyUsageFilter = policyUsageFilter {
            try container.encode(policyUsageFilter, forKey: ClientRuntime.Key("PolicyUsageFilter"))
        }
        try container.encode("ListEntitiesForPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListEntitiesForPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEntitiesForPolicyInput: Swift.Equatable {
    /// The entity type to use for filtering the results. For example, when EntityFilter is Role, only the roles that are attached to the specified policy are returned. This parameter is optional. If it is not included, all attached entities (users, groups, and roles) are returned. The argument for this parameter must be one of the valid values listed below.
    public var entityFilter: IAMClientTypes.EntityType?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all entities. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM policy for which you want the versions. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The policy usage method to use for filtering the results. To list only permissions policies, set PolicyUsageFilter to PermissionsPolicy. To list only the policies used to set permissions boundaries, set the value to PermissionsBoundary. This parameter is optional. If it is not included, all policies are returned.
    public var policyUsageFilter: IAMClientTypes.PolicyUsageType?

    public init (
        entityFilter: IAMClientTypes.EntityType? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        policyUsageFilter: IAMClientTypes.PolicyUsageType? = nil
    )
    {
        self.entityFilter = entityFilter
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
        self.policyArn = policyArn
        self.policyUsageFilter = policyUsageFilter
    }
}

struct ListEntitiesForPolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let entityFilter: IAMClientTypes.EntityType?
    let pathPrefix: Swift.String?
    let policyUsageFilter: IAMClientTypes.PolicyUsageType?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListEntitiesForPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityFilter = "EntityFilter"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
        case policyArn = "PolicyArn"
        case policyUsageFilter = "PolicyUsageFilter"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let entityFilterDecoded = try containerValues.decodeIfPresent(IAMClientTypes.EntityType.self, forKey: .entityFilter)
        entityFilter = entityFilterDecoded
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let policyUsageFilterDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyUsageType.self, forKey: .policyUsageFilter)
        policyUsageFilter = policyUsageFilterDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListEntitiesForPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListEntitiesForPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListEntitiesForPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEntitiesForPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListEntitiesForPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policyGroups = output.policyGroups
            self.policyRoles = output.policyRoles
            self.policyUsers = output.policyUsers
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policyGroups = nil
            self.policyRoles = nil
            self.policyUsers = nil
        }
    }
}

/// Contains the response to a successful [ListEntitiesForPolicy] request.
public struct ListEntitiesForPolicyOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of IAM groups that the policy is attached to.
    public var policyGroups: [IAMClientTypes.PolicyGroup]?
    /// A list of IAM roles that the policy is attached to.
    public var policyRoles: [IAMClientTypes.PolicyRole]?
    /// A list of IAM users that the policy is attached to.
    public var policyUsers: [IAMClientTypes.PolicyUser]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyGroups: [IAMClientTypes.PolicyGroup]? = nil,
        policyRoles: [IAMClientTypes.PolicyRole]? = nil,
        policyUsers: [IAMClientTypes.PolicyUser]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyGroups = policyGroups
        self.policyRoles = policyRoles
        self.policyUsers = policyUsers
    }
}

struct ListEntitiesForPolicyOutputResponseBody: Swift.Equatable {
    let policyGroups: [IAMClientTypes.PolicyGroup]?
    let policyUsers: [IAMClientTypes.PolicyUser]?
    let policyRoles: [IAMClientTypes.PolicyRole]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListEntitiesForPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policyGroups = "PolicyGroups"
        case policyRoles = "PolicyRoles"
        case policyUsers = "PolicyUsers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListEntitiesForPolicyResult"))
        if containerValues.contains(.policyGroups) {
            struct KeyVal0{struct member{}}
            let policyGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyGroups)
            if let policyGroupsWrappedContainer = policyGroupsWrappedContainer {
                let policyGroupsContainer = try policyGroupsWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyGroup].self, forKey: .member)
                var policyGroupsBuffer:[IAMClientTypes.PolicyGroup]? = nil
                if let policyGroupsContainer = policyGroupsContainer {
                    policyGroupsBuffer = [IAMClientTypes.PolicyGroup]()
                    for structureContainer0 in policyGroupsContainer {
                        policyGroupsBuffer?.append(structureContainer0)
                    }
                }
                policyGroups = policyGroupsBuffer
            } else {
                policyGroups = []
            }
        } else {
            policyGroups = nil
        }
        if containerValues.contains(.policyUsers) {
            struct KeyVal0{struct member{}}
            let policyUsersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyUsers)
            if let policyUsersWrappedContainer = policyUsersWrappedContainer {
                let policyUsersContainer = try policyUsersWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyUser].self, forKey: .member)
                var policyUsersBuffer:[IAMClientTypes.PolicyUser]? = nil
                if let policyUsersContainer = policyUsersContainer {
                    policyUsersBuffer = [IAMClientTypes.PolicyUser]()
                    for structureContainer0 in policyUsersContainer {
                        policyUsersBuffer?.append(structureContainer0)
                    }
                }
                policyUsers = policyUsersBuffer
            } else {
                policyUsers = []
            }
        } else {
            policyUsers = nil
        }
        if containerValues.contains(.policyRoles) {
            struct KeyVal0{struct member{}}
            let policyRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyRoles)
            if let policyRolesWrappedContainer = policyRolesWrappedContainer {
                let policyRolesContainer = try policyRolesWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyRole].self, forKey: .member)
                var policyRolesBuffer:[IAMClientTypes.PolicyRole]? = nil
                if let policyRolesContainer = policyRolesContainer {
                    policyRolesBuffer = [IAMClientTypes.PolicyRole]()
                    for structureContainer0 in policyRolesContainer {
                        policyRolesBuffer?.append(structureContainer0)
                    }
                }
                policyRoles = policyRolesBuffer
            } else {
                policyRoles = []
            }
        } else {
            policyRoles = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListGroupPoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("ListGroupPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListGroupPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupPoliciesInput: Swift.Equatable {
    /// The name of the group to list policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init (
        groupName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.groupName = groupName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListGroupPoliciesInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListGroupPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListGroupPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListGroupPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGroupPoliciesOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGroupPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policyNames = output.policyNames
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policyNames = nil
        }
    }
}

/// Contains the response to a successful [ListGroupPolicies] request.
public struct ListGroupPoliciesOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy names. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyNames = policyNames
    }
}

struct ListGroupPoliciesOutputResponseBody: Swift.Equatable {
    let policyNames: [Swift.String]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListGroupPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policyNames = "PolicyNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListGroupPoliciesResult"))
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyNamesBuffer:[Swift.String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [Swift.String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListGroupsForUserInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListGroupsForUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListGroupsForUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupsForUserInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user to list groups for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

struct ListGroupsForUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListGroupsForUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListGroupsForUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListGroupsForUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGroupsForUserOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsForUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGroupsForUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.groups = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListGroupsForUser] request.
public struct ListGroupsForUserOutputResponse: Swift.Equatable {
    /// A list of groups.
    /// This member is required.
    public var groups: [IAMClientTypes.Group]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init (
        groups: [IAMClientTypes.Group]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.groups = groups
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListGroupsForUserOutputResponseBody: Swift.Equatable {
    let groups: [IAMClientTypes.Group]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListGroupsForUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListGroupsForUserResult"))
        if containerValues.contains(.groups) {
            struct KeyVal0{struct member{}}
            let groupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groups)
            if let groupsWrappedContainer = groupsWrappedContainer {
                let groupsContainer = try groupsWrappedContainer.decodeIfPresent([IAMClientTypes.Group].self, forKey: .member)
                var groupsBuffer:[IAMClientTypes.Group]? = nil
                if let groupsContainer = groupsContainer {
                    groupsBuffer = [IAMClientTypes.Group]()
                    for structureContainer0 in groupsContainer {
                        groupsBuffer?.append(structureContainer0)
                    }
                }
                groups = groupsBuffer
            } else {
                groups = []
            }
        } else {
            groups = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListGroupsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example, the prefix /division_abc/subdivision_xyz/ gets all groups whose path starts with /division_abc/subdivision_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all groups. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

struct ListGroupsInputBody: Swift.Equatable {
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGroupsOutputError: Swift.Error, Swift.Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.groups = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListGroups] request.
public struct ListGroupsOutputResponse: Swift.Equatable {
    /// A list of groups.
    /// This member is required.
    public var groups: [IAMClientTypes.Group]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init (
        groups: [IAMClientTypes.Group]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.groups = groups
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListGroupsOutputResponseBody: Swift.Equatable {
    let groups: [IAMClientTypes.Group]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListGroupsResult"))
        if containerValues.contains(.groups) {
            struct KeyVal0{struct member{}}
            let groupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groups)
            if let groupsWrappedContainer = groupsWrappedContainer {
                let groupsContainer = try groupsWrappedContainer.decodeIfPresent([IAMClientTypes.Group].self, forKey: .member)
                var groupsBuffer:[IAMClientTypes.Group]? = nil
                if let groupsContainer = groupsContainer {
                    groupsBuffer = [IAMClientTypes.Group]()
                    for structureContainer0 in groupsContainer {
                        groupsBuffer?.append(structureContainer0)
                    }
                }
                groups = groupsBuffer
            } else {
                groups = []
            }
        } else {
            groups = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListInstanceProfileTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("ListInstanceProfileTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListInstanceProfileTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListInstanceProfileTagsInput: Swift.Equatable {
    /// The name of the IAM instance profile whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init (
        instanceProfileName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListInstanceProfileTagsInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListInstanceProfileTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListInstanceProfileTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListInstanceProfileTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListInstanceProfileTagsOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstanceProfileTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListInstanceProfileTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListInstanceProfileTagsOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the IAM instance profile. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListInstanceProfileTagsOutputResponseBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListInstanceProfileTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListInstanceProfileTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListInstanceProfilesForRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("ListInstanceProfilesForRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListInstanceProfilesForRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListInstanceProfilesForRoleInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the role to list instance profiles for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.roleName = roleName
    }
}

struct ListInstanceProfilesForRoleInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListInstanceProfilesForRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListInstanceProfilesForRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListInstanceProfilesForRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListInstanceProfilesForRoleOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstanceProfilesForRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListInstanceProfilesForRoleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfiles = output.instanceProfiles
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.instanceProfiles = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListInstanceProfilesForRole] request.
public struct ListInstanceProfilesForRoleOutputResponse: Swift.Equatable {
    /// A list of instance profiles.
    /// This member is required.
    public var instanceProfiles: [IAMClientTypes.InstanceProfile]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init (
        instanceProfiles: [IAMClientTypes.InstanceProfile]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListInstanceProfilesForRoleOutputResponseBody: Swift.Equatable {
    let instanceProfiles: [IAMClientTypes.InstanceProfile]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListInstanceProfilesForRoleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfiles = "InstanceProfiles"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListInstanceProfilesForRoleResult"))
        if containerValues.contains(.instanceProfiles) {
            struct KeyVal0{struct member{}}
            let instanceProfilesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instanceProfiles)
            if let instanceProfilesWrappedContainer = instanceProfilesWrappedContainer {
                let instanceProfilesContainer = try instanceProfilesWrappedContainer.decodeIfPresent([IAMClientTypes.InstanceProfile].self, forKey: .member)
                var instanceProfilesBuffer:[IAMClientTypes.InstanceProfile]? = nil
                if let instanceProfilesContainer = instanceProfilesContainer {
                    instanceProfilesBuffer = [IAMClientTypes.InstanceProfile]()
                    for structureContainer0 in instanceProfilesContainer {
                        instanceProfilesBuffer?.append(structureContainer0)
                    }
                }
                instanceProfiles = instanceProfilesBuffer
            } else {
                instanceProfiles = []
            }
        } else {
            instanceProfiles = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListInstanceProfilesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListInstanceProfiles", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListInstanceProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListInstanceProfilesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example, the prefix /application_abc/component_xyz/ gets all instance profiles whose path starts with /application_abc/component_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all instance profiles. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

struct ListInstanceProfilesInputBody: Swift.Equatable {
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListInstanceProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListInstanceProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListInstanceProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListInstanceProfilesOutputError: Swift.Error, Swift.Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstanceProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListInstanceProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfiles = output.instanceProfiles
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.instanceProfiles = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListInstanceProfiles] request.
public struct ListInstanceProfilesOutputResponse: Swift.Equatable {
    /// A list of instance profiles.
    /// This member is required.
    public var instanceProfiles: [IAMClientTypes.InstanceProfile]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init (
        instanceProfiles: [IAMClientTypes.InstanceProfile]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListInstanceProfilesOutputResponseBody: Swift.Equatable {
    let instanceProfiles: [IAMClientTypes.InstanceProfile]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListInstanceProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfiles = "InstanceProfiles"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListInstanceProfilesResult"))
        if containerValues.contains(.instanceProfiles) {
            struct KeyVal0{struct member{}}
            let instanceProfilesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instanceProfiles)
            if let instanceProfilesWrappedContainer = instanceProfilesWrappedContainer {
                let instanceProfilesContainer = try instanceProfilesWrappedContainer.decodeIfPresent([IAMClientTypes.InstanceProfile].self, forKey: .member)
                var instanceProfilesBuffer:[IAMClientTypes.InstanceProfile]? = nil
                if let instanceProfilesContainer = instanceProfilesContainer {
                    instanceProfilesBuffer = [IAMClientTypes.InstanceProfile]()
                    for structureContainer0 in instanceProfilesContainer {
                        instanceProfilesBuffer?.append(structureContainer0)
                    }
                }
                instanceProfiles = instanceProfilesBuffer
            } else {
                instanceProfiles = []
            }
        } else {
            instanceProfiles = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListMFADeviceTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        try container.encode("ListMFADeviceTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListMFADeviceTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMFADeviceTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The unique identifier for the IAM virtual MFA device whose tags you want to see. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        serialNumber: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.serialNumber = serialNumber
    }
}

struct ListMFADeviceTagsInputBody: Swift.Equatable {
    let serialNumber: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListMFADeviceTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case serialNumber = "SerialNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListMFADeviceTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListMFADeviceTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMFADeviceTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMFADeviceTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMFADeviceTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListMFADeviceTagsOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the virtual MFA device. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListMFADeviceTagsOutputResponseBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListMFADeviceTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListMFADeviceTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListMFADevicesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListMFADevices", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListMFADevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMFADevicesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user whose MFA devices you want to list. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

struct ListMFADevicesInputBody: Swift.Equatable {
    let userName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListMFADevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListMFADevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListMFADevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMFADevicesOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMFADevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMFADevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.mfaDevices = output.mfaDevices
        } else {
            self.isTruncated = false
            self.mfaDevices = nil
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListMFADevices] request.
public struct ListMFADevicesOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of MFA devices.
    /// This member is required.
    public var mfaDevices: [IAMClientTypes.MFADevice]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        mfaDevices: [IAMClientTypes.MFADevice]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.mfaDevices = mfaDevices
    }
}

struct ListMFADevicesOutputResponseBody: Swift.Equatable {
    let mfaDevices: [IAMClientTypes.MFADevice]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListMFADevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case mfaDevices = "MFADevices"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListMFADevicesResult"))
        if containerValues.contains(.mfaDevices) {
            struct KeyVal0{struct member{}}
            let mfaDevicesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .mfaDevices)
            if let mfaDevicesWrappedContainer = mfaDevicesWrappedContainer {
                let mfaDevicesContainer = try mfaDevicesWrappedContainer.decodeIfPresent([IAMClientTypes.MFADevice].self, forKey: .member)
                var mfaDevicesBuffer:[IAMClientTypes.MFADevice]? = nil
                if let mfaDevicesContainer = mfaDevicesContainer {
                    mfaDevicesBuffer = [IAMClientTypes.MFADevice]()
                    for structureContainer0 in mfaDevicesContainer {
                        mfaDevicesBuffer?.append(structureContainer0)
                    }
                }
                mfaDevices = mfaDevicesBuffer
            } else {
                mfaDevices = []
            }
        } else {
            mfaDevices = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListOpenIDConnectProviderTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        try container.encode("ListOpenIDConnectProviderTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListOpenIDConnectProviderTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListOpenIDConnectProviderTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The ARN of the OpenID Connect (OIDC) identity provider whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

struct ListOpenIDConnectProviderTagsInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListOpenIDConnectProviderTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListOpenIDConnectProviderTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListOpenIDConnectProviderTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListOpenIDConnectProviderTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOpenIDConnectProviderTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListOpenIDConnectProviderTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListOpenIDConnectProviderTagsOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the OpenID Connect (OIDC) identity provider. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListOpenIDConnectProviderTagsOutputResponseBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListOpenIDConnectProviderTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListOpenIDConnectProviderTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListOpenIDConnectProvidersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("ListOpenIDConnectProviders", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListOpenIDConnectProvidersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListOpenIDConnectProvidersInput: Swift.Equatable {

    public init () { }
}

extension ListOpenIDConnectProvidersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListOpenIDConnectProvidersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListOpenIDConnectProvidersOutputError: Swift.Error, Swift.Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOpenIDConnectProvidersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListOpenIDConnectProvidersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.openIDConnectProviderList = output.openIDConnectProviderList
        } else {
            self.openIDConnectProviderList = nil
        }
    }
}

/// Contains the response to a successful [ListOpenIDConnectProviders] request.
public struct ListOpenIDConnectProvidersOutputResponse: Swift.Equatable {
    /// The list of IAM OIDC provider resource objects defined in the Amazon Web Services account.
    public var openIDConnectProviderList: [IAMClientTypes.OpenIDConnectProviderListEntry]?

    public init (
        openIDConnectProviderList: [IAMClientTypes.OpenIDConnectProviderListEntry]? = nil
    )
    {
        self.openIDConnectProviderList = openIDConnectProviderList
    }
}

struct ListOpenIDConnectProvidersOutputResponseBody: Swift.Equatable {
    let openIDConnectProviderList: [IAMClientTypes.OpenIDConnectProviderListEntry]?
}

extension ListOpenIDConnectProvidersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderList = "OpenIDConnectProviderList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListOpenIDConnectProvidersResult"))
        if containerValues.contains(.openIDConnectProviderList) {
            struct KeyVal0{struct member{}}
            let openIDConnectProviderListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .openIDConnectProviderList)
            if let openIDConnectProviderListWrappedContainer = openIDConnectProviderListWrappedContainer {
                let openIDConnectProviderListContainer = try openIDConnectProviderListWrappedContainer.decodeIfPresent([IAMClientTypes.OpenIDConnectProviderListEntry].self, forKey: .member)
                var openIDConnectProviderListBuffer:[IAMClientTypes.OpenIDConnectProviderListEntry]? = nil
                if let openIDConnectProviderListContainer = openIDConnectProviderListContainer {
                    openIDConnectProviderListBuffer = [IAMClientTypes.OpenIDConnectProviderListEntry]()
                    for structureContainer0 in openIDConnectProviderListContainer {
                        openIDConnectProviderListBuffer?.append(structureContainer0)
                    }
                }
                openIDConnectProviderList = openIDConnectProviderListBuffer
            } else {
                openIDConnectProviderList = []
            }
        } else {
            openIDConnectProviderList = nil
        }
    }
}

extension IAMClientTypes.ListPoliciesGrantingServiceAccessEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policies = "Policies"
        case serviceNamespace = "ServiceNamespace"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policies = policies {
            if !policies.isEmpty {
                var policiesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Policies"))
                for (index0, policygrantingserviceaccess0) in policies.enumerated() {
                    try policiesContainer.encode(policygrantingserviceaccess0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policiesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Policies"))
                try policiesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: ClientRuntime.Key("ServiceNamespace"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNamespace)
        serviceNamespace = serviceNamespaceDecoded
        if containerValues.contains(.policies) {
            struct KeyVal0{struct member{}}
            let policiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policies)
            if let policiesWrappedContainer = policiesWrappedContainer {
                let policiesContainer = try policiesWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyGrantingServiceAccess].self, forKey: .member)
                var policiesBuffer:[IAMClientTypes.PolicyGrantingServiceAccess]? = nil
                if let policiesContainer = policiesContainer {
                    policiesBuffer = [IAMClientTypes.PolicyGrantingServiceAccess]()
                    for structureContainer0 in policiesContainer {
                        policiesBuffer?.append(structureContainer0)
                    }
                }
                policies = policiesBuffer
            } else {
                policies = []
            }
        } else {
            policies = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains details about the permissions policies that are attached to the specified identity (user, group, or role). This data type is used as a response element in the [ListPoliciesGrantingServiceAccess] operation.
    public struct ListPoliciesGrantingServiceAccessEntry: Swift.Equatable {
        /// The PoliciesGrantingServiceAccess object that contains details about the policy.
        public var policies: [IAMClientTypes.PolicyGrantingServiceAccess]?
        /// The namespace of the service that was accessed. To learn the service namespace of a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the Service Authorization Reference. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
        public var serviceNamespace: Swift.String?

        public init (
            policies: [IAMClientTypes.PolicyGrantingServiceAccess]? = nil,
            serviceNamespace: Swift.String? = nil
        )
        {
            self.policies = policies
            self.serviceNamespace = serviceNamespace
        }
    }

}

extension ListPoliciesGrantingServiceAccessInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let serviceNamespaces = serviceNamespaces {
            if !serviceNamespaces.isEmpty {
                var serviceNamespacesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ServiceNamespaces"))
                for (index0, servicenamespacetype0) in serviceNamespaces.enumerated() {
                    try serviceNamespacesContainer.encode(servicenamespacetype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var serviceNamespacesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ServiceNamespaces"))
                try serviceNamespacesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("ListPoliciesGrantingServiceAccess", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPoliciesGrantingServiceAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPoliciesGrantingServiceAccessInput: Swift.Equatable {
    /// The ARN of the IAM identity (user, group, or role) whose policies you want to list.
    /// This member is required.
    public var arn: Swift.String?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// The service namespace for the Amazon Web Services services whose policies you want to list. To learn the service namespace for a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the IAM User Guide. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services service namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
    /// This member is required.
    public var serviceNamespaces: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        marker: Swift.String? = nil,
        serviceNamespaces: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.marker = marker
        self.serviceNamespaces = serviceNamespaces
    }
}

struct ListPoliciesGrantingServiceAccessInputBody: Swift.Equatable {
    let marker: Swift.String?
    let arn: Swift.String?
    let serviceNamespaces: [Swift.String]?
}

extension ListPoliciesGrantingServiceAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case marker = "Marker"
        case serviceNamespaces = "ServiceNamespaces"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        if containerValues.contains(.serviceNamespaces) {
            struct KeyVal0{struct member{}}
            let serviceNamespacesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .serviceNamespaces)
            if let serviceNamespacesWrappedContainer = serviceNamespacesWrappedContainer {
                let serviceNamespacesContainer = try serviceNamespacesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var serviceNamespacesBuffer:[Swift.String]? = nil
                if let serviceNamespacesContainer = serviceNamespacesContainer {
                    serviceNamespacesBuffer = [Swift.String]()
                    for stringContainer0 in serviceNamespacesContainer {
                        serviceNamespacesBuffer?.append(stringContainer0)
                    }
                }
                serviceNamespaces = serviceNamespacesBuffer
            } else {
                serviceNamespaces = []
            }
        } else {
            serviceNamespaces = nil
        }
    }
}

extension ListPoliciesGrantingServiceAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPoliciesGrantingServiceAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPoliciesGrantingServiceAccessOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPoliciesGrantingServiceAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPoliciesGrantingServiceAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policiesGrantingServiceAccess = output.policiesGrantingServiceAccess
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policiesGrantingServiceAccess = nil
        }
    }
}

public struct ListPoliciesGrantingServiceAccessOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A ListPoliciesGrantingServiceAccess object that contains details about the permissions policies attached to the specified identity (user, group, or role).
    /// This member is required.
    public var policiesGrantingServiceAccess: [IAMClientTypes.ListPoliciesGrantingServiceAccessEntry]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policiesGrantingServiceAccess: [IAMClientTypes.ListPoliciesGrantingServiceAccessEntry]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policiesGrantingServiceAccess = policiesGrantingServiceAccess
    }
}

struct ListPoliciesGrantingServiceAccessOutputResponseBody: Swift.Equatable {
    let policiesGrantingServiceAccess: [IAMClientTypes.ListPoliciesGrantingServiceAccessEntry]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListPoliciesGrantingServiceAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policiesGrantingServiceAccess = "PoliciesGrantingServiceAccess"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListPoliciesGrantingServiceAccessResult"))
        if containerValues.contains(.policiesGrantingServiceAccess) {
            struct KeyVal0{struct member{}}
            let policiesGrantingServiceAccessWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policiesGrantingServiceAccess)
            if let policiesGrantingServiceAccessWrappedContainer = policiesGrantingServiceAccessWrappedContainer {
                let policiesGrantingServiceAccessContainer = try policiesGrantingServiceAccessWrappedContainer.decodeIfPresent([IAMClientTypes.ListPoliciesGrantingServiceAccessEntry].self, forKey: .member)
                var policiesGrantingServiceAccessBuffer:[IAMClientTypes.ListPoliciesGrantingServiceAccessEntry]? = nil
                if let policiesGrantingServiceAccessContainer = policiesGrantingServiceAccessContainer {
                    policiesGrantingServiceAccessBuffer = [IAMClientTypes.ListPoliciesGrantingServiceAccessEntry]()
                    for structureContainer0 in policiesGrantingServiceAccessContainer {
                        policiesGrantingServiceAccessBuffer?.append(structureContainer0)
                    }
                }
                policiesGrantingServiceAccess = policiesGrantingServiceAccessBuffer
            } else {
                policiesGrantingServiceAccess = []
            }
        } else {
            policiesGrantingServiceAccess = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListPoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let onlyAttached = onlyAttached {
            try container.encode(onlyAttached, forKey: ClientRuntime.Key("OnlyAttached"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        if let policyUsageFilter = policyUsageFilter {
            try container.encode(policyUsageFilter, forKey: ClientRuntime.Key("PolicyUsageFilter"))
        }
        if let scope = scope {
            try container.encode(scope, forKey: ClientRuntime.Key("Scope"))
        }
        try container.encode("ListPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPoliciesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// A flag to filter the results to only the attached policies. When OnlyAttached is true, the returned list contains only the policies that are attached to an IAM user, group, or role. When OnlyAttached is false, or when the parameter is not included, all policies are returned.
    public var onlyAttached: Swift.Bool?
    /// The path prefix for filtering the results. This parameter is optional. If it is not included, it defaults to a slash (/), listing all policies. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?
    /// The policy usage method to use for filtering the results. To list only permissions policies, set PolicyUsageFilter to PermissionsPolicy. To list only the policies used to set permissions boundaries, set the value to PermissionsBoundary. This parameter is optional. If it is not included, all policies are returned.
    public var policyUsageFilter: IAMClientTypes.PolicyUsageType?
    /// The scope to use for filtering the results. To list only Amazon Web Services managed policies, set Scope to AWS. To list only the customer managed policies in your Amazon Web Services account, set Scope to Local. This parameter is optional. If it is not included, or if it is set to All, all policies are returned.
    public var scope: IAMClientTypes.PolicyScopeType?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        onlyAttached: Swift.Bool? = nil,
        pathPrefix: Swift.String? = nil,
        policyUsageFilter: IAMClientTypes.PolicyUsageType? = nil,
        scope: IAMClientTypes.PolicyScopeType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.onlyAttached = onlyAttached
        self.pathPrefix = pathPrefix
        self.policyUsageFilter = policyUsageFilter
        self.scope = scope
    }
}

struct ListPoliciesInputBody: Swift.Equatable {
    let scope: IAMClientTypes.PolicyScopeType?
    let onlyAttached: Swift.Bool?
    let pathPrefix: Swift.String?
    let policyUsageFilter: IAMClientTypes.PolicyUsageType?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case onlyAttached = "OnlyAttached"
        case pathPrefix = "PathPrefix"
        case policyUsageFilter = "PolicyUsageFilter"
        case scope = "Scope"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyScopeType.self, forKey: .scope)
        scope = scopeDecoded
        let onlyAttachedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .onlyAttached)
        onlyAttached = onlyAttachedDecoded
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let policyUsageFilterDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyUsageType.self, forKey: .policyUsageFilter)
        policyUsageFilter = policyUsageFilterDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPoliciesOutputError: Swift.Error, Swift.Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policies = output.policies
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policies = nil
        }
    }
}

/// Contains the response to a successful [ListPolicies] request.
public struct ListPoliciesOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policies.
    public var policies: [IAMClientTypes.Policy]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policies: [IAMClientTypes.Policy]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policies = policies
    }
}

struct ListPoliciesOutputResponseBody: Swift.Equatable {
    let policies: [IAMClientTypes.Policy]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policies = "Policies"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListPoliciesResult"))
        if containerValues.contains(.policies) {
            struct KeyVal0{struct member{}}
            let policiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policies)
            if let policiesWrappedContainer = policiesWrappedContainer {
                let policiesContainer = try policiesWrappedContainer.decodeIfPresent([IAMClientTypes.Policy].self, forKey: .member)
                var policiesBuffer:[IAMClientTypes.Policy]? = nil
                if let policiesContainer = policiesContainer {
                    policiesBuffer = [IAMClientTypes.Policy]()
                    for structureContainer0 in policiesContainer {
                        policiesBuffer?.append(structureContainer0)
                    }
                }
                policies = policiesBuffer
            } else {
                policies = []
            }
        } else {
            policies = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListPolicyTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("ListPolicyTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPolicyTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPolicyTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The ARN of the IAM customer managed policy whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyArn: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.policyArn = policyArn
    }
}

struct ListPolicyTagsInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListPolicyTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListPolicyTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPolicyTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPolicyTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPolicyTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPolicyTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListPolicyTagsOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the IAM customer managed policy. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListPolicyTagsOutputResponseBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListPolicyTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListPolicyTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListPolicyVersionsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        try container.encode("ListPolicyVersions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPolicyVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPolicyVersionsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The Amazon Resource Name (ARN) of the IAM policy for which you want the versions. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.policyArn = policyArn
    }
}

struct ListPolicyVersionsInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListPolicyVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListPolicyVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPolicyVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPolicyVersionsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPolicyVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPolicyVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.versions = output.versions
        } else {
            self.isTruncated = false
            self.marker = nil
            self.versions = nil
        }
    }
}

/// Contains the response to a successful [ListPolicyVersions] request.
public struct ListPolicyVersionsOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy versions. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    public var versions: [IAMClientTypes.PolicyVersion]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        versions: [IAMClientTypes.PolicyVersion]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.versions = versions
    }
}

struct ListPolicyVersionsOutputResponseBody: Swift.Equatable {
    let versions: [IAMClientTypes.PolicyVersion]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListPolicyVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case versions = "Versions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListPolicyVersionsResult"))
        if containerValues.contains(.versions) {
            struct KeyVal0{struct member{}}
            let versionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .versions)
            if let versionsWrappedContainer = versionsWrappedContainer {
                let versionsContainer = try versionsWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyVersion].self, forKey: .member)
                var versionsBuffer:[IAMClientTypes.PolicyVersion]? = nil
                if let versionsContainer = versionsContainer {
                    versionsBuffer = [IAMClientTypes.PolicyVersion]()
                    for structureContainer0 in versionsContainer {
                        versionsBuffer?.append(structureContainer0)
                    }
                }
                versions = versionsBuffer
            } else {
                versions = []
            }
        } else {
            versions = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListRolePoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("ListRolePolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListRolePoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRolePoliciesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the role to list policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.roleName = roleName
    }
}

struct ListRolePoliciesInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListRolePoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListRolePoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListRolePoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRolePoliciesOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRolePoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRolePoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policyNames = output.policyNames
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policyNames = nil
        }
    }
}

/// Contains the response to a successful [ListRolePolicies] request.
public struct ListRolePoliciesOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy names.
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyNames = policyNames
    }
}

struct ListRolePoliciesOutputResponseBody: Swift.Equatable {
    let policyNames: [Swift.String]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListRolePoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policyNames = "PolicyNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListRolePoliciesResult"))
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyNamesBuffer:[Swift.String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [Swift.String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListRoleTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("ListRoleTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListRoleTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRoleTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM role for which you want to see the list of tags. This parameter accepts (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.roleName = roleName
    }
}

struct ListRoleTagsInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListRoleTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListRoleTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListRoleTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRoleTagsOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRoleTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRoleTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListRoleTagsOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the role. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListRoleTagsOutputResponseBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListRoleTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListRoleTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListRolesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListRoles", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListRolesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRolesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example, the prefix /application_abc/component_xyz/ gets all roles whose path starts with /application_abc/component_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all roles. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

struct ListRolesInputBody: Swift.Equatable {
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListRolesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListRolesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListRolesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRolesOutputError: Swift.Error, Swift.Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRolesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRolesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.roles = output.roles
        } else {
            self.isTruncated = false
            self.marker = nil
            self.roles = nil
        }
    }
}

/// Contains the response to a successful [ListRoles] request.
public struct ListRolesOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of roles.
    /// This member is required.
    public var roles: [IAMClientTypes.Role]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        roles: [IAMClientTypes.Role]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.roles = roles
    }
}

struct ListRolesOutputResponseBody: Swift.Equatable {
    let roles: [IAMClientTypes.Role]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListRolesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case roles = "Roles"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListRolesResult"))
        if containerValues.contains(.roles) {
            struct KeyVal0{struct member{}}
            let rolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .roles)
            if let rolesWrappedContainer = rolesWrappedContainer {
                let rolesContainer = try rolesWrappedContainer.decodeIfPresent([IAMClientTypes.Role].self, forKey: .member)
                var rolesBuffer:[IAMClientTypes.Role]? = nil
                if let rolesContainer = rolesContainer {
                    rolesBuffer = [IAMClientTypes.Role]()
                    for structureContainer0 in rolesContainer {
                        rolesBuffer?.append(structureContainer0)
                    }
                }
                roles = rolesBuffer
            } else {
                roles = []
            }
        } else {
            roles = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListSAMLProviderTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        try container.encode("ListSAMLProviderTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSAMLProviderTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSAMLProviderTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The ARN of the Security Assertion Markup Language (SAML) identity provider whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        samlProviderArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.samlProviderArn = samlProviderArn
    }
}

struct ListSAMLProviderTagsInputBody: Swift.Equatable {
    let samlProviderArn: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListSAMLProviderTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case samlProviderArn = "SAMLProviderArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListSAMLProviderTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSAMLProviderTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSAMLProviderTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSAMLProviderTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSAMLProviderTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListSAMLProviderTagsOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the Security Assertion Markup Language (SAML) identity provider. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListSAMLProviderTagsOutputResponseBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListSAMLProviderTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListSAMLProviderTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListSAMLProvidersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("ListSAMLProviders", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSAMLProvidersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSAMLProvidersInput: Swift.Equatable {

    public init () { }
}

extension ListSAMLProvidersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSAMLProvidersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSAMLProvidersOutputError: Swift.Error, Swift.Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSAMLProvidersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSAMLProvidersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.samlProviderList = output.samlProviderList
        } else {
            self.samlProviderList = nil
        }
    }
}

/// Contains the response to a successful [ListSAMLProviders] request.
public struct ListSAMLProvidersOutputResponse: Swift.Equatable {
    /// The list of SAML provider resource objects defined in IAM for this Amazon Web Services account.
    public var samlProviderList: [IAMClientTypes.SAMLProviderListEntry]?

    public init (
        samlProviderList: [IAMClientTypes.SAMLProviderListEntry]? = nil
    )
    {
        self.samlProviderList = samlProviderList
    }
}

struct ListSAMLProvidersOutputResponseBody: Swift.Equatable {
    let samlProviderList: [IAMClientTypes.SAMLProviderListEntry]?
}

extension ListSAMLProvidersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderList = "SAMLProviderList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListSAMLProvidersResult"))
        if containerValues.contains(.samlProviderList) {
            struct KeyVal0{struct member{}}
            let samlProviderListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .samlProviderList)
            if let samlProviderListWrappedContainer = samlProviderListWrappedContainer {
                let samlProviderListContainer = try samlProviderListWrappedContainer.decodeIfPresent([IAMClientTypes.SAMLProviderListEntry].self, forKey: .member)
                var samlProviderListBuffer:[IAMClientTypes.SAMLProviderListEntry]? = nil
                if let samlProviderListContainer = samlProviderListContainer {
                    samlProviderListBuffer = [IAMClientTypes.SAMLProviderListEntry]()
                    for structureContainer0 in samlProviderListContainer {
                        samlProviderListBuffer?.append(structureContainer0)
                    }
                }
                samlProviderList = samlProviderListBuffer
            } else {
                samlProviderList = []
            }
        } else {
            samlProviderList = nil
        }
    }
}

extension ListSSHPublicKeysInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListSSHPublicKeys", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSSHPublicKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSSHPublicKeysInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM user to list SSH public keys for. If none is specified, the UserName field is determined implicitly based on the Amazon Web Services access key used to sign the request. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

struct ListSSHPublicKeysInputBody: Swift.Equatable {
    let userName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListSSHPublicKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListSSHPublicKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSSHPublicKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSSHPublicKeysOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSSHPublicKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSSHPublicKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.sshPublicKeys = output.sshPublicKeys
        } else {
            self.isTruncated = false
            self.marker = nil
            self.sshPublicKeys = nil
        }
    }
}

/// Contains the response to a successful [ListSSHPublicKeys] request.
public struct ListSSHPublicKeysOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of the SSH public keys assigned to IAM user.
    public var sshPublicKeys: [IAMClientTypes.SSHPublicKeyMetadata]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        sshPublicKeys: [IAMClientTypes.SSHPublicKeyMetadata]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.sshPublicKeys = sshPublicKeys
    }
}

struct ListSSHPublicKeysOutputResponseBody: Swift.Equatable {
    let sshPublicKeys: [IAMClientTypes.SSHPublicKeyMetadata]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListSSHPublicKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case sshPublicKeys = "SSHPublicKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListSSHPublicKeysResult"))
        if containerValues.contains(.sshPublicKeys) {
            struct KeyVal0{struct member{}}
            let sshPublicKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sshPublicKeys)
            if let sshPublicKeysWrappedContainer = sshPublicKeysWrappedContainer {
                let sshPublicKeysContainer = try sshPublicKeysWrappedContainer.decodeIfPresent([IAMClientTypes.SSHPublicKeyMetadata].self, forKey: .member)
                var sshPublicKeysBuffer:[IAMClientTypes.SSHPublicKeyMetadata]? = nil
                if let sshPublicKeysContainer = sshPublicKeysContainer {
                    sshPublicKeysBuffer = [IAMClientTypes.SSHPublicKeyMetadata]()
                    for structureContainer0 in sshPublicKeysContainer {
                        sshPublicKeysBuffer?.append(structureContainer0)
                    }
                }
                sshPublicKeys = sshPublicKeysBuffer
            } else {
                sshPublicKeys = []
            }
        } else {
            sshPublicKeys = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListServerCertificateTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        try container.encode("ListServerCertificateTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListServerCertificateTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServerCertificateTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM server certificate whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        serverCertificateName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.serverCertificateName = serverCertificateName
    }
}

struct ListServerCertificateTagsInputBody: Swift.Equatable {
    let serverCertificateName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListServerCertificateTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case serverCertificateName = "ServerCertificateName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListServerCertificateTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListServerCertificateTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListServerCertificateTagsOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServerCertificateTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListServerCertificateTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListServerCertificateTagsOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the IAM server certificate. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListServerCertificateTagsOutputResponseBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListServerCertificateTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListServerCertificateTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListServerCertificatesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListServerCertificates", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListServerCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServerCertificatesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example: /company/servercerts would get all server certificates for which the path starts with /company/servercerts. This parameter is optional. If it is not included, it defaults to a slash (/), listing all server certificates. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

struct ListServerCertificatesInputBody: Swift.Equatable {
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListServerCertificatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListServerCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListServerCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListServerCertificatesOutputError: Swift.Error, Swift.Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServerCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListServerCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.serverCertificateMetadataList = output.serverCertificateMetadataList
        } else {
            self.isTruncated = false
            self.marker = nil
            self.serverCertificateMetadataList = nil
        }
    }
}

/// Contains the response to a successful [ListServerCertificates] request.
public struct ListServerCertificatesOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of server certificates.
    /// This member is required.
    public var serverCertificateMetadataList: [IAMClientTypes.ServerCertificateMetadata]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        serverCertificateMetadataList: [IAMClientTypes.ServerCertificateMetadata]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.serverCertificateMetadataList = serverCertificateMetadataList
    }
}

struct ListServerCertificatesOutputResponseBody: Swift.Equatable {
    let serverCertificateMetadataList: [IAMClientTypes.ServerCertificateMetadata]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListServerCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case serverCertificateMetadataList = "ServerCertificateMetadataList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListServerCertificatesResult"))
        if containerValues.contains(.serverCertificateMetadataList) {
            struct KeyVal0{struct member{}}
            let serverCertificateMetadataListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .serverCertificateMetadataList)
            if let serverCertificateMetadataListWrappedContainer = serverCertificateMetadataListWrappedContainer {
                let serverCertificateMetadataListContainer = try serverCertificateMetadataListWrappedContainer.decodeIfPresent([IAMClientTypes.ServerCertificateMetadata].self, forKey: .member)
                var serverCertificateMetadataListBuffer:[IAMClientTypes.ServerCertificateMetadata]? = nil
                if let serverCertificateMetadataListContainer = serverCertificateMetadataListContainer {
                    serverCertificateMetadataListBuffer = [IAMClientTypes.ServerCertificateMetadata]()
                    for structureContainer0 in serverCertificateMetadataListContainer {
                        serverCertificateMetadataListBuffer?.append(structureContainer0)
                    }
                }
                serverCertificateMetadataList = serverCertificateMetadataListBuffer
            } else {
                serverCertificateMetadataList = []
            }
        } else {
            serverCertificateMetadataList = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListServiceSpecificCredentialsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListServiceSpecificCredentials", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListServiceSpecificCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServiceSpecificCredentialsInput: Swift.Equatable {
    /// Filters the returned results to only those for the specified Amazon Web Services service. If not specified, then Amazon Web Services returns service-specific credentials for all services.
    public var serviceName: Swift.String?
    /// The name of the user whose service-specific credentials you want information about. If this value is not specified, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init (
        serviceName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceName = serviceName
        self.userName = userName
    }
}

struct ListServiceSpecificCredentialsInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serviceName: Swift.String?
}

extension ListServiceSpecificCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName = "ServiceName"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension ListServiceSpecificCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListServiceSpecificCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotSupportedService" : self = .serviceNotSupportedException(try ServiceNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListServiceSpecificCredentialsOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceNotSupportedException(ServiceNotSupportedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceSpecificCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListServiceSpecificCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceSpecificCredentials = output.serviceSpecificCredentials
        } else {
            self.serviceSpecificCredentials = nil
        }
    }
}

public struct ListServiceSpecificCredentialsOutputResponse: Swift.Equatable {
    /// A list of structures that each contain details about a service-specific credential.
    public var serviceSpecificCredentials: [IAMClientTypes.ServiceSpecificCredentialMetadata]?

    public init (
        serviceSpecificCredentials: [IAMClientTypes.ServiceSpecificCredentialMetadata]? = nil
    )
    {
        self.serviceSpecificCredentials = serviceSpecificCredentials
    }
}

struct ListServiceSpecificCredentialsOutputResponseBody: Swift.Equatable {
    let serviceSpecificCredentials: [IAMClientTypes.ServiceSpecificCredentialMetadata]?
}

extension ListServiceSpecificCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSpecificCredentials = "ServiceSpecificCredentials"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListServiceSpecificCredentialsResult"))
        if containerValues.contains(.serviceSpecificCredentials) {
            struct KeyVal0{struct member{}}
            let serviceSpecificCredentialsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .serviceSpecificCredentials)
            if let serviceSpecificCredentialsWrappedContainer = serviceSpecificCredentialsWrappedContainer {
                let serviceSpecificCredentialsContainer = try serviceSpecificCredentialsWrappedContainer.decodeIfPresent([IAMClientTypes.ServiceSpecificCredentialMetadata].self, forKey: .member)
                var serviceSpecificCredentialsBuffer:[IAMClientTypes.ServiceSpecificCredentialMetadata]? = nil
                if let serviceSpecificCredentialsContainer = serviceSpecificCredentialsContainer {
                    serviceSpecificCredentialsBuffer = [IAMClientTypes.ServiceSpecificCredentialMetadata]()
                    for structureContainer0 in serviceSpecificCredentialsContainer {
                        serviceSpecificCredentialsBuffer?.append(structureContainer0)
                    }
                }
                serviceSpecificCredentials = serviceSpecificCredentialsBuffer
            } else {
                serviceSpecificCredentials = []
            }
        } else {
            serviceSpecificCredentials = nil
        }
    }
}

extension ListSigningCertificatesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListSigningCertificates", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSigningCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSigningCertificatesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM user whose signing certificates you want to examine. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

struct ListSigningCertificatesInputBody: Swift.Equatable {
    let userName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListSigningCertificatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListSigningCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSigningCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSigningCertificatesOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSigningCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSigningCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificates = output.certificates
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.certificates = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [ListSigningCertificates] request.
public struct ListSigningCertificatesOutputResponse: Swift.Equatable {
    /// A list of the user's signing certificate information.
    /// This member is required.
    public var certificates: [IAMClientTypes.SigningCertificate]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init (
        certificates: [IAMClientTypes.SigningCertificate]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct ListSigningCertificatesOutputResponseBody: Swift.Equatable {
    let certificates: [IAMClientTypes.SigningCertificate]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListSigningCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificates = "Certificates"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListSigningCertificatesResult"))
        if containerValues.contains(.certificates) {
            struct KeyVal0{struct member{}}
            let certificatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .certificates)
            if let certificatesWrappedContainer = certificatesWrappedContainer {
                let certificatesContainer = try certificatesWrappedContainer.decodeIfPresent([IAMClientTypes.SigningCertificate].self, forKey: .member)
                var certificatesBuffer:[IAMClientTypes.SigningCertificate]? = nil
                if let certificatesContainer = certificatesContainer {
                    certificatesBuffer = [IAMClientTypes.SigningCertificate]()
                    for structureContainer0 in certificatesContainer {
                        certificatesBuffer?.append(structureContainer0)
                    }
                }
                certificates = certificatesBuffer
            } else {
                certificates = []
            }
        } else {
            certificates = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListUserPoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListUserPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListUserPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUserPoliciesInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the user to list policies for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

struct ListUserPoliciesInputBody: Swift.Equatable {
    let userName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListUserPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListUserPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListUserPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUserPoliciesOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUserPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.policyNames = output.policyNames
        } else {
            self.isTruncated = false
            self.marker = nil
            self.policyNames = nil
        }
    }
}

/// Contains the response to a successful [ListUserPolicies] request.
public struct ListUserPoliciesOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of policy names.
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.policyNames = policyNames
    }
}

struct ListUserPoliciesOutputResponseBody: Swift.Equatable {
    let policyNames: [Swift.String]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListUserPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policyNames = "PolicyNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListUserPoliciesResult"))
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyNamesBuffer:[Swift.String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [Swift.String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListUserTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ListUserTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListUserTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUserTagsInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The name of the IAM user whose tags you want to see. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.userName = userName
    }
}

struct ListUserTagsInputBody: Swift.Equatable {
    let userName: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListUserTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListUserTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListUserTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUserTagsOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUserTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.tags = output.tags
        } else {
            self.isTruncated = false
            self.marker = nil
            self.tags = nil
        }
    }
}

public struct ListUserTagsOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of tags that are currently attached to the user. Each tag consists of a key name and an associated value. If no tags are attached to the specified resource, the response contains an empty list.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.tags = tags
    }
}

struct ListUserTagsOutputResponseBody: Swift.Equatable {
    let tags: [IAMClientTypes.Tag]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListUserTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListUserTagsResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListUsersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let pathPrefix = pathPrefix {
            try container.encode(pathPrefix, forKey: ClientRuntime.Key("PathPrefix"))
        }
        try container.encode("ListUsers", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The path prefix for filtering the results. For example: /division_abc/subdivision_xyz/, which would get all user names whose path starts with /division_abc/subdivision_xyz/. This parameter is optional. If it is not included, it defaults to a slash (/), listing all user names. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var pathPrefix: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        pathPrefix: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.pathPrefix = pathPrefix
    }
}

struct ListUsersInputBody: Swift.Equatable {
    let pathPrefix: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case pathPrefix = "PathPrefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPrefix)
        pathPrefix = pathPrefixDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUsersOutputError: Swift.Error, Swift.Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.users = output.users
        } else {
            self.isTruncated = false
            self.marker = nil
            self.users = nil
        }
    }
}

/// Contains the response to a successful [ListUsers] request.
public struct ListUsersOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// A list of users.
    /// This member is required.
    public var users: [IAMClientTypes.User]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        users: [IAMClientTypes.User]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Swift.Equatable {
    let users: [IAMClientTypes.User]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case users = "Users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListUsersResult"))
        if containerValues.contains(.users) {
            struct KeyVal0{struct member{}}
            let usersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .users)
            if let usersWrappedContainer = usersWrappedContainer {
                let usersContainer = try usersWrappedContainer.decodeIfPresent([IAMClientTypes.User].self, forKey: .member)
                var usersBuffer:[IAMClientTypes.User]? = nil
                if let usersContainer = usersContainer {
                    usersBuffer = [IAMClientTypes.User]()
                    for structureContainer0 in usersContainer {
                        usersBuffer?.append(structureContainer0)
                    }
                }
                users = usersBuffer
            } else {
                users = []
            }
        } else {
            users = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListVirtualMFADevicesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let assignmentStatus = assignmentStatus {
            try container.encode(assignmentStatus, forKey: ClientRuntime.Key("AssignmentStatus"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        try container.encode("ListVirtualMFADevices", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListVirtualMFADevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVirtualMFADevicesInput: Swift.Equatable {
    /// The status (Unassigned or Assigned) of the devices to list. If you do not specify an AssignmentStatus, the operation defaults to Any, which lists both assigned and unassigned virtual MFA devices.,
    public var assignmentStatus: IAMClientTypes.AssignmentStatusType?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?

    public init (
        assignmentStatus: IAMClientTypes.AssignmentStatusType? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.assignmentStatus = assignmentStatus
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListVirtualMFADevicesInputBody: Swift.Equatable {
    let assignmentStatus: IAMClientTypes.AssignmentStatusType?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListVirtualMFADevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentStatus = "AssignmentStatus"
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AssignmentStatusType.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListVirtualMFADevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListVirtualMFADevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVirtualMFADevicesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualMFADevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVirtualMFADevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isTruncated = output.isTruncated
            self.marker = output.marker
            self.virtualMFADevices = output.virtualMFADevices
        } else {
            self.isTruncated = false
            self.marker = nil
            self.virtualMFADevices = nil
        }
    }
}

/// Contains the response to a successful [ListVirtualMFADevices] request.
public struct ListVirtualMFADevicesOutputResponse: Swift.Equatable {
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?
    /// The list of virtual MFA devices in the current account that match the AssignmentStatus value that was passed in the request.
    /// This member is required.
    public var virtualMFADevices: [IAMClientTypes.VirtualMFADevice]?

    public init (
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil,
        virtualMFADevices: [IAMClientTypes.VirtualMFADevice]? = nil
    )
    {
        self.isTruncated = isTruncated
        self.marker = marker
        self.virtualMFADevices = virtualMFADevices
    }
}

struct ListVirtualMFADevicesOutputResponseBody: Swift.Equatable {
    let virtualMFADevices: [IAMClientTypes.VirtualMFADevice]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension ListVirtualMFADevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case virtualMFADevices = "VirtualMFADevices"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListVirtualMFADevicesResult"))
        if containerValues.contains(.virtualMFADevices) {
            struct KeyVal0{struct member{}}
            let virtualMFADevicesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .virtualMFADevices)
            if let virtualMFADevicesWrappedContainer = virtualMFADevicesWrappedContainer {
                let virtualMFADevicesContainer = try virtualMFADevicesWrappedContainer.decodeIfPresent([IAMClientTypes.VirtualMFADevice].self, forKey: .member)
                var virtualMFADevicesBuffer:[IAMClientTypes.VirtualMFADevice]? = nil
                if let virtualMFADevicesContainer = virtualMFADevicesContainer {
                    virtualMFADevicesBuffer = [IAMClientTypes.VirtualMFADevice]()
                    for structureContainer0 in virtualMFADevicesContainer {
                        virtualMFADevicesBuffer?.append(structureContainer0)
                    }
                }
                virtualMFADevices = virtualMFADevicesBuffer
            } else {
                virtualMFADevices = []
            }
        } else {
            virtualMFADevices = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension IAMClientTypes.LoginProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case passwordResetRequired = "PasswordResetRequired"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if passwordResetRequired != false {
            try container.encode(passwordResetRequired, forKey: ClientRuntime.Key("PasswordResetRequired"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let passwordResetRequiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .passwordResetRequired)
        passwordResetRequired = passwordResetRequiredDecoded
    }
}

extension IAMClientTypes {
    /// Contains the user name and password create date for a user. This data type is used as a response element in the [CreateLoginProfile] and [GetLoginProfile] operations.
    public struct LoginProfile: Swift.Equatable {
        /// The date when the password for the user was created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// Specifies whether the user is required to set a new password on next sign-in.
        public var passwordResetRequired: Swift.Bool
        /// The name of the user, which can be used for signing in to the Amazon Web Services Management Console.
        /// This member is required.
        public var userName: Swift.String?

        public init (
            createDate: ClientRuntime.Date? = nil,
            passwordResetRequired: Swift.Bool = false,
            userName: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.passwordResetRequired = passwordResetRequired
            self.userName = userName
        }
    }

}

extension IAMClientTypes.MFADevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableDate = "EnableDate"
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enableDate = enableDate {
            try container.encodeTimestamp(enableDate, format: .dateTime, forKey: ClientRuntime.Key("enableDate"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let enableDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .enableDate)
        enableDate = enableDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an MFA device. This data type is used as a response element in the [ListMFADevices] operation.
    public struct MFADevice: Swift.Equatable {
        /// The date when the MFA device was enabled for the user.
        /// This member is required.
        public var enableDate: ClientRuntime.Date?
        /// The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN.
        /// This member is required.
        public var serialNumber: Swift.String?
        /// The user with whom the MFA device is associated.
        /// This member is required.
        public var userName: Swift.String?

        public init (
            enableDate: ClientRuntime.Date? = nil,
            serialNumber: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.enableDate = enableDate
            self.serialNumber = serialNumber
            self.userName = userName
        }
    }

}

extension MalformedCertificateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<MalformedCertificateExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the certificate was malformed or expired. The error message describes the specific error.
public struct MalformedCertificateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedCertificateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MalformedCertificateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MalformedPolicyDocumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<MalformedPolicyDocumentExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the policy document was malformed. The error message describes the specific error.
public struct MalformedPolicyDocumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedPolicyDocumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MalformedPolicyDocumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes.ManagedPolicyDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case attachmentCount = "AttachmentCount"
        case createDate = "CreateDate"
        case defaultVersionId = "DefaultVersionId"
        case description = "Description"
        case isAttachable = "IsAttachable"
        case path = "Path"
        case permissionsBoundaryUsageCount = "PermissionsBoundaryUsageCount"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case policyVersionList = "PolicyVersionList"
        case updateDate = "UpdateDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let attachmentCount = attachmentCount {
            try container.encode(attachmentCount, forKey: ClientRuntime.Key("AttachmentCount"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if let defaultVersionId = defaultVersionId {
            try container.encode(defaultVersionId, forKey: ClientRuntime.Key("DefaultVersionId"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if isAttachable != false {
            try container.encode(isAttachable, forKey: ClientRuntime.Key("IsAttachable"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundaryUsageCount = permissionsBoundaryUsageCount {
            try container.encode(permissionsBoundaryUsageCount, forKey: ClientRuntime.Key("PermissionsBoundaryUsageCount"))
        }
        if let policyId = policyId {
            try container.encode(policyId, forKey: ClientRuntime.Key("PolicyId"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let policyVersionList = policyVersionList {
            if !policyVersionList.isEmpty {
                var policyVersionListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyVersionList"))
                for (index0, policyversion0) in policyVersionList.enumerated() {
                    try policyVersionListContainer.encode(policyversion0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyVersionListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyVersionList"))
                try policyVersionListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let updateDate = updateDate {
            try container.encodeTimestamp(updateDate, format: .dateTime, forKey: ClientRuntime.Key("updateDate"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let attachmentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attachmentCount)
        attachmentCount = attachmentCountDecoded
        let permissionsBoundaryUsageCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permissionsBoundaryUsageCount)
        permissionsBoundaryUsageCount = permissionsBoundaryUsageCountDecoded
        let isAttachableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isAttachable)
        isAttachable = isAttachableDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let updateDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateDate)
        updateDate = updateDateDecoded
        if containerValues.contains(.policyVersionList) {
            struct KeyVal0{struct member{}}
            let policyVersionListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyVersionList)
            if let policyVersionListWrappedContainer = policyVersionListWrappedContainer {
                let policyVersionListContainer = try policyVersionListWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyVersion].self, forKey: .member)
                var policyVersionListBuffer:[IAMClientTypes.PolicyVersion]? = nil
                if let policyVersionListContainer = policyVersionListContainer {
                    policyVersionListBuffer = [IAMClientTypes.PolicyVersion]()
                    for structureContainer0 in policyVersionListContainer {
                        policyVersionListBuffer?.append(structureContainer0)
                    }
                }
                policyVersionList = policyVersionListBuffer
            } else {
                policyVersionList = []
            }
        } else {
            policyVersionList = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a managed policy, including the policy's ARN, versions, and the number of principal entities (users, groups, and roles) that the policy is attached to. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation. For more information about managed policies, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct ManagedPolicyDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The number of principal entities (users, groups, and roles) that the policy is attached to.
        public var attachmentCount: Swift.Int?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was created.
        public var createDate: ClientRuntime.Date?
        /// The identifier for the version of the policy that is set as the default (operative) version. For more information about policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
        public var defaultVersionId: Swift.String?
        /// A friendly description of the policy.
        public var description: Swift.String?
        /// Specifies whether the policy can be attached to an IAM user, group, or role.
        public var isAttachable: Swift.Bool
        /// The path to the policy. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The number of entities (users and roles) for which the policy is used as the permissions boundary. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundaryUsageCount: Swift.Int?
        /// The stable and unique string identifying the policy. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var policyId: Swift.String?
        /// The friendly name (not ARN) identifying the policy.
        public var policyName: Swift.String?
        /// A list containing information about the versions of the policy.
        public var policyVersionList: [IAMClientTypes.PolicyVersion]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was last updated. When a policy has only one version, this field contains the date and time when the policy was created. When a policy has more than one version, this field contains the date and time when the most recent policy version was created.
        public var updateDate: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            attachmentCount: Swift.Int? = nil,
            createDate: ClientRuntime.Date? = nil,
            defaultVersionId: Swift.String? = nil,
            description: Swift.String? = nil,
            isAttachable: Swift.Bool = false,
            path: Swift.String? = nil,
            permissionsBoundaryUsageCount: Swift.Int? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyVersionList: [IAMClientTypes.PolicyVersion]? = nil,
            updateDate: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.attachmentCount = attachmentCount
            self.createDate = createDate
            self.defaultVersionId = defaultVersionId
            self.description = description
            self.isAttachable = isAttachable
            self.path = path
            self.permissionsBoundaryUsageCount = permissionsBoundaryUsageCount
            self.policyId = policyId
            self.policyName = policyName
            self.policyVersionList = policyVersionList
            self.updateDate = updateDate
        }
    }

}

extension NoSuchEntityException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchEntityExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it referenced a resource entity that does not exist. The error message describes the resource.
public struct NoSuchEntityException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchEntityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes.OpenIDConnectProviderListEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IAMClientTypes {
    /// Contains the Amazon Resource Name (ARN) for an IAM OpenID Connect provider.
    public struct OpenIDConnectProviderListEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension IAMClientTypes.OrganizationsDecisionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedByOrganizations = "AllowedByOrganizations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowedByOrganizations != false {
            try container.encode(allowedByOrganizations, forKey: ClientRuntime.Key("AllowedByOrganizations"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedByOrganizationsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowedByOrganizations)
        allowedByOrganizations = allowedByOrganizationsDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about the effect that Organizations has on a policy simulation.
    public struct OrganizationsDecisionDetail: Swift.Equatable {
        /// Specifies whether the simulated operation is allowed by the Organizations service control policies that impact the simulated user's account.
        public var allowedByOrganizations: Swift.Bool

        public init (
            allowedByOrganizations: Swift.Bool = false
        )
        {
            self.allowedByOrganizations = allowedByOrganizations
        }
    }

}

extension IAMClientTypes.PasswordPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUsersToChangePassword = "AllowUsersToChangePassword"
        case expirePasswords = "ExpirePasswords"
        case hardExpiry = "HardExpiry"
        case maxPasswordAge = "MaxPasswordAge"
        case minimumPasswordLength = "MinimumPasswordLength"
        case passwordReusePrevention = "PasswordReusePrevention"
        case requireLowercaseCharacters = "RequireLowercaseCharacters"
        case requireNumbers = "RequireNumbers"
        case requireSymbols = "RequireSymbols"
        case requireUppercaseCharacters = "RequireUppercaseCharacters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowUsersToChangePassword != false {
            try container.encode(allowUsersToChangePassword, forKey: ClientRuntime.Key("AllowUsersToChangePassword"))
        }
        if expirePasswords != false {
            try container.encode(expirePasswords, forKey: ClientRuntime.Key("ExpirePasswords"))
        }
        if let hardExpiry = hardExpiry {
            try container.encode(hardExpiry, forKey: ClientRuntime.Key("HardExpiry"))
        }
        if let maxPasswordAge = maxPasswordAge {
            try container.encode(maxPasswordAge, forKey: ClientRuntime.Key("MaxPasswordAge"))
        }
        if let minimumPasswordLength = minimumPasswordLength {
            try container.encode(minimumPasswordLength, forKey: ClientRuntime.Key("MinimumPasswordLength"))
        }
        if let passwordReusePrevention = passwordReusePrevention {
            try container.encode(passwordReusePrevention, forKey: ClientRuntime.Key("PasswordReusePrevention"))
        }
        if requireLowercaseCharacters != false {
            try container.encode(requireLowercaseCharacters, forKey: ClientRuntime.Key("RequireLowercaseCharacters"))
        }
        if requireNumbers != false {
            try container.encode(requireNumbers, forKey: ClientRuntime.Key("RequireNumbers"))
        }
        if requireSymbols != false {
            try container.encode(requireSymbols, forKey: ClientRuntime.Key("RequireSymbols"))
        }
        if requireUppercaseCharacters != false {
            try container.encode(requireUppercaseCharacters, forKey: ClientRuntime.Key("RequireUppercaseCharacters"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumPasswordLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumPasswordLength)
        minimumPasswordLength = minimumPasswordLengthDecoded
        let requireSymbolsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .requireSymbols)
        requireSymbols = requireSymbolsDecoded
        let requireNumbersDecoded = try containerValues.decode(Swift.Bool.self, forKey: .requireNumbers)
        requireNumbers = requireNumbersDecoded
        let requireUppercaseCharactersDecoded = try containerValues.decode(Swift.Bool.self, forKey: .requireUppercaseCharacters)
        requireUppercaseCharacters = requireUppercaseCharactersDecoded
        let requireLowercaseCharactersDecoded = try containerValues.decode(Swift.Bool.self, forKey: .requireLowercaseCharacters)
        requireLowercaseCharacters = requireLowercaseCharactersDecoded
        let allowUsersToChangePasswordDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUsersToChangePassword)
        allowUsersToChangePassword = allowUsersToChangePasswordDecoded
        let expirePasswordsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .expirePasswords)
        expirePasswords = expirePasswordsDecoded
        let maxPasswordAgeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxPasswordAge)
        maxPasswordAge = maxPasswordAgeDecoded
        let passwordReusePreventionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .passwordReusePrevention)
        passwordReusePrevention = passwordReusePreventionDecoded
        let hardExpiryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hardExpiry)
        hardExpiry = hardExpiryDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about the account password policy. This data type is used as a response element in the [GetAccountPasswordPolicy] operation.
    public struct PasswordPolicy: Swift.Equatable {
        /// Specifies whether IAM users are allowed to change their own password. Gives IAM users permissions to iam:ChangePassword for only their user and to the iam:GetAccountPasswordPolicy action. This option does not attach a permissions policy to each user, rather the permissions are applied at the account-level for all users by IAM.
        public var allowUsersToChangePassword: Swift.Bool
        /// Indicates whether passwords in the account expire. Returns true if MaxPasswordAge contains a value greater than 0. Returns false if MaxPasswordAge is 0 or not present.
        public var expirePasswords: Swift.Bool
        /// Specifies whether IAM users are prevented from setting a new password via the Amazon Web Services Management Console after their password has expired. The IAM user cannot access the console until an administrator resets the password. IAM users with iam:ChangePassword permission and active access keys can reset their own expired console password using the CLI or API.
        public var hardExpiry: Swift.Bool?
        /// The number of days that an IAM user password is valid.
        public var maxPasswordAge: Swift.Int?
        /// Minimum length to require for IAM user passwords.
        public var minimumPasswordLength: Swift.Int?
        /// Specifies the number of previous passwords that IAM users are prevented from reusing.
        public var passwordReusePrevention: Swift.Int?
        /// Specifies whether IAM user passwords must contain at least one lowercase character (a to z).
        public var requireLowercaseCharacters: Swift.Bool
        /// Specifies whether IAM user passwords must contain at least one numeric character (0 to 9).
        public var requireNumbers: Swift.Bool
        /// Specifies whether IAM user passwords must contain at least one of the following symbols: ! @ # $ % ^ & * ( ) _ + - = [ ] { } | '
        public var requireSymbols: Swift.Bool
        /// Specifies whether IAM user passwords must contain at least one uppercase character (A to Z).
        public var requireUppercaseCharacters: Swift.Bool

        public init (
            allowUsersToChangePassword: Swift.Bool = false,
            expirePasswords: Swift.Bool = false,
            hardExpiry: Swift.Bool? = nil,
            maxPasswordAge: Swift.Int? = nil,
            minimumPasswordLength: Swift.Int? = nil,
            passwordReusePrevention: Swift.Int? = nil,
            requireLowercaseCharacters: Swift.Bool = false,
            requireNumbers: Swift.Bool = false,
            requireSymbols: Swift.Bool = false,
            requireUppercaseCharacters: Swift.Bool = false
        )
        {
            self.allowUsersToChangePassword = allowUsersToChangePassword
            self.expirePasswords = expirePasswords
            self.hardExpiry = hardExpiry
            self.maxPasswordAge = maxPasswordAge
            self.minimumPasswordLength = minimumPasswordLength
            self.passwordReusePrevention = passwordReusePrevention
            self.requireLowercaseCharacters = requireLowercaseCharacters
            self.requireNumbers = requireNumbers
            self.requireSymbols = requireSymbols
            self.requireUppercaseCharacters = requireUppercaseCharacters
        }
    }

}

extension PasswordPolicyViolationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<PasswordPolicyViolationExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the provided password did not meet the requirements imposed by the account password policy.
public struct PasswordPolicyViolationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PasswordPolicyViolationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PasswordPolicyViolationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes {
    public enum PermissionsBoundaryAttachmentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case policy
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionsBoundaryAttachmentType] {
            return [
                .policy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .policy: return "PermissionsBoundaryPolicy"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionsBoundaryAttachmentType(rawValue: rawValue) ?? PermissionsBoundaryAttachmentType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.PermissionsBoundaryDecisionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedByPermissionsBoundary = "AllowedByPermissionsBoundary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowedByPermissionsBoundary != false {
            try container.encode(allowedByPermissionsBoundary, forKey: ClientRuntime.Key("AllowedByPermissionsBoundary"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedByPermissionsBoundaryDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowedByPermissionsBoundary)
        allowedByPermissionsBoundary = allowedByPermissionsBoundaryDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about the effect that a permissions boundary has on a policy simulation when the boundary is applied to an IAM entity.
    public struct PermissionsBoundaryDecisionDetail: Swift.Equatable {
        /// Specifies whether an action is allowed by a permissions boundary that is applied to an IAM entity (user or role). A value of true means that the permissions boundary does not deny the action. This means that the policy includes an Allow statement that matches the request. In this case, if an identity-based policy also allows the action, the request is allowed. A value of false means that either the requested action is not allowed (implicitly denied) or that the action is explicitly denied by the permissions boundary. In both of these cases, the action is not allowed, regardless of the identity-based policy.
        public var allowedByPermissionsBoundary: Swift.Bool

        public init (
            allowedByPermissionsBoundary: Swift.Bool = false
        )
        {
            self.allowedByPermissionsBoundary = allowedByPermissionsBoundary
        }
    }

}

extension IAMClientTypes.Policy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case attachmentCount = "AttachmentCount"
        case createDate = "CreateDate"
        case defaultVersionId = "DefaultVersionId"
        case description = "Description"
        case isAttachable = "IsAttachable"
        case path = "Path"
        case permissionsBoundaryUsageCount = "PermissionsBoundaryUsageCount"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case tags = "Tags"
        case updateDate = "UpdateDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let attachmentCount = attachmentCount {
            try container.encode(attachmentCount, forKey: ClientRuntime.Key("AttachmentCount"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if let defaultVersionId = defaultVersionId {
            try container.encode(defaultVersionId, forKey: ClientRuntime.Key("DefaultVersionId"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if isAttachable != false {
            try container.encode(isAttachable, forKey: ClientRuntime.Key("IsAttachable"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundaryUsageCount = permissionsBoundaryUsageCount {
            try container.encode(permissionsBoundaryUsageCount, forKey: ClientRuntime.Key("PermissionsBoundaryUsageCount"))
        }
        if let policyId = policyId {
            try container.encode(policyId, forKey: ClientRuntime.Key("PolicyId"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let updateDate = updateDate {
            try container.encodeTimestamp(updateDate, format: .dateTime, forKey: ClientRuntime.Key("updateDate"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let attachmentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attachmentCount)
        attachmentCount = attachmentCountDecoded
        let permissionsBoundaryUsageCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permissionsBoundaryUsageCount)
        permissionsBoundaryUsageCount = permissionsBoundaryUsageCountDecoded
        let isAttachableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isAttachable)
        isAttachable = isAttachableDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let updateDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateDate)
        updateDate = updateDateDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a managed policy. This data type is used as a response element in the [CreatePolicy], [GetPolicy], and [ListPolicies] operations. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct Policy: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The number of entities (users, groups, and roles) that the policy is attached to.
        public var attachmentCount: Swift.Int?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was created.
        public var createDate: ClientRuntime.Date?
        /// The identifier for the version of the policy that is set as the default version.
        public var defaultVersionId: Swift.String?
        /// A friendly description of the policy. This element is included in the response to the [GetPolicy] operation. It is not included in the response to the [ListPolicies] operation.
        public var description: Swift.String?
        /// Specifies whether the policy can be attached to an IAM user, group, or role.
        public var isAttachable: Swift.Bool
        /// The path to the policy. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The number of entities (users and roles) for which the policy is used to set the permissions boundary. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundaryUsageCount: Swift.Int?
        /// The stable and unique string identifying the policy. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var policyId: Swift.String?
        /// The friendly name (not ARN) identifying the policy.
        public var policyName: Swift.String?
        /// A list of tags that are attached to the instance profile. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy was last updated. When a policy has only one version, this field contains the date and time when the policy was created. When a policy has more than one version, this field contains the date and time when the most recent policy version was created.
        public var updateDate: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            attachmentCount: Swift.Int? = nil,
            createDate: ClientRuntime.Date? = nil,
            defaultVersionId: Swift.String? = nil,
            description: Swift.String? = nil,
            isAttachable: Swift.Bool = false,
            path: Swift.String? = nil,
            permissionsBoundaryUsageCount: Swift.Int? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            updateDate: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.attachmentCount = attachmentCount
            self.createDate = createDate
            self.defaultVersionId = defaultVersionId
            self.description = description
            self.isAttachable = isAttachable
            self.path = path
            self.permissionsBoundaryUsageCount = permissionsBoundaryUsageCount
            self.policyId = policyId
            self.policyName = policyName
            self.tags = tags
            self.updateDate = updateDate
        }
    }

}

extension IAMClientTypes.PolicyDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM policy, including the policy document. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct PolicyDetail: Swift.Equatable {
        /// The policy document.
        public var policyDocument: Swift.String?
        /// The name of the policy.
        public var policyName: Swift.String?

        public init (
            policyDocument: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.policyDocument = policyDocument
            self.policyName = policyName
        }
    }

}

extension IAMClientTypes {
    public enum PolicyEvaluationDecisionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allowed
        case explicitDeny
        case implicitDeny
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyEvaluationDecisionType] {
            return [
                .allowed,
                .explicitDeny,
                .implicitDeny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allowed: return "allowed"
            case .explicitDeny: return "explicitDeny"
            case .implicitDeny: return "implicitDeny"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyEvaluationDecisionType(rawValue: rawValue) ?? PolicyEvaluationDecisionType.sdkUnknown(rawValue)
        }
    }
}

extension PolicyEvaluationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<PolicyEvaluationExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed because a provided policy could not be successfully evaluated. An additional detailed message indicates the source of the failure.
public struct PolicyEvaluationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyEvaluationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PolicyEvaluationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes.PolicyGrantingServiceAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityName = "EntityName"
        case entityType = "EntityType"
        case policyArn = "PolicyArn"
        case policyName = "PolicyName"
        case policyType = "PolicyType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let entityName = entityName {
            try container.encode(entityName, forKey: ClientRuntime.Key("EntityName"))
        }
        if let entityType = entityType {
            try container.encode(entityType, forKey: ClientRuntime.Key("EntityType"))
        }
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let policyType = policyType {
            try container.encode(policyType, forKey: ClientRuntime.Key("PolicyType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyType.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyOwnerEntityType.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
    }
}

extension IAMClientTypes {
    /// Contains details about the permissions policies that are attached to the specified identity (user, group, or role). This data type is an element of the [ListPoliciesGrantingServiceAccessEntry] object.
    public struct PolicyGrantingServiceAccess: Swift.Equatable {
        /// The name of the entity (user or role) to which the inline policy is attached. This field is null for managed policies. For more information about these policy types, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html) in the IAM User Guide.
        public var entityName: Swift.String?
        /// The type of entity (user or role) that used the policy to access the service to which the inline policy is attached. This field is null for managed policies. For more information about these policy types, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html) in the IAM User Guide.
        public var entityType: IAMClientTypes.PolicyOwnerEntityType?
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var policyArn: Swift.String?
        /// The policy name.
        /// This member is required.
        public var policyName: Swift.String?
        /// The policy type. For more information about these policy types, see [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html) in the IAM User Guide.
        /// This member is required.
        public var policyType: IAMClientTypes.PolicyType?

        public init (
            entityName: Swift.String? = nil,
            entityType: IAMClientTypes.PolicyOwnerEntityType? = nil,
            policyArn: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyType: IAMClientTypes.PolicyType? = nil
        )
        {
            self.entityName = entityName
            self.entityType = entityType
            self.policyArn = policyArn
            self.policyName = policyName
            self.policyType = policyType
        }
    }

}

extension IAMClientTypes.PolicyGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupId = groupId {
            try container.encode(groupId, forKey: ClientRuntime.Key("GroupId"))
        }
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about a group that a managed policy is attached to. This data type is used as a response element in the [ListEntitiesForPolicy] operation. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyGroup: Swift.Equatable {
        /// The stable and unique string identifying the group. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        public var groupId: Swift.String?
        /// The name (friendly name, not ARN) identifying the group.
        public var groupName: Swift.String?

        public init (
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }

}

extension PolicyNotAttachableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<PolicyNotAttachableExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed because Amazon Web Services service role policies can only be attached to the service-linked role for that service.
public struct PolicyNotAttachableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyNotAttachableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PolicyNotAttachableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes {
    public enum PolicyOwnerEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case role
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyOwnerEntityType] {
            return [
                .group,
                .role,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .role: return "ROLE"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyOwnerEntityType(rawValue: rawValue) ?? PolicyOwnerEntityType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.PolicyRole: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleId = "RoleId"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleId = roleId {
            try container.encode(roleId, forKey: ClientRuntime.Key("RoleId"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleId)
        roleId = roleIdDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about a role that a managed policy is attached to. This data type is used as a response element in the [ListEntitiesForPolicy] operation. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyRole: Swift.Equatable {
        /// The stable and unique string identifying the role. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        public var roleId: Swift.String?
        /// The name (friendly name, not ARN) identifying the role.
        public var roleName: Swift.String?

        public init (
            roleId: Swift.String? = nil,
            roleName: Swift.String? = nil
        )
        {
            self.roleId = roleId
            self.roleName = roleName
        }
    }

}

extension IAMClientTypes {
    public enum PolicyScopeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aws
        case all
        case local
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyScopeType] {
            return [
                .aws,
                .all,
                .local,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .all: return "All"
            case .local: return "Local"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyScopeType(rawValue: rawValue) ?? PolicyScopeType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes {
    public enum PolicySourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsManaged
        case group
        case `none`
        case resource
        case role
        case user
        case userManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicySourceType] {
            return [
                .awsManaged,
                .group,
                .none,
                .resource,
                .role,
                .user,
                .userManaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsManaged: return "aws-managed"
            case .group: return "group"
            case .none: return "none"
            case .resource: return "resource"
            case .role: return "role"
            case .user: return "user"
            case .userManaged: return "user-managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicySourceType(rawValue: rawValue) ?? PolicySourceType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes {
    public enum PolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inline
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyType] {
            return [
                .inline,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inline: return "INLINE"
            case .managed: return "MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyType(rawValue: rawValue) ?? PolicyType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes {
    /// The policy usage type that indicates whether the policy is used as a permissions policy or as the permissions boundary for an entity. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
    public enum PolicyUsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case permissionsboundary
        case permissionspolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyUsageType] {
            return [
                .permissionsboundary,
                .permissionspolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .permissionsboundary: return "PermissionsBoundary"
            case .permissionspolicy: return "PermissionsPolicy"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyUsageType(rawValue: rawValue) ?? PolicyUsageType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.PolicyUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId = "UserId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let userId = userId {
            try container.encode(userId, forKey: ClientRuntime.Key("UserId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about a user that a managed policy is attached to. This data type is used as a response element in the [ListEntitiesForPolicy] operation. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyUser: Swift.Equatable {
        /// The stable and unique string identifying the user. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        public var userId: Swift.String?
        /// The name (friendly name, not ARN) identifying the user.
        public var userName: Swift.String?

        public init (
            userId: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.userId = userId
            self.userName = userName
        }
    }

}

extension IAMClientTypes.PolicyVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case document = "Document"
        case isDefaultVersion = "IsDefaultVersion"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if let document = document {
            try container.encode(document, forKey: ClientRuntime.Key("Document"))
        }
        if isDefaultVersion != false {
            try container.encode(isDefaultVersion, forKey: ClientRuntime.Key("IsDefaultVersion"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let isDefaultVersionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isDefaultVersion)
        isDefaultVersion = isDefaultVersionDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about a version of a managed policy. This data type is used as a response element in the [CreatePolicyVersion], [GetPolicyVersion], [ListPolicyVersions], and [GetAccountAuthorizationDetails] operations. For more information about managed policies, refer to [Managed policies and inline policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the IAM User Guide.
    public struct PolicyVersion: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the policy version was created.
        public var createDate: ClientRuntime.Date?
        /// The policy document. The policy document is returned in the response to the [GetPolicyVersion] and [GetAccountAuthorizationDetails] operations. It is not returned in the response to the [CreatePolicyVersion] or [ListPolicyVersions] operations. The policy document returned in this structure is URL-encoded compliant with [RFC 3986](https://tools.ietf.org/html/rfc3986). You can use a URL decoding method to convert the policy back to plain JSON text. For example, if you use Java, you can use the decode method of the java.net.URLDecoder utility class in the Java SDK. Other languages and SDKs provide similar functionality.
        public var document: Swift.String?
        /// Specifies whether the policy version is set as the policy's default version.
        public var isDefaultVersion: Swift.Bool
        /// The identifier for the policy version. Policy version identifiers always begin with v (always lowercase). When a policy is created, the first policy version is v1.
        public var versionId: Swift.String?

        public init (
            createDate: ClientRuntime.Date? = nil,
            document: Swift.String? = nil,
            isDefaultVersion: Swift.Bool = false,
            versionId: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.document = document
            self.isDefaultVersion = isDefaultVersion
            self.versionId = versionId
        }
    }

}

extension IAMClientTypes.Position: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column = "Column"
        case line = "Line"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if column != 0 {
            try container.encode(column, forKey: ClientRuntime.Key("Column"))
        }
        if line != 0 {
            try container.encode(line, forKey: ClientRuntime.Key("Line"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineDecoded = try containerValues.decode(Swift.Int.self, forKey: .line)
        line = lineDecoded
        let columnDecoded = try containerValues.decode(Swift.Int.self, forKey: .column)
        column = columnDecoded
    }
}

extension IAMClientTypes {
    /// Contains the row and column of a location of a Statement element in a policy document. This data type is used as a member of the [Statement] type.
    public struct Position: Swift.Equatable {
        /// The column in the line containing the specified position in the document.
        public var column: Swift.Int
        /// The line containing the specified position in the document.
        public var line: Swift.Int

        public init (
            column: Swift.Int = 0,
            line: Swift.Int = 0
        )
        {
            self.column = column
            self.line = line
        }
    }

}

extension PutGroupPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        try container.encode("PutGroupPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutGroupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutGroupPolicyInput: Swift.Equatable {
    /// The name of the group to associate the policy with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-.
    /// This member is required.
    public var groupName: Swift.String?
    /// The policy document. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to = IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy document. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?

    public init (
        groupName: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.policyDocument = policyDocument
        self.policyName = policyName
    }
}

struct PutGroupPolicyInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let policyName: Swift.String?
    let policyDocument: Swift.String?
}

extension PutGroupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutGroupPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutGroupPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocument" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutGroupPolicyOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutGroupPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutGroupPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutRolePermissionsBoundaryInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("PutRolePermissionsBoundary", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutRolePermissionsBoundaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRolePermissionsBoundaryInput: Swift.Equatable {
    /// The ARN of the managed policy that is used to set the permissions boundary for the role. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    /// This member is required.
    public var permissionsBoundary: Swift.String?
    /// The name (friendly name, not ARN) of the IAM role for which you want to set the permissions boundary.
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        permissionsBoundary: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.permissionsBoundary = permissionsBoundary
        self.roleName = roleName
    }
}

struct PutRolePermissionsBoundaryInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let permissionsBoundary: Swift.String?
}

extension PutRolePermissionsBoundaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionsBoundary = "PermissionsBoundary"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
    }
}

extension PutRolePermissionsBoundaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutRolePermissionsBoundaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotAttachable" : self = .policyNotAttachableException(try PolicyNotAttachableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntity" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutRolePermissionsBoundaryOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case policyNotAttachableException(PolicyNotAttachableException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRolePermissionsBoundaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutRolePermissionsBoundaryOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutRolePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("PutRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutRolePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRolePolicyInput: Swift.Equatable {
    /// The policy document. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy document. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the role to associate the policy with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.roleName = roleName
    }
}

struct PutRolePolicyInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let policyName: Swift.String?
    let policyDocument: Swift.String?
}

extension PutRolePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutRolePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutRolePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocument" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntity" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutRolePolicyOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRolePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutRolePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutUserPermissionsBoundaryInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("PutUserPermissionsBoundary", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutUserPermissionsBoundaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutUserPermissionsBoundaryInput: Swift.Equatable {
    /// The ARN of the managed policy that is used to set the permissions boundary for the user. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. For more information about policy types, see [Policy types ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types) in the IAM User Guide.
    /// This member is required.
    public var permissionsBoundary: Swift.String?
    /// The name (friendly name, not ARN) of the IAM user for which you want to set the permissions boundary.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        permissionsBoundary: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.permissionsBoundary = permissionsBoundary
        self.userName = userName
    }
}

struct PutUserPermissionsBoundaryInputBody: Swift.Equatable {
    let userName: Swift.String?
    let permissionsBoundary: Swift.String?
}

extension PutUserPermissionsBoundaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionsBoundary = "PermissionsBoundary"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
    }
}

extension PutUserPermissionsBoundaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutUserPermissionsBoundaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotAttachable" : self = .policyNotAttachableException(try PolicyNotAttachableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutUserPermissionsBoundaryOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case policyNotAttachableException(PolicyNotAttachableException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutUserPermissionsBoundaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutUserPermissionsBoundaryOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutUserPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("PutUserPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutUserPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutUserPolicyInput: Swift.Equatable {
    /// The policy document. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the policy document. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the user to associate the policy with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.userName = userName
    }
}

struct PutUserPolicyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let policyName: Swift.String?
    let policyDocument: Swift.String?
}

extension PutUserPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutUserPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutUserPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocument" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutUserPolicyOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutUserPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutUserPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension RemoveClientIDFromOpenIDConnectProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let clientID = clientID {
            try container.encode(clientID, forKey: ClientRuntime.Key("ClientID"))
        }
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        try container.encode("RemoveClientIDFromOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveClientIDFromOpenIDConnectProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveClientIDFromOpenIDConnectProviderInput: Swift.Equatable {
    /// The client ID (also known as audience) to remove from the IAM OIDC provider resource. For more information about client IDs, see [CreateOpenIDConnectProvider].
    /// This member is required.
    public var clientID: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM OIDC provider resource to remove the client ID from. You can get a list of OIDC provider ARNs by using the [ListOpenIDConnectProviders] operation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?

    public init (
        clientID: Swift.String? = nil,
        openIDConnectProviderArn: Swift.String? = nil
    )
    {
        self.clientID = clientID
        self.openIDConnectProviderArn = openIDConnectProviderArn
    }
}

struct RemoveClientIDFromOpenIDConnectProviderInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
    let clientID: Swift.String?
}

extension RemoveClientIDFromOpenIDConnectProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientID = "ClientID"
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
        let clientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientID)
        clientID = clientIDDecoded
    }
}

extension RemoveClientIDFromOpenIDConnectProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveClientIDFromOpenIDConnectProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveClientIDFromOpenIDConnectProviderOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveClientIDFromOpenIDConnectProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveClientIDFromOpenIDConnectProviderOutputResponse: Swift.Equatable {

    public init () { }
}

extension RemoveRoleFromInstanceProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("RemoveRoleFromInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveRoleFromInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveRoleFromInstanceProfileInput: Swift.Equatable {
    /// The name of the instance profile to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The name of the role to remove. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        instanceProfileName: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.roleName = roleName
    }
}

struct RemoveRoleFromInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
    let roleName: Swift.String?
}

extension RemoveRoleFromInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension RemoveRoleFromInstanceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveRoleFromInstanceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntity" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveRoleFromInstanceProfileOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveRoleFromInstanceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveRoleFromInstanceProfileOutputResponse: Swift.Equatable {

    public init () { }
}

extension RemoveUserFromGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("RemoveUserFromGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveUserFromGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveUserFromGroupInput: Swift.Equatable {
    /// The name of the group to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the user to remove. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        groupName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.userName = userName
    }
}

struct RemoveUserFromGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let userName: Swift.String?
}

extension RemoveUserFromGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension RemoveUserFromGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveUserFromGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveUserFromGroupOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveUserFromGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveUserFromGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension IAMClientTypes {
    public enum ReportFormatType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case textCsv
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFormatType] {
            return [
                .textCsv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .textCsv: return "text/csv"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFormatType(rawValue: rawValue) ?? ReportFormatType.sdkUnknown(rawValue)
        }
    }
}

extension ReportGenerationLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ReportGenerationLimitExceededExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed because the maximum number of concurrent requests for this account are already running.
public struct ReportGenerationLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReportGenerationLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReportGenerationLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes {
    public enum ReportStateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case inprogress
        case started
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportStateType] {
            return [
                .complete,
                .inprogress,
                .started,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .inprogress: return "INPROGRESS"
            case .started: return "STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportStateType(rawValue: rawValue) ?? ReportStateType.sdkUnknown(rawValue)
        }
    }
}

extension ResetServiceSpecificCredentialInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: ClientRuntime.Key("ServiceSpecificCredentialId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ResetServiceSpecificCredential", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ResetServiceSpecificCredentialInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResetServiceSpecificCredentialInput: Swift.Equatable {
    /// The unique identifier of the service-specific credential. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var serviceSpecificCredentialId: Swift.String?
    /// The name of the IAM user associated with the service-specific credential. If this value is not specified, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init (
        serviceSpecificCredentialId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.userName = userName
    }
}

struct ResetServiceSpecificCredentialInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serviceSpecificCredentialId: Swift.String?
}

extension ResetServiceSpecificCredentialInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serviceSpecificCredentialIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceSpecificCredentialId)
        serviceSpecificCredentialId = serviceSpecificCredentialIdDecoded
    }
}

extension ResetServiceSpecificCredentialOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResetServiceSpecificCredentialOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ResetServiceSpecificCredentialOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetServiceSpecificCredentialOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResetServiceSpecificCredentialOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceSpecificCredential = output.serviceSpecificCredential
        } else {
            self.serviceSpecificCredential = nil
        }
    }
}

public struct ResetServiceSpecificCredentialOutputResponse: Swift.Equatable {
    /// A structure with details about the updated service-specific credential, including the new password. This is the only time that you can access the password. You cannot recover the password later, but you can reset it again.
    public var serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential?

    public init (
        serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential? = nil
    )
    {
        self.serviceSpecificCredential = serviceSpecificCredential
    }
}

struct ResetServiceSpecificCredentialOutputResponseBody: Swift.Equatable {
    let serviceSpecificCredential: IAMClientTypes.ServiceSpecificCredential?
}

extension ResetServiceSpecificCredentialOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSpecificCredential = "ServiceSpecificCredential"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ResetServiceSpecificCredentialResult"))
        let serviceSpecificCredentialDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ServiceSpecificCredential.self, forKey: .serviceSpecificCredential)
        serviceSpecificCredential = serviceSpecificCredentialDecoded
    }
}

extension IAMClientTypes.ResourceSpecificResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evalDecisionDetails = "EvalDecisionDetails"
        case evalResourceDecision = "EvalResourceDecision"
        case evalResourceName = "EvalResourceName"
        case matchedStatements = "MatchedStatements"
        case missingContextValues = "MissingContextValues"
        case permissionsBoundaryDecisionDetail = "PermissionsBoundaryDecisionDetail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let evalDecisionDetails = evalDecisionDetails {
            var evalDecisionDetailsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EvalDecisionDetails"))
            for (index0, element0) in evalDecisionDetails.sorted(by: { $0.key < $1.key }).enumerated() {
                let evaldecisionsourcetypeKey0 = element0.key
                let policyevaluationdecisiontypeValue0 = element0.value
                var entryContainer0 = evalDecisionDetailsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(evaldecisionsourcetypeKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(policyevaluationdecisiontypeValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let evalResourceDecision = evalResourceDecision {
            try container.encode(evalResourceDecision, forKey: ClientRuntime.Key("EvalResourceDecision"))
        }
        if let evalResourceName = evalResourceName {
            try container.encode(evalResourceName, forKey: ClientRuntime.Key("EvalResourceName"))
        }
        if let matchedStatements = matchedStatements {
            if !matchedStatements.isEmpty {
                var matchedStatementsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MatchedStatements"))
                for (index0, statement0) in matchedStatements.enumerated() {
                    try matchedStatementsContainer.encode(statement0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var matchedStatementsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MatchedStatements"))
                try matchedStatementsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let missingContextValues = missingContextValues {
            if !missingContextValues.isEmpty {
                var missingContextValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MissingContextValues"))
                for (index0, contextkeynametype0) in missingContextValues.enumerated() {
                    try missingContextValuesContainer.encode(contextkeynametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var missingContextValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MissingContextValues"))
                try missingContextValuesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail {
            try container.encode(permissionsBoundaryDecisionDetail, forKey: ClientRuntime.Key("PermissionsBoundaryDecisionDetail"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evalResourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evalResourceName)
        evalResourceName = evalResourceNameDecoded
        let evalResourceDecisionDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicyEvaluationDecisionType.self, forKey: .evalResourceDecision)
        evalResourceDecision = evalResourceDecisionDecoded
        if containerValues.contains(.matchedStatements) {
            struct KeyVal0{struct member{}}
            let matchedStatementsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .matchedStatements)
            if let matchedStatementsWrappedContainer = matchedStatementsWrappedContainer {
                let matchedStatementsContainer = try matchedStatementsWrappedContainer.decodeIfPresent([IAMClientTypes.Statement].self, forKey: .member)
                var matchedStatementsBuffer:[IAMClientTypes.Statement]? = nil
                if let matchedStatementsContainer = matchedStatementsContainer {
                    matchedStatementsBuffer = [IAMClientTypes.Statement]()
                    for structureContainer0 in matchedStatementsContainer {
                        matchedStatementsBuffer?.append(structureContainer0)
                    }
                }
                matchedStatements = matchedStatementsBuffer
            } else {
                matchedStatements = []
            }
        } else {
            matchedStatements = nil
        }
        if containerValues.contains(.missingContextValues) {
            struct KeyVal0{struct member{}}
            let missingContextValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .missingContextValues)
            if let missingContextValuesWrappedContainer = missingContextValuesWrappedContainer {
                let missingContextValuesContainer = try missingContextValuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var missingContextValuesBuffer:[Swift.String]? = nil
                if let missingContextValuesContainer = missingContextValuesContainer {
                    missingContextValuesBuffer = [Swift.String]()
                    for stringContainer0 in missingContextValuesContainer {
                        missingContextValuesBuffer?.append(stringContainer0)
                    }
                }
                missingContextValues = missingContextValuesBuffer
            } else {
                missingContextValues = []
            }
        } else {
            missingContextValues = nil
        }
        if containerValues.contains(.evalDecisionDetails) {
            struct KeyVal0{struct key{}; struct value{}}
            let evalDecisionDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, IAMClientTypes.PolicyEvaluationDecisionType, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .evalDecisionDetails)
            if let evalDecisionDetailsWrappedContainer = evalDecisionDetailsWrappedContainer {
                let evalDecisionDetailsContainer = try evalDecisionDetailsWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, IAMClientTypes.PolicyEvaluationDecisionType, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var evalDecisionDetailsBuffer: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]? = nil
                if let evalDecisionDetailsContainer = evalDecisionDetailsContainer {
                    evalDecisionDetailsBuffer = [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]()
                    for enumContainer0 in evalDecisionDetailsContainer {
                        evalDecisionDetailsBuffer?[enumContainer0.key] = enumContainer0.value
                    }
                }
                evalDecisionDetails = evalDecisionDetailsBuffer
            } else {
                evalDecisionDetails = [:]
            }
        } else {
            evalDecisionDetails = nil
        }
        let permissionsBoundaryDecisionDetailDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PermissionsBoundaryDecisionDetail.self, forKey: .permissionsBoundaryDecisionDetail)
        permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetailDecoded
    }
}

extension IAMClientTypes {
    /// Contains the result of the simulation of a single API operation call on a single resource. This data type is used by a member of the [EvaluationResult] data type.
    public struct ResourceSpecificResult: Swift.Equatable {
        /// Additional details about the results of the evaluation decision on a single resource. This parameter is returned only for cross-account simulations. This parameter explains how each policy type contributes to the resource-specific evaluation decision.
        public var evalDecisionDetails: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]?
        /// The result of the simulation of the simulated API operation on the resource specified in EvalResourceName.
        /// This member is required.
        public var evalResourceDecision: IAMClientTypes.PolicyEvaluationDecisionType?
        /// The name of the simulated resource, in Amazon Resource Name (ARN) format.
        /// This member is required.
        public var evalResourceName: Swift.String?
        /// A list of the statements in the input policies that determine the result for this part of the simulation. Remember that even if multiple statements allow the operation on the resource, if any statement denies that operation, then the explicit deny overrides any allow. In addition, the deny statement is the only entry included in the result.
        public var matchedStatements: [IAMClientTypes.Statement]?
        /// A list of context keys that are required by the included input policies but that were not provided by one of the input parameters. This list is used when a list of ARNs is included in the ResourceArns parameter instead of "*". If you do not specify individual resources, by setting ResourceArns to "*" or by not including the ResourceArns parameter, then any missing context values are instead included under the EvaluationResults section. To discover the context keys used by a set of policies, you can call [GetContextKeysForCustomPolicy] or [GetContextKeysForPrincipalPolicy].
        public var missingContextValues: [Swift.String]?
        /// Contains information about the effect that a permissions boundary has on a policy simulation when that boundary is applied to an IAM entity.
        public var permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail?

        public init (
            evalDecisionDetails: [Swift.String:IAMClientTypes.PolicyEvaluationDecisionType]? = nil,
            evalResourceDecision: IAMClientTypes.PolicyEvaluationDecisionType? = nil,
            evalResourceName: Swift.String? = nil,
            matchedStatements: [IAMClientTypes.Statement]? = nil,
            missingContextValues: [Swift.String]? = nil,
            permissionsBoundaryDecisionDetail: IAMClientTypes.PermissionsBoundaryDecisionDetail? = nil
        )
        {
            self.evalDecisionDetails = evalDecisionDetails
            self.evalResourceDecision = evalResourceDecision
            self.evalResourceName = evalResourceName
            self.matchedStatements = matchedStatements
            self.missingContextValues = missingContextValues
            self.permissionsBoundaryDecisionDetail = permissionsBoundaryDecisionDetail
        }
    }

}

extension ResyncMFADeviceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authenticationCode1 = authenticationCode1 {
            try container.encode(authenticationCode1, forKey: ClientRuntime.Key("AuthenticationCode1"))
        }
        if let authenticationCode2 = authenticationCode2 {
            try container.encode(authenticationCode2, forKey: ClientRuntime.Key("AuthenticationCode2"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("ResyncMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension ResyncMFADeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResyncMFADeviceInput: Swift.Equatable {
    /// An authentication code emitted by the device. The format for this parameter is a sequence of six digits.
    /// This member is required.
    public var authenticationCode1: Swift.String?
    /// A subsequent authentication code emitted by the device. The format for this parameter is a sequence of six digits.
    /// This member is required.
    public var authenticationCode2: Swift.String?
    /// Serial number that uniquely identifies the MFA device. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The name of the user whose MFA device you want to resynchronize. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        authenticationCode1: Swift.String? = nil,
        authenticationCode2: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationCode1 = authenticationCode1
        self.authenticationCode2 = authenticationCode2
        self.serialNumber = serialNumber
        self.userName = userName
    }
}

struct ResyncMFADeviceInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serialNumber: Swift.String?
    let authenticationCode1: Swift.String?
    let authenticationCode2: Swift.String?
}

extension ResyncMFADeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationCode1 = "AuthenticationCode1"
        case authenticationCode2 = "AuthenticationCode2"
        case serialNumber = "SerialNumber"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let authenticationCode1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authenticationCode1)
        authenticationCode1 = authenticationCode1Decoded
        let authenticationCode2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authenticationCode2)
        authenticationCode2 = authenticationCode2Decoded
    }
}

extension ResyncMFADeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResyncMFADeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAuthenticationCode" : self = .invalidAuthenticationCodeException(try InvalidAuthenticationCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ResyncMFADeviceOutputError: Swift.Error, Swift.Equatable {
    case invalidAuthenticationCodeException(InvalidAuthenticationCodeException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResyncMFADeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ResyncMFADeviceOutputResponse: Swift.Equatable {

    public init () { }
}

extension IAMClientTypes.Role: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
        case createDate = "CreateDate"
        case description = "Description"
        case maxSessionDuration = "MaxSessionDuration"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case roleId = "RoleId"
        case roleLastUsed = "RoleLastUsed"
        case roleName = "RoleName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let assumeRolePolicyDocument = assumeRolePolicyDocument {
            try container.encode(assumeRolePolicyDocument, forKey: ClientRuntime.Key("AssumeRolePolicyDocument"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let maxSessionDuration = maxSessionDuration {
            try container.encode(maxSessionDuration, forKey: ClientRuntime.Key("MaxSessionDuration"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let roleId = roleId {
            try container.encode(roleId, forKey: ClientRuntime.Key("RoleId"))
        }
        if let roleLastUsed = roleLastUsed {
            try container.encode(roleLastUsed, forKey: ClientRuntime.Key("RoleLastUsed"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleId)
        roleId = roleIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let assumeRolePolicyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assumeRolePolicyDocument)
        assumeRolePolicyDocument = assumeRolePolicyDocumentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let maxSessionDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSessionDuration)
        maxSessionDuration = maxSessionDurationDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AttachedPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let roleLastUsedDecoded = try containerValues.decodeIfPresent(IAMClientTypes.RoleLastUsed.self, forKey: .roleLastUsed)
        roleLastUsed = roleLastUsedDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM role. This structure is returned as a response element in several API operations that interact with roles.
    public struct Role: Swift.Equatable {
        /// The Amazon Resource Name (ARN) specifying the role. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The policy that grants an entity permission to assume the role.
        public var assumeRolePolicyDocument: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the role was created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// A description of the role that you provide.
        public var description: Swift.String?
        /// The maximum session duration (in seconds) for the specified role. Anyone who uses the CLI, or API to assume the role can specify the duration using the optional DurationSeconds API parameter or duration-seconds CLI parameter.
        public var maxSessionDuration: Swift.Int?
        /// The path to the role. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?
        /// The ARN of the policy used to set the permissions boundary for the role. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// The stable and unique string identifying the role. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var roleId: Swift.String?
        /// Contains information about the last time that an IAM role was used. This includes the date and time and the Region in which the role was last used. Activity is only reported for the trailing 400 days. This period can be shorter if your Region began supporting these features within the last year. The role might have been used more than 400 days ago. For more information, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM User Guide.
        public var roleLastUsed: IAMClientTypes.RoleLastUsed?
        /// The friendly name that identifies the role.
        /// This member is required.
        public var roleName: Swift.String?
        /// A list of tags that are attached to the role. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init (
            arn: Swift.String? = nil,
            assumeRolePolicyDocument: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            maxSessionDuration: Swift.Int? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            roleId: Swift.String? = nil,
            roleLastUsed: IAMClientTypes.RoleLastUsed? = nil,
            roleName: Swift.String? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.arn = arn
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.createDate = createDate
            self.description = description
            self.maxSessionDuration = maxSessionDuration
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.roleId = roleId
            self.roleLastUsed = roleLastUsed
            self.roleName = roleName
            self.tags = tags
        }
    }

}

extension IAMClientTypes.RoleDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case instanceProfileList = "InstanceProfileList"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case roleId = "RoleId"
        case roleLastUsed = "RoleLastUsed"
        case roleName = "RoleName"
        case rolePolicyList = "RolePolicyList"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let assumeRolePolicyDocument = assumeRolePolicyDocument {
            try container.encode(assumeRolePolicyDocument, forKey: ClientRuntime.Key("AssumeRolePolicyDocument"))
        }
        if let attachedManagedPolicies = attachedManagedPolicies {
            if !attachedManagedPolicies.isEmpty {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                for (index0, attachedpolicy0) in attachedManagedPolicies.enumerated() {
                    try attachedManagedPoliciesContainer.encode(attachedpolicy0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                try attachedManagedPoliciesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if let instanceProfileList = instanceProfileList {
            if !instanceProfileList.isEmpty {
                var instanceProfileListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("InstanceProfileList"))
                for (index0, instanceprofile0) in instanceProfileList.enumerated() {
                    try instanceProfileListContainer.encode(instanceprofile0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var instanceProfileListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("InstanceProfileList"))
                try instanceProfileListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let roleId = roleId {
            try container.encode(roleId, forKey: ClientRuntime.Key("RoleId"))
        }
        if let roleLastUsed = roleLastUsed {
            try container.encode(roleLastUsed, forKey: ClientRuntime.Key("RoleLastUsed"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        if let rolePolicyList = rolePolicyList {
            if !rolePolicyList.isEmpty {
                var rolePolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RolePolicyList"))
                for (index0, policydetail0) in rolePolicyList.enumerated() {
                    try rolePolicyListContainer.encode(policydetail0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var rolePolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RolePolicyList"))
                try rolePolicyListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleId)
        roleId = roleIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let assumeRolePolicyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assumeRolePolicyDocument)
        assumeRolePolicyDocument = assumeRolePolicyDocumentDecoded
        if containerValues.contains(.instanceProfileList) {
            struct KeyVal0{struct member{}}
            let instanceProfileListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instanceProfileList)
            if let instanceProfileListWrappedContainer = instanceProfileListWrappedContainer {
                let instanceProfileListContainer = try instanceProfileListWrappedContainer.decodeIfPresent([IAMClientTypes.InstanceProfile].self, forKey: .member)
                var instanceProfileListBuffer:[IAMClientTypes.InstanceProfile]? = nil
                if let instanceProfileListContainer = instanceProfileListContainer {
                    instanceProfileListBuffer = [IAMClientTypes.InstanceProfile]()
                    for structureContainer0 in instanceProfileListContainer {
                        instanceProfileListBuffer?.append(structureContainer0)
                    }
                }
                instanceProfileList = instanceProfileListBuffer
            } else {
                instanceProfileList = []
            }
        } else {
            instanceProfileList = nil
        }
        if containerValues.contains(.rolePolicyList) {
            struct KeyVal0{struct member{}}
            let rolePolicyListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .rolePolicyList)
            if let rolePolicyListWrappedContainer = rolePolicyListWrappedContainer {
                let rolePolicyListContainer = try rolePolicyListWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyDetail].self, forKey: .member)
                var rolePolicyListBuffer:[IAMClientTypes.PolicyDetail]? = nil
                if let rolePolicyListContainer = rolePolicyListContainer {
                    rolePolicyListBuffer = [IAMClientTypes.PolicyDetail]()
                    for structureContainer0 in rolePolicyListContainer {
                        rolePolicyListBuffer?.append(structureContainer0)
                    }
                }
                rolePolicyList = rolePolicyListBuffer
            } else {
                rolePolicyList = []
            }
        } else {
            rolePolicyList = nil
        }
        if containerValues.contains(.attachedManagedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedManagedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedManagedPolicies)
            if let attachedManagedPoliciesWrappedContainer = attachedManagedPoliciesWrappedContainer {
                let attachedManagedPoliciesContainer = try attachedManagedPoliciesWrappedContainer.decodeIfPresent([IAMClientTypes.AttachedPolicy].self, forKey: .member)
                var attachedManagedPoliciesBuffer:[IAMClientTypes.AttachedPolicy]? = nil
                if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
                    attachedManagedPoliciesBuffer = [IAMClientTypes.AttachedPolicy]()
                    for structureContainer0 in attachedManagedPoliciesContainer {
                        attachedManagedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedManagedPolicies = attachedManagedPoliciesBuffer
            } else {
                attachedManagedPolicies = []
            }
        } else {
            attachedManagedPolicies = nil
        }
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AttachedPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let roleLastUsedDecoded = try containerValues.decodeIfPresent(IAMClientTypes.RoleLastUsed.self, forKey: .roleLastUsed)
        roleLastUsed = roleLastUsedDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM role, including all of the role's policies. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct RoleDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The trust policy that grants permission to assume the role.
        public var assumeRolePolicyDocument: Swift.String?
        /// A list of managed policies attached to the role. These policies are the role's access (permissions) policies.
        public var attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the role was created.
        public var createDate: ClientRuntime.Date?
        /// A list of instance profiles that contain this role.
        public var instanceProfileList: [IAMClientTypes.InstanceProfile]?
        /// The path to the role. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The ARN of the policy used to set the permissions boundary for the role. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// The stable and unique string identifying the role. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var roleId: Swift.String?
        /// Contains information about the last time that an IAM role was used. This includes the date and time and the Region in which the role was last used. Activity is only reported for the trailing 400 days. This period can be shorter if your Region began supporting these features within the last year. The role might have been used more than 400 days ago. For more information, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM User Guide.
        public var roleLastUsed: IAMClientTypes.RoleLastUsed?
        /// The friendly name that identifies the role.
        public var roleName: Swift.String?
        /// A list of inline policies embedded in the role. These policies are the role's access (permissions) policies.
        public var rolePolicyList: [IAMClientTypes.PolicyDetail]?
        /// A list of tags that are attached to the role. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init (
            arn: Swift.String? = nil,
            assumeRolePolicyDocument: Swift.String? = nil,
            attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
            createDate: ClientRuntime.Date? = nil,
            instanceProfileList: [IAMClientTypes.InstanceProfile]? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            roleId: Swift.String? = nil,
            roleLastUsed: IAMClientTypes.RoleLastUsed? = nil,
            roleName: Swift.String? = nil,
            rolePolicyList: [IAMClientTypes.PolicyDetail]? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.arn = arn
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.instanceProfileList = instanceProfileList
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.roleId = roleId
            self.roleLastUsed = roleLastUsed
            self.roleName = roleName
            self.rolePolicyList = rolePolicyList
            self.tags = tags
        }
    }

}

extension IAMClientTypes.RoleLastUsed: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUsedDate = "LastUsedDate"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let lastUsedDate = lastUsedDate {
            try container.encodeTimestamp(lastUsedDate, format: .dateTime, forKey: ClientRuntime.Key("lastUsedDate"))
        }
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUsedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUsedDate)
        lastUsedDate = lastUsedDateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about the last time that an IAM role was used. This includes the date and time and the Region in which the role was last used. Activity is only reported for the trailing 400 days. This period can be shorter if your Region began supporting these features within the last year. The role might have been used more than 400 days ago. For more information, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM User Guide. This data type is returned as a response element in the [GetRole] and [GetAccountAuthorizationDetails] operations.
    public struct RoleLastUsed: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601) that the role was last used. This field is null if the role has not been used within the IAM tracking period. For more information about the tracking period, see [Regions where data is tracked](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#access-advisor_tracking-period) in the IAM User Guide.
        public var lastUsedDate: ClientRuntime.Date?
        /// The name of the Amazon Web Services Region in which the role was last used.
        public var region: Swift.String?

        public init (
            lastUsedDate: ClientRuntime.Date? = nil,
            region: Swift.String? = nil
        )
        {
            self.lastUsedDate = lastUsedDate
            self.region = region
        }
    }

}

extension IAMClientTypes.RoleUsageType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case region = "Region"
        case resources = "Resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
        if let resources = resources {
            if !resources.isEmpty {
                var resourcesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Resources"))
                for (index0, arntype0) in resources.enumerated() {
                    try resourcesContainer.encode(arntype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var resourcesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Resources"))
                try resourcesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        if containerValues.contains(.resources) {
            struct KeyVal0{struct member{}}
            let resourcesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .resources)
            if let resourcesWrappedContainer = resourcesWrappedContainer {
                let resourcesContainer = try resourcesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var resourcesBuffer:[Swift.String]? = nil
                if let resourcesContainer = resourcesContainer {
                    resourcesBuffer = [Swift.String]()
                    for stringContainer0 in resourcesContainer {
                        resourcesBuffer?.append(stringContainer0)
                    }
                }
                resources = resourcesBuffer
            } else {
                resources = []
            }
        } else {
            resources = nil
        }
    }
}

extension IAMClientTypes {
    /// An object that contains details about how a service-linked role is used, if that information is returned by the service. This data type is used as a response element in the [GetServiceLinkedRoleDeletionStatus] operation.
    public struct RoleUsageType: Swift.Equatable {
        /// The name of the Region where the service-linked role is being used.
        public var region: Swift.String?
        /// The name of the resource that is using the service-linked role.
        public var resources: [Swift.String]?

        public init (
            region: Swift.String? = nil,
            resources: [Swift.String]? = nil
        )
        {
            self.region = region
            self.resources = resources
        }
    }

}

extension IAMClientTypes.SAMLProviderListEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case validUntil = "ValidUntil"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if let validUntil = validUntil {
            try container.encodeTimestamp(validUntil, format: .dateTime, forKey: ClientRuntime.Key("validUntil"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let validUntilDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .validUntil)
        validUntil = validUntilDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains the list of SAML providers for this account.
    public struct SAMLProviderListEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the SAML provider.
        public var arn: Swift.String?
        /// The date and time when the SAML provider was created.
        public var createDate: ClientRuntime.Date?
        /// The expiration date and time for the SAML provider.
        public var validUntil: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            validUntil: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.validUntil = validUntil
        }
    }

}

extension IAMClientTypes.SSHPublicKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fingerprint = "Fingerprint"
        case sshPublicKeyBody = "SSHPublicKeyBody"
        case sshPublicKeyId = "SSHPublicKeyId"
        case status = "Status"
        case uploadDate = "UploadDate"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let fingerprint = fingerprint {
            try container.encode(fingerprint, forKey: ClientRuntime.Key("Fingerprint"))
        }
        if let sshPublicKeyBody = sshPublicKeyBody {
            try container.encode(sshPublicKeyBody, forKey: ClientRuntime.Key("SSHPublicKeyBody"))
        }
        if let sshPublicKeyId = sshPublicKeyId {
            try container.encode(sshPublicKeyId, forKey: ClientRuntime.Key("SSHPublicKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let uploadDate = uploadDate {
            try container.encodeTimestamp(uploadDate, format: .dateTime, forKey: ClientRuntime.Key("uploadDate"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
        let uploadDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .uploadDate)
        uploadDate = uploadDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an SSH public key. This data type is used as a response element in the [GetSSHPublicKey] and [UploadSSHPublicKey] operations.
    public struct SSHPublicKey: Swift.Equatable {
        /// The MD5 message digest of the SSH public key.
        /// This member is required.
        public var fingerprint: Swift.String?
        /// The SSH public key.
        /// This member is required.
        public var sshPublicKeyBody: Swift.String?
        /// The unique identifier for the SSH public key.
        /// This member is required.
        public var sshPublicKeyId: Swift.String?
        /// The status of the SSH public key. Active means that the key can be used for authentication with an CodeCommit repository. Inactive means that the key cannot be used.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the SSH public key was uploaded.
        public var uploadDate: ClientRuntime.Date?
        /// The name of the IAM user associated with the SSH public key.
        /// This member is required.
        public var userName: Swift.String?

        public init (
            fingerprint: Swift.String? = nil,
            sshPublicKeyBody: Swift.String? = nil,
            sshPublicKeyId: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            uploadDate: ClientRuntime.Date? = nil,
            userName: Swift.String? = nil
        )
        {
            self.fingerprint = fingerprint
            self.sshPublicKeyBody = sshPublicKeyBody
            self.sshPublicKeyId = sshPublicKeyId
            self.status = status
            self.uploadDate = uploadDate
            self.userName = userName
        }
    }

}

extension IAMClientTypes.SSHPublicKeyMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKeyId = "SSHPublicKeyId"
        case status = "Status"
        case uploadDate = "UploadDate"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sshPublicKeyId = sshPublicKeyId {
            try container.encode(sshPublicKeyId, forKey: ClientRuntime.Key("SSHPublicKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let uploadDate = uploadDate {
            try container.encodeTimestamp(uploadDate, format: .dateTime, forKey: ClientRuntime.Key("uploadDate"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
        let uploadDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .uploadDate)
        uploadDate = uploadDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an SSH public key, without the key's body or fingerprint. This data type is used as a response element in the [ListSSHPublicKeys] operation.
    public struct SSHPublicKeyMetadata: Swift.Equatable {
        /// The unique identifier for the SSH public key.
        /// This member is required.
        public var sshPublicKeyId: Swift.String?
        /// The status of the SSH public key. Active means that the key can be used for authentication with an CodeCommit repository. Inactive means that the key cannot be used.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the SSH public key was uploaded.
        /// This member is required.
        public var uploadDate: ClientRuntime.Date?
        /// The name of the IAM user associated with the SSH public key.
        /// This member is required.
        public var userName: Swift.String?

        public init (
            sshPublicKeyId: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            uploadDate: ClientRuntime.Date? = nil,
            userName: Swift.String? = nil
        )
        {
            self.sshPublicKeyId = sshPublicKeyId
            self.status = status
            self.uploadDate = uploadDate
            self.userName = userName
        }
    }

}

extension IAMClientTypes.ServerCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBody = "CertificateBody"
        case certificateChain = "CertificateChain"
        case serverCertificateMetadata = "ServerCertificateMetadata"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: ClientRuntime.Key("CertificateBody"))
        }
        if let certificateChain = certificateChain {
            try container.encode(certificateChain, forKey: ClientRuntime.Key("CertificateChain"))
        }
        if let serverCertificateMetadata = serverCertificateMetadata {
            try container.encode(serverCertificateMetadata, forKey: ClientRuntime.Key("ServerCertificateMetadata"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateMetadataDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ServerCertificateMetadata.self, forKey: .serverCertificateMetadata)
        serverCertificateMetadata = serverCertificateMetadataDecoded
        let certificateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateBody)
        certificateBody = certificateBodyDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains information about a server certificate. This data type is used as a response element in the [GetServerCertificate] operation.
    public struct ServerCertificate: Swift.Equatable {
        /// The contents of the public key certificate.
        /// This member is required.
        public var certificateBody: Swift.String?
        /// The contents of the public key certificate chain.
        public var certificateChain: Swift.String?
        /// The meta information of the server certificate, such as its name, path, ID, and ARN.
        /// This member is required.
        public var serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata?
        /// A list of tags that are attached to the server certificate. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?

        public init (
            certificateBody: Swift.String? = nil,
            certificateChain: Swift.String? = nil,
            serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata? = nil,
            tags: [IAMClientTypes.Tag]? = nil
        )
        {
            self.certificateBody = certificateBody
            self.certificateChain = certificateChain
            self.serverCertificateMetadata = serverCertificateMetadata
            self.tags = tags
        }
    }

}

extension IAMClientTypes.ServerCertificateMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case expiration = "Expiration"
        case path = "Path"
        case serverCertificateId = "ServerCertificateId"
        case serverCertificateName = "ServerCertificateName"
        case uploadDate = "UploadDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let expiration = expiration {
            try container.encodeTimestamp(expiration, format: .dateTime, forKey: ClientRuntime.Key("expiration"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let serverCertificateId = serverCertificateId {
            try container.encode(serverCertificateId, forKey: ClientRuntime.Key("ServerCertificateId"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        if let uploadDate = uploadDate {
            try container.encodeTimestamp(uploadDate, format: .dateTime, forKey: ClientRuntime.Key("uploadDate"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
        let serverCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateId)
        serverCertificateId = serverCertificateIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let uploadDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .uploadDate)
        uploadDate = uploadDateDecoded
        let expirationDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expiration)
        expiration = expirationDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about a server certificate without its certificate body, certificate chain, and private key. This data type is used as a response element in the [UploadServerCertificate] and [ListServerCertificates] operations.
    public struct ServerCertificateMetadata: Swift.Equatable {
        /// The Amazon Resource Name (ARN) specifying the server certificate. For more information about ARNs and how to use them in policies, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date on which the certificate is set to expire.
        public var expiration: ClientRuntime.Date?
        /// The path to the server certificate. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var path: Swift.String?
        /// The stable and unique string identifying the server certificate. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var serverCertificateId: Swift.String?
        /// The name that identifies the server certificate.
        /// This member is required.
        public var serverCertificateName: Swift.String?
        /// The date when the server certificate was uploaded.
        public var uploadDate: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            expiration: ClientRuntime.Date? = nil,
            path: Swift.String? = nil,
            serverCertificateId: Swift.String? = nil,
            serverCertificateName: Swift.String? = nil,
            uploadDate: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.expiration = expiration
            self.path = path
            self.serverCertificateId = serverCertificateId
            self.serverCertificateName = serverCertificateName
            self.uploadDate = uploadDate
        }
    }

}

extension ServiceFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ServiceFailureExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct ServiceFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes.ServiceLastAccessed: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastAuthenticated = "LastAuthenticated"
        case lastAuthenticatedEntity = "LastAuthenticatedEntity"
        case lastAuthenticatedRegion = "LastAuthenticatedRegion"
        case serviceName = "ServiceName"
        case serviceNamespace = "ServiceNamespace"
        case totalAuthenticatedEntities = "TotalAuthenticatedEntities"
        case trackedActionsLastAccessed = "TrackedActionsLastAccessed"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let lastAuthenticated = lastAuthenticated {
            try container.encodeTimestamp(lastAuthenticated, format: .dateTime, forKey: ClientRuntime.Key("lastAuthenticated"))
        }
        if let lastAuthenticatedEntity = lastAuthenticatedEntity {
            try container.encode(lastAuthenticatedEntity, forKey: ClientRuntime.Key("LastAuthenticatedEntity"))
        }
        if let lastAuthenticatedRegion = lastAuthenticatedRegion {
            try container.encode(lastAuthenticatedRegion, forKey: ClientRuntime.Key("LastAuthenticatedRegion"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let serviceNamespace = serviceNamespace {
            try container.encode(serviceNamespace, forKey: ClientRuntime.Key("ServiceNamespace"))
        }
        if let totalAuthenticatedEntities = totalAuthenticatedEntities {
            try container.encode(totalAuthenticatedEntities, forKey: ClientRuntime.Key("TotalAuthenticatedEntities"))
        }
        if let trackedActionsLastAccessed = trackedActionsLastAccessed {
            if !trackedActionsLastAccessed.isEmpty {
                var trackedActionsLastAccessedContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TrackedActionsLastAccessed"))
                for (index0, trackedactionlastaccessed0) in trackedActionsLastAccessed.enumerated() {
                    try trackedActionsLastAccessedContainer.encode(trackedactionlastaccessed0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var trackedActionsLastAccessedContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TrackedActionsLastAccessed"))
                try trackedActionsLastAccessedContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let lastAuthenticatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastAuthenticated)
        lastAuthenticated = lastAuthenticatedDecoded
        let serviceNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNamespace)
        serviceNamespace = serviceNamespaceDecoded
        let lastAuthenticatedEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAuthenticatedEntity)
        lastAuthenticatedEntity = lastAuthenticatedEntityDecoded
        let lastAuthenticatedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAuthenticatedRegion)
        lastAuthenticatedRegion = lastAuthenticatedRegionDecoded
        let totalAuthenticatedEntitiesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalAuthenticatedEntities)
        totalAuthenticatedEntities = totalAuthenticatedEntitiesDecoded
        if containerValues.contains(.trackedActionsLastAccessed) {
            struct KeyVal0{struct member{}}
            let trackedActionsLastAccessedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .trackedActionsLastAccessed)
            if let trackedActionsLastAccessedWrappedContainer = trackedActionsLastAccessedWrappedContainer {
                let trackedActionsLastAccessedContainer = try trackedActionsLastAccessedWrappedContainer.decodeIfPresent([IAMClientTypes.TrackedActionLastAccessed].self, forKey: .member)
                var trackedActionsLastAccessedBuffer:[IAMClientTypes.TrackedActionLastAccessed]? = nil
                if let trackedActionsLastAccessedContainer = trackedActionsLastAccessedContainer {
                    trackedActionsLastAccessedBuffer = [IAMClientTypes.TrackedActionLastAccessed]()
                    for structureContainer0 in trackedActionsLastAccessedContainer {
                        trackedActionsLastAccessedBuffer?.append(structureContainer0)
                    }
                }
                trackedActionsLastAccessed = trackedActionsLastAccessedBuffer
            } else {
                trackedActionsLastAccessed = []
            }
        } else {
            trackedActionsLastAccessed = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains details about the most recent attempt to access the service. This data type is used as a response element in the [GetServiceLastAccessedDetails] operation.
    public struct ServiceLastAccessed: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when an authenticated entity most recently attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticated: ClientRuntime.Date?
        /// The ARN of the authenticated entity (user or role) that last attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticatedEntity: Swift.String?
        /// The Region from which the authenticated entity (user or role) last attempted to access the service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAuthenticatedRegion: Swift.String?
        /// The name of the service in which access was attempted.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The namespace of the service in which access was attempted. To learn the service namespace of a service, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the Service Authorization Reference. Choose the name of the service to view details for that service. In the first paragraph, find the service prefix. For example, (service prefix: a4b). For more information about service namespaces, see [Amazon Web Services Service Namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces) in the Amazon Web Services General Reference.
        /// This member is required.
        public var serviceNamespace: Swift.String?
        /// The total number of authenticated principals (root user, IAM users, or IAM roles) that have attempted to access the service. This field is null if no principals attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var totalAuthenticatedEntities: Swift.Int?
        /// An object that contains details about the most recent attempt to access a tracked action within the service. This field is null if there no tracked actions or if the principal did not use the tracked actions within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period). This field is also null if the report was generated at the service level and not the action level. For more information, see the Granularity field in [GenerateServiceLastAccessedDetails].
        public var trackedActionsLastAccessed: [IAMClientTypes.TrackedActionLastAccessed]?

        public init (
            lastAuthenticated: ClientRuntime.Date? = nil,
            lastAuthenticatedEntity: Swift.String? = nil,
            lastAuthenticatedRegion: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceNamespace: Swift.String? = nil,
            totalAuthenticatedEntities: Swift.Int? = nil,
            trackedActionsLastAccessed: [IAMClientTypes.TrackedActionLastAccessed]? = nil
        )
        {
            self.lastAuthenticated = lastAuthenticated
            self.lastAuthenticatedEntity = lastAuthenticatedEntity
            self.lastAuthenticatedRegion = lastAuthenticatedRegion
            self.serviceName = serviceName
            self.serviceNamespace = serviceNamespace
            self.totalAuthenticatedEntities = totalAuthenticatedEntities
            self.trackedActionsLastAccessed = trackedActionsLastAccessed
        }
    }

}

extension ServiceNotSupportedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ServiceNotSupportedExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified service does not support service-specific credentials.
public struct ServiceNotSupportedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IAMClientTypes.ServiceSpecificCredential: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case serviceName = "ServiceName"
        case servicePassword = "ServicePassword"
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case serviceUserName = "ServiceUserName"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let servicePassword = servicePassword {
            try container.encode(servicePassword, forKey: ClientRuntime.Key("ServicePassword"))
        }
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: ClientRuntime.Key("ServiceSpecificCredentialId"))
        }
        if let serviceUserName = serviceUserName {
            try container.encode(serviceUserName, forKey: ClientRuntime.Key("ServiceUserName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUserName)
        serviceUserName = serviceUserNameDecoded
        let servicePasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .servicePassword)
        servicePassword = servicePasswordDecoded
        let serviceSpecificCredentialIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceSpecificCredentialId)
        serviceSpecificCredentialId = serviceSpecificCredentialIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension IAMClientTypes.ServiceSpecificCredential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceSpecificCredential(createDate: \(Swift.String(describing: createDate)), serviceName: \(Swift.String(describing: serviceName)), serviceSpecificCredentialId: \(Swift.String(describing: serviceSpecificCredentialId)), serviceUserName: \(Swift.String(describing: serviceUserName)), status: \(Swift.String(describing: status)), userName: \(Swift.String(describing: userName)), servicePassword: \"CONTENT_REDACTED\")"}
}

extension IAMClientTypes {
    /// Contains the details of a service-specific credential.
    public struct ServiceSpecificCredential: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the service-specific credential were created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// The name of the service associated with the service-specific credential.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The generated password for the service-specific credential.
        /// This member is required.
        public var servicePassword: Swift.String?
        /// The unique identifier for the service-specific credential.
        /// This member is required.
        public var serviceSpecificCredentialId: Swift.String?
        /// The generated user name for the service-specific credential. This value is generated by combining the IAM user's name combined with the ID number of the Amazon Web Services account, as in jane-at-123456789012, for example. This value cannot be configured by the user.
        /// This member is required.
        public var serviceUserName: Swift.String?
        /// The status of the service-specific credential. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user associated with the service-specific credential.
        /// This member is required.
        public var userName: Swift.String?

        public init (
            createDate: ClientRuntime.Date? = nil,
            serviceName: Swift.String? = nil,
            servicePassword: Swift.String? = nil,
            serviceSpecificCredentialId: Swift.String? = nil,
            serviceUserName: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.serviceName = serviceName
            self.servicePassword = servicePassword
            self.serviceSpecificCredentialId = serviceSpecificCredentialId
            self.serviceUserName = serviceUserName
            self.status = status
            self.userName = userName
        }
    }

}

extension IAMClientTypes.ServiceSpecificCredentialMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case serviceName = "ServiceName"
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case serviceUserName = "ServiceUserName"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: ClientRuntime.Key("ServiceSpecificCredentialId"))
        }
        if let serviceUserName = serviceUserName {
            try container.encode(serviceUserName, forKey: ClientRuntime.Key("ServiceUserName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
        let serviceUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUserName)
        serviceUserName = serviceUserNameDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let serviceSpecificCredentialIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceSpecificCredentialId)
        serviceSpecificCredentialId = serviceSpecificCredentialIdDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension IAMClientTypes {
    /// Contains additional details about a service-specific credential.
    public struct ServiceSpecificCredentialMetadata: Swift.Equatable {
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the service-specific credential were created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// The name of the service associated with the service-specific credential.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The unique identifier for the service-specific credential.
        /// This member is required.
        public var serviceSpecificCredentialId: Swift.String?
        /// The generated user name for the service-specific credential.
        /// This member is required.
        public var serviceUserName: Swift.String?
        /// The status of the service-specific credential. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The name of the IAM user associated with the service-specific credential.
        /// This member is required.
        public var userName: Swift.String?

        public init (
            createDate: ClientRuntime.Date? = nil,
            serviceName: Swift.String? = nil,
            serviceSpecificCredentialId: Swift.String? = nil,
            serviceUserName: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            userName: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.serviceName = serviceName
            self.serviceSpecificCredentialId = serviceSpecificCredentialId
            self.serviceUserName = serviceUserName
            self.status = status
            self.userName = userName
        }
    }

}

extension SetDefaultPolicyVersionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: ClientRuntime.Key("VersionId"))
        }
        try container.encode("SetDefaultPolicyVersion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetDefaultPolicyVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetDefaultPolicyVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM policy whose default version you want to set. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The version of the policy to set as the default (operative) version. For more information about managed policy versions, see [Versioning for managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html) in the IAM User Guide.
    /// This member is required.
    public var versionId: Swift.String?

    public init (
        policyArn: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.versionId = versionId
    }
}

struct SetDefaultPolicyVersionInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let versionId: Swift.String?
}

extension SetDefaultPolicyVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension SetDefaultPolicyVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetDefaultPolicyVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SetDefaultPolicyVersionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetDefaultPolicyVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetDefaultPolicyVersionOutputResponse: Swift.Equatable {

    public init () { }
}

extension SetSecurityTokenServicePreferencesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let globalEndpointTokenVersion = globalEndpointTokenVersion {
            try container.encode(globalEndpointTokenVersion, forKey: ClientRuntime.Key("GlobalEndpointTokenVersion"))
        }
        try container.encode("SetSecurityTokenServicePreferences", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetSecurityTokenServicePreferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetSecurityTokenServicePreferencesInput: Swift.Equatable {
    /// The version of the global endpoint token. Version 1 tokens are valid only in Amazon Web Services Regions that are available by default. These tokens do not work in manually enabled Regions, such as Asia Pacific (Hong Kong). Version 2 tokens are valid in all Regions. However, version 2 tokens are longer and might affect systems where you temporarily store tokens. For information, see [Activating and deactivating STS in an Amazon Web Services Region](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html) in the IAM User Guide.
    /// This member is required.
    public var globalEndpointTokenVersion: IAMClientTypes.GlobalEndpointTokenVersion?

    public init (
        globalEndpointTokenVersion: IAMClientTypes.GlobalEndpointTokenVersion? = nil
    )
    {
        self.globalEndpointTokenVersion = globalEndpointTokenVersion
    }
}

struct SetSecurityTokenServicePreferencesInputBody: Swift.Equatable {
    let globalEndpointTokenVersion: IAMClientTypes.GlobalEndpointTokenVersion?
}

extension SetSecurityTokenServicePreferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalEndpointTokenVersion = "GlobalEndpointTokenVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalEndpointTokenVersionDecoded = try containerValues.decodeIfPresent(IAMClientTypes.GlobalEndpointTokenVersion.self, forKey: .globalEndpointTokenVersion)
        globalEndpointTokenVersion = globalEndpointTokenVersionDecoded
    }
}

extension SetSecurityTokenServicePreferencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetSecurityTokenServicePreferencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SetSecurityTokenServicePreferencesOutputError: Swift.Error, Swift.Equatable {
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetSecurityTokenServicePreferencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetSecurityTokenServicePreferencesOutputResponse: Swift.Equatable {

    public init () { }
}

extension IAMClientTypes.SigningCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBody = "CertificateBody"
        case certificateId = "CertificateId"
        case status = "Status"
        case uploadDate = "UploadDate"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: ClientRuntime.Key("CertificateBody"))
        }
        if let certificateId = certificateId {
            try container.encode(certificateId, forKey: ClientRuntime.Key("CertificateId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let uploadDate = uploadDate {
            try container.encodeTimestamp(uploadDate, format: .dateTime, forKey: ClientRuntime.Key("uploadDate"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let certificateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateBody)
        certificateBody = certificateBodyDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
        let uploadDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .uploadDate)
        uploadDate = uploadDateDecoded
    }
}

extension IAMClientTypes {
    /// Contains information about an X.509 signing certificate. This data type is used as a response element in the [UploadSigningCertificate] and [ListSigningCertificates] operations.
    public struct SigningCertificate: Swift.Equatable {
        /// The contents of the signing certificate.
        /// This member is required.
        public var certificateBody: Swift.String?
        /// The ID for the signing certificate.
        /// This member is required.
        public var certificateId: Swift.String?
        /// The status of the signing certificate. Active means that the key is valid for API calls, while Inactive means it is not.
        /// This member is required.
        public var status: IAMClientTypes.StatusType?
        /// The date when the signing certificate was uploaded.
        public var uploadDate: ClientRuntime.Date?
        /// The name of the user the signing certificate is associated with.
        /// This member is required.
        public var userName: Swift.String?

        public init (
            certificateBody: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            status: IAMClientTypes.StatusType? = nil,
            uploadDate: ClientRuntime.Date? = nil,
            userName: Swift.String? = nil
        )
        {
            self.certificateBody = certificateBody
            self.certificateId = certificateId
            self.status = status
            self.uploadDate = uploadDate
            self.userName = userName
        }
    }

}

extension SimulateCustomPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let actionNames = actionNames {
            if !actionNames.isEmpty {
                var actionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionNames"))
                for (index0, actionnametype0) in actionNames.enumerated() {
                    try actionNamesContainer.encode(actionnametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var actionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionNames"))
                try actionNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let callerArn = callerArn {
            try container.encode(callerArn, forKey: ClientRuntime.Key("CallerArn"))
        }
        if let contextEntries = contextEntries {
            if !contextEntries.isEmpty {
                var contextEntriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextEntries"))
                for (index0, contextentry0) in contextEntries.enumerated() {
                    try contextEntriesContainer.encode(contextentry0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var contextEntriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextEntries"))
                try contextEntriesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList {
            if !permissionsBoundaryPolicyInputList.isEmpty {
                var permissionsBoundaryPolicyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PermissionsBoundaryPolicyInputList"))
                for (index0, policydocumenttype0) in permissionsBoundaryPolicyInputList.enumerated() {
                    try permissionsBoundaryPolicyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var permissionsBoundaryPolicyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PermissionsBoundaryPolicyInputList"))
                try permissionsBoundaryPolicyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policyInputList = policyInputList {
            if !policyInputList.isEmpty {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                for (index0, policydocumenttype0) in policyInputList.enumerated() {
                    try policyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                try policyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let resourceArns = resourceArns {
            if !resourceArns.isEmpty {
                var resourceArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceArns"))
                for (index0, resourcenametype0) in resourceArns.enumerated() {
                    try resourceArnsContainer.encode(resourcenametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var resourceArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceArns"))
                try resourceArnsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let resourceHandlingOption = resourceHandlingOption {
            try container.encode(resourceHandlingOption, forKey: ClientRuntime.Key("ResourceHandlingOption"))
        }
        if let resourceOwner = resourceOwner {
            try container.encode(resourceOwner, forKey: ClientRuntime.Key("ResourceOwner"))
        }
        if let resourcePolicy = resourcePolicy {
            try container.encode(resourcePolicy, forKey: ClientRuntime.Key("ResourcePolicy"))
        }
        try container.encode("SimulateCustomPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension SimulateCustomPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SimulateCustomPolicyInput: Swift.Equatable {
    /// A list of names of API operations to evaluate in the simulation. Each operation is evaluated against each resource. Each operation must include the service identifier, such as iam:CreateUser. This operation does not support using wildcards (*) in an action name.
    /// This member is required.
    public var actionNames: [Swift.String]?
    /// The ARN of the IAM user that you want to use as the simulated caller of the API operations. CallerArn is required if you include a ResourcePolicy so that the policy's Principal element has a value to use in evaluating the policy. You can specify only the ARN of an IAM user. You cannot specify the ARN of an assumed role, federated user, or a service principal.
    public var callerArn: Swift.String?
    /// A list of context keys and corresponding values for the simulation to use. Whenever a context key is evaluated in one of the simulated IAM permissions policies, the corresponding value is supplied.
    public var contextEntries: [IAMClientTypes.ContextEntry]?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The IAM permissions boundary policy to simulate. The permissions boundary sets the maximum permissions that an IAM entity can have. You can input only one permissions boundary when you pass a policy to this operation. For more information about permissions boundaries, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. The policy input is specified as a string that contains the complete, valid JSON text of a permissions boundary policy. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var permissionsBoundaryPolicyInputList: [Swift.String]?
    /// A list of policy documents to include in the simulation. Each document is specified as a string containing the complete, valid JSON text of an IAM policy. Do not include any resource-based policies in this parameter. Any resource-based policy must be submitted with the ResourcePolicy parameter. The policies cannot be "scope-down" policies, such as you could include in a call to [GetFederationToken](https://docs.aws.amazon.com/IAM/latest/APIReference/API_GetFederationToken.html) or one of the [AssumeRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_AssumeRole.html) API operations. In other words, do not use policies designed to restrict what a user can do while using the temporary credentials. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyInputList: [Swift.String]?
    /// A list of ARNs of Amazon Web Services resources to include in the simulation. If this parameter is not provided, then the value defaults to * (all resources). Each API in the ActionNames parameter is evaluated for each resource in this list. The simulation determines the access result (allowed or denied) of each combination and reports it in the response. You can simulate resources that don't exist in your account. The simulation does not automatically retrieve policies for the specified resources. If you want to include a resource policy in the simulation, then you must include the policy as a string in the ResourcePolicy parameter. If you include a ResourcePolicy, then it must be applicable to all of the resources included in the simulation or you receive an invalid input error. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. Simulation of resource-based policies isn't supported for IAM roles.
    public var resourceArns: [Swift.String]?
    /// Specifies the type of simulation to run. Different API operations that support resource-based policies require different combinations of resources. By specifying the type of simulation to run, you enable the policy simulator to enforce the presence of the required resources to ensure reliable simulation results. If your simulation does not match one of the following scenarios, then you can omit this parameter. The following list shows each of the supported scenario values and the resources that you must define to run the simulation. Each of the EC2 scenarios requires that you specify instance, image, and security group resources. If your scenario includes an EBS volume, then you must specify that volume as a resource. If the EC2 scenario includes VPC, then you must supply the network interface resource. If it includes an IP subnet, then you must specify the subnet resource. For more information on the EC2 scenario options, see [Supported platforms](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html) in the Amazon EC2 User Guide.
    ///
    /// * EC2-VPC-InstanceStore instance, image, security group, network interface
    ///
    /// * EC2-VPC-InstanceStore-Subnet instance, image, security group, network interface, subnet
    ///
    /// * EC2-VPC-EBS instance, image, security group, network interface, volume
    ///
    /// * EC2-VPC-EBS-Subnet instance, image, security group, network interface, subnet, volume
    public var resourceHandlingOption: Swift.String?
    /// An ARN representing the Amazon Web Services account ID that specifies the owner of any simulated resource that does not identify its owner in the resource ARN. Examples of resource ARNs include an S3 bucket or object. If ResourceOwner is specified, it is also used as the account owner of any ResourcePolicy included in the simulation. If the ResourceOwner parameter is not specified, then the owner of the resources and the resource policy defaults to the account of the identity provided in CallerArn. This parameter is required only if you specify a resource-based policy and account that owns the resource is different from the account that owns the simulated calling user CallerArn. The ARN for an account uses the following syntax: arn:aws:iam::AWS-account-ID:root. For example, to represent the account with the 112233445566 ID, use the following ARN: arn:aws:iam::112233445566-ID:root.
    public var resourceOwner: Swift.String?
    /// A resource-based policy to include in the simulation provided as a string. Each resource in the simulation is treated as if it had this policy attached. You can include only one resource-based policy in a simulation. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// Simulation of resource-based policies isn't supported for IAM roles.
    public var resourcePolicy: Swift.String?

    public init (
        actionNames: [Swift.String]? = nil,
        callerArn: Swift.String? = nil,
        contextEntries: [IAMClientTypes.ContextEntry]? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        permissionsBoundaryPolicyInputList: [Swift.String]? = nil,
        policyInputList: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceHandlingOption: Swift.String? = nil,
        resourceOwner: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.actionNames = actionNames
        self.callerArn = callerArn
        self.contextEntries = contextEntries
        self.marker = marker
        self.maxItems = maxItems
        self.permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList
        self.policyInputList = policyInputList
        self.resourceArns = resourceArns
        self.resourceHandlingOption = resourceHandlingOption
        self.resourceOwner = resourceOwner
        self.resourcePolicy = resourcePolicy
    }
}

struct SimulateCustomPolicyInputBody: Swift.Equatable {
    let policyInputList: [Swift.String]?
    let permissionsBoundaryPolicyInputList: [Swift.String]?
    let actionNames: [Swift.String]?
    let resourceArns: [Swift.String]?
    let resourcePolicy: Swift.String?
    let resourceOwner: Swift.String?
    let callerArn: Swift.String?
    let contextEntries: [IAMClientTypes.ContextEntry]?
    let resourceHandlingOption: Swift.String?
    let maxItems: Swift.Int?
    let marker: Swift.String?
}

extension SimulateCustomPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionNames = "ActionNames"
        case callerArn = "CallerArn"
        case contextEntries = "ContextEntries"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case permissionsBoundaryPolicyInputList = "PermissionsBoundaryPolicyInputList"
        case policyInputList = "PolicyInputList"
        case resourceArns = "ResourceArns"
        case resourceHandlingOption = "ResourceHandlingOption"
        case resourceOwner = "ResourceOwner"
        case resourcePolicy = "ResourcePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.policyInputList) {
            struct KeyVal0{struct member{}}
            let policyInputListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyInputList)
            if let policyInputListWrappedContainer = policyInputListWrappedContainer {
                let policyInputListContainer = try policyInputListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyInputListBuffer:[Swift.String]? = nil
                if let policyInputListContainer = policyInputListContainer {
                    policyInputListBuffer = [Swift.String]()
                    for stringContainer0 in policyInputListContainer {
                        policyInputListBuffer?.append(stringContainer0)
                    }
                }
                policyInputList = policyInputListBuffer
            } else {
                policyInputList = []
            }
        } else {
            policyInputList = nil
        }
        if containerValues.contains(.permissionsBoundaryPolicyInputList) {
            struct KeyVal0{struct member{}}
            let permissionsBoundaryPolicyInputListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .permissionsBoundaryPolicyInputList)
            if let permissionsBoundaryPolicyInputListWrappedContainer = permissionsBoundaryPolicyInputListWrappedContainer {
                let permissionsBoundaryPolicyInputListContainer = try permissionsBoundaryPolicyInputListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var permissionsBoundaryPolicyInputListBuffer:[Swift.String]? = nil
                if let permissionsBoundaryPolicyInputListContainer = permissionsBoundaryPolicyInputListContainer {
                    permissionsBoundaryPolicyInputListBuffer = [Swift.String]()
                    for stringContainer0 in permissionsBoundaryPolicyInputListContainer {
                        permissionsBoundaryPolicyInputListBuffer?.append(stringContainer0)
                    }
                }
                permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputListBuffer
            } else {
                permissionsBoundaryPolicyInputList = []
            }
        } else {
            permissionsBoundaryPolicyInputList = nil
        }
        if containerValues.contains(.actionNames) {
            struct KeyVal0{struct member{}}
            let actionNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .actionNames)
            if let actionNamesWrappedContainer = actionNamesWrappedContainer {
                let actionNamesContainer = try actionNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var actionNamesBuffer:[Swift.String]? = nil
                if let actionNamesContainer = actionNamesContainer {
                    actionNamesBuffer = [Swift.String]()
                    for stringContainer0 in actionNamesContainer {
                        actionNamesBuffer?.append(stringContainer0)
                    }
                }
                actionNames = actionNamesBuffer
            } else {
                actionNames = []
            }
        } else {
            actionNames = nil
        }
        if containerValues.contains(.resourceArns) {
            struct KeyVal0{struct member{}}
            let resourceArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .resourceArns)
            if let resourceArnsWrappedContainer = resourceArnsWrappedContainer {
                let resourceArnsContainer = try resourceArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var resourceArnsBuffer:[Swift.String]? = nil
                if let resourceArnsContainer = resourceArnsContainer {
                    resourceArnsBuffer = [Swift.String]()
                    for stringContainer0 in resourceArnsContainer {
                        resourceArnsBuffer?.append(stringContainer0)
                    }
                }
                resourceArns = resourceArnsBuffer
            } else {
                resourceArns = []
            }
        } else {
            resourceArns = nil
        }
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let callerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerArn)
        callerArn = callerArnDecoded
        if containerValues.contains(.contextEntries) {
            struct KeyVal0{struct member{}}
            let contextEntriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .contextEntries)
            if let contextEntriesWrappedContainer = contextEntriesWrappedContainer {
                let contextEntriesContainer = try contextEntriesWrappedContainer.decodeIfPresent([IAMClientTypes.ContextEntry].self, forKey: .member)
                var contextEntriesBuffer:[IAMClientTypes.ContextEntry]? = nil
                if let contextEntriesContainer = contextEntriesContainer {
                    contextEntriesBuffer = [IAMClientTypes.ContextEntry]()
                    for structureContainer0 in contextEntriesContainer {
                        contextEntriesBuffer?.append(structureContainer0)
                    }
                }
                contextEntries = contextEntriesBuffer
            } else {
                contextEntries = []
            }
        } else {
            contextEntries = nil
        }
        let resourceHandlingOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceHandlingOption)
        resourceHandlingOption = resourceHandlingOptionDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension SimulateCustomPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SimulateCustomPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyEvaluation" : self = .policyEvaluationException(try PolicyEvaluationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SimulateCustomPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case policyEvaluationException(PolicyEvaluationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SimulateCustomPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SimulateCustomPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.evaluationResults = output.evaluationResults
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.evaluationResults = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [SimulatePrincipalPolicy] or [SimulateCustomPolicy] request.
public struct SimulateCustomPolicyOutputResponse: Swift.Equatable {
    /// The results of the simulation.
    public var evaluationResults: [IAMClientTypes.EvaluationResult]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init (
        evaluationResults: [IAMClientTypes.EvaluationResult]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct SimulateCustomPolicyOutputResponseBody: Swift.Equatable {
    let evaluationResults: [IAMClientTypes.EvaluationResult]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension SimulateCustomPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationResults = "EvaluationResults"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("SimulateCustomPolicyResult"))
        if containerValues.contains(.evaluationResults) {
            struct KeyVal0{struct member{}}
            let evaluationResultsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .evaluationResults)
            if let evaluationResultsWrappedContainer = evaluationResultsWrappedContainer {
                let evaluationResultsContainer = try evaluationResultsWrappedContainer.decodeIfPresent([IAMClientTypes.EvaluationResult].self, forKey: .member)
                var evaluationResultsBuffer:[IAMClientTypes.EvaluationResult]? = nil
                if let evaluationResultsContainer = evaluationResultsContainer {
                    evaluationResultsBuffer = [IAMClientTypes.EvaluationResult]()
                    for structureContainer0 in evaluationResultsContainer {
                        evaluationResultsBuffer?.append(structureContainer0)
                    }
                }
                evaluationResults = evaluationResultsBuffer
            } else {
                evaluationResults = []
            }
        } else {
            evaluationResults = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension SimulatePrincipalPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let actionNames = actionNames {
            if !actionNames.isEmpty {
                var actionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionNames"))
                for (index0, actionnametype0) in actionNames.enumerated() {
                    try actionNamesContainer.encode(actionnametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var actionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionNames"))
                try actionNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let callerArn = callerArn {
            try container.encode(callerArn, forKey: ClientRuntime.Key("CallerArn"))
        }
        if let contextEntries = contextEntries {
            if !contextEntries.isEmpty {
                var contextEntriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextEntries"))
                for (index0, contextentry0) in contextEntries.enumerated() {
                    try contextEntriesContainer.encode(contextentry0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var contextEntriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ContextEntries"))
                try contextEntriesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList {
            if !permissionsBoundaryPolicyInputList.isEmpty {
                var permissionsBoundaryPolicyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PermissionsBoundaryPolicyInputList"))
                for (index0, policydocumenttype0) in permissionsBoundaryPolicyInputList.enumerated() {
                    try permissionsBoundaryPolicyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var permissionsBoundaryPolicyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PermissionsBoundaryPolicyInputList"))
                try permissionsBoundaryPolicyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policyInputList = policyInputList {
            if !policyInputList.isEmpty {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                for (index0, policydocumenttype0) in policyInputList.enumerated() {
                    try policyInputListContainer.encode(policydocumenttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyInputListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyInputList"))
                try policyInputListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policySourceArn = policySourceArn {
            try container.encode(policySourceArn, forKey: ClientRuntime.Key("PolicySourceArn"))
        }
        if let resourceArns = resourceArns {
            if !resourceArns.isEmpty {
                var resourceArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceArns"))
                for (index0, resourcenametype0) in resourceArns.enumerated() {
                    try resourceArnsContainer.encode(resourcenametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var resourceArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceArns"))
                try resourceArnsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let resourceHandlingOption = resourceHandlingOption {
            try container.encode(resourceHandlingOption, forKey: ClientRuntime.Key("ResourceHandlingOption"))
        }
        if let resourceOwner = resourceOwner {
            try container.encode(resourceOwner, forKey: ClientRuntime.Key("ResourceOwner"))
        }
        if let resourcePolicy = resourcePolicy {
            try container.encode(resourcePolicy, forKey: ClientRuntime.Key("ResourcePolicy"))
        }
        try container.encode("SimulatePrincipalPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension SimulatePrincipalPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SimulatePrincipalPolicyInput: Swift.Equatable {
    /// A list of names of API operations to evaluate in the simulation. Each operation is evaluated for each resource. Each operation must include the service identifier, such as iam:CreateUser.
    /// This member is required.
    public var actionNames: [Swift.String]?
    /// The ARN of the IAM user that you want to specify as the simulated caller of the API operations. If you do not specify a CallerArn, it defaults to the ARN of the user that you specify in PolicySourceArn, if you specified a user. If you include both a PolicySourceArn (for example, arn:aws:iam::123456789012:user/David) and a CallerArn (for example, arn:aws:iam::123456789012:user/Bob), the result is that you simulate calling the API operations as Bob, as if Bob had David's policies. You can specify only the ARN of an IAM user. You cannot specify the ARN of an assumed role, federated user, or a service principal. CallerArn is required if you include a ResourcePolicy and the PolicySourceArn is not the ARN for an IAM user. This is required so that the resource-based policy's Principal element has a value to use in evaluating the policy. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    public var callerArn: Swift.String?
    /// A list of context keys and corresponding values for the simulation to use. Whenever a context key is evaluated in one of the simulated IAM permissions policies, the corresponding value is supplied.
    public var contextEntries: [IAMClientTypes.ContextEntry]?
    /// Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.
    public var marker: Swift.String?
    /// Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true. If you do not include this parameter, the number of items defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true, and Marker contains a value to include in the subsequent call that tells the service where to continue from.
    public var maxItems: Swift.Int?
    /// The IAM permissions boundary policy to simulate. The permissions boundary sets the maximum permissions that the entity can have. You can input only one permissions boundary when you pass a policy to this operation. An IAM entity can only have one permissions boundary in effect at a time. For example, if a permissions boundary is attached to an entity and you pass in a different permissions boundary policy using this parameter, then the new permissions boundary policy is used for the simulation. For more information about permissions boundaries, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. The policy input is specified as a string containing the complete, valid JSON text of a permissions boundary policy. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var permissionsBoundaryPolicyInputList: [Swift.String]?
    /// An optional list of additional policy documents to include in the simulation. Each document is specified as a string containing the complete, valid JSON text of an IAM policy. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var policyInputList: [Swift.String]?
    /// The Amazon Resource Name (ARN) of a user, group, or role whose policies you want to include in the simulation. If you specify a user, group, or role, the simulation includes all policies that are associated with that entity. If you specify a user, the simulation also includes all policies that are attached to any groups the user belongs to. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var policySourceArn: Swift.String?
    /// A list of ARNs of Amazon Web Services resources to include in the simulation. If this parameter is not provided, then the value defaults to * (all resources). Each API in the ActionNames parameter is evaluated for each resource in this list. The simulation determines the access result (allowed or denied) of each combination and reports it in the response. You can simulate resources that don't exist in your account. The simulation does not automatically retrieve policies for the specified resources. If you want to include a resource policy in the simulation, then you must include the policy as a string in the ResourcePolicy parameter. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. Simulation of resource-based policies isn't supported for IAM roles.
    public var resourceArns: [Swift.String]?
    /// Specifies the type of simulation to run. Different API operations that support resource-based policies require different combinations of resources. By specifying the type of simulation to run, you enable the policy simulator to enforce the presence of the required resources to ensure reliable simulation results. If your simulation does not match one of the following scenarios, then you can omit this parameter. The following list shows each of the supported scenario values and the resources that you must define to run the simulation. Each of the EC2 scenarios requires that you specify instance, image, and security group resources. If your scenario includes an EBS volume, then you must specify that volume as a resource. If the EC2 scenario includes VPC, then you must supply the network interface resource. If it includes an IP subnet, then you must specify the subnet resource. For more information on the EC2 scenario options, see [Supported platforms](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html) in the Amazon EC2 User Guide.
    ///
    /// * EC2-VPC-InstanceStore instance, image, security group, network interface
    ///
    /// * EC2-VPC-InstanceStore-Subnet instance, image, security group, network interface, subnet
    ///
    /// * EC2-VPC-EBS instance, image, security group, network interface, volume
    ///
    /// * EC2-VPC-EBS-Subnet instance, image, security group, network interface, subnet, volume
    public var resourceHandlingOption: Swift.String?
    /// An Amazon Web Services account ID that specifies the owner of any simulated resource that does not identify its owner in the resource ARN. Examples of resource ARNs include an S3 bucket or object. If ResourceOwner is specified, it is also used as the account owner of any ResourcePolicy included in the simulation. If the ResourceOwner parameter is not specified, then the owner of the resources and the resource policy defaults to the account of the identity provided in CallerArn. This parameter is required only if you specify a resource-based policy and account that owns the resource is different from the account that owns the simulated calling user CallerArn.
    public var resourceOwner: Swift.String?
    /// A resource-based policy to include in the simulation provided as a string. Each resource in the simulation is treated as if it had this policy attached. You can include only one resource-based policy in a simulation. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see [IAM and STS character quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length). The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// Simulation of resource-based policies isn't supported for IAM roles.
    public var resourcePolicy: Swift.String?

    public init (
        actionNames: [Swift.String]? = nil,
        callerArn: Swift.String? = nil,
        contextEntries: [IAMClientTypes.ContextEntry]? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        permissionsBoundaryPolicyInputList: [Swift.String]? = nil,
        policyInputList: [Swift.String]? = nil,
        policySourceArn: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceHandlingOption: Swift.String? = nil,
        resourceOwner: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.actionNames = actionNames
        self.callerArn = callerArn
        self.contextEntries = contextEntries
        self.marker = marker
        self.maxItems = maxItems
        self.permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputList
        self.policyInputList = policyInputList
        self.policySourceArn = policySourceArn
        self.resourceArns = resourceArns
        self.resourceHandlingOption = resourceHandlingOption
        self.resourceOwner = resourceOwner
        self.resourcePolicy = resourcePolicy
    }
}

struct SimulatePrincipalPolicyInputBody: Swift.Equatable {
    let policySourceArn: Swift.String?
    let policyInputList: [Swift.String]?
    let permissionsBoundaryPolicyInputList: [Swift.String]?
    let actionNames: [Swift.String]?
    let resourceArns: [Swift.String]?
    let resourcePolicy: Swift.String?
    let resourceOwner: Swift.String?
    let callerArn: Swift.String?
    let contextEntries: [IAMClientTypes.ContextEntry]?
    let resourceHandlingOption: Swift.String?
    let maxItems: Swift.Int?
    let marker: Swift.String?
}

extension SimulatePrincipalPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionNames = "ActionNames"
        case callerArn = "CallerArn"
        case contextEntries = "ContextEntries"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case permissionsBoundaryPolicyInputList = "PermissionsBoundaryPolicyInputList"
        case policyInputList = "PolicyInputList"
        case policySourceArn = "PolicySourceArn"
        case resourceArns = "ResourceArns"
        case resourceHandlingOption = "ResourceHandlingOption"
        case resourceOwner = "ResourceOwner"
        case resourcePolicy = "ResourcePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policySourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policySourceArn)
        policySourceArn = policySourceArnDecoded
        if containerValues.contains(.policyInputList) {
            struct KeyVal0{struct member{}}
            let policyInputListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyInputList)
            if let policyInputListWrappedContainer = policyInputListWrappedContainer {
                let policyInputListContainer = try policyInputListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyInputListBuffer:[Swift.String]? = nil
                if let policyInputListContainer = policyInputListContainer {
                    policyInputListBuffer = [Swift.String]()
                    for stringContainer0 in policyInputListContainer {
                        policyInputListBuffer?.append(stringContainer0)
                    }
                }
                policyInputList = policyInputListBuffer
            } else {
                policyInputList = []
            }
        } else {
            policyInputList = nil
        }
        if containerValues.contains(.permissionsBoundaryPolicyInputList) {
            struct KeyVal0{struct member{}}
            let permissionsBoundaryPolicyInputListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .permissionsBoundaryPolicyInputList)
            if let permissionsBoundaryPolicyInputListWrappedContainer = permissionsBoundaryPolicyInputListWrappedContainer {
                let permissionsBoundaryPolicyInputListContainer = try permissionsBoundaryPolicyInputListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var permissionsBoundaryPolicyInputListBuffer:[Swift.String]? = nil
                if let permissionsBoundaryPolicyInputListContainer = permissionsBoundaryPolicyInputListContainer {
                    permissionsBoundaryPolicyInputListBuffer = [Swift.String]()
                    for stringContainer0 in permissionsBoundaryPolicyInputListContainer {
                        permissionsBoundaryPolicyInputListBuffer?.append(stringContainer0)
                    }
                }
                permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputListBuffer
            } else {
                permissionsBoundaryPolicyInputList = []
            }
        } else {
            permissionsBoundaryPolicyInputList = nil
        }
        if containerValues.contains(.actionNames) {
            struct KeyVal0{struct member{}}
            let actionNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .actionNames)
            if let actionNamesWrappedContainer = actionNamesWrappedContainer {
                let actionNamesContainer = try actionNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var actionNamesBuffer:[Swift.String]? = nil
                if let actionNamesContainer = actionNamesContainer {
                    actionNamesBuffer = [Swift.String]()
                    for stringContainer0 in actionNamesContainer {
                        actionNamesBuffer?.append(stringContainer0)
                    }
                }
                actionNames = actionNamesBuffer
            } else {
                actionNames = []
            }
        } else {
            actionNames = nil
        }
        if containerValues.contains(.resourceArns) {
            struct KeyVal0{struct member{}}
            let resourceArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .resourceArns)
            if let resourceArnsWrappedContainer = resourceArnsWrappedContainer {
                let resourceArnsContainer = try resourceArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var resourceArnsBuffer:[Swift.String]? = nil
                if let resourceArnsContainer = resourceArnsContainer {
                    resourceArnsBuffer = [Swift.String]()
                    for stringContainer0 in resourceArnsContainer {
                        resourceArnsBuffer?.append(stringContainer0)
                    }
                }
                resourceArns = resourceArnsBuffer
            } else {
                resourceArns = []
            }
        } else {
            resourceArns = nil
        }
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let callerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerArn)
        callerArn = callerArnDecoded
        if containerValues.contains(.contextEntries) {
            struct KeyVal0{struct member{}}
            let contextEntriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .contextEntries)
            if let contextEntriesWrappedContainer = contextEntriesWrappedContainer {
                let contextEntriesContainer = try contextEntriesWrappedContainer.decodeIfPresent([IAMClientTypes.ContextEntry].self, forKey: .member)
                var contextEntriesBuffer:[IAMClientTypes.ContextEntry]? = nil
                if let contextEntriesContainer = contextEntriesContainer {
                    contextEntriesBuffer = [IAMClientTypes.ContextEntry]()
                    for structureContainer0 in contextEntriesContainer {
                        contextEntriesBuffer?.append(structureContainer0)
                    }
                }
                contextEntries = contextEntriesBuffer
            } else {
                contextEntries = []
            }
        } else {
            contextEntries = nil
        }
        let resourceHandlingOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceHandlingOption)
        resourceHandlingOption = resourceHandlingOptionDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension SimulatePrincipalPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SimulatePrincipalPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyEvaluation" : self = .policyEvaluationException(try PolicyEvaluationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SimulatePrincipalPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case policyEvaluationException(PolicyEvaluationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SimulatePrincipalPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SimulatePrincipalPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.evaluationResults = output.evaluationResults
            self.isTruncated = output.isTruncated
            self.marker = output.marker
        } else {
            self.evaluationResults = nil
            self.isTruncated = false
            self.marker = nil
        }
    }
}

/// Contains the response to a successful [SimulatePrincipalPolicy] or [SimulateCustomPolicy] request.
public struct SimulatePrincipalPolicyOutputResponse: Swift.Equatable {
    /// The results of the simulation.
    public var evaluationResults: [IAMClientTypes.EvaluationResult]?
    /// A flag that indicates whether there are more items to return. If your results were truncated, you can make a subsequent pagination request using the Marker request parameter to retrieve more items. Note that IAM might return fewer than the MaxItems number of results even when there are more results available. We recommend that you check IsTruncated after every call to ensure that you receive all your results.
    public var isTruncated: Swift.Bool
    /// When IsTruncated is true, this element is present and contains the value to use for the Marker parameter in a subsequent pagination request.
    public var marker: Swift.String?

    public init (
        evaluationResults: [IAMClientTypes.EvaluationResult]? = nil,
        isTruncated: Swift.Bool = false,
        marker: Swift.String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.isTruncated = isTruncated
        self.marker = marker
    }
}

struct SimulatePrincipalPolicyOutputResponseBody: Swift.Equatable {
    let evaluationResults: [IAMClientTypes.EvaluationResult]?
    let isTruncated: Swift.Bool
    let marker: Swift.String?
}

extension SimulatePrincipalPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationResults = "EvaluationResults"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("SimulatePrincipalPolicyResult"))
        if containerValues.contains(.evaluationResults) {
            struct KeyVal0{struct member{}}
            let evaluationResultsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .evaluationResults)
            if let evaluationResultsWrappedContainer = evaluationResultsWrappedContainer {
                let evaluationResultsContainer = try evaluationResultsWrappedContainer.decodeIfPresent([IAMClientTypes.EvaluationResult].self, forKey: .member)
                var evaluationResultsBuffer:[IAMClientTypes.EvaluationResult]? = nil
                if let evaluationResultsContainer = evaluationResultsContainer {
                    evaluationResultsBuffer = [IAMClientTypes.EvaluationResult]()
                    for structureContainer0 in evaluationResultsContainer {
                        evaluationResultsBuffer?.append(structureContainer0)
                    }
                }
                evaluationResults = evaluationResultsBuffer
            } else {
                evaluationResults = []
            }
        } else {
            evaluationResults = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension IAMClientTypes {
    public enum SortKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lastAuthenticatedTimeAscending
        case lastAuthenticatedTimeDescending
        case serviceNamespaceAscending
        case serviceNamespaceDescending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortKeyType] {
            return [
                .lastAuthenticatedTimeAscending,
                .lastAuthenticatedTimeDescending,
                .serviceNamespaceAscending,
                .serviceNamespaceDescending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lastAuthenticatedTimeAscending: return "LAST_AUTHENTICATED_TIME_ASCENDING"
            case .lastAuthenticatedTimeDescending: return "LAST_AUTHENTICATED_TIME_DESCENDING"
            case .serviceNamespaceAscending: return "SERVICE_NAMESPACE_ASCENDING"
            case .serviceNamespaceDescending: return "SERVICE_NAMESPACE_DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortKeyType(rawValue: rawValue) ?? SortKeyType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.Statement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endPosition = "EndPosition"
        case sourcePolicyId = "SourcePolicyId"
        case sourcePolicyType = "SourcePolicyType"
        case startPosition = "StartPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endPosition = endPosition {
            try container.encode(endPosition, forKey: ClientRuntime.Key("EndPosition"))
        }
        if let sourcePolicyId = sourcePolicyId {
            try container.encode(sourcePolicyId, forKey: ClientRuntime.Key("SourcePolicyId"))
        }
        if let sourcePolicyType = sourcePolicyType {
            try container.encode(sourcePolicyType, forKey: ClientRuntime.Key("SourcePolicyType"))
        }
        if let startPosition = startPosition {
            try container.encode(startPosition, forKey: ClientRuntime.Key("StartPosition"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcePolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePolicyId)
        sourcePolicyId = sourcePolicyIdDecoded
        let sourcePolicyTypeDecoded = try containerValues.decodeIfPresent(IAMClientTypes.PolicySourceType.self, forKey: .sourcePolicyType)
        sourcePolicyType = sourcePolicyTypeDecoded
        let startPositionDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Position.self, forKey: .startPosition)
        startPosition = startPositionDecoded
        let endPositionDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Position.self, forKey: .endPosition)
        endPosition = endPositionDecoded
    }
}

extension IAMClientTypes {
    /// Contains a reference to a Statement element in a policy document that determines the result of the simulation. This data type is used by the MatchedStatements member of the [EvaluationResult] type.
    public struct Statement: Swift.Equatable {
        /// The row and column of the end of a Statement in an IAM policy.
        public var endPosition: IAMClientTypes.Position?
        /// The identifier of the policy that was provided as an input.
        public var sourcePolicyId: Swift.String?
        /// The type of the policy.
        public var sourcePolicyType: IAMClientTypes.PolicySourceType?
        /// The row and column of the beginning of the Statement in an IAM policy.
        public var startPosition: IAMClientTypes.Position?

        public init (
            endPosition: IAMClientTypes.Position? = nil,
            sourcePolicyId: Swift.String? = nil,
            sourcePolicyType: IAMClientTypes.PolicySourceType? = nil,
            startPosition: IAMClientTypes.Position? = nil
        )
        {
            self.endPosition = endPosition
            self.sourcePolicyId = sourcePolicyId
            self.sourcePolicyType = sourcePolicyType
            self.startPosition = startPosition
        }
    }

}

extension IAMClientTypes {
    public enum StatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusType] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusType(rawValue: rawValue) ?? StatusType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes {
    public enum SummaryKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accesskeysperuserquota
        case accountaccesskeyspresent
        case accountmfaenabled
        case accountsigningcertificatespresent
        case attachedpoliciespergroupquota
        case attachedpoliciesperrolequota
        case attachedpoliciesperuserquota
        case globalendpointtokenversion
        case grouppolicysizequota
        case groups
        case groupsperuserquota
        case groupsquota
        case mfadevices
        case mfadevicesinuse
        case policies
        case policiesquota
        case policysizequota
        case policyversionsinuse
        case policyversionsinusequota
        case servercertificates
        case servercertificatesquota
        case signingcertificatesperuserquota
        case userpolicysizequota
        case users
        case usersquota
        case versionsperpolicyquota
        case sdkUnknown(Swift.String)

        public static var allCases: [SummaryKeyType] {
            return [
                .accesskeysperuserquota,
                .accountaccesskeyspresent,
                .accountmfaenabled,
                .accountsigningcertificatespresent,
                .attachedpoliciespergroupquota,
                .attachedpoliciesperrolequota,
                .attachedpoliciesperuserquota,
                .globalendpointtokenversion,
                .grouppolicysizequota,
                .groups,
                .groupsperuserquota,
                .groupsquota,
                .mfadevices,
                .mfadevicesinuse,
                .policies,
                .policiesquota,
                .policysizequota,
                .policyversionsinuse,
                .policyversionsinusequota,
                .servercertificates,
                .servercertificatesquota,
                .signingcertificatesperuserquota,
                .userpolicysizequota,
                .users,
                .usersquota,
                .versionsperpolicyquota,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accesskeysperuserquota: return "AccessKeysPerUserQuota"
            case .accountaccesskeyspresent: return "AccountAccessKeysPresent"
            case .accountmfaenabled: return "AccountMFAEnabled"
            case .accountsigningcertificatespresent: return "AccountSigningCertificatesPresent"
            case .attachedpoliciespergroupquota: return "AttachedPoliciesPerGroupQuota"
            case .attachedpoliciesperrolequota: return "AttachedPoliciesPerRoleQuota"
            case .attachedpoliciesperuserquota: return "AttachedPoliciesPerUserQuota"
            case .globalendpointtokenversion: return "GlobalEndpointTokenVersion"
            case .grouppolicysizequota: return "GroupPolicySizeQuota"
            case .groups: return "Groups"
            case .groupsperuserquota: return "GroupsPerUserQuota"
            case .groupsquota: return "GroupsQuota"
            case .mfadevices: return "MFADevices"
            case .mfadevicesinuse: return "MFADevicesInUse"
            case .policies: return "Policies"
            case .policiesquota: return "PoliciesQuota"
            case .policysizequota: return "PolicySizeQuota"
            case .policyversionsinuse: return "PolicyVersionsInUse"
            case .policyversionsinusequota: return "PolicyVersionsInUseQuota"
            case .servercertificates: return "ServerCertificates"
            case .servercertificatesquota: return "ServerCertificatesQuota"
            case .signingcertificatesperuserquota: return "SigningCertificatesPerUserQuota"
            case .userpolicysizequota: return "UserPolicySizeQuota"
            case .users: return "Users"
            case .usersquota: return "UsersQuota"
            case .versionsperpolicyquota: return "VersionsPerPolicyQuota"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SummaryKeyType(rawValue: rawValue) ?? SummaryKeyType.sdkUnknown(rawValue)
        }
    }
}

extension IAMClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IAMClientTypes {
    /// A structure that represents user-provided metadata that can be associated with an IAM resource. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public struct Tag: Swift.Equatable {
        /// The key name that can be used to look up or retrieve the associated value. For example, Department or Cost Center are common choices.
        /// This member is required.
        public var key: Swift.String?
        /// The value associated with this tag. For example, tags with a key name of Department could have values such as Human Resources, Accounting, and Support. Tags with a key name of Cost Center might have values that consist of the number associated with the different cost centers in your company. Typically, many resources have tags with the same key name but with different values. Amazon Web Services always interprets the tag Value as a single string. If you need to store an array, you can store comma-separated values in the string. However, you must interpret the value in your code.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagInstanceProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagInstanceProfileInput: Swift.Equatable {
    /// The name of the IAM instance profile to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The list of tags that you want to attach to the IAM instance profile. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        instanceProfileName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.tags = tags
    }
}

struct TagInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagInstanceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagInstanceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagInstanceProfileOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagInstanceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagInstanceProfileOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagMFADeviceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagMFADeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagMFADeviceInput: Swift.Equatable {
    /// The unique identifier for the IAM virtual MFA device to which you want to add tags. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// The list of tags that you want to attach to the IAM virtual MFA device. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        serialNumber: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.serialNumber = serialNumber
        self.tags = tags
    }
}

struct TagMFADeviceInputBody: Swift.Equatable {
    let serialNumber: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagMFADeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serialNumber = "SerialNumber"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagMFADeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagMFADeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagMFADeviceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagMFADeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagMFADeviceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagOpenIDConnectProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagOpenIDConnectProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagOpenIDConnectProviderInput: Swift.Equatable {
    /// The ARN of the OIDC identity provider in IAM to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?
    /// The list of tags that you want to attach to the OIDC identity provider in IAM. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        openIDConnectProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.tags = tags
    }
}

struct TagOpenIDConnectProviderInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagOpenIDConnectProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagOpenIDConnectProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagOpenIDConnectProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagOpenIDConnectProviderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagOpenIDConnectProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagOpenIDConnectProviderOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagPolicyInput: Swift.Equatable {
    /// The ARN of the IAM customer managed policy to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyArn: Swift.String?
    /// The list of tags that you want to attach to the IAM customer managed policy. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        policyArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.policyArn = policyArn
        self.tags = tags
    }
}

struct TagPolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagPolicyOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagRoleInput: Swift.Equatable {
    /// The name of the IAM role to which you want to add tags. This parameter accepts (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?
    /// The list of tags that you want to attach to the IAM role. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        roleName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.roleName = roleName
        self.tags = tags
    }
}

struct TagRoleInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagRoleOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagRoleOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagSAMLProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagSAMLProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagSAMLProviderInput: Swift.Equatable {
    /// The ARN of the SAML identity provider in IAM to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var samlProviderArn: Swift.String?
    /// The list of tags that you want to attach to the SAML identity provider in IAM. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        samlProviderArn: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
        self.tags = tags
    }
}

struct TagSAMLProviderInputBody: Swift.Equatable {
    let samlProviderArn: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagSAMLProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagSAMLProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagSAMLProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagSAMLProviderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagSAMLProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagSAMLProviderOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagServerCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagServerCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagServerCertificateInput: Swift.Equatable {
    /// The name of the IAM server certificate to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?
    /// The list of tags that you want to attach to the IAM server certificate. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        serverCertificateName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
        self.tags = tags
    }
}

struct TagServerCertificateInputBody: Swift.Equatable {
    let serverCertificateName: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagServerCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificateName = "ServerCertificateName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagServerCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagServerCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagServerCertificateOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagServerCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagServerCertificateOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagUserInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("TagUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagUserInput: Swift.Equatable {
    /// The list of tags that you want to attach to the IAM user. Each tag consists of a key name and an associated value.
    /// This member is required.
    public var tags: [IAMClientTypes.Tag]?
    /// The name of the IAM user to which you want to add tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        tags: [IAMClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.tags = tags
        self.userName = userName
    }
}

struct TagUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension TagUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagUserOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagUserOutputResponse: Swift.Equatable {

    public init () { }
}

extension IAMClientTypes.TrackedActionLastAccessed: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionName = "ActionName"
        case lastAccessedEntity = "LastAccessedEntity"
        case lastAccessedRegion = "LastAccessedRegion"
        case lastAccessedTime = "LastAccessedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let actionName = actionName {
            try container.encode(actionName, forKey: ClientRuntime.Key("ActionName"))
        }
        if let lastAccessedEntity = lastAccessedEntity {
            try container.encode(lastAccessedEntity, forKey: ClientRuntime.Key("LastAccessedEntity"))
        }
        if let lastAccessedRegion = lastAccessedRegion {
            try container.encode(lastAccessedRegion, forKey: ClientRuntime.Key("LastAccessedRegion"))
        }
        if let lastAccessedTime = lastAccessedTime {
            try container.encodeTimestamp(lastAccessedTime, format: .dateTime, forKey: ClientRuntime.Key("lastAccessedTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let lastAccessedEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAccessedEntity)
        lastAccessedEntity = lastAccessedEntityDecoded
        let lastAccessedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastAccessedTime)
        lastAccessedTime = lastAccessedTimeDecoded
        let lastAccessedRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAccessedRegion)
        lastAccessedRegion = lastAccessedRegionDecoded
    }
}

extension IAMClientTypes {
    /// Contains details about the most recent attempt to access an action within the service. This data type is used as a response element in the [GetServiceLastAccessedDetails] operation.
    public struct TrackedActionLastAccessed: Swift.Equatable {
        /// The name of the tracked action to which access was attempted. Tracked actions are actions that report activity to IAM.
        public var actionName: Swift.String?
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var lastAccessedEntity: Swift.String?
        /// The Region from which the authenticated entity (user or role) last attempted to access the tracked action. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAccessedRegion: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when an authenticated entity most recently attempted to access the tracked service. Amazon Web Services does not report unauthenticated requests. This field is null if no IAM entities attempted to access the service within the [tracking period](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html#service-last-accessed-reporting-period).
        public var lastAccessedTime: ClientRuntime.Date?

        public init (
            actionName: Swift.String? = nil,
            lastAccessedEntity: Swift.String? = nil,
            lastAccessedRegion: Swift.String? = nil,
            lastAccessedTime: ClientRuntime.Date? = nil
        )
        {
            self.actionName = actionName
            self.lastAccessedEntity = lastAccessedEntity
            self.lastAccessedRegion = lastAccessedRegion
            self.lastAccessedTime = lastAccessedTime
        }
    }

}

extension UnmodifiableEntityException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<UnmodifiableEntityExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because only the service that depends on the service-linked role can modify or delete the role on your behalf. The error message includes the name of the service that depends on this service-linked role. You must request the change through that service.
public struct UnmodifiableEntityException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnmodifiableEntityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnmodifiableEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnrecognizedPublicKeyEncodingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<UnrecognizedPublicKeyEncodingExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the public key encoding format is unsupported or unrecognized.
public struct UnrecognizedPublicKeyEncodingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnrecognizedPublicKeyEncodingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnrecognizedPublicKeyEncodingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagInstanceProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceProfileName = instanceProfileName {
            try container.encode(instanceProfileName, forKey: ClientRuntime.Key("InstanceProfileName"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagInstanceProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagInstanceProfileInput: Swift.Equatable {
    /// The name of the IAM instance profile from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified instance profile.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        instanceProfileName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.instanceProfileName = instanceProfileName
        self.tagKeys = tagKeys
    }
}

struct UntagInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileName: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileName = "InstanceProfileName"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagInstanceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagInstanceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagInstanceProfileOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagInstanceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagInstanceProfileOutputResponse: Swift.Equatable {

    public init () { }
}

extension UntagMFADeviceInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagMFADevice", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagMFADeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagMFADeviceInput: Swift.Equatable {
    /// The unique identifier for the IAM virtual MFA device from which you want to remove tags. For virtual MFA devices, the serial number is the same as the ARN. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serialNumber: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified instance profile.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        serialNumber: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.serialNumber = serialNumber
        self.tagKeys = tagKeys
    }
}

struct UntagMFADeviceInputBody: Swift.Equatable {
    let serialNumber: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagMFADeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serialNumber = "SerialNumber"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagMFADeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagMFADeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagMFADeviceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagMFADeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagMFADeviceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UntagOpenIDConnectProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagOpenIDConnectProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagOpenIDConnectProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagOpenIDConnectProviderInput: Swift.Equatable {
    /// The ARN of the OIDC provider in IAM from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified OIDC provider.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        openIDConnectProviderArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.tagKeys = tagKeys
    }
}

struct UntagOpenIDConnectProviderInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagOpenIDConnectProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagOpenIDConnectProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagOpenIDConnectProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagOpenIDConnectProviderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagOpenIDConnectProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagOpenIDConnectProviderOutputResponse: Swift.Equatable {

    public init () { }
}

extension UntagPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyArn = policyArn {
            try container.encode(policyArn, forKey: ClientRuntime.Key("PolicyArn"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagPolicyInput: Swift.Equatable {
    /// The ARN of the IAM customer managed policy from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var policyArn: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified policy.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        policyArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.policyArn = policyArn
        self.tagKeys = tagKeys
    }
}

struct UntagPolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagPolicyOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension UntagRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagRoleInput: Swift.Equatable {
    /// The name of the IAM role from which you want to remove tags. This parameter accepts (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified role.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        roleName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.roleName = roleName
        self.tagKeys = tagKeys
    }
}

struct UntagRoleInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName = "RoleName"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagRoleOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagRoleOutputResponse: Swift.Equatable {

    public init () { }
}

extension UntagSAMLProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagSAMLProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagSAMLProviderInput: Swift.Equatable {
    /// The ARN of the SAML identity provider in IAM from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var samlProviderArn: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified SAML identity provider.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        samlProviderArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
        self.tagKeys = tagKeys
    }
}

struct UntagSAMLProviderInputBody: Swift.Equatable {
    let samlProviderArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagSAMLProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagSAMLProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagSAMLProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagSAMLProviderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagSAMLProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagSAMLProviderOutputResponse: Swift.Equatable {

    public init () { }
}

extension UntagServerCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagServerCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagServerCertificateInput: Swift.Equatable {
    /// The name of the IAM server certificate from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified IAM server certificate.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        serverCertificateName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.serverCertificateName = serverCertificateName
        self.tagKeys = tagKeys
    }
}

struct UntagServerCertificateInputBody: Swift.Equatable {
    let serverCertificateName: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagServerCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificateName = "ServerCertificateName"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagServerCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagServerCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagServerCertificateOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagServerCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagServerCertificateOutputResponse: Swift.Equatable {

    public init () { }
}

extension UntagUserInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkeytype0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UntagUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagUserInput: Swift.Equatable {
    /// A list of key names as a simple array of strings. The tags with matching keys are removed from the specified user.
    /// This member is required.
    public var tagKeys: [Swift.String]?
    /// The name of the IAM user from which you want to remove tags. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        tagKeys: [Swift.String]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.tagKeys = tagKeys
        self.userName = userName
    }
}

struct UntagUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        if containerValues.contains(.tagKeys) {
            struct KeyVal0{struct member{}}
            let tagKeysWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagKeys)
            if let tagKeysWrappedContainer = tagKeysWrappedContainer {
                let tagKeysContainer = try tagKeysWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var tagKeysBuffer:[Swift.String]? = nil
                if let tagKeysContainer = tagKeysContainer {
                    tagKeysBuffer = [Swift.String]()
                    for stringContainer0 in tagKeysContainer {
                        tagKeysBuffer?.append(stringContainer0)
                    }
                }
                tagKeys = tagKeysBuffer
            } else {
                tagKeys = []
            }
        } else {
            tagKeys = nil
        }
    }
}

extension UntagUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagUserOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagUserOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateAccessKeyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateAccessKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateAccessKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAccessKeyInput: Swift.Equatable {
    /// The access key ID of the secret access key you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var accessKeyId: Swift.String?
    /// The status you want to assign to the secret access key. Active means that the key can be used for programmatic calls to Amazon Web Services, while Inactive means that the key cannot be used.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the user whose key you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init (
        accessKeyId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.status = status
        self.userName = userName
    }
}

struct UpdateAccessKeyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let accessKeyId: Swift.String?
    let status: IAMClientTypes.StatusType?
}

extension UpdateAccessKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case status = "Status"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateAccessKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateAccessKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAccessKeyOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccessKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAccessKeyOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateAccountPasswordPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowUsersToChangePassword = allowUsersToChangePassword {
            try container.encode(allowUsersToChangePassword, forKey: ClientRuntime.Key("AllowUsersToChangePassword"))
        }
        if let hardExpiry = hardExpiry {
            try container.encode(hardExpiry, forKey: ClientRuntime.Key("HardExpiry"))
        }
        if let maxPasswordAge = maxPasswordAge {
            try container.encode(maxPasswordAge, forKey: ClientRuntime.Key("MaxPasswordAge"))
        }
        if let minimumPasswordLength = minimumPasswordLength {
            try container.encode(minimumPasswordLength, forKey: ClientRuntime.Key("MinimumPasswordLength"))
        }
        if let passwordReusePrevention = passwordReusePrevention {
            try container.encode(passwordReusePrevention, forKey: ClientRuntime.Key("PasswordReusePrevention"))
        }
        if let requireLowercaseCharacters = requireLowercaseCharacters {
            try container.encode(requireLowercaseCharacters, forKey: ClientRuntime.Key("RequireLowercaseCharacters"))
        }
        if let requireNumbers = requireNumbers {
            try container.encode(requireNumbers, forKey: ClientRuntime.Key("RequireNumbers"))
        }
        if let requireSymbols = requireSymbols {
            try container.encode(requireSymbols, forKey: ClientRuntime.Key("RequireSymbols"))
        }
        if let requireUppercaseCharacters = requireUppercaseCharacters {
            try container.encode(requireUppercaseCharacters, forKey: ClientRuntime.Key("RequireUppercaseCharacters"))
        }
        try container.encode("UpdateAccountPasswordPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateAccountPasswordPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAccountPasswordPolicyInput: Swift.Equatable {
    /// Allows all IAM users in your account to use the Amazon Web Services Management Console to change their own passwords. For more information, see [Permitting IAM users to change their own passwords](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_passwords_enable-user-change.html) in the IAM User Guide. If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that IAM users in the account do not automatically have permissions to change their own password.
    public var allowUsersToChangePassword: Swift.Bool?
    /// Prevents IAM users who are accessing the account via the Amazon Web Services Management Console from setting a new console password after their password has expired. The IAM user cannot access the console until an administrator resets the password. If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that IAM users can change their passwords after they expire and continue to sign in as the user. In the Amazon Web Services Management Console, the custom password policy option Allow users to change their own password gives IAM users permissions to iam:ChangePassword for only their user and to the iam:GetAccountPasswordPolicy action. This option does not attach a permissions policy to each user, rather the permissions are applied at the account-level for all users by IAM. IAM users with iam:ChangePassword permission and active access keys can reset their own expired console password using the CLI or API.
    public var hardExpiry: Swift.Bool?
    /// The number of days that an IAM user password is valid. If you do not specify a value for this parameter, then the operation uses the default value of 0. The result is that IAM user passwords never expire.
    public var maxPasswordAge: Swift.Int?
    /// The minimum number of characters allowed in an IAM user password. If you do not specify a value for this parameter, then the operation uses the default value of 6.
    public var minimumPasswordLength: Swift.Int?
    /// Specifies the number of previous passwords that IAM users are prevented from reusing. If you do not specify a value for this parameter, then the operation uses the default value of 0. The result is that IAM users are not prevented from reusing previous passwords.
    public var passwordReusePrevention: Swift.Int?
    /// Specifies whether IAM user passwords must contain at least one lowercase character from the ISO basic Latin alphabet (a to z). If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one lowercase character.
    public var requireLowercaseCharacters: Swift.Bool?
    /// Specifies whether IAM user passwords must contain at least one numeric character (0 to 9). If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one numeric character.
    public var requireNumbers: Swift.Bool?
    /// Specifies whether IAM user passwords must contain at least one of the following non-alphanumeric characters: ! @ # $ % ^ & * ( ) _ + - = [ ] { } | ' If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one symbol character.
    public var requireSymbols: Swift.Bool?
    /// Specifies whether IAM user passwords must contain at least one uppercase character from the ISO basic Latin alphabet (A to Z). If you do not specify a value for this parameter, then the operation uses the default value of false. The result is that passwords do not require at least one uppercase character.
    public var requireUppercaseCharacters: Swift.Bool?

    public init (
        allowUsersToChangePassword: Swift.Bool? = nil,
        hardExpiry: Swift.Bool? = nil,
        maxPasswordAge: Swift.Int? = nil,
        minimumPasswordLength: Swift.Int? = nil,
        passwordReusePrevention: Swift.Int? = nil,
        requireLowercaseCharacters: Swift.Bool? = nil,
        requireNumbers: Swift.Bool? = nil,
        requireSymbols: Swift.Bool? = nil,
        requireUppercaseCharacters: Swift.Bool? = nil
    )
    {
        self.allowUsersToChangePassword = allowUsersToChangePassword
        self.hardExpiry = hardExpiry
        self.maxPasswordAge = maxPasswordAge
        self.minimumPasswordLength = minimumPasswordLength
        self.passwordReusePrevention = passwordReusePrevention
        self.requireLowercaseCharacters = requireLowercaseCharacters
        self.requireNumbers = requireNumbers
        self.requireSymbols = requireSymbols
        self.requireUppercaseCharacters = requireUppercaseCharacters
    }
}

struct UpdateAccountPasswordPolicyInputBody: Swift.Equatable {
    let minimumPasswordLength: Swift.Int?
    let requireSymbols: Swift.Bool?
    let requireNumbers: Swift.Bool?
    let requireUppercaseCharacters: Swift.Bool?
    let requireLowercaseCharacters: Swift.Bool?
    let allowUsersToChangePassword: Swift.Bool?
    let maxPasswordAge: Swift.Int?
    let passwordReusePrevention: Swift.Int?
    let hardExpiry: Swift.Bool?
}

extension UpdateAccountPasswordPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUsersToChangePassword = "AllowUsersToChangePassword"
        case hardExpiry = "HardExpiry"
        case maxPasswordAge = "MaxPasswordAge"
        case minimumPasswordLength = "MinimumPasswordLength"
        case passwordReusePrevention = "PasswordReusePrevention"
        case requireLowercaseCharacters = "RequireLowercaseCharacters"
        case requireNumbers = "RequireNumbers"
        case requireSymbols = "RequireSymbols"
        case requireUppercaseCharacters = "RequireUppercaseCharacters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumPasswordLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumPasswordLength)
        minimumPasswordLength = minimumPasswordLengthDecoded
        let requireSymbolsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireSymbols)
        requireSymbols = requireSymbolsDecoded
        let requireNumbersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireNumbers)
        requireNumbers = requireNumbersDecoded
        let requireUppercaseCharactersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireUppercaseCharacters)
        requireUppercaseCharacters = requireUppercaseCharactersDecoded
        let requireLowercaseCharactersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireLowercaseCharacters)
        requireLowercaseCharacters = requireLowercaseCharactersDecoded
        let allowUsersToChangePasswordDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowUsersToChangePassword)
        allowUsersToChangePassword = allowUsersToChangePasswordDecoded
        let maxPasswordAgeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxPasswordAge)
        maxPasswordAge = maxPasswordAgeDecoded
        let passwordReusePreventionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .passwordReusePrevention)
        passwordReusePrevention = passwordReusePreventionDecoded
        let hardExpiryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hardExpiry)
        hardExpiry = hardExpiryDecoded
    }
}

extension UpdateAccountPasswordPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateAccountPasswordPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocument" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAccountPasswordPolicyOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountPasswordPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAccountPasswordPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateAssumeRolePolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyDocument = policyDocument {
            try container.encode(policyDocument, forKey: ClientRuntime.Key("PolicyDocument"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("UpdateAssumeRolePolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateAssumeRolePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAssumeRolePolicyInput: Swift.Equatable {
    /// The policy that grants an entity permission to assume the role. You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the role to update with the new policy. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        policyDocument: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.roleName = roleName
    }
}

struct UpdateAssumeRolePolicyInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let policyDocument: Swift.String?
}

extension UpdateAssumeRolePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument = "PolicyDocument"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension UpdateAssumeRolePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateAssumeRolePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocument" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntity" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAssumeRolePolicyOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssumeRolePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAssumeRolePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateGroupInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let newGroupName = newGroupName {
            try container.encode(newGroupName, forKey: ClientRuntime.Key("NewGroupName"))
        }
        if let newPath = newPath {
            try container.encode(newPath, forKey: ClientRuntime.Key("NewPath"))
        }
        try container.encode("UpdateGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateGroupInput: Swift.Equatable {
    /// Name of the IAM group to update. If you're changing the name of the group, this is the original name. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var groupName: Swift.String?
    /// New name for the IAM group. Only include this if changing the group's name. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    public var newGroupName: Swift.String?
    /// New path for the IAM group. Only include this if changing the group's path. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var newPath: Swift.String?

    public init (
        groupName: Swift.String? = nil,
        newGroupName: Swift.String? = nil,
        newPath: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.newGroupName = newGroupName
        self.newPath = newPath
    }
}

struct UpdateGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let newPath: Swift.String?
    let newGroupName: Swift.String?
}

extension UpdateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case newGroupName = "NewGroupName"
        case newPath = "NewPath"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let newPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newPath)
        newPath = newPathDecoded
        let newGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newGroupName)
        newGroupName = newGroupNameDecoded
    }
}

extension UpdateGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGroupOutputError: Swift.Error, Swift.Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateLoginProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLoginProfileInput(passwordResetRequired: \(Swift.String(describing: passwordResetRequired)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

extension UpdateLoginProfileInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let password = password {
            try container.encode(password, forKey: ClientRuntime.Key("Password"))
        }
        if let passwordResetRequired = passwordResetRequired {
            try container.encode(passwordResetRequired, forKey: ClientRuntime.Key("PasswordResetRequired"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateLoginProfile", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateLoginProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateLoginProfileInput: Swift.Equatable {
    /// The new password for the specified IAM user. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    ///
    ///
    /// However, the format can be further restricted by the account administrator by setting a password policy on the Amazon Web Services account. For more information, see [UpdateAccountPasswordPolicy].
    public var password: Swift.String?
    /// Allows this new password to be used only once by requiring the specified IAM user to set a new password on next sign-in.
    public var passwordResetRequired: Swift.Bool?
    /// The name of the user whose password you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        password: Swift.String? = nil,
        passwordResetRequired: Swift.Bool? = nil,
        userName: Swift.String? = nil
    )
    {
        self.password = password
        self.passwordResetRequired = passwordResetRequired
        self.userName = userName
    }
}

struct UpdateLoginProfileInputBody: Swift.Equatable {
    let userName: Swift.String?
    let password: Swift.String?
    let passwordResetRequired: Swift.Bool?
}

extension UpdateLoginProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case passwordResetRequired = "PasswordResetRequired"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let passwordResetRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .passwordResetRequired)
        passwordResetRequired = passwordResetRequiredDecoded
    }
}

extension UpdateLoginProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateLoginProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityTemporarilyUnmodifiable" : self = .entityTemporarilyUnmodifiableException(try EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordPolicyViolation" : self = .passwordPolicyViolationException(try PasswordPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateLoginProfileOutputError: Swift.Error, Swift.Equatable {
    case entityTemporarilyUnmodifiableException(EntityTemporarilyUnmodifiableException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case passwordPolicyViolationException(PasswordPolicyViolationException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLoginProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLoginProfileOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateOpenIDConnectProviderThumbprintInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let openIDConnectProviderArn = openIDConnectProviderArn {
            try container.encode(openIDConnectProviderArn, forKey: ClientRuntime.Key("OpenIDConnectProviderArn"))
        }
        if let thumbprintList = thumbprintList {
            if !thumbprintList.isEmpty {
                var thumbprintListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ThumbprintList"))
                for (index0, thumbprinttype0) in thumbprintList.enumerated() {
                    try thumbprintListContainer.encode(thumbprinttype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var thumbprintListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ThumbprintList"))
                try thumbprintListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UpdateOpenIDConnectProviderThumbprint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateOpenIDConnectProviderThumbprintInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateOpenIDConnectProviderThumbprintInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM OIDC provider resource object for which you want to update the thumbprint. You can get a list of OIDC provider ARNs by using the [ListOpenIDConnectProviders] operation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var openIDConnectProviderArn: Swift.String?
    /// A list of certificate thumbprints that are associated with the specified IAM OpenID Connect provider. For more information, see [CreateOpenIDConnectProvider].
    /// This member is required.
    public var thumbprintList: [Swift.String]?

    public init (
        openIDConnectProviderArn: Swift.String? = nil,
        thumbprintList: [Swift.String]? = nil
    )
    {
        self.openIDConnectProviderArn = openIDConnectProviderArn
        self.thumbprintList = thumbprintList
    }
}

struct UpdateOpenIDConnectProviderThumbprintInputBody: Swift.Equatable {
    let openIDConnectProviderArn: Swift.String?
    let thumbprintList: [Swift.String]?
}

extension UpdateOpenIDConnectProviderThumbprintInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openIDConnectProviderArn = "OpenIDConnectProviderArn"
        case thumbprintList = "ThumbprintList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openIDConnectProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDConnectProviderArn)
        openIDConnectProviderArn = openIDConnectProviderArnDecoded
        if containerValues.contains(.thumbprintList) {
            struct KeyVal0{struct member{}}
            let thumbprintListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .thumbprintList)
            if let thumbprintListWrappedContainer = thumbprintListWrappedContainer {
                let thumbprintListContainer = try thumbprintListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var thumbprintListBuffer:[Swift.String]? = nil
                if let thumbprintListContainer = thumbprintListContainer {
                    thumbprintListBuffer = [Swift.String]()
                    for stringContainer0 in thumbprintListContainer {
                        thumbprintListBuffer?.append(stringContainer0)
                    }
                }
                thumbprintList = thumbprintListBuffer
            } else {
                thumbprintList = []
            }
        } else {
            thumbprintList = nil
        }
    }
}

extension UpdateOpenIDConnectProviderThumbprintOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateOpenIDConnectProviderThumbprintOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateOpenIDConnectProviderThumbprintOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOpenIDConnectProviderThumbprintOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateOpenIDConnectProviderThumbprintOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateRoleDescriptionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("UpdateRoleDescription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateRoleDescriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRoleDescriptionInput: Swift.Equatable {
    /// The new description that you want to apply to the specified role.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the role that you want to modify.
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        description: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.description = description
        self.roleName = roleName
    }
}

struct UpdateRoleDescriptionInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let description: Swift.String?
}

extension UpdateRoleDescriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRoleDescriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateRoleDescriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntity" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRoleDescriptionOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoleDescriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateRoleDescriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.role = output.role
        } else {
            self.role = nil
        }
    }
}

public struct UpdateRoleDescriptionOutputResponse: Swift.Equatable {
    /// A structure that contains details about the modified role.
    public var role: IAMClientTypes.Role?

    public init (
        role: IAMClientTypes.Role? = nil
    )
    {
        self.role = role
    }
}

struct UpdateRoleDescriptionOutputResponseBody: Swift.Equatable {
    let role: IAMClientTypes.Role?
}

extension UpdateRoleDescriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UpdateRoleDescriptionResult"))
        let roleDecoded = try containerValues.decodeIfPresent(IAMClientTypes.Role.self, forKey: .role)
        role = roleDecoded
    }
}

extension UpdateRoleInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let maxSessionDuration = maxSessionDuration {
            try container.encode(maxSessionDuration, forKey: ClientRuntime.Key("MaxSessionDuration"))
        }
        if let roleName = roleName {
            try container.encode(roleName, forKey: ClientRuntime.Key("RoleName"))
        }
        try container.encode("UpdateRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRoleInput: Swift.Equatable {
    /// The new description that you want to apply to the specified role.
    public var description: Swift.String?
    /// The maximum session duration (in seconds) that you want to set for the specified role. If you do not specify a value for this setting, the default value of one hour is applied. This setting can have a value from 1 hour to 12 hours. Anyone who assumes the role from the CLI or API can use the DurationSeconds API parameter or the duration-seconds CLI parameter to request a longer session. The MaxSessionDuration setting determines the maximum duration that can be requested using the DurationSeconds parameter. If users don't specify a value for the DurationSeconds parameter, their security credentials are valid for one hour by default. This applies when you use the AssumeRole* API operations or the assume-role* CLI operations but does not apply when you use those operations to create a console URL. For more information, see [Using IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html) in the IAM User Guide.
    public var maxSessionDuration: Swift.Int?
    /// The name of the role that you want to modify.
    /// This member is required.
    public var roleName: Swift.String?

    public init (
        description: Swift.String? = nil,
        maxSessionDuration: Swift.Int? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.description = description
        self.maxSessionDuration = maxSessionDuration
        self.roleName = roleName
    }
}

struct UpdateRoleInputBody: Swift.Equatable {
    let roleName: Swift.String?
    let description: Swift.String?
    let maxSessionDuration: Swift.Int?
}

extension UpdateRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case maxSessionDuration = "MaxSessionDuration"
        case roleName = "RoleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let maxSessionDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSessionDuration)
        maxSessionDuration = maxSessionDurationDecoded
    }
}

extension UpdateRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnmodifiableEntity" : self = .unmodifiableEntityException(try UnmodifiableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRoleOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unmodifiableEntityException(UnmodifiableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoleOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateSAMLProviderInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let samlMetadataDocument = samlMetadataDocument {
            try container.encode(samlMetadataDocument, forKey: ClientRuntime.Key("SAMLMetadataDocument"))
        }
        if let samlProviderArn = samlProviderArn {
            try container.encode(samlProviderArn, forKey: ClientRuntime.Key("SAMLProviderArn"))
        }
        try container.encode("UpdateSAMLProvider", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateSAMLProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSAMLProviderInput: Swift.Equatable {
    /// An XML document generated by an identity provider (IdP) that supports SAML 2.0. The document includes the issuer's name, expiration information, and keys that can be used to validate the SAML authentication response (assertions) that are received from the IdP. You must generate the metadata document using the identity management software that is used as your organization's IdP.
    /// This member is required.
    public var samlMetadataDocument: Swift.String?
    /// The Amazon Resource Name (ARN) of the SAML provider to update. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var samlProviderArn: Swift.String?

    public init (
        samlMetadataDocument: Swift.String? = nil,
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlMetadataDocument = samlMetadataDocument
        self.samlProviderArn = samlProviderArn
    }
}

struct UpdateSAMLProviderInputBody: Swift.Equatable {
    let samlMetadataDocument: Swift.String?
    let samlProviderArn: Swift.String?
}

extension UpdateSAMLProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlMetadataDocument = "SAMLMetadataDocument"
        case samlProviderArn = "SAMLProviderArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlMetadataDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlMetadataDocument)
        samlMetadataDocument = samlMetadataDocumentDecoded
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
    }
}

extension UpdateSAMLProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateSAMLProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSAMLProviderOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSAMLProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSAMLProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.samlProviderArn = output.samlProviderArn
        } else {
            self.samlProviderArn = nil
        }
    }
}

/// Contains the response to a successful [UpdateSAMLProvider] request.
public struct UpdateSAMLProviderOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the SAML provider that was updated.
    public var samlProviderArn: Swift.String?

    public init (
        samlProviderArn: Swift.String? = nil
    )
    {
        self.samlProviderArn = samlProviderArn
    }
}

struct UpdateSAMLProviderOutputResponseBody: Swift.Equatable {
    let samlProviderArn: Swift.String?
}

extension UpdateSAMLProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlProviderArn = "SAMLProviderArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UpdateSAMLProviderResult"))
        let samlProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlProviderArn)
        samlProviderArn = samlProviderArnDecoded
    }
}

extension UpdateSSHPublicKeyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sshPublicKeyId = sshPublicKeyId {
            try container.encode(sshPublicKeyId, forKey: ClientRuntime.Key("SSHPublicKeyId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateSSHPublicKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateSSHPublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSSHPublicKeyInput: Swift.Equatable {
    /// The unique identifier for the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// The status to assign to the SSH public key. Active means that the key can be used for authentication with an CodeCommit repository. Inactive means that the key cannot be used.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the IAM user associated with the SSH public key. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        sshPublicKeyId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.sshPublicKeyId = sshPublicKeyId
        self.status = status
        self.userName = userName
    }
}

struct UpdateSSHPublicKeyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let sshPublicKeyId: Swift.String?
    let status: IAMClientTypes.StatusType?
}

extension UpdateSSHPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKeyId = "SSHPublicKeyId"
        case status = "Status"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateSSHPublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateSSHPublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSSHPublicKeyOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSSHPublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSSHPublicKeyOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateServerCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let newPath = newPath {
            try container.encode(newPath, forKey: ClientRuntime.Key("NewPath"))
        }
        if let newServerCertificateName = newServerCertificateName {
            try container.encode(newServerCertificateName, forKey: ClientRuntime.Key("NewServerCertificateName"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        try container.encode("UpdateServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateServerCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServerCertificateInput: Swift.Equatable {
    /// The new path for the server certificate. Include this only if you are updating the server certificate's path. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var newPath: Swift.String?
    /// The new name for the server certificate. Include this only if you are updating the server certificate's name. The name of the certificate cannot contain any spaces. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var newServerCertificateName: Swift.String?
    /// The name of the server certificate that you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?

    public init (
        newPath: Swift.String? = nil,
        newServerCertificateName: Swift.String? = nil,
        serverCertificateName: Swift.String? = nil
    )
    {
        self.newPath = newPath
        self.newServerCertificateName = newServerCertificateName
        self.serverCertificateName = serverCertificateName
    }
}

struct UpdateServerCertificateInputBody: Swift.Equatable {
    let serverCertificateName: Swift.String?
    let newPath: Swift.String?
    let newServerCertificateName: Swift.String?
}

extension UpdateServerCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newPath = "NewPath"
        case newServerCertificateName = "NewServerCertificateName"
        case serverCertificateName = "ServerCertificateName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
        let newPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newPath)
        newPath = newPathDecoded
        let newServerCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newServerCertificateName)
        newServerCertificateName = newServerCertificateNameDecoded
    }
}

extension UpdateServerCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateServerCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateServerCertificateOutputError: Swift.Error, Swift.Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServerCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateServerCertificateOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateServiceSpecificCredentialInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let serviceSpecificCredentialId = serviceSpecificCredentialId {
            try container.encode(serviceSpecificCredentialId, forKey: ClientRuntime.Key("ServiceSpecificCredentialId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateServiceSpecificCredential", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateServiceSpecificCredentialInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServiceSpecificCredentialInput: Swift.Equatable {
    /// The unique identifier of the service-specific credential. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var serviceSpecificCredentialId: Swift.String?
    /// The status to be assigned to the service-specific credential.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the IAM user associated with the service-specific credential. If you do not specify this value, then the operation assumes the user whose credentials are used to call the operation. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init (
        serviceSpecificCredentialId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serviceSpecificCredentialId = serviceSpecificCredentialId
        self.status = status
        self.userName = userName
    }
}

struct UpdateServiceSpecificCredentialInputBody: Swift.Equatable {
    let userName: Swift.String?
    let serviceSpecificCredentialId: Swift.String?
    let status: IAMClientTypes.StatusType?
}

extension UpdateServiceSpecificCredentialInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSpecificCredentialId = "ServiceSpecificCredentialId"
        case status = "Status"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serviceSpecificCredentialIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceSpecificCredentialId)
        serviceSpecificCredentialId = serviceSpecificCredentialIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateServiceSpecificCredentialOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateServiceSpecificCredentialOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateServiceSpecificCredentialOutputError: Swift.Error, Swift.Equatable {
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceSpecificCredentialOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateServiceSpecificCredentialOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateSigningCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateId = certificateId {
            try container.encode(certificateId, forKey: ClientRuntime.Key("CertificateId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateSigningCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateSigningCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSigningCertificateInput: Swift.Equatable {
    /// The ID of the signing certificate you want to update. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters that can consist of any upper or lowercased letter or digit.
    /// This member is required.
    public var certificateId: Swift.String?
    /// The status you want to assign to the certificate. Active means that the certificate can be used for programmatic calls to Amazon Web Services Inactive means that the certificate cannot be used.
    /// This member is required.
    public var status: IAMClientTypes.StatusType?
    /// The name of the IAM user the signing certificate belongs to. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init (
        certificateId: Swift.String? = nil,
        status: IAMClientTypes.StatusType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
        self.status = status
        self.userName = userName
    }
}

struct UpdateSigningCertificateInputBody: Swift.Equatable {
    let userName: Swift.String?
    let certificateId: Swift.String?
    let status: IAMClientTypes.StatusType?
}

extension UpdateSigningCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
        case status = "Status"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IAMClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateSigningCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateSigningCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSigningCertificateOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSigningCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSigningCertificateOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateUserInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let newPath = newPath {
            try container.encode(newPath, forKey: ClientRuntime.Key("NewPath"))
        }
        if let newUserName = newUserName {
            try container.encode(newUserName, forKey: ClientRuntime.Key("NewUserName"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UpdateUser", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// New path for the IAM user. Include this parameter only if you're changing the user's path. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters.
    public var newPath: Swift.String?
    /// New name for the user. Include this parameter only if you're changing the user's name. IAM user, group, role, and policy names must be unique within the account. Names are not distinguished by case. For example, you cannot create resources named both "MyResource" and "myresource".
    public var newUserName: Swift.String?
    /// Name of the user to update. If you're changing the name of the user, this is the original user name. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        newPath: Swift.String? = nil,
        newUserName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.newPath = newPath
        self.newUserName = newUserName
        self.userName = userName
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let newPath: Swift.String?
    let newUserName: Swift.String?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newPath = "NewPath"
        case newUserName = "NewUserName"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let newPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newPath)
        newPath = newPathDecoded
        let newUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newUserName)
        newUserName = newUserNameDecoded
    }
}

extension UpdateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityTemporarilyUnmodifiable" : self = .entityTemporarilyUnmodifiableException(try EntityTemporarilyUnmodifiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateUserOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityTemporarilyUnmodifiableException(EntityTemporarilyUnmodifiableException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserOutputResponse: Swift.Equatable {

    public init () { }
}

extension UploadSSHPublicKeyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sshPublicKeyBody = sshPublicKeyBody {
            try container.encode(sshPublicKeyBody, forKey: ClientRuntime.Key("SSHPublicKeyBody"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UploadSSHPublicKey", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UploadSSHPublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UploadSSHPublicKeyInput: Swift.Equatable {
    /// The SSH public key. The public key must be encoded in ssh-rsa format or PEM format. The minimum bit-length of the public key is 2048 bits. For example, you can generate a 2048-bit key, and the resulting PEM file is 1679 bytes long. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var sshPublicKeyBody: Swift.String?
    /// The name of the IAM user to associate the SSH public key with. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var userName: Swift.String?

    public init (
        sshPublicKeyBody: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.sshPublicKeyBody = sshPublicKeyBody
        self.userName = userName
    }
}

struct UploadSSHPublicKeyInputBody: Swift.Equatable {
    let userName: Swift.String?
    let sshPublicKeyBody: Swift.String?
}

extension UploadSSHPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKeyBody = "SSHPublicKeyBody"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
    }
}

extension UploadSSHPublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UploadSSHPublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateSSHPublicKey" : self = .duplicateSSHPublicKeyException(try DuplicateSSHPublicKeyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPublicKey" : self = .invalidPublicKeyException(try InvalidPublicKeyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnrecognizedPublicKeyEncoding" : self = .unrecognizedPublicKeyEncodingException(try UnrecognizedPublicKeyEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UploadSSHPublicKeyOutputError: Swift.Error, Swift.Equatable {
    case duplicateSSHPublicKeyException(DuplicateSSHPublicKeyException)
    case invalidPublicKeyException(InvalidPublicKeyException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case unrecognizedPublicKeyEncodingException(UnrecognizedPublicKeyEncodingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadSSHPublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UploadSSHPublicKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sshPublicKey = output.sshPublicKey
        } else {
            self.sshPublicKey = nil
        }
    }
}

/// Contains the response to a successful [UploadSSHPublicKey] request.
public struct UploadSSHPublicKeyOutputResponse: Swift.Equatable {
    /// Contains information about the SSH public key.
    public var sshPublicKey: IAMClientTypes.SSHPublicKey?

    public init (
        sshPublicKey: IAMClientTypes.SSHPublicKey? = nil
    )
    {
        self.sshPublicKey = sshPublicKey
    }
}

struct UploadSSHPublicKeyOutputResponseBody: Swift.Equatable {
    let sshPublicKey: IAMClientTypes.SSHPublicKey?
}

extension UploadSSHPublicKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKey = "SSHPublicKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UploadSSHPublicKeyResult"))
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(IAMClientTypes.SSHPublicKey.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension UploadServerCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadServerCertificateInput(certificateBody: \(Swift.String(describing: certificateBody)), certificateChain: \(Swift.String(describing: certificateChain)), path: \(Swift.String(describing: path)), serverCertificateName: \(Swift.String(describing: serverCertificateName)), tags: \(Swift.String(describing: tags)), privateKey: \"CONTENT_REDACTED\")"}
}

extension UploadServerCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: ClientRuntime.Key("CertificateBody"))
        }
        if let certificateChain = certificateChain {
            try container.encode(certificateChain, forKey: ClientRuntime.Key("CertificateChain"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let privateKey = privateKey {
            try container.encode(privateKey, forKey: ClientRuntime.Key("PrivateKey"))
        }
        if let serverCertificateName = serverCertificateName {
            try container.encode(serverCertificateName, forKey: ClientRuntime.Key("ServerCertificateName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UploadServerCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UploadServerCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UploadServerCertificateInput: Swift.Equatable {
    /// The contents of the public key certificate in PEM-encoded format. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var certificateBody: Swift.String?
    /// The contents of the certificate chain. This is typically a concatenation of the PEM-encoded public key certificates of the chain. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    public var certificateChain: Swift.String?
    /// The path for the server certificate. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character (\u007F), including most punctuation characters, digits, and upper and lowercased letters. If you are uploading a server certificate specifically for use with Amazon CloudFront distributions, you must specify a path using the path parameter. The path must begin with /cloudfront and must include a trailing slash (for example, /cloudfront/test/).
    public var path: Swift.String?
    /// The contents of the private key in PEM-encoded format. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var privateKey: Swift.String?
    /// The name for the server certificate. Do not include the path in this value. The name of the certificate cannot contain any spaces. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    /// This member is required.
    public var serverCertificateName: Swift.String?
    /// A list of tags that you want to attach to the new IAM server certificate resource. Each tag consists of a key name and an associated value. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide. If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        certificateBody: Swift.String? = nil,
        certificateChain: Swift.String? = nil,
        path: Swift.String? = nil,
        privateKey: Swift.String? = nil,
        serverCertificateName: Swift.String? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.certificateBody = certificateBody
        self.certificateChain = certificateChain
        self.path = path
        self.privateKey = privateKey
        self.serverCertificateName = serverCertificateName
        self.tags = tags
    }
}

struct UploadServerCertificateInputBody: Swift.Equatable {
    let path: Swift.String?
    let serverCertificateName: Swift.String?
    let certificateBody: Swift.String?
    let privateKey: Swift.String?
    let certificateChain: Swift.String?
    let tags: [IAMClientTypes.Tag]?
}

extension UploadServerCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBody = "CertificateBody"
        case certificateChain = "CertificateChain"
        case path = "Path"
        case privateKey = "PrivateKey"
        case serverCertificateName = "ServerCertificateName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let serverCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateName)
        serverCertificateName = serverCertificateNameDecoded
        let certificateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateBody)
        certificateBody = certificateBodyDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension UploadServerCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UploadServerCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModification" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyPairMismatch" : self = .keyPairMismatchException(try KeyPairMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedCertificate" : self = .malformedCertificateException(try MalformedCertificateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UploadServerCertificateOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidInputException(InvalidInputException)
    case keyPairMismatchException(KeyPairMismatchException)
    case limitExceededException(LimitExceededException)
    case malformedCertificateException(MalformedCertificateException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadServerCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UploadServerCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverCertificateMetadata = output.serverCertificateMetadata
            self.tags = output.tags
        } else {
            self.serverCertificateMetadata = nil
            self.tags = nil
        }
    }
}

/// Contains the response to a successful [UploadServerCertificate] request.
public struct UploadServerCertificateOutputResponse: Swift.Equatable {
    /// The meta information of the uploaded server certificate without its certificate body, certificate chain, and private key.
    public var serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata?
    /// A list of tags that are attached to the new IAM server certificate. The returned list of tags is sorted by tag key. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
    public var tags: [IAMClientTypes.Tag]?

    public init (
        serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata? = nil,
        tags: [IAMClientTypes.Tag]? = nil
    )
    {
        self.serverCertificateMetadata = serverCertificateMetadata
        self.tags = tags
    }
}

struct UploadServerCertificateOutputResponseBody: Swift.Equatable {
    let serverCertificateMetadata: IAMClientTypes.ServerCertificateMetadata?
    let tags: [IAMClientTypes.Tag]?
}

extension UploadServerCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificateMetadata = "ServerCertificateMetadata"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UploadServerCertificateResult"))
        let serverCertificateMetadataDecoded = try containerValues.decodeIfPresent(IAMClientTypes.ServerCertificateMetadata.self, forKey: .serverCertificateMetadata)
        serverCertificateMetadata = serverCertificateMetadataDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension UploadSigningCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateBody = certificateBody {
            try container.encode(certificateBody, forKey: ClientRuntime.Key("CertificateBody"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        try container.encode("UploadSigningCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-05-08", forKey:ClientRuntime.Key("Version"))
    }
}

extension UploadSigningCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UploadSigningCertificateInput: Swift.Equatable {
    /// The contents of the signing certificate. The [regex pattern](http://wikipedia.org/wiki/regex) used to validate this parameter is a string of characters consisting of the following:
    ///
    /// * Any printable ASCII character ranging from the space character (\u0020) through the end of the ASCII character range
    ///
    /// * The printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
    ///
    /// * The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D)
    /// This member is required.
    public var certificateBody: Swift.String?
    /// The name of the user the signing certificate is for. This parameter allows (through its [regex pattern](http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
    public var userName: Swift.String?

    public init (
        certificateBody: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.certificateBody = certificateBody
        self.userName = userName
    }
}

struct UploadSigningCertificateInputBody: Swift.Equatable {
    let userName: Swift.String?
    let certificateBody: Swift.String?
}

extension UploadSigningCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBody = "CertificateBody"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let certificateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateBody)
        certificateBody = certificateBodyDecoded
    }
}

extension UploadSigningCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UploadSigningCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateCertificate" : self = .duplicateCertificateException(try DuplicateCertificateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExists" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCertificate" : self = .invalidCertificateException(try InvalidCertificateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedCertificate" : self = .malformedCertificateException(try MalformedCertificateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntity" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailure" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UploadSigningCertificateOutputError: Swift.Error, Swift.Equatable {
    case duplicateCertificateException(DuplicateCertificateException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case invalidCertificateException(InvalidCertificateException)
    case limitExceededException(LimitExceededException)
    case malformedCertificateException(MalformedCertificateException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadSigningCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UploadSigningCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

/// Contains the response to a successful [UploadSigningCertificate] request.
public struct UploadSigningCertificateOutputResponse: Swift.Equatable {
    /// Information about the certificate.
    /// This member is required.
    public var certificate: IAMClientTypes.SigningCertificate?

    public init (
        certificate: IAMClientTypes.SigningCertificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct UploadSigningCertificateOutputResponseBody: Swift.Equatable {
    let certificate: IAMClientTypes.SigningCertificate?
}

extension UploadSigningCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UploadSigningCertificateResult"))
        let certificateDecoded = try containerValues.decodeIfPresent(IAMClientTypes.SigningCertificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension IAMClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case passwordLastUsed = "PasswordLastUsed"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case tags = "Tags"
        case userId = "UserId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if let passwordLastUsed = passwordLastUsed {
            try container.encodeTimestamp(passwordLastUsed, format: .dateTime, forKey: ClientRuntime.Key("passwordLastUsed"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userId = userId {
            try container.encode(userId, forKey: ClientRuntime.Key("UserId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        let passwordLastUsedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .passwordLastUsed)
        passwordLastUsed = passwordLastUsedDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AttachedPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM user entity. This data type is used as a response element in the following operations:
    ///
    /// * [CreateUser]
    ///
    /// * [GetUser]
    ///
    /// * [ListUsers]
    public struct User: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the user was created.
        /// This member is required.
        public var createDate: ClientRuntime.Date?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the user's password was last used to sign in to an Amazon Web Services website. For a list of Amazon Web Services websites that capture a user's last sign-in time, see the [Credential reports](https://docs.aws.amazon.com/IAM/latest/UserGuide/credential-reports.html) topic in the IAM User Guide. If a password is used more than once in a five-minute span, only the first use is returned in this field. If the field is null (no value), then it indicates that they never signed in with a password. This can be because:
        ///
        /// * The user never had a password.
        ///
        /// * A password exists but has not been used since IAM started tracking this information on October 20, 2014.
        ///
        ///
        /// A null value does not mean that the user never had a password. Also, if the user does not currently have a password but had one in the past, then this field contains the date and time the most recent password was used. This value is returned only in the [GetUser] and [ListUsers] operations.
        public var passwordLastUsed: ClientRuntime.Date?
        /// The path to the user. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide. The ARN of the policy used to set the permissions boundary for the user.
        /// This member is required.
        public var path: Swift.String?
        /// For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// A list of tags that are associated with the user. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The stable and unique string identifying the user. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var userId: Swift.String?
        /// The friendly name identifying the user.
        /// This member is required.
        public var userName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            passwordLastUsed: ClientRuntime.Date? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            userId: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.passwordLastUsed = passwordLastUsed
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.tags = tags
            self.userId = userId
            self.userName = userName
        }
    }

}

extension IAMClientTypes.UserDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case groupList = "GroupList"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case tags = "Tags"
        case userId = "UserId"
        case userName = "UserName"
        case userPolicyList = "UserPolicyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let attachedManagedPolicies = attachedManagedPolicies {
            if !attachedManagedPolicies.isEmpty {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                for (index0, attachedpolicy0) in attachedManagedPolicies.enumerated() {
                    try attachedManagedPoliciesContainer.encode(attachedpolicy0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var attachedManagedPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttachedManagedPolicies"))
                try attachedManagedPoliciesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let createDate = createDate {
            try container.encodeTimestamp(createDate, format: .dateTime, forKey: ClientRuntime.Key("createDate"))
        }
        if let groupList = groupList {
            if !groupList.isEmpty {
                var groupListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupList"))
                for (index0, groupnametype0) in groupList.enumerated() {
                    try groupListContainer.encode(groupnametype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var groupListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupList"))
                try groupListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let permissionsBoundary = permissionsBoundary {
            try container.encode(permissionsBoundary, forKey: ClientRuntime.Key("PermissionsBoundary"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userId = userId {
            try container.encode(userId, forKey: ClientRuntime.Key("UserId"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
        if let userPolicyList = userPolicyList {
            if !userPolicyList.isEmpty {
                var userPolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("UserPolicyList"))
                for (index0, policydetail0) in userPolicyList.enumerated() {
                    try userPolicyListContainer.encode(policydetail0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var userPolicyListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("UserPolicyList"))
                try userPolicyListContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDate)
        createDate = createDateDecoded
        if containerValues.contains(.userPolicyList) {
            struct KeyVal0{struct member{}}
            let userPolicyListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .userPolicyList)
            if let userPolicyListWrappedContainer = userPolicyListWrappedContainer {
                let userPolicyListContainer = try userPolicyListWrappedContainer.decodeIfPresent([IAMClientTypes.PolicyDetail].self, forKey: .member)
                var userPolicyListBuffer:[IAMClientTypes.PolicyDetail]? = nil
                if let userPolicyListContainer = userPolicyListContainer {
                    userPolicyListBuffer = [IAMClientTypes.PolicyDetail]()
                    for structureContainer0 in userPolicyListContainer {
                        userPolicyListBuffer?.append(structureContainer0)
                    }
                }
                userPolicyList = userPolicyListBuffer
            } else {
                userPolicyList = []
            }
        } else {
            userPolicyList = nil
        }
        if containerValues.contains(.groupList) {
            struct KeyVal0{struct member{}}
            let groupListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groupList)
            if let groupListWrappedContainer = groupListWrappedContainer {
                let groupListContainer = try groupListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var groupListBuffer:[Swift.String]? = nil
                if let groupListContainer = groupListContainer {
                    groupListBuffer = [Swift.String]()
                    for stringContainer0 in groupListContainer {
                        groupListBuffer?.append(stringContainer0)
                    }
                }
                groupList = groupListBuffer
            } else {
                groupList = []
            }
        } else {
            groupList = nil
        }
        if containerValues.contains(.attachedManagedPolicies) {
            struct KeyVal0{struct member{}}
            let attachedManagedPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attachedManagedPolicies)
            if let attachedManagedPoliciesWrappedContainer = attachedManagedPoliciesWrappedContainer {
                let attachedManagedPoliciesContainer = try attachedManagedPoliciesWrappedContainer.decodeIfPresent([IAMClientTypes.AttachedPolicy].self, forKey: .member)
                var attachedManagedPoliciesBuffer:[IAMClientTypes.AttachedPolicy]? = nil
                if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
                    attachedManagedPoliciesBuffer = [IAMClientTypes.AttachedPolicy]()
                    for structureContainer0 in attachedManagedPoliciesContainer {
                        attachedManagedPoliciesBuffer?.append(structureContainer0)
                    }
                }
                attachedManagedPolicies = attachedManagedPoliciesBuffer
            } else {
                attachedManagedPolicies = []
            }
        } else {
            attachedManagedPolicies = nil
        }
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(IAMClientTypes.AttachedPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension IAMClientTypes {
    /// Contains information about an IAM user, including all the user's policies and all the IAM groups the user is in. This data type is used as a response element in the [GetAccountAuthorizationDetails] operation.
    public struct UserDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN). ARNs are unique identifiers for Amazon Web Services resources. For more information about ARNs, go to [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// A list of the managed policies attached to the user.
        public var attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]?
        /// The date and time, in [ISO 8601 date-time format](http://www.iso.org/iso/iso8601), when the user was created.
        public var createDate: ClientRuntime.Date?
        /// A list of IAM groups that the user is in.
        public var groupList: [Swift.String]?
        /// The path to the user. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var path: Swift.String?
        /// The ARN of the policy used to set the permissions boundary for the user. For more information about permissions boundaries, see [Permissions boundaries for IAM identities ](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide.
        public var permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary?
        /// A list of tags that are associated with the user. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The stable and unique string identifying the user. For more information about IDs, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the IAM User Guide.
        public var userId: Swift.String?
        /// The friendly name identifying the user.
        public var userName: Swift.String?
        /// A list of the inline policies embedded in the user.
        public var userPolicyList: [IAMClientTypes.PolicyDetail]?

        public init (
            arn: Swift.String? = nil,
            attachedManagedPolicies: [IAMClientTypes.AttachedPolicy]? = nil,
            createDate: ClientRuntime.Date? = nil,
            groupList: [Swift.String]? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: IAMClientTypes.AttachedPermissionsBoundary? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            userId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userPolicyList: [IAMClientTypes.PolicyDetail]? = nil
        )
        {
            self.arn = arn
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupList = groupList
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.tags = tags
            self.userId = userId
            self.userName = userName
            self.userPolicyList = userPolicyList
        }
    }

}

extension IAMClientTypes.VirtualMFADevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base32StringSeed = "Base32StringSeed"
        case enableDate = "EnableDate"
        case qrCodePNG = "QRCodePNG"
        case serialNumber = "SerialNumber"
        case tags = "Tags"
        case user = "User"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let base32StringSeed = base32StringSeed {
            try container.encode(base32StringSeed.base64EncodedString(), forKey: ClientRuntime.Key("Base32StringSeed"))
        }
        if let enableDate = enableDate {
            try container.encodeTimestamp(enableDate, format: .dateTime, forKey: ClientRuntime.Key("enableDate"))
        }
        if let qrCodePNG = qrCodePNG {
            try container.encode(qrCodePNG.base64EncodedString(), forKey: ClientRuntime.Key("QRCodePNG"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let user = user {
            try container.encode(user, forKey: ClientRuntime.Key("User"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        if containerValues.contains(.base32StringSeed) {
            do {
                let base32StringSeedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .base32StringSeed)
                base32StringSeed = base32StringSeedDecoded
            } catch {
                base32StringSeed = "".data(using: .utf8)
            }
        } else {
            base32StringSeed = nil
        }
        if containerValues.contains(.qrCodePNG) {
            do {
                let qrCodePNGDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .qrCodePNG)
                qrCodePNG = qrCodePNGDecoded
            } catch {
                qrCodePNG = "".data(using: .utf8)
            }
        } else {
            qrCodePNG = nil
        }
        let userDecoded = try containerValues.decodeIfPresent(IAMClientTypes.User.self, forKey: .user)
        user = userDecoded
        let enableDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .enableDate)
        enableDate = enableDateDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([IAMClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[IAMClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [IAMClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension IAMClientTypes.VirtualMFADevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VirtualMFADevice(enableDate: \(Swift.String(describing: enableDate)), serialNumber: \(Swift.String(describing: serialNumber)), tags: \(Swift.String(describing: tags)), user: \(Swift.String(describing: user)), base32StringSeed: \"CONTENT_REDACTED\", qrCodePNG: \"CONTENT_REDACTED\")"}
}

extension IAMClientTypes {
    /// Contains information about a virtual MFA device.
    public struct VirtualMFADevice: Swift.Equatable {
        /// The base32 seed defined as specified in [RFC3548](https://tools.ietf.org/html/rfc3548.txt). The Base32StringSeed is base64-encoded.
        public var base32StringSeed: ClientRuntime.Data?
        /// The date and time on which the virtual MFA device was enabled.
        public var enableDate: ClientRuntime.Date?
        /// A QR code PNG image that encodes otpauth://totp/$virtualMFADeviceName@$AccountName?secret=$Base32String where $virtualMFADeviceName is one of the create call arguments. AccountName is the user name if set (otherwise, the account ID otherwise), and Base32String is the seed in base32 format. The Base32String value is base64-encoded.
        public var qrCodePNG: ClientRuntime.Data?
        /// The serial number associated with VirtualMFADevice.
        /// This member is required.
        public var serialNumber: Swift.String?
        /// A list of tags that are attached to the virtual MFA device. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the IAM User Guide.
        public var tags: [IAMClientTypes.Tag]?
        /// The IAM user associated with this virtual MFA device.
        public var user: IAMClientTypes.User?

        public init (
            base32StringSeed: ClientRuntime.Data? = nil,
            enableDate: ClientRuntime.Date? = nil,
            qrCodePNG: ClientRuntime.Data? = nil,
            serialNumber: Swift.String? = nil,
            tags: [IAMClientTypes.Tag]? = nil,
            user: IAMClientTypes.User? = nil
        )
        {
            self.base32StringSeed = base32StringSeed
            self.enableDate = enableDate
            self.qrCodePNG = qrCodePNG
            self.serialNumber = serialNumber
            self.tags = tags
            self.user = user
        }
    }

}
