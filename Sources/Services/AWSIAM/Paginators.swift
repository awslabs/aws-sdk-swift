// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension IAMClient {
    /// Paginate over `[GetAccountAuthorizationDetailsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetAccountAuthorizationDetailsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetAccountAuthorizationDetailsOutput`
    public func getAccountAuthorizationDetailsPaginated(input: GetAccountAuthorizationDetailsInput) -> ClientRuntime.PaginatorSequence<GetAccountAuthorizationDetailsInput, GetAccountAuthorizationDetailsOutput> {
        return ClientRuntime.PaginatorSequence<GetAccountAuthorizationDetailsInput, GetAccountAuthorizationDetailsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.getAccountAuthorizationDetails(input:))
    }
}

extension GetAccountAuthorizationDetailsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetAccountAuthorizationDetailsInput {
        return GetAccountAuthorizationDetailsInput(
            filter: self.filter,
            marker: token,
            maxItems: self.maxItems
        )}
}
extension IAMClient {
    /// Paginate over `[GetGroupOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetGroupInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetGroupOutput`
    public func getGroupPaginated(input: GetGroupInput) -> ClientRuntime.PaginatorSequence<GetGroupInput, GetGroupOutput> {
        return ClientRuntime.PaginatorSequence<GetGroupInput, GetGroupOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.getGroup(input:))
    }
}

extension GetGroupInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetGroupInput {
        return GetGroupInput(
            groupName: self.groupName,
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == GetGroupInput, OperationStackOutput == GetGroupOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getGroupPaginated`
    /// to access the nested member `[IAMClientTypes.User]`
    /// - Returns: `[IAMClientTypes.User]`
    public func users() async throws -> [IAMClientTypes.User] {
        return try await self.asyncCompactMap { item in item.users }
    }
}
extension IAMClient {
    /// Paginate over `[ListAccessKeysOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAccessKeysInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAccessKeysOutput`
    public func listAccessKeysPaginated(input: ListAccessKeysInput) -> ClientRuntime.PaginatorSequence<ListAccessKeysInput, ListAccessKeysOutput> {
        return ClientRuntime.PaginatorSequence<ListAccessKeysInput, ListAccessKeysOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listAccessKeys(input:))
    }
}

extension ListAccessKeysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAccessKeysInput {
        return ListAccessKeysInput(
            marker: token,
            maxItems: self.maxItems,
            userName: self.userName
        )}
}

extension PaginatorSequence where OperationStackInput == ListAccessKeysInput, OperationStackOutput == ListAccessKeysOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAccessKeysPaginated`
    /// to access the nested member `[IAMClientTypes.AccessKeyMetadata]`
    /// - Returns: `[IAMClientTypes.AccessKeyMetadata]`
    public func accessKeyMetadata() async throws -> [IAMClientTypes.AccessKeyMetadata] {
        return try await self.asyncCompactMap { item in item.accessKeyMetadata }
    }
}
extension IAMClient {
    /// Paginate over `[ListAccountAliasesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAccountAliasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAccountAliasesOutput`
    public func listAccountAliasesPaginated(input: ListAccountAliasesInput) -> ClientRuntime.PaginatorSequence<ListAccountAliasesInput, ListAccountAliasesOutput> {
        return ClientRuntime.PaginatorSequence<ListAccountAliasesInput, ListAccountAliasesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listAccountAliases(input:))
    }
}

extension ListAccountAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAccountAliasesInput {
        return ListAccountAliasesInput(
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListAccountAliasesInput, OperationStackOutput == ListAccountAliasesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAccountAliasesPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func accountAliases() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.accountAliases }
    }
}
extension IAMClient {
    /// Paginate over `[ListAttachedGroupPoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAttachedGroupPoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAttachedGroupPoliciesOutput`
    public func listAttachedGroupPoliciesPaginated(input: ListAttachedGroupPoliciesInput) -> ClientRuntime.PaginatorSequence<ListAttachedGroupPoliciesInput, ListAttachedGroupPoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListAttachedGroupPoliciesInput, ListAttachedGroupPoliciesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listAttachedGroupPolicies(input:))
    }
}

extension ListAttachedGroupPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAttachedGroupPoliciesInput {
        return ListAttachedGroupPoliciesInput(
            groupName: self.groupName,
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix
        )}
}

extension PaginatorSequence where OperationStackInput == ListAttachedGroupPoliciesInput, OperationStackOutput == ListAttachedGroupPoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAttachedGroupPoliciesPaginated`
    /// to access the nested member `[IAMClientTypes.AttachedPolicy]`
    /// - Returns: `[IAMClientTypes.AttachedPolicy]`
    public func attachedPolicies() async throws -> [IAMClientTypes.AttachedPolicy] {
        return try await self.asyncCompactMap { item in item.attachedPolicies }
    }
}
extension IAMClient {
    /// Paginate over `[ListAttachedRolePoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAttachedRolePoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAttachedRolePoliciesOutput`
    public func listAttachedRolePoliciesPaginated(input: ListAttachedRolePoliciesInput) -> ClientRuntime.PaginatorSequence<ListAttachedRolePoliciesInput, ListAttachedRolePoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListAttachedRolePoliciesInput, ListAttachedRolePoliciesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listAttachedRolePolicies(input:))
    }
}

extension ListAttachedRolePoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAttachedRolePoliciesInput {
        return ListAttachedRolePoliciesInput(
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix,
            roleName: self.roleName
        )}
}

extension PaginatorSequence where OperationStackInput == ListAttachedRolePoliciesInput, OperationStackOutput == ListAttachedRolePoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAttachedRolePoliciesPaginated`
    /// to access the nested member `[IAMClientTypes.AttachedPolicy]`
    /// - Returns: `[IAMClientTypes.AttachedPolicy]`
    public func attachedPolicies() async throws -> [IAMClientTypes.AttachedPolicy] {
        return try await self.asyncCompactMap { item in item.attachedPolicies }
    }
}
extension IAMClient {
    /// Paginate over `[ListAttachedUserPoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAttachedUserPoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAttachedUserPoliciesOutput`
    public func listAttachedUserPoliciesPaginated(input: ListAttachedUserPoliciesInput) -> ClientRuntime.PaginatorSequence<ListAttachedUserPoliciesInput, ListAttachedUserPoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListAttachedUserPoliciesInput, ListAttachedUserPoliciesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listAttachedUserPolicies(input:))
    }
}

extension ListAttachedUserPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAttachedUserPoliciesInput {
        return ListAttachedUserPoliciesInput(
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix,
            userName: self.userName
        )}
}

extension PaginatorSequence where OperationStackInput == ListAttachedUserPoliciesInput, OperationStackOutput == ListAttachedUserPoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAttachedUserPoliciesPaginated`
    /// to access the nested member `[IAMClientTypes.AttachedPolicy]`
    /// - Returns: `[IAMClientTypes.AttachedPolicy]`
    public func attachedPolicies() async throws -> [IAMClientTypes.AttachedPolicy] {
        return try await self.asyncCompactMap { item in item.attachedPolicies }
    }
}
extension IAMClient {
    /// Paginate over `[ListEntitiesForPolicyOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEntitiesForPolicyInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEntitiesForPolicyOutput`
    public func listEntitiesForPolicyPaginated(input: ListEntitiesForPolicyInput) -> ClientRuntime.PaginatorSequence<ListEntitiesForPolicyInput, ListEntitiesForPolicyOutput> {
        return ClientRuntime.PaginatorSequence<ListEntitiesForPolicyInput, ListEntitiesForPolicyOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listEntitiesForPolicy(input:))
    }
}

extension ListEntitiesForPolicyInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEntitiesForPolicyInput {
        return ListEntitiesForPolicyInput(
            entityFilter: self.entityFilter,
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix,
            policyArn: self.policyArn,
            policyUsageFilter: self.policyUsageFilter
        )}
}
extension IAMClient {
    /// Paginate over `[ListGroupPoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGroupPoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGroupPoliciesOutput`
    public func listGroupPoliciesPaginated(input: ListGroupPoliciesInput) -> ClientRuntime.PaginatorSequence<ListGroupPoliciesInput, ListGroupPoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListGroupPoliciesInput, ListGroupPoliciesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listGroupPolicies(input:))
    }
}

extension ListGroupPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGroupPoliciesInput {
        return ListGroupPoliciesInput(
            groupName: self.groupName,
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListGroupPoliciesInput, OperationStackOutput == ListGroupPoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listGroupPoliciesPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func policyNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.policyNames }
    }
}
extension IAMClient {
    /// Paginate over `[ListGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGroupsOutput`
    public func listGroupsPaginated(input: ListGroupsInput) -> ClientRuntime.PaginatorSequence<ListGroupsInput, ListGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListGroupsInput, ListGroupsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listGroups(input:))
    }
}

extension ListGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGroupsInput {
        return ListGroupsInput(
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix
        )}
}

extension PaginatorSequence where OperationStackInput == ListGroupsInput, OperationStackOutput == ListGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listGroupsPaginated`
    /// to access the nested member `[IAMClientTypes.Group]`
    /// - Returns: `[IAMClientTypes.Group]`
    public func groups() async throws -> [IAMClientTypes.Group] {
        return try await self.asyncCompactMap { item in item.groups }
    }
}
extension IAMClient {
    /// Paginate over `[ListGroupsForUserOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGroupsForUserInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGroupsForUserOutput`
    public func listGroupsForUserPaginated(input: ListGroupsForUserInput) -> ClientRuntime.PaginatorSequence<ListGroupsForUserInput, ListGroupsForUserOutput> {
        return ClientRuntime.PaginatorSequence<ListGroupsForUserInput, ListGroupsForUserOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listGroupsForUser(input:))
    }
}

extension ListGroupsForUserInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGroupsForUserInput {
        return ListGroupsForUserInput(
            marker: token,
            maxItems: self.maxItems,
            userName: self.userName
        )}
}

extension PaginatorSequence where OperationStackInput == ListGroupsForUserInput, OperationStackOutput == ListGroupsForUserOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listGroupsForUserPaginated`
    /// to access the nested member `[IAMClientTypes.Group]`
    /// - Returns: `[IAMClientTypes.Group]`
    public func groups() async throws -> [IAMClientTypes.Group] {
        return try await self.asyncCompactMap { item in item.groups }
    }
}
extension IAMClient {
    /// Paginate over `[ListInstanceProfilesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInstanceProfilesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInstanceProfilesOutput`
    public func listInstanceProfilesPaginated(input: ListInstanceProfilesInput) -> ClientRuntime.PaginatorSequence<ListInstanceProfilesInput, ListInstanceProfilesOutput> {
        return ClientRuntime.PaginatorSequence<ListInstanceProfilesInput, ListInstanceProfilesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listInstanceProfiles(input:))
    }
}

extension ListInstanceProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstanceProfilesInput {
        return ListInstanceProfilesInput(
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix
        )}
}

extension PaginatorSequence where OperationStackInput == ListInstanceProfilesInput, OperationStackOutput == ListInstanceProfilesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInstanceProfilesPaginated`
    /// to access the nested member `[IAMClientTypes.InstanceProfile]`
    /// - Returns: `[IAMClientTypes.InstanceProfile]`
    public func instanceProfiles() async throws -> [IAMClientTypes.InstanceProfile] {
        return try await self.asyncCompactMap { item in item.instanceProfiles }
    }
}
extension IAMClient {
    /// Paginate over `[ListInstanceProfilesForRoleOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInstanceProfilesForRoleInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInstanceProfilesForRoleOutput`
    public func listInstanceProfilesForRolePaginated(input: ListInstanceProfilesForRoleInput) -> ClientRuntime.PaginatorSequence<ListInstanceProfilesForRoleInput, ListInstanceProfilesForRoleOutput> {
        return ClientRuntime.PaginatorSequence<ListInstanceProfilesForRoleInput, ListInstanceProfilesForRoleOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listInstanceProfilesForRole(input:))
    }
}

extension ListInstanceProfilesForRoleInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstanceProfilesForRoleInput {
        return ListInstanceProfilesForRoleInput(
            marker: token,
            maxItems: self.maxItems,
            roleName: self.roleName
        )}
}

extension PaginatorSequence where OperationStackInput == ListInstanceProfilesForRoleInput, OperationStackOutput == ListInstanceProfilesForRoleOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInstanceProfilesForRolePaginated`
    /// to access the nested member `[IAMClientTypes.InstanceProfile]`
    /// - Returns: `[IAMClientTypes.InstanceProfile]`
    public func instanceProfiles() async throws -> [IAMClientTypes.InstanceProfile] {
        return try await self.asyncCompactMap { item in item.instanceProfiles }
    }
}
extension IAMClient {
    /// Paginate over `[ListInstanceProfileTagsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInstanceProfileTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInstanceProfileTagsOutput`
    public func listInstanceProfileTagsPaginated(input: ListInstanceProfileTagsInput) -> ClientRuntime.PaginatorSequence<ListInstanceProfileTagsInput, ListInstanceProfileTagsOutput> {
        return ClientRuntime.PaginatorSequence<ListInstanceProfileTagsInput, ListInstanceProfileTagsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listInstanceProfileTags(input:))
    }
}

extension ListInstanceProfileTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstanceProfileTagsInput {
        return ListInstanceProfileTagsInput(
            instanceProfileName: self.instanceProfileName,
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListInstanceProfileTagsInput, OperationStackOutput == ListInstanceProfileTagsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInstanceProfileTagsPaginated`
    /// to access the nested member `[IAMClientTypes.Tag]`
    /// - Returns: `[IAMClientTypes.Tag]`
    public func tags() async throws -> [IAMClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
extension IAMClient {
    /// Paginate over `[ListMFADevicesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMFADevicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMFADevicesOutput`
    public func listMFADevicesPaginated(input: ListMFADevicesInput) -> ClientRuntime.PaginatorSequence<ListMFADevicesInput, ListMFADevicesOutput> {
        return ClientRuntime.PaginatorSequence<ListMFADevicesInput, ListMFADevicesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listMFADevices(input:))
    }
}

extension ListMFADevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMFADevicesInput {
        return ListMFADevicesInput(
            marker: token,
            maxItems: self.maxItems,
            userName: self.userName
        )}
}

extension PaginatorSequence where OperationStackInput == ListMFADevicesInput, OperationStackOutput == ListMFADevicesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMFADevicesPaginated`
    /// to access the nested member `[IAMClientTypes.MFADevice]`
    /// - Returns: `[IAMClientTypes.MFADevice]`
    public func mfaDevices() async throws -> [IAMClientTypes.MFADevice] {
        return try await self.asyncCompactMap { item in item.mfaDevices }
    }
}
extension IAMClient {
    /// Paginate over `[ListMFADeviceTagsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMFADeviceTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMFADeviceTagsOutput`
    public func listMFADeviceTagsPaginated(input: ListMFADeviceTagsInput) -> ClientRuntime.PaginatorSequence<ListMFADeviceTagsInput, ListMFADeviceTagsOutput> {
        return ClientRuntime.PaginatorSequence<ListMFADeviceTagsInput, ListMFADeviceTagsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listMFADeviceTags(input:))
    }
}

extension ListMFADeviceTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMFADeviceTagsInput {
        return ListMFADeviceTagsInput(
            marker: token,
            maxItems: self.maxItems,
            serialNumber: self.serialNumber
        )}
}

extension PaginatorSequence where OperationStackInput == ListMFADeviceTagsInput, OperationStackOutput == ListMFADeviceTagsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMFADeviceTagsPaginated`
    /// to access the nested member `[IAMClientTypes.Tag]`
    /// - Returns: `[IAMClientTypes.Tag]`
    public func tags() async throws -> [IAMClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
extension IAMClient {
    /// Paginate over `[ListOpenIDConnectProviderTagsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOpenIDConnectProviderTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOpenIDConnectProviderTagsOutput`
    public func listOpenIDConnectProviderTagsPaginated(input: ListOpenIDConnectProviderTagsInput) -> ClientRuntime.PaginatorSequence<ListOpenIDConnectProviderTagsInput, ListOpenIDConnectProviderTagsOutput> {
        return ClientRuntime.PaginatorSequence<ListOpenIDConnectProviderTagsInput, ListOpenIDConnectProviderTagsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listOpenIDConnectProviderTags(input:))
    }
}

extension ListOpenIDConnectProviderTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOpenIDConnectProviderTagsInput {
        return ListOpenIDConnectProviderTagsInput(
            marker: token,
            maxItems: self.maxItems,
            openIDConnectProviderArn: self.openIDConnectProviderArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListOpenIDConnectProviderTagsInput, OperationStackOutput == ListOpenIDConnectProviderTagsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOpenIDConnectProviderTagsPaginated`
    /// to access the nested member `[IAMClientTypes.Tag]`
    /// - Returns: `[IAMClientTypes.Tag]`
    public func tags() async throws -> [IAMClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
extension IAMClient {
    /// Paginate over `[ListPoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPoliciesOutput`
    public func listPoliciesPaginated(input: ListPoliciesInput) -> ClientRuntime.PaginatorSequence<ListPoliciesInput, ListPoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListPoliciesInput, ListPoliciesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listPolicies(input:))
    }
}

extension ListPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPoliciesInput {
        return ListPoliciesInput(
            marker: token,
            maxItems: self.maxItems,
            onlyAttached: self.onlyAttached,
            pathPrefix: self.pathPrefix,
            policyUsageFilter: self.policyUsageFilter,
            scope: self.scope
        )}
}

extension PaginatorSequence where OperationStackInput == ListPoliciesInput, OperationStackOutput == ListPoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPoliciesPaginated`
    /// to access the nested member `[IAMClientTypes.Policy]`
    /// - Returns: `[IAMClientTypes.Policy]`
    public func policies() async throws -> [IAMClientTypes.Policy] {
        return try await self.asyncCompactMap { item in item.policies }
    }
}
extension IAMClient {
    /// Paginate over `[ListPolicyTagsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPolicyTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPolicyTagsOutput`
    public func listPolicyTagsPaginated(input: ListPolicyTagsInput) -> ClientRuntime.PaginatorSequence<ListPolicyTagsInput, ListPolicyTagsOutput> {
        return ClientRuntime.PaginatorSequence<ListPolicyTagsInput, ListPolicyTagsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listPolicyTags(input:))
    }
}

extension ListPolicyTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPolicyTagsInput {
        return ListPolicyTagsInput(
            marker: token,
            maxItems: self.maxItems,
            policyArn: self.policyArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListPolicyTagsInput, OperationStackOutput == ListPolicyTagsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPolicyTagsPaginated`
    /// to access the nested member `[IAMClientTypes.Tag]`
    /// - Returns: `[IAMClientTypes.Tag]`
    public func tags() async throws -> [IAMClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
extension IAMClient {
    /// Paginate over `[ListPolicyVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPolicyVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPolicyVersionsOutput`
    public func listPolicyVersionsPaginated(input: ListPolicyVersionsInput) -> ClientRuntime.PaginatorSequence<ListPolicyVersionsInput, ListPolicyVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListPolicyVersionsInput, ListPolicyVersionsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listPolicyVersions(input:))
    }
}

extension ListPolicyVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPolicyVersionsInput {
        return ListPolicyVersionsInput(
            marker: token,
            maxItems: self.maxItems,
            policyArn: self.policyArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListPolicyVersionsInput, OperationStackOutput == ListPolicyVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPolicyVersionsPaginated`
    /// to access the nested member `[IAMClientTypes.PolicyVersion]`
    /// - Returns: `[IAMClientTypes.PolicyVersion]`
    public func versions() async throws -> [IAMClientTypes.PolicyVersion] {
        return try await self.asyncCompactMap { item in item.versions }
    }
}
extension IAMClient {
    /// Paginate over `[ListRolePoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRolePoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRolePoliciesOutput`
    public func listRolePoliciesPaginated(input: ListRolePoliciesInput) -> ClientRuntime.PaginatorSequence<ListRolePoliciesInput, ListRolePoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListRolePoliciesInput, ListRolePoliciesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listRolePolicies(input:))
    }
}

extension ListRolePoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRolePoliciesInput {
        return ListRolePoliciesInput(
            marker: token,
            maxItems: self.maxItems,
            roleName: self.roleName
        )}
}

extension PaginatorSequence where OperationStackInput == ListRolePoliciesInput, OperationStackOutput == ListRolePoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRolePoliciesPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func policyNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.policyNames }
    }
}
extension IAMClient {
    /// Paginate over `[ListRolesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRolesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRolesOutput`
    public func listRolesPaginated(input: ListRolesInput) -> ClientRuntime.PaginatorSequence<ListRolesInput, ListRolesOutput> {
        return ClientRuntime.PaginatorSequence<ListRolesInput, ListRolesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listRoles(input:))
    }
}

extension ListRolesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRolesInput {
        return ListRolesInput(
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix
        )}
}

extension PaginatorSequence where OperationStackInput == ListRolesInput, OperationStackOutput == ListRolesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRolesPaginated`
    /// to access the nested member `[IAMClientTypes.Role]`
    /// - Returns: `[IAMClientTypes.Role]`
    public func roles() async throws -> [IAMClientTypes.Role] {
        return try await self.asyncCompactMap { item in item.roles }
    }
}
extension IAMClient {
    /// Paginate over `[ListRoleTagsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRoleTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRoleTagsOutput`
    public func listRoleTagsPaginated(input: ListRoleTagsInput) -> ClientRuntime.PaginatorSequence<ListRoleTagsInput, ListRoleTagsOutput> {
        return ClientRuntime.PaginatorSequence<ListRoleTagsInput, ListRoleTagsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listRoleTags(input:))
    }
}

extension ListRoleTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRoleTagsInput {
        return ListRoleTagsInput(
            marker: token,
            maxItems: self.maxItems,
            roleName: self.roleName
        )}
}

extension PaginatorSequence where OperationStackInput == ListRoleTagsInput, OperationStackOutput == ListRoleTagsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRoleTagsPaginated`
    /// to access the nested member `[IAMClientTypes.Tag]`
    /// - Returns: `[IAMClientTypes.Tag]`
    public func tags() async throws -> [IAMClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
extension IAMClient {
    /// Paginate over `[ListSAMLProviderTagsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSAMLProviderTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSAMLProviderTagsOutput`
    public func listSAMLProviderTagsPaginated(input: ListSAMLProviderTagsInput) -> ClientRuntime.PaginatorSequence<ListSAMLProviderTagsInput, ListSAMLProviderTagsOutput> {
        return ClientRuntime.PaginatorSequence<ListSAMLProviderTagsInput, ListSAMLProviderTagsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listSAMLProviderTags(input:))
    }
}

extension ListSAMLProviderTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSAMLProviderTagsInput {
        return ListSAMLProviderTagsInput(
            marker: token,
            maxItems: self.maxItems,
            samlProviderArn: self.samlProviderArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListSAMLProviderTagsInput, OperationStackOutput == ListSAMLProviderTagsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSAMLProviderTagsPaginated`
    /// to access the nested member `[IAMClientTypes.Tag]`
    /// - Returns: `[IAMClientTypes.Tag]`
    public func tags() async throws -> [IAMClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
extension IAMClient {
    /// Paginate over `[ListServerCertificatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListServerCertificatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListServerCertificatesOutput`
    public func listServerCertificatesPaginated(input: ListServerCertificatesInput) -> ClientRuntime.PaginatorSequence<ListServerCertificatesInput, ListServerCertificatesOutput> {
        return ClientRuntime.PaginatorSequence<ListServerCertificatesInput, ListServerCertificatesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listServerCertificates(input:))
    }
}

extension ListServerCertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListServerCertificatesInput {
        return ListServerCertificatesInput(
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix
        )}
}

extension PaginatorSequence where OperationStackInput == ListServerCertificatesInput, OperationStackOutput == ListServerCertificatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listServerCertificatesPaginated`
    /// to access the nested member `[IAMClientTypes.ServerCertificateMetadata]`
    /// - Returns: `[IAMClientTypes.ServerCertificateMetadata]`
    public func serverCertificateMetadataList() async throws -> [IAMClientTypes.ServerCertificateMetadata] {
        return try await self.asyncCompactMap { item in item.serverCertificateMetadataList }
    }
}
extension IAMClient {
    /// Paginate over `[ListServerCertificateTagsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListServerCertificateTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListServerCertificateTagsOutput`
    public func listServerCertificateTagsPaginated(input: ListServerCertificateTagsInput) -> ClientRuntime.PaginatorSequence<ListServerCertificateTagsInput, ListServerCertificateTagsOutput> {
        return ClientRuntime.PaginatorSequence<ListServerCertificateTagsInput, ListServerCertificateTagsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listServerCertificateTags(input:))
    }
}

extension ListServerCertificateTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListServerCertificateTagsInput {
        return ListServerCertificateTagsInput(
            marker: token,
            maxItems: self.maxItems,
            serverCertificateName: self.serverCertificateName
        )}
}

extension PaginatorSequence where OperationStackInput == ListServerCertificateTagsInput, OperationStackOutput == ListServerCertificateTagsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listServerCertificateTagsPaginated`
    /// to access the nested member `[IAMClientTypes.Tag]`
    /// - Returns: `[IAMClientTypes.Tag]`
    public func tags() async throws -> [IAMClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
extension IAMClient {
    /// Paginate over `[ListSigningCertificatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSigningCertificatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSigningCertificatesOutput`
    public func listSigningCertificatesPaginated(input: ListSigningCertificatesInput) -> ClientRuntime.PaginatorSequence<ListSigningCertificatesInput, ListSigningCertificatesOutput> {
        return ClientRuntime.PaginatorSequence<ListSigningCertificatesInput, ListSigningCertificatesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listSigningCertificates(input:))
    }
}

extension ListSigningCertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSigningCertificatesInput {
        return ListSigningCertificatesInput(
            marker: token,
            maxItems: self.maxItems,
            userName: self.userName
        )}
}

extension PaginatorSequence where OperationStackInput == ListSigningCertificatesInput, OperationStackOutput == ListSigningCertificatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSigningCertificatesPaginated`
    /// to access the nested member `[IAMClientTypes.SigningCertificate]`
    /// - Returns: `[IAMClientTypes.SigningCertificate]`
    public func certificates() async throws -> [IAMClientTypes.SigningCertificate] {
        return try await self.asyncCompactMap { item in item.certificates }
    }
}
extension IAMClient {
    /// Paginate over `[ListSSHPublicKeysOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSSHPublicKeysInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSSHPublicKeysOutput`
    public func listSSHPublicKeysPaginated(input: ListSSHPublicKeysInput) -> ClientRuntime.PaginatorSequence<ListSSHPublicKeysInput, ListSSHPublicKeysOutput> {
        return ClientRuntime.PaginatorSequence<ListSSHPublicKeysInput, ListSSHPublicKeysOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listSSHPublicKeys(input:))
    }
}

extension ListSSHPublicKeysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSSHPublicKeysInput {
        return ListSSHPublicKeysInput(
            marker: token,
            maxItems: self.maxItems,
            userName: self.userName
        )}
}

extension PaginatorSequence where OperationStackInput == ListSSHPublicKeysInput, OperationStackOutput == ListSSHPublicKeysOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSSHPublicKeysPaginated`
    /// to access the nested member `[IAMClientTypes.SSHPublicKeyMetadata]`
    /// - Returns: `[IAMClientTypes.SSHPublicKeyMetadata]`
    public func sshPublicKeys() async throws -> [IAMClientTypes.SSHPublicKeyMetadata] {
        return try await self.asyncCompactMap { item in item.sshPublicKeys }
    }
}
extension IAMClient {
    /// Paginate over `[ListUserPoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUserPoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUserPoliciesOutput`
    public func listUserPoliciesPaginated(input: ListUserPoliciesInput) -> ClientRuntime.PaginatorSequence<ListUserPoliciesInput, ListUserPoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListUserPoliciesInput, ListUserPoliciesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listUserPolicies(input:))
    }
}

extension ListUserPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUserPoliciesInput {
        return ListUserPoliciesInput(
            marker: token,
            maxItems: self.maxItems,
            userName: self.userName
        )}
}

extension PaginatorSequence where OperationStackInput == ListUserPoliciesInput, OperationStackOutput == ListUserPoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listUserPoliciesPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func policyNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.policyNames }
    }
}
extension IAMClient {
    /// Paginate over `[ListUsersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUsersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUsersOutput`
    public func listUsersPaginated(input: ListUsersInput) -> ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutput> {
        return ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listUsers(input:))
    }
}

extension ListUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUsersInput {
        return ListUsersInput(
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix
        )}
}

extension PaginatorSequence where OperationStackInput == ListUsersInput, OperationStackOutput == ListUsersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listUsersPaginated`
    /// to access the nested member `[IAMClientTypes.User]`
    /// - Returns: `[IAMClientTypes.User]`
    public func users() async throws -> [IAMClientTypes.User] {
        return try await self.asyncCompactMap { item in item.users }
    }
}
extension IAMClient {
    /// Paginate over `[ListUserTagsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUserTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUserTagsOutput`
    public func listUserTagsPaginated(input: ListUserTagsInput) -> ClientRuntime.PaginatorSequence<ListUserTagsInput, ListUserTagsOutput> {
        return ClientRuntime.PaginatorSequence<ListUserTagsInput, ListUserTagsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listUserTags(input:))
    }
}

extension ListUserTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUserTagsInput {
        return ListUserTagsInput(
            marker: token,
            maxItems: self.maxItems,
            userName: self.userName
        )}
}

extension PaginatorSequence where OperationStackInput == ListUserTagsInput, OperationStackOutput == ListUserTagsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listUserTagsPaginated`
    /// to access the nested member `[IAMClientTypes.Tag]`
    /// - Returns: `[IAMClientTypes.Tag]`
    public func tags() async throws -> [IAMClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
extension IAMClient {
    /// Paginate over `[ListVirtualMFADevicesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListVirtualMFADevicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListVirtualMFADevicesOutput`
    public func listVirtualMFADevicesPaginated(input: ListVirtualMFADevicesInput) -> ClientRuntime.PaginatorSequence<ListVirtualMFADevicesInput, ListVirtualMFADevicesOutput> {
        return ClientRuntime.PaginatorSequence<ListVirtualMFADevicesInput, ListVirtualMFADevicesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listVirtualMFADevices(input:))
    }
}

extension ListVirtualMFADevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListVirtualMFADevicesInput {
        return ListVirtualMFADevicesInput(
            assignmentStatus: self.assignmentStatus,
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListVirtualMFADevicesInput, OperationStackOutput == ListVirtualMFADevicesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listVirtualMFADevicesPaginated`
    /// to access the nested member `[IAMClientTypes.VirtualMFADevice]`
    /// - Returns: `[IAMClientTypes.VirtualMFADevice]`
    public func virtualMFADevices() async throws -> [IAMClientTypes.VirtualMFADevice] {
        return try await self.asyncCompactMap { item in item.virtualMFADevices }
    }
}
extension IAMClient {
    /// Paginate over `[SimulateCustomPolicyOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SimulateCustomPolicyInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SimulateCustomPolicyOutput`
    public func simulateCustomPolicyPaginated(input: SimulateCustomPolicyInput) -> ClientRuntime.PaginatorSequence<SimulateCustomPolicyInput, SimulateCustomPolicyOutput> {
        return ClientRuntime.PaginatorSequence<SimulateCustomPolicyInput, SimulateCustomPolicyOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.simulateCustomPolicy(input:))
    }
}

extension SimulateCustomPolicyInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SimulateCustomPolicyInput {
        return SimulateCustomPolicyInput(
            actionNames: self.actionNames,
            callerArn: self.callerArn,
            contextEntries: self.contextEntries,
            marker: token,
            maxItems: self.maxItems,
            permissionsBoundaryPolicyInputList: self.permissionsBoundaryPolicyInputList,
            policyInputList: self.policyInputList,
            resourceArns: self.resourceArns,
            resourceHandlingOption: self.resourceHandlingOption,
            resourceOwner: self.resourceOwner,
            resourcePolicy: self.resourcePolicy
        )}
}

extension PaginatorSequence where OperationStackInput == SimulateCustomPolicyInput, OperationStackOutput == SimulateCustomPolicyOutput {
    /// This paginator transforms the `AsyncSequence` returned by `simulateCustomPolicyPaginated`
    /// to access the nested member `[IAMClientTypes.EvaluationResult]`
    /// - Returns: `[IAMClientTypes.EvaluationResult]`
    public func evaluationResults() async throws -> [IAMClientTypes.EvaluationResult] {
        return try await self.asyncCompactMap { item in item.evaluationResults }
    }
}
extension IAMClient {
    /// Paginate over `[SimulatePrincipalPolicyOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SimulatePrincipalPolicyInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SimulatePrincipalPolicyOutput`
    public func simulatePrincipalPolicyPaginated(input: SimulatePrincipalPolicyInput) -> ClientRuntime.PaginatorSequence<SimulatePrincipalPolicyInput, SimulatePrincipalPolicyOutput> {
        return ClientRuntime.PaginatorSequence<SimulatePrincipalPolicyInput, SimulatePrincipalPolicyOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.simulatePrincipalPolicy(input:))
    }
}

extension SimulatePrincipalPolicyInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SimulatePrincipalPolicyInput {
        return SimulatePrincipalPolicyInput(
            actionNames: self.actionNames,
            callerArn: self.callerArn,
            contextEntries: self.contextEntries,
            marker: token,
            maxItems: self.maxItems,
            permissionsBoundaryPolicyInputList: self.permissionsBoundaryPolicyInputList,
            policyInputList: self.policyInputList,
            policySourceArn: self.policySourceArn,
            resourceArns: self.resourceArns,
            resourceHandlingOption: self.resourceHandlingOption,
            resourceOwner: self.resourceOwner,
            resourcePolicy: self.resourcePolicy
        )}
}

extension PaginatorSequence where OperationStackInput == SimulatePrincipalPolicyInput, OperationStackOutput == SimulatePrincipalPolicyOutput {
    /// This paginator transforms the `AsyncSequence` returned by `simulatePrincipalPolicyPaginated`
    /// to access the nested member `[IAMClientTypes.EvaluationResult]`
    /// - Returns: `[IAMClientTypes.EvaluationResult]`
    public func evaluationResults() async throws -> [IAMClientTypes.EvaluationResult] {
        return try await self.asyncCompactMap { item in item.evaluationResults }
    }
}
