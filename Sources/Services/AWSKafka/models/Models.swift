// Code generated by smithy-swift-codegen. DO NOT EDIT!
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension KafkaClientTypes.AmazonMskCluster {

    static func write(value: KafkaClientTypes.AmazonMskCluster?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mskClusterArn"].write(value.mskClusterArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.AmazonMskCluster {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.AmazonMskCluster()
        value.mskClusterArn = try reader["mskClusterArn"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Details of an Amazon MSK Cluster.
    public struct AmazonMskCluster {
        /// The Amazon Resource Name (ARN) of an Amazon MSK cluster.
        /// This member is required.
        public var mskClusterArn: Swift.String?

        public init(
            mskClusterArn: Swift.String? = nil
        )
        {
            self.mskClusterArn = mskClusterArn
        }
    }

}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.invalidParameter = try reader["invalidParameter"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Returns information about an error.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

extension BatchAssociateScramSecretInput {

    static func urlPathProvider(_ value: BatchAssociateScramSecretInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/scram-secrets"
    }
}

extension BatchAssociateScramSecretInput {

    static func write(value: BatchAssociateScramSecretInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["secretArnList"].writeList(value.secretArnList, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

/// Associates sasl scram secrets to cluster.
public struct BatchAssociateScramSecretInput {
    /// The Amazon Resource Name (ARN) of the cluster to be updated.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// List of AWS Secrets Manager secret ARNs.
    /// This member is required.
    public var secretArnList: [Swift.String]?

    public init(
        clusterArn: Swift.String? = nil,
        secretArnList: [Swift.String]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.secretArnList = secretArnList
    }
}

extension BatchAssociateScramSecretOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> BatchAssociateScramSecretOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchAssociateScramSecretOutput()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.unprocessedScramSecrets = try reader["unprocessedScramSecrets"].readListIfPresent(memberReadingClosure: KafkaClientTypes.UnprocessedScramSecret.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct BatchAssociateScramSecretOutput {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// List of errors when associating secrets to cluster.
    public var unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]?

    public init(
        clusterArn: Swift.String? = nil,
        unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.unprocessedScramSecrets = unprocessedScramSecrets
    }
}

enum BatchAssociateScramSecretOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BatchDisassociateScramSecretInput {

    static func urlPathProvider(_ value: BatchDisassociateScramSecretInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/scram-secrets"
    }
}

extension BatchDisassociateScramSecretInput {

    static func write(value: BatchDisassociateScramSecretInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["secretArnList"].writeList(value.secretArnList, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

/// Disassociates sasl scram secrets to cluster.
public struct BatchDisassociateScramSecretInput {
    /// The Amazon Resource Name (ARN) of the cluster to be updated.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// List of AWS Secrets Manager secret ARNs.
    /// This member is required.
    public var secretArnList: [Swift.String]?

    public init(
        clusterArn: Swift.String? = nil,
        secretArnList: [Swift.String]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.secretArnList = secretArnList
    }
}

extension BatchDisassociateScramSecretOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> BatchDisassociateScramSecretOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDisassociateScramSecretOutput()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.unprocessedScramSecrets = try reader["unprocessedScramSecrets"].readListIfPresent(memberReadingClosure: KafkaClientTypes.UnprocessedScramSecret.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct BatchDisassociateScramSecretOutput {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// List of errors when disassociating secrets to cluster.
    public var unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]?

    public init(
        clusterArn: Swift.String? = nil,
        unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.unprocessedScramSecrets = unprocessedScramSecrets
    }
}

enum BatchDisassociateScramSecretOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension KafkaClientTypes {

    /// The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed. Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.
    public enum BrokerAZDistribution: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [BrokerAZDistribution] {
            return [
                .default,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaClientTypes.BrokerCountUpdateInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.BrokerCountUpdateInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.BrokerCountUpdateInfo()
        value.createdBrokerIds = try reader["createdBrokerIds"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.deletedBrokerIds = try reader["deletedBrokerIds"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension KafkaClientTypes {
    /// Information regarding UpdateBrokerCount.
    public struct BrokerCountUpdateInfo {
        /// Kafka Broker IDs of brokers being created.
        public var createdBrokerIds: [Swift.Double]?
        /// Kafka Broker IDs of brokers being deleted.
        public var deletedBrokerIds: [Swift.Double]?

        public init(
            createdBrokerIds: [Swift.Double]? = nil,
            deletedBrokerIds: [Swift.Double]? = nil
        )
        {
            self.createdBrokerIds = createdBrokerIds
            self.deletedBrokerIds = deletedBrokerIds
        }
    }

}

extension KafkaClientTypes.BrokerEBSVolumeInfo {

    static func write(value: KafkaClientTypes.BrokerEBSVolumeInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kafkaBrokerNodeId"].write(value.kafkaBrokerNodeId)
        try writer["provisionedThroughput"].write(value.provisionedThroughput, with: KafkaClientTypes.ProvisionedThroughput.write(value:to:))
        try writer["volumeSizeGB"].write(value.volumeSizeGB)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.BrokerEBSVolumeInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.BrokerEBSVolumeInfo()
        value.kafkaBrokerNodeId = try reader["kafkaBrokerNodeId"].readIfPresent()
        value.provisionedThroughput = try reader["provisionedThroughput"].readIfPresent(with: KafkaClientTypes.ProvisionedThroughput.read(from:))
        value.volumeSizeGB = try reader["volumeSizeGB"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Specifies the EBS volume upgrade information. The broker identifier must be set to the keyword ALL. This means the changes apply to all the brokers in the cluster.
    public struct BrokerEBSVolumeInfo {
        /// The ID of the broker to update.
        /// This member is required.
        public var kafkaBrokerNodeId: Swift.String?
        /// EBS volume provisioned throughput information.
        public var provisionedThroughput: KafkaClientTypes.ProvisionedThroughput?
        /// Size of the EBS volume to update.
        public var volumeSizeGB: Swift.Int?

        public init(
            kafkaBrokerNodeId: Swift.String? = nil,
            provisionedThroughput: KafkaClientTypes.ProvisionedThroughput? = nil,
            volumeSizeGB: Swift.Int? = nil
        )
        {
            self.kafkaBrokerNodeId = kafkaBrokerNodeId
            self.provisionedThroughput = provisionedThroughput
            self.volumeSizeGB = volumeSizeGB
        }
    }

}

extension KafkaClientTypes.BrokerLogs {

    static func write(value: KafkaClientTypes.BrokerLogs?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchLogs"].write(value.cloudWatchLogs, with: KafkaClientTypes.CloudWatchLogs.write(value:to:))
        try writer["firehose"].write(value.firehose, with: KafkaClientTypes.Firehose.write(value:to:))
        try writer["s3"].write(value.s3, with: KafkaClientTypes.S3.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.BrokerLogs {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.BrokerLogs()
        value.cloudWatchLogs = try reader["cloudWatchLogs"].readIfPresent(with: KafkaClientTypes.CloudWatchLogs.read(from:))
        value.firehose = try reader["firehose"].readIfPresent(with: KafkaClientTypes.Firehose.read(from:))
        value.s3 = try reader["s3"].readIfPresent(with: KafkaClientTypes.S3.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    public struct BrokerLogs {
        public var cloudWatchLogs: KafkaClientTypes.CloudWatchLogs?
        public var firehose: KafkaClientTypes.Firehose?
        public var s3: KafkaClientTypes.S3?

        public init(
            cloudWatchLogs: KafkaClientTypes.CloudWatchLogs? = nil,
            firehose: KafkaClientTypes.Firehose? = nil,
            s3: KafkaClientTypes.S3? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.firehose = firehose
            self.s3 = s3
        }
    }

}

extension KafkaClientTypes.BrokerNodeGroupInfo {

    static func write(value: KafkaClientTypes.BrokerNodeGroupInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["brokerAZDistribution"].write(value.brokerAZDistribution)
        try writer["clientSubnets"].writeList(value.clientSubnets, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["connectivityInfo"].write(value.connectivityInfo, with: KafkaClientTypes.ConnectivityInfo.write(value:to:))
        try writer["instanceType"].write(value.instanceType)
        try writer["securityGroups"].writeList(value.securityGroups, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["storageInfo"].write(value.storageInfo, with: KafkaClientTypes.StorageInfo.write(value:to:))
        try writer["zoneIds"].writeList(value.zoneIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.BrokerNodeGroupInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.BrokerNodeGroupInfo()
        value.brokerAZDistribution = try reader["brokerAZDistribution"].readIfPresent()
        value.clientSubnets = try reader["clientSubnets"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceType = try reader["instanceType"].readIfPresent()
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.storageInfo = try reader["storageInfo"].readIfPresent(with: KafkaClientTypes.StorageInfo.read(from:))
        value.connectivityInfo = try reader["connectivityInfo"].readIfPresent(with: KafkaClientTypes.ConnectivityInfo.read(from:))
        value.zoneIds = try reader["zoneIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension KafkaClientTypes {
    /// Describes the setup to be used for Apache Kafka broker nodes in the cluster.
    public struct BrokerNodeGroupInfo {
        /// The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed. Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.
        public var brokerAZDistribution: KafkaClientTypes.BrokerAZDistribution?
        /// The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't occupy the Availability Zone with ID use use1-az3.
        /// This member is required.
        public var clientSubnets: [Swift.String]?
        /// Information about the broker access configuration.
        public var connectivityInfo: KafkaClientTypes.ConnectivityInfo?
        /// The type of Amazon EC2 instances to use for Apache Kafka brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge, kafka.m5.4xlarge, kafka.m5.12xlarge, and kafka.m5.24xlarge.
        /// This member is required.
        public var instanceType: Swift.String?
        /// The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC.
        public var securityGroups: [Swift.String]?
        /// Contains information about storage volumes attached to MSK broker nodes.
        public var storageInfo: KafkaClientTypes.StorageInfo?
        /// The list of zoneIds for the cluster in the virtual private cloud (VPC).
        public var zoneIds: [Swift.String]?

        public init(
            brokerAZDistribution: KafkaClientTypes.BrokerAZDistribution? = nil,
            clientSubnets: [Swift.String]? = nil,
            connectivityInfo: KafkaClientTypes.ConnectivityInfo? = nil,
            instanceType: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            storageInfo: KafkaClientTypes.StorageInfo? = nil,
            zoneIds: [Swift.String]? = nil
        )
        {
            self.brokerAZDistribution = brokerAZDistribution
            self.clientSubnets = clientSubnets
            self.connectivityInfo = connectivityInfo
            self.instanceType = instanceType
            self.securityGroups = securityGroups
            self.storageInfo = storageInfo
            self.zoneIds = zoneIds
        }
    }

}

extension KafkaClientTypes.BrokerNodeInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.BrokerNodeInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.BrokerNodeInfo()
        value.attachedENIId = try reader["attachedENIId"].readIfPresent()
        value.brokerId = try reader["brokerId"].readIfPresent()
        value.clientSubnet = try reader["clientSubnet"].readIfPresent()
        value.clientVpcIpAddress = try reader["clientVpcIpAddress"].readIfPresent()
        value.currentBrokerSoftwareInfo = try reader["currentBrokerSoftwareInfo"].readIfPresent(with: KafkaClientTypes.BrokerSoftwareInfo.read(from:))
        value.endpoints = try reader["endpoints"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension KafkaClientTypes {
    /// BrokerNodeInfo
    public struct BrokerNodeInfo {
        /// The attached elastic network interface of the broker.
        public var attachedENIId: Swift.String?
        /// The ID of the broker.
        public var brokerId: Swift.Double?
        /// The client subnet to which this broker node belongs.
        public var clientSubnet: Swift.String?
        /// The virtual private cloud (VPC) of the client.
        public var clientVpcIpAddress: Swift.String?
        /// Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.
        public var currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo?
        /// Endpoints for accessing the broker.
        public var endpoints: [Swift.String]?

        public init(
            attachedENIId: Swift.String? = nil,
            brokerId: Swift.Double? = nil,
            clientSubnet: Swift.String? = nil,
            clientVpcIpAddress: Swift.String? = nil,
            currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo? = nil,
            endpoints: [Swift.String]? = nil
        )
        {
            self.attachedENIId = attachedENIId
            self.brokerId = brokerId
            self.clientSubnet = clientSubnet
            self.clientVpcIpAddress = clientVpcIpAddress
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.endpoints = endpoints
        }
    }

}

extension KafkaClientTypes.BrokerSoftwareInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.BrokerSoftwareInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.BrokerSoftwareInfo()
        value.configurationArn = try reader["configurationArn"].readIfPresent()
        value.configurationRevision = try reader["configurationRevision"].readIfPresent()
        value.kafkaVersion = try reader["kafkaVersion"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Information about the current software installed on the cluster.
    public struct BrokerSoftwareInfo {
        /// The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.
        public var configurationArn: Swift.String?
        /// The revision of the configuration to use. This field isn't visible in this preview release.
        public var configurationRevision: Swift.Int?
        /// The version of Apache Kafka.
        public var kafkaVersion: Swift.String?

        public init(
            configurationArn: Swift.String? = nil,
            configurationRevision: Swift.Int? = nil,
            kafkaVersion: Swift.String? = nil
        )
        {
            self.configurationArn = configurationArn
            self.configurationRevision = configurationRevision
            self.kafkaVersion = kafkaVersion
        }
    }

}

extension KafkaClientTypes.ClientAuthentication {

    static func write(value: KafkaClientTypes.ClientAuthentication?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sasl"].write(value.sasl, with: KafkaClientTypes.Sasl.write(value:to:))
        try writer["tls"].write(value.tls, with: KafkaClientTypes.Tls.write(value:to:))
        try writer["unauthenticated"].write(value.unauthenticated, with: KafkaClientTypes.Unauthenticated.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ClientAuthentication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ClientAuthentication()
        value.sasl = try reader["sasl"].readIfPresent(with: KafkaClientTypes.Sasl.read(from:))
        value.tls = try reader["tls"].readIfPresent(with: KafkaClientTypes.Tls.read(from:))
        value.unauthenticated = try reader["unauthenticated"].readIfPresent(with: KafkaClientTypes.Unauthenticated.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Includes all client authentication information.
    public struct ClientAuthentication {
        /// Details for ClientAuthentication using SASL.
        public var sasl: KafkaClientTypes.Sasl?
        /// Details for ClientAuthentication using TLS.
        public var tls: KafkaClientTypes.Tls?
        /// Contains information about unauthenticated traffic to the cluster.
        public var unauthenticated: KafkaClientTypes.Unauthenticated?

        public init(
            sasl: KafkaClientTypes.Sasl? = nil,
            tls: KafkaClientTypes.Tls? = nil,
            unauthenticated: KafkaClientTypes.Unauthenticated? = nil
        )
        {
            self.sasl = sasl
            self.tls = tls
            self.unauthenticated = unauthenticated
        }
    }

}

extension KafkaClientTypes {

    /// Client-broker encryption in transit setting.
    public enum ClientBroker: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case plaintext
        case tls
        case tlsPlaintext
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientBroker] {
            return [
                .plaintext,
                .tls,
                .tlsPlaintext,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "PLAINTEXT"
            case .tls: return "TLS"
            case .tlsPlaintext: return "TLS_PLAINTEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaClientTypes.ClientVpcConnection {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ClientVpcConnection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ClientVpcConnection()
        value.authentication = try reader["authentication"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.state = try reader["state"].readIfPresent()
        value.vpcConnectionArn = try reader["vpcConnectionArn"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// The client VPC connection object.
    public struct ClientVpcConnection {
        /// Information about the auth scheme of Vpc Connection.
        public var authentication: Swift.String?
        /// Creation time of the Vpc Connection.
        public var creationTime: ClientRuntime.Date?
        /// The Owner of the Vpc Connection.
        public var owner: Swift.String?
        /// State of the Vpc Connection.
        public var state: KafkaClientTypes.VpcConnectionState?
        /// The ARN that identifies the Vpc Connection.
        /// This member is required.
        public var vpcConnectionArn: Swift.String?

        public init(
            authentication: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            owner: Swift.String? = nil,
            state: KafkaClientTypes.VpcConnectionState? = nil,
            vpcConnectionArn: Swift.String? = nil
        )
        {
            self.authentication = authentication
            self.creationTime = creationTime
            self.owner = owner
            self.state = state
            self.vpcConnectionArn = vpcConnectionArn
        }
    }

}

extension KafkaClientTypes.CloudWatchLogs {

    static func write(value: KafkaClientTypes.CloudWatchLogs?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["logGroup"].write(value.logGroup)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.CloudWatchLogs {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.CloudWatchLogs()
        value.enabled = try reader["enabled"].readIfPresent()
        value.logGroup = try reader["logGroup"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    public struct CloudWatchLogs {
        /// This member is required.
        public var enabled: Swift.Bool?
        public var logGroup: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            logGroup: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.logGroup = logGroup
        }
    }

}

extension KafkaClientTypes.Cluster {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.Cluster {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.Cluster()
        value.activeOperationArn = try reader["activeOperationArn"].readIfPresent()
        value.clusterType = try reader["clusterType"].readIfPresent()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterName = try reader["clusterName"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.currentVersion = try reader["currentVersion"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.stateInfo = try reader["stateInfo"].readIfPresent(with: KafkaClientTypes.StateInfo.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.provisioned = try reader["provisioned"].readIfPresent(with: KafkaClientTypes.Provisioned.read(from:))
        value.serverless = try reader["serverless"].readIfPresent(with: KafkaClientTypes.Serverless.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Returns information about a cluster.
    public struct Cluster {
        /// The Amazon Resource Name (ARN) that uniquely identifies a cluster operation.
        public var activeOperationArn: Swift.String?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public var clusterArn: Swift.String?
        /// The name of the cluster.
        public var clusterName: Swift.String?
        /// Cluster Type.
        public var clusterType: KafkaClientTypes.ClusterType?
        /// The time when the cluster was created.
        public var creationTime: ClientRuntime.Date?
        /// The current version of the MSK cluster.
        public var currentVersion: Swift.String?
        /// Information about the provisioned cluster.
        public var provisioned: KafkaClientTypes.Provisioned?
        /// Information about the serverless cluster.
        public var serverless: KafkaClientTypes.Serverless?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public var state: KafkaClientTypes.ClusterState?
        /// State Info for the Amazon MSK cluster.
        public var stateInfo: KafkaClientTypes.StateInfo?
        /// Tags attached to the cluster.
        public var tags: [Swift.String:Swift.String]?

        public init(
            activeOperationArn: Swift.String? = nil,
            clusterArn: Swift.String? = nil,
            clusterName: Swift.String? = nil,
            clusterType: KafkaClientTypes.ClusterType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            currentVersion: Swift.String? = nil,
            provisioned: KafkaClientTypes.Provisioned? = nil,
            serverless: KafkaClientTypes.Serverless? = nil,
            state: KafkaClientTypes.ClusterState? = nil,
            stateInfo: KafkaClientTypes.StateInfo? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeOperationArn = activeOperationArn
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.creationTime = creationTime
            self.currentVersion = currentVersion
            self.provisioned = provisioned
            self.serverless = serverless
            self.state = state
            self.stateInfo = stateInfo
            self.tags = tags
        }
    }

}

extension KafkaClientTypes.ClusterInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ClusterInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ClusterInfo()
        value.activeOperationArn = try reader["activeOperationArn"].readIfPresent()
        value.brokerNodeGroupInfo = try reader["brokerNodeGroupInfo"].readIfPresent(with: KafkaClientTypes.BrokerNodeGroupInfo.read(from:))
        value.clientAuthentication = try reader["clientAuthentication"].readIfPresent(with: KafkaClientTypes.ClientAuthentication.read(from:))
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterName = try reader["clusterName"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.currentBrokerSoftwareInfo = try reader["currentBrokerSoftwareInfo"].readIfPresent(with: KafkaClientTypes.BrokerSoftwareInfo.read(from:))
        value.currentVersion = try reader["currentVersion"].readIfPresent()
        value.encryptionInfo = try reader["encryptionInfo"].readIfPresent(with: KafkaClientTypes.EncryptionInfo.read(from:))
        value.enhancedMonitoring = try reader["enhancedMonitoring"].readIfPresent()
        value.openMonitoring = try reader["openMonitoring"].readIfPresent(with: KafkaClientTypes.OpenMonitoring.read(from:))
        value.loggingInfo = try reader["loggingInfo"].readIfPresent(with: KafkaClientTypes.LoggingInfo.read(from:))
        value.numberOfBrokerNodes = try reader["numberOfBrokerNodes"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.stateInfo = try reader["stateInfo"].readIfPresent(with: KafkaClientTypes.StateInfo.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.zookeeperConnectString = try reader["zookeeperConnectString"].readIfPresent()
        value.zookeeperConnectStringTls = try reader["zookeeperConnectStringTls"].readIfPresent()
        value.storageMode = try reader["storageMode"].readIfPresent()
        value.customerActionStatus = try reader["customerActionStatus"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Returns information about a cluster.
    public struct ClusterInfo {
        /// Arn of active cluster operation.
        public var activeOperationArn: Swift.String?
        /// Information about the broker nodes.
        public var brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo?
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public var clusterArn: Swift.String?
        /// The name of the cluster.
        public var clusterName: Swift.String?
        /// The time when the cluster was created.
        public var creationTime: ClientRuntime.Date?
        /// Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.
        public var currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo?
        /// The current version of the MSK cluster.
        public var currentVersion: Swift.String?
        /// Determines if there is an action required from the customer.
        public var customerActionStatus: KafkaClientTypes.CustomerActionStatus?
        /// Includes all encryption-related information.
        public var encryptionInfo: KafkaClientTypes.EncryptionInfo?
        /// Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see [Monitoring](https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html).
        public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
        public var loggingInfo: KafkaClientTypes.LoggingInfo?
        /// The number of broker nodes in the cluster.
        public var numberOfBrokerNodes: Swift.Int?
        /// Settings for open monitoring using Prometheus.
        public var openMonitoring: KafkaClientTypes.OpenMonitoring?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public var state: KafkaClientTypes.ClusterState?
        public var stateInfo: KafkaClientTypes.StateInfo?
        /// This controls storage mode for supported storage tiers.
        public var storageMode: KafkaClientTypes.StorageMode?
        /// Tags attached to the cluster.
        public var tags: [Swift.String:Swift.String]?
        /// The connection string to use to connect to the Apache ZooKeeper cluster.
        public var zookeeperConnectString: Swift.String?
        /// The connection string to use to connect to zookeeper cluster on Tls port.
        public var zookeeperConnectStringTls: Swift.String?

        public init(
            activeOperationArn: Swift.String? = nil,
            brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo? = nil,
            clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
            clusterArn: Swift.String? = nil,
            clusterName: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo? = nil,
            currentVersion: Swift.String? = nil,
            customerActionStatus: KafkaClientTypes.CustomerActionStatus? = nil,
            encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil,
            enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
            loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
            numberOfBrokerNodes: Swift.Int? = nil,
            openMonitoring: KafkaClientTypes.OpenMonitoring? = nil,
            state: KafkaClientTypes.ClusterState? = nil,
            stateInfo: KafkaClientTypes.StateInfo? = nil,
            storageMode: KafkaClientTypes.StorageMode? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            zookeeperConnectString: Swift.String? = nil,
            zookeeperConnectStringTls: Swift.String? = nil
        )
        {
            self.activeOperationArn = activeOperationArn
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.creationTime = creationTime
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.currentVersion = currentVersion
            self.customerActionStatus = customerActionStatus
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.state = state
            self.stateInfo = stateInfo
            self.storageMode = storageMode
            self.tags = tags
            self.zookeeperConnectString = zookeeperConnectString
            self.zookeeperConnectStringTls = zookeeperConnectStringTls
        }
    }

}

extension KafkaClientTypes.ClusterOperationInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ClusterOperationInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ClusterOperationInfo()
        value.clientRequestId = try reader["clientRequestId"].readIfPresent()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: .dateTime)
        value.errorInfo = try reader["errorInfo"].readIfPresent(with: KafkaClientTypes.ErrorInfo.read(from:))
        value.operationArn = try reader["operationArn"].readIfPresent()
        value.operationState = try reader["operationState"].readIfPresent()
        value.operationSteps = try reader["operationSteps"].readListIfPresent(memberReadingClosure: KafkaClientTypes.ClusterOperationStep.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.operationType = try reader["operationType"].readIfPresent()
        value.sourceClusterInfo = try reader["sourceClusterInfo"].readIfPresent(with: KafkaClientTypes.MutableClusterInfo.read(from:))
        value.targetClusterInfo = try reader["targetClusterInfo"].readIfPresent(with: KafkaClientTypes.MutableClusterInfo.read(from:))
        value.vpcConnectionInfo = try reader["vpcConnectionInfo"].readIfPresent(with: KafkaClientTypes.VpcConnectionInfo.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Returns information about a cluster operation.
    public struct ClusterOperationInfo {
        /// The ID of the API request that triggered this operation.
        public var clientRequestId: Swift.String?
        /// ARN of the cluster.
        public var clusterArn: Swift.String?
        /// The time that the operation was created.
        public var creationTime: ClientRuntime.Date?
        /// The time at which the operation finished.
        public var endTime: ClientRuntime.Date?
        /// Describes the error if the operation fails.
        public var errorInfo: KafkaClientTypes.ErrorInfo?
        /// ARN of the cluster operation.
        public var operationArn: Swift.String?
        /// State of the cluster operation.
        public var operationState: Swift.String?
        /// Steps completed during the operation.
        public var operationSteps: [KafkaClientTypes.ClusterOperationStep]?
        /// Type of the cluster operation.
        public var operationType: Swift.String?
        /// Information about cluster attributes before a cluster is updated.
        public var sourceClusterInfo: KafkaClientTypes.MutableClusterInfo?
        /// Information about cluster attributes after a cluster is updated.
        public var targetClusterInfo: KafkaClientTypes.MutableClusterInfo?
        /// Description of the VPC connection for CreateVpcConnection and DeleteVpcConnection operations.
        public var vpcConnectionInfo: KafkaClientTypes.VpcConnectionInfo?

        public init(
            clientRequestId: Swift.String? = nil,
            clusterArn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            endTime: ClientRuntime.Date? = nil,
            errorInfo: KafkaClientTypes.ErrorInfo? = nil,
            operationArn: Swift.String? = nil,
            operationState: Swift.String? = nil,
            operationSteps: [KafkaClientTypes.ClusterOperationStep]? = nil,
            operationType: Swift.String? = nil,
            sourceClusterInfo: KafkaClientTypes.MutableClusterInfo? = nil,
            targetClusterInfo: KafkaClientTypes.MutableClusterInfo? = nil,
            vpcConnectionInfo: KafkaClientTypes.VpcConnectionInfo? = nil
        )
        {
            self.clientRequestId = clientRequestId
            self.clusterArn = clusterArn
            self.creationTime = creationTime
            self.endTime = endTime
            self.errorInfo = errorInfo
            self.operationArn = operationArn
            self.operationState = operationState
            self.operationSteps = operationSteps
            self.operationType = operationType
            self.sourceClusterInfo = sourceClusterInfo
            self.targetClusterInfo = targetClusterInfo
            self.vpcConnectionInfo = vpcConnectionInfo
        }
    }

}

extension KafkaClientTypes.ClusterOperationStep {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ClusterOperationStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ClusterOperationStep()
        value.stepInfo = try reader["stepInfo"].readIfPresent(with: KafkaClientTypes.ClusterOperationStepInfo.read(from:))
        value.stepName = try reader["stepName"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Step taken during a cluster operation.
    public struct ClusterOperationStep {
        /// Information about the step and its status.
        public var stepInfo: KafkaClientTypes.ClusterOperationStepInfo?
        /// The name of the step.
        public var stepName: Swift.String?

        public init(
            stepInfo: KafkaClientTypes.ClusterOperationStepInfo? = nil,
            stepName: Swift.String? = nil
        )
        {
            self.stepInfo = stepInfo
            self.stepName = stepName
        }
    }

}

extension KafkaClientTypes.ClusterOperationStepInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ClusterOperationStepInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ClusterOperationStepInfo()
        value.stepStatus = try reader["stepStatus"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// State information about the operation step.
    public struct ClusterOperationStepInfo {
        /// The steps current status.
        public var stepStatus: Swift.String?

        public init(
            stepStatus: Swift.String? = nil
        )
        {
            self.stepStatus = stepStatus
        }
    }

}

extension KafkaClientTypes.ClusterOperationV2 {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ClusterOperationV2 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ClusterOperationV2()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterType = try reader["clusterType"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: .dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: .dateTime)
        value.errorInfo = try reader["errorInfo"].readIfPresent(with: KafkaClientTypes.ErrorInfo.read(from:))
        value.operationArn = try reader["operationArn"].readIfPresent()
        value.operationState = try reader["operationState"].readIfPresent()
        value.operationType = try reader["operationType"].readIfPresent()
        value.provisioned = try reader["provisioned"].readIfPresent(with: KafkaClientTypes.ClusterOperationV2Provisioned.read(from:))
        value.serverless = try reader["serverless"].readIfPresent(with: KafkaClientTypes.ClusterOperationV2Serverless.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Returns information about a cluster operation.
    public struct ClusterOperationV2 {
        /// ARN of the cluster.
        public var clusterArn: Swift.String?
        /// Type of the backend cluster.
        public var clusterType: KafkaClientTypes.ClusterType?
        /// The time at which the operation finished.
        public var endTime: ClientRuntime.Date?
        /// If cluster operation failed from an error, it describes the error.
        public var errorInfo: KafkaClientTypes.ErrorInfo?
        /// ARN of the cluster operation.
        public var operationArn: Swift.String?
        /// State of the cluster operation.
        public var operationState: Swift.String?
        /// Type of the cluster operation.
        public var operationType: Swift.String?
        /// Properties of a provisioned cluster.
        public var provisioned: KafkaClientTypes.ClusterOperationV2Provisioned?
        /// Properties of a serverless cluster.
        public var serverless: KafkaClientTypes.ClusterOperationV2Serverless?
        /// The time at which operation was started.
        public var startTime: ClientRuntime.Date?

        public init(
            clusterArn: Swift.String? = nil,
            clusterType: KafkaClientTypes.ClusterType? = nil,
            endTime: ClientRuntime.Date? = nil,
            errorInfo: KafkaClientTypes.ErrorInfo? = nil,
            operationArn: Swift.String? = nil,
            operationState: Swift.String? = nil,
            operationType: Swift.String? = nil,
            provisioned: KafkaClientTypes.ClusterOperationV2Provisioned? = nil,
            serverless: KafkaClientTypes.ClusterOperationV2Serverless? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.clusterArn = clusterArn
            self.clusterType = clusterType
            self.endTime = endTime
            self.errorInfo = errorInfo
            self.operationArn = operationArn
            self.operationState = operationState
            self.operationType = operationType
            self.provisioned = provisioned
            self.serverless = serverless
            self.startTime = startTime
        }
    }

}

extension KafkaClientTypes.ClusterOperationV2Provisioned {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ClusterOperationV2Provisioned {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ClusterOperationV2Provisioned()
        value.operationSteps = try reader["operationSteps"].readListIfPresent(memberReadingClosure: KafkaClientTypes.ClusterOperationStep.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceClusterInfo = try reader["sourceClusterInfo"].readIfPresent(with: KafkaClientTypes.MutableClusterInfo.read(from:))
        value.targetClusterInfo = try reader["targetClusterInfo"].readIfPresent(with: KafkaClientTypes.MutableClusterInfo.read(from:))
        value.vpcConnectionInfo = try reader["vpcConnectionInfo"].readIfPresent(with: KafkaClientTypes.VpcConnectionInfo.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Returns information about a provisioned cluster operation.
    public struct ClusterOperationV2Provisioned {
        /// Steps completed during the operation.
        public var operationSteps: [KafkaClientTypes.ClusterOperationStep]?
        /// Information about cluster attributes before a cluster is updated.
        public var sourceClusterInfo: KafkaClientTypes.MutableClusterInfo?
        /// Information about cluster attributes after a cluster is updated.
        public var targetClusterInfo: KafkaClientTypes.MutableClusterInfo?
        /// Description of the VPC connection for CreateVpcConnection and DeleteVpcConnection operations.
        public var vpcConnectionInfo: KafkaClientTypes.VpcConnectionInfo?

        public init(
            operationSteps: [KafkaClientTypes.ClusterOperationStep]? = nil,
            sourceClusterInfo: KafkaClientTypes.MutableClusterInfo? = nil,
            targetClusterInfo: KafkaClientTypes.MutableClusterInfo? = nil,
            vpcConnectionInfo: KafkaClientTypes.VpcConnectionInfo? = nil
        )
        {
            self.operationSteps = operationSteps
            self.sourceClusterInfo = sourceClusterInfo
            self.targetClusterInfo = targetClusterInfo
            self.vpcConnectionInfo = vpcConnectionInfo
        }
    }

}

extension KafkaClientTypes.ClusterOperationV2Serverless {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ClusterOperationV2Serverless {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ClusterOperationV2Serverless()
        value.vpcConnectionInfo = try reader["vpcConnectionInfo"].readIfPresent(with: KafkaClientTypes.VpcConnectionInfoServerless.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Returns information about a serverless cluster operation.
    public struct ClusterOperationV2Serverless {
        /// Description of the VPC connection for CreateVpcConnection and DeleteVpcConnection operations.
        public var vpcConnectionInfo: KafkaClientTypes.VpcConnectionInfoServerless?

        public init(
            vpcConnectionInfo: KafkaClientTypes.VpcConnectionInfoServerless? = nil
        )
        {
            self.vpcConnectionInfo = vpcConnectionInfo
        }
    }

}

extension KafkaClientTypes.ClusterOperationV2Summary {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ClusterOperationV2Summary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ClusterOperationV2Summary()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterType = try reader["clusterType"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: .dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: .dateTime)
        value.operationArn = try reader["operationArn"].readIfPresent()
        value.operationState = try reader["operationState"].readIfPresent()
        value.operationType = try reader["operationType"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Returns information about a cluster operation.
    public struct ClusterOperationV2Summary {
        /// ARN of the cluster.
        public var clusterArn: Swift.String?
        /// Type of the backend cluster.
        public var clusterType: KafkaClientTypes.ClusterType?
        /// The time at which the operation finished.
        public var endTime: ClientRuntime.Date?
        /// ARN of the cluster operation.
        public var operationArn: Swift.String?
        /// State of the cluster operation.
        public var operationState: Swift.String?
        /// Type of the cluster operation.
        public var operationType: Swift.String?
        /// The time at which operation was started.
        public var startTime: ClientRuntime.Date?

        public init(
            clusterArn: Swift.String? = nil,
            clusterType: KafkaClientTypes.ClusterType? = nil,
            endTime: ClientRuntime.Date? = nil,
            operationArn: Swift.String? = nil,
            operationState: Swift.String? = nil,
            operationType: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.clusterArn = clusterArn
            self.clusterType = clusterType
            self.endTime = endTime
            self.operationArn = operationArn
            self.operationState = operationState
            self.operationType = operationType
            self.startTime = startTime
        }
    }

}

extension KafkaClientTypes {

    /// The state of the Apache Kafka cluster.
    public enum ClusterState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case healing
        case maintenance
        case rebootingBroker
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .healing,
                .maintenance,
                .rebootingBroker,
                .updating,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .healing: return "HEALING"
            case .maintenance: return "MAINTENANCE"
            case .rebootingBroker: return "REBOOTING_BROKER"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaClientTypes {

    /// The type of cluster.
    public enum ClusterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case provisioned
        case serverless
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterType] {
            return [
                .provisioned,
                .serverless,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .provisioned: return "PROVISIONED"
            case .serverless: return "SERVERLESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaClientTypes.CompatibleKafkaVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.CompatibleKafkaVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.CompatibleKafkaVersion()
        value.sourceVersion = try reader["sourceVersion"].readIfPresent()
        value.targetVersions = try reader["targetVersions"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension KafkaClientTypes {
    /// Contains source Apache Kafka versions and compatible target Apache Kafka versions.
    public struct CompatibleKafkaVersion {
        /// An Apache Kafka version.
        public var sourceVersion: Swift.String?
        /// A list of Apache Kafka versions.
        public var targetVersions: [Swift.String]?

        public init(
            sourceVersion: Swift.String? = nil,
            targetVersions: [Swift.String]? = nil
        )
        {
            self.sourceVersion = sourceVersion
            self.targetVersions = targetVersions
        }
    }

}

extension KafkaClientTypes.Configuration {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.Configuration()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.kafkaVersions = try reader["kafkaVersions"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.latestRevision = try reader["latestRevision"].readIfPresent(with: KafkaClientTypes.ConfigurationRevision.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Represents an MSK Configuration.
    public struct Configuration {
        /// The Amazon Resource Name (ARN) of the configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the configuration was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The description of the configuration.
        /// This member is required.
        public var description: Swift.String?
        /// An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.
        /// This member is required.
        public var kafkaVersions: [Swift.String]?
        /// Latest revision of the configuration.
        /// This member is required.
        public var latestRevision: KafkaClientTypes.ConfigurationRevision?
        /// The name of the configuration.
        /// This member is required.
        public var name: Swift.String?
        /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
        /// This member is required.
        public var state: KafkaClientTypes.ConfigurationState?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            kafkaVersions: [Swift.String]? = nil,
            latestRevision: KafkaClientTypes.ConfigurationRevision? = nil,
            name: Swift.String? = nil,
            state: KafkaClientTypes.ConfigurationState? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.kafkaVersions = kafkaVersions
            self.latestRevision = latestRevision
            self.name = name
            self.state = state
        }
    }

}

extension KafkaClientTypes.ConfigurationInfo {

    static func write(value: KafkaClientTypes.ConfigurationInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["revision"].write(value.revision)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ConfigurationInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ConfigurationInfo()
        value.arn = try reader["arn"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Specifies the configuration to use for the brokers.
    public struct ConfigurationInfo {
        /// ARN of the configuration to use.
        /// This member is required.
        public var arn: Swift.String?
        /// The revision of the configuration to use.
        /// This member is required.
        public var revision: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            revision: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.revision = revision
        }
    }

}

extension KafkaClientTypes.ConfigurationRevision {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ConfigurationRevision {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ConfigurationRevision()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Describes a configuration revision.
    public struct ConfigurationRevision {
        /// The time when the configuration revision was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The description of the configuration revision.
        public var description: Swift.String?
        /// The revision number.
        /// This member is required.
        public var revision: Swift.Int?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            revision: Swift.Int? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.revision = revision
        }
    }

}

extension KafkaClientTypes {

    /// The state of a configuration.
    public enum ConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleteFailed
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationState] {
            return [
                .active,
                .deleteFailed,
                .deleting,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.invalidParameter = try reader["invalidParameter"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Returns information about an error.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

extension KafkaClientTypes.ConnectivityInfo {

    static func write(value: KafkaClientTypes.ConnectivityInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["publicAccess"].write(value.publicAccess, with: KafkaClientTypes.PublicAccess.write(value:to:))
        try writer["vpcConnectivity"].write(value.vpcConnectivity, with: KafkaClientTypes.VpcConnectivity.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ConnectivityInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ConnectivityInfo()
        value.publicAccess = try reader["publicAccess"].readIfPresent(with: KafkaClientTypes.PublicAccess.read(from:))
        value.vpcConnectivity = try reader["vpcConnectivity"].readIfPresent(with: KafkaClientTypes.VpcConnectivity.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Information about the broker access configuration.
    public struct ConnectivityInfo {
        /// Public access control for brokers.
        public var publicAccess: KafkaClientTypes.PublicAccess?
        /// VPC connectivity access control for brokers.
        public var vpcConnectivity: KafkaClientTypes.VpcConnectivity?

        public init(
            publicAccess: KafkaClientTypes.PublicAccess? = nil,
            vpcConnectivity: KafkaClientTypes.VpcConnectivity? = nil
        )
        {
            self.publicAccess = publicAccess
            self.vpcConnectivity = vpcConnectivity
        }
    }

}

extension KafkaClientTypes.ConsumerGroupReplication {

    static func write(value: KafkaClientTypes.ConsumerGroupReplication?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["consumerGroupsToExclude"].writeList(value.consumerGroupsToExclude, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["consumerGroupsToReplicate"].writeList(value.consumerGroupsToReplicate, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["detectAndCopyNewConsumerGroups"].write(value.detectAndCopyNewConsumerGroups)
        try writer["synchroniseConsumerGroupOffsets"].write(value.synchroniseConsumerGroupOffsets)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ConsumerGroupReplication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ConsumerGroupReplication()
        value.consumerGroupsToExclude = try reader["consumerGroupsToExclude"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.consumerGroupsToReplicate = try reader["consumerGroupsToReplicate"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.detectAndCopyNewConsumerGroups = try reader["detectAndCopyNewConsumerGroups"].readIfPresent()
        value.synchroniseConsumerGroupOffsets = try reader["synchroniseConsumerGroupOffsets"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Details about consumer group replication.
    public struct ConsumerGroupReplication {
        /// List of regular expression patterns indicating the consumer groups that should not be replicated.
        public var consumerGroupsToExclude: [Swift.String]?
        /// List of regular expression patterns indicating the consumer groups to copy.
        /// This member is required.
        public var consumerGroupsToReplicate: [Swift.String]?
        /// Enables synchronization of consumer groups to target cluster.
        public var detectAndCopyNewConsumerGroups: Swift.Bool?
        /// Enables synchronization of consumer group offsets to target cluster. The translated offsets will be written to topic __consumer_offsets.
        public var synchroniseConsumerGroupOffsets: Swift.Bool?

        public init(
            consumerGroupsToExclude: [Swift.String]? = nil,
            consumerGroupsToReplicate: [Swift.String]? = nil,
            detectAndCopyNewConsumerGroups: Swift.Bool? = nil,
            synchroniseConsumerGroupOffsets: Swift.Bool? = nil
        )
        {
            self.consumerGroupsToExclude = consumerGroupsToExclude
            self.consumerGroupsToReplicate = consumerGroupsToReplicate
            self.detectAndCopyNewConsumerGroups = detectAndCopyNewConsumerGroups
            self.synchroniseConsumerGroupOffsets = synchroniseConsumerGroupOffsets
        }
    }

}

extension KafkaClientTypes.ConsumerGroupReplicationUpdate {

    static func write(value: KafkaClientTypes.ConsumerGroupReplicationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["consumerGroupsToExclude"].writeList(value.consumerGroupsToExclude, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["consumerGroupsToReplicate"].writeList(value.consumerGroupsToReplicate, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["detectAndCopyNewConsumerGroups"].write(value.detectAndCopyNewConsumerGroups)
        try writer["synchroniseConsumerGroupOffsets"].write(value.synchroniseConsumerGroupOffsets)
    }
}

extension KafkaClientTypes {
    /// Details about consumer group replication.
    public struct ConsumerGroupReplicationUpdate {
        /// List of regular expression patterns indicating the consumer groups that should not be replicated.
        /// This member is required.
        public var consumerGroupsToExclude: [Swift.String]?
        /// List of regular expression patterns indicating the consumer groups to copy.
        /// This member is required.
        public var consumerGroupsToReplicate: [Swift.String]?
        /// Enables synchronization of consumer groups to target cluster.
        /// This member is required.
        public var detectAndCopyNewConsumerGroups: Swift.Bool?
        /// Enables synchronization of consumer group offsets to target cluster. The translated offsets will be written to topic __consumer_offsets.
        /// This member is required.
        public var synchroniseConsumerGroupOffsets: Swift.Bool?

        public init(
            consumerGroupsToExclude: [Swift.String]? = nil,
            consumerGroupsToReplicate: [Swift.String]? = nil,
            detectAndCopyNewConsumerGroups: Swift.Bool? = nil,
            synchroniseConsumerGroupOffsets: Swift.Bool? = nil
        )
        {
            self.consumerGroupsToExclude = consumerGroupsToExclude
            self.consumerGroupsToReplicate = consumerGroupsToReplicate
            self.detectAndCopyNewConsumerGroups = detectAndCopyNewConsumerGroups
            self.synchroniseConsumerGroupOffsets = synchroniseConsumerGroupOffsets
        }
    }

}

extension CreateClusterInput {

    static func urlPathProvider(_ value: CreateClusterInput) -> Swift.String? {
        return "/v1/clusters"
    }
}

extension CreateClusterInput {

    static func write(value: CreateClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["brokerNodeGroupInfo"].write(value.brokerNodeGroupInfo, with: KafkaClientTypes.BrokerNodeGroupInfo.write(value:to:))
        try writer["clientAuthentication"].write(value.clientAuthentication, with: KafkaClientTypes.ClientAuthentication.write(value:to:))
        try writer["clusterName"].write(value.clusterName)
        try writer["configurationInfo"].write(value.configurationInfo, with: KafkaClientTypes.ConfigurationInfo.write(value:to:))
        try writer["encryptionInfo"].write(value.encryptionInfo, with: KafkaClientTypes.EncryptionInfo.write(value:to:))
        try writer["enhancedMonitoring"].write(value.enhancedMonitoring)
        try writer["kafkaVersion"].write(value.kafkaVersion)
        try writer["loggingInfo"].write(value.loggingInfo, with: KafkaClientTypes.LoggingInfo.write(value:to:))
        try writer["numberOfBrokerNodes"].write(value.numberOfBrokerNodes)
        try writer["openMonitoring"].write(value.openMonitoring, with: KafkaClientTypes.OpenMonitoringInfo.write(value:to:))
        try writer["storageMode"].write(value.storageMode)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateClusterInput {
    /// Information about the broker nodes in the cluster.
    /// This member is required.
    public var brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo?
    /// Includes all client authentication related information.
    public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
    /// The name of the cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// Represents the configuration that you want MSK to use for the brokers in a cluster.
    public var configurationInfo: KafkaClientTypes.ConfigurationInfo?
    /// Includes all encryption-related information.
    public var encryptionInfo: KafkaClientTypes.EncryptionInfo?
    /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
    public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
    /// The version of Apache Kafka.
    /// This member is required.
    public var kafkaVersion: Swift.String?
    public var loggingInfo: KafkaClientTypes.LoggingInfo?
    /// The number of broker nodes in the cluster.
    /// This member is required.
    public var numberOfBrokerNodes: Swift.Int?
    /// The settings for open monitoring.
    public var openMonitoring: KafkaClientTypes.OpenMonitoringInfo?
    /// This controls storage mode for supported storage tiers.
    public var storageMode: KafkaClientTypes.StorageMode?
    /// Create tags when creating the cluster.
    public var tags: [Swift.String:Swift.String]?

    public init(
        brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo? = nil,
        clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
        clusterName: Swift.String? = nil,
        configurationInfo: KafkaClientTypes.ConfigurationInfo? = nil,
        encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil,
        enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
        kafkaVersion: Swift.String? = nil,
        loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
        numberOfBrokerNodes: Swift.Int? = nil,
        openMonitoring: KafkaClientTypes.OpenMonitoringInfo? = nil,
        storageMode: KafkaClientTypes.StorageMode? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.brokerNodeGroupInfo = brokerNodeGroupInfo
        self.clientAuthentication = clientAuthentication
        self.clusterName = clusterName
        self.configurationInfo = configurationInfo
        self.encryptionInfo = encryptionInfo
        self.enhancedMonitoring = enhancedMonitoring
        self.kafkaVersion = kafkaVersion
        self.loggingInfo = loggingInfo
        self.numberOfBrokerNodes = numberOfBrokerNodes
        self.openMonitoring = openMonitoring
        self.storageMode = storageMode
        self.tags = tags
    }
}

extension CreateClusterOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateClusterOutput()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterName = try reader["clusterName"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

public struct CreateClusterOutput {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The name of the MSK cluster.
    public var clusterName: Swift.String?
    /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
    public var state: KafkaClientTypes.ClusterState?

    public init(
        clusterArn: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        state: KafkaClientTypes.ClusterState? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterName = clusterName
        self.state = state
    }
}

enum CreateClusterOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateClusterV2Input {

    static func urlPathProvider(_ value: CreateClusterV2Input) -> Swift.String? {
        return "/api/v2/clusters"
    }
}

extension CreateClusterV2Input {

    static func write(value: CreateClusterV2Input?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clusterName"].write(value.clusterName)
        try writer["provisioned"].write(value.provisioned, with: KafkaClientTypes.ProvisionedRequest.write(value:to:))
        try writer["serverless"].write(value.serverless, with: KafkaClientTypes.ServerlessRequest.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateClusterV2Input {
    /// The name of the cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// Information about the provisioned cluster.
    public var provisioned: KafkaClientTypes.ProvisionedRequest?
    /// Information about the serverless cluster.
    public var serverless: KafkaClientTypes.ServerlessRequest?
    /// A map of tags that you want the cluster to have.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clusterName: Swift.String? = nil,
        provisioned: KafkaClientTypes.ProvisionedRequest? = nil,
        serverless: KafkaClientTypes.ServerlessRequest? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clusterName = clusterName
        self.provisioned = provisioned
        self.serverless = serverless
        self.tags = tags
    }
}

extension CreateClusterV2Output {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateClusterV2Output {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateClusterV2Output()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterName = try reader["clusterName"].readIfPresent()
        value.clusterType = try reader["clusterType"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

public struct CreateClusterV2Output {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The name of the MSK cluster.
    public var clusterName: Swift.String?
    /// The type of the cluster. The possible states are PROVISIONED or SERVERLESS.
    public var clusterType: KafkaClientTypes.ClusterType?
    /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
    public var state: KafkaClientTypes.ClusterState?

    public init(
        clusterArn: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        clusterType: KafkaClientTypes.ClusterType? = nil,
        state: KafkaClientTypes.ClusterState? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterName = clusterName
        self.clusterType = clusterType
        self.state = state
    }
}

enum CreateClusterV2OutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateConfigurationInput {

    static func urlPathProvider(_ value: CreateConfigurationInput) -> Swift.String? {
        return "/v1/configurations"
    }
}

extension CreateConfigurationInput {

    static func write(value: CreateConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["kafkaVersions"].writeList(value.kafkaVersions, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["serverProperties"].write(value.serverProperties)
    }
}

public struct CreateConfigurationInput {
    /// The description of the configuration.
    public var description: Swift.String?
    /// The versions of Apache Kafka with which you can use this MSK configuration.
    public var kafkaVersions: [Swift.String]?
    /// The name of the configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded. When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
    /// This member is required.
    public var serverProperties: ClientRuntime.Data?

    public init(
        description: Swift.String? = nil,
        kafkaVersions: [Swift.String]? = nil,
        name: Swift.String? = nil,
        serverProperties: ClientRuntime.Data? = nil
    )
    {
        self.description = description
        self.kafkaVersions = kafkaVersions
        self.name = name
        self.serverProperties = serverProperties
    }
}

extension CreateConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConfigurationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.latestRevision = try reader["latestRevision"].readIfPresent(with: KafkaClientTypes.ConfigurationRevision.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

public struct CreateConfigurationOutput {
    /// The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// The time when the configuration was created.
    public var creationTime: ClientRuntime.Date?
    /// Latest revision of the configuration.
    public var latestRevision: KafkaClientTypes.ConfigurationRevision?
    /// The name of the configuration.
    public var name: Swift.String?
    /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
    public var state: KafkaClientTypes.ConfigurationState?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        latestRevision: KafkaClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil,
        state: KafkaClientTypes.ConfigurationState? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.latestRevision = latestRevision
        self.name = name
        self.state = state
    }
}

enum CreateConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateReplicatorInput {

    static func urlPathProvider(_ value: CreateReplicatorInput) -> Swift.String? {
        return "/replication/v1/replicators"
    }
}

extension CreateReplicatorInput {

    static func write(value: CreateReplicatorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["kafkaClusters"].writeList(value.kafkaClusters, memberWritingClosure: KafkaClientTypes.KafkaCluster.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["replicationInfoList"].writeList(value.replicationInfoList, memberWritingClosure: KafkaClientTypes.ReplicationInfo.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["replicatorName"].write(value.replicatorName)
        try writer["serviceExecutionRoleArn"].write(value.serviceExecutionRoleArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

/// Creates a replicator using the specified configuration.
public struct CreateReplicatorInput {
    /// A summary description of the replicator.
    public var description: Swift.String?
    /// Kafka Clusters to use in setting up sources / targets for replication.
    /// This member is required.
    public var kafkaClusters: [KafkaClientTypes.KafkaCluster]?
    /// A list of replication configurations, where each configuration targets a given source cluster to target cluster replication flow.
    /// This member is required.
    public var replicationInfoList: [KafkaClientTypes.ReplicationInfo]?
    /// The name of the replicator. Alpha-numeric characters with '-' are allowed.
    /// This member is required.
    public var replicatorName: Swift.String?
    /// The ARN of the IAM role used by the replicator to access resources in the customer's account (e.g source and target clusters)
    /// This member is required.
    public var serviceExecutionRoleArn: Swift.String?
    /// List of tags to attach to created Replicator.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        kafkaClusters: [KafkaClientTypes.KafkaCluster]? = nil,
        replicationInfoList: [KafkaClientTypes.ReplicationInfo]? = nil,
        replicatorName: Swift.String? = nil,
        serviceExecutionRoleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.kafkaClusters = kafkaClusters
        self.replicationInfoList = replicationInfoList
        self.replicatorName = replicatorName
        self.serviceExecutionRoleArn = serviceExecutionRoleArn
        self.tags = tags
    }
}

extension CreateReplicatorOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateReplicatorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateReplicatorOutput()
        value.replicatorArn = try reader["replicatorArn"].readIfPresent()
        value.replicatorName = try reader["replicatorName"].readIfPresent()
        value.replicatorState = try reader["replicatorState"].readIfPresent()
        return value
    }
}

public struct CreateReplicatorOutput {
    /// The Amazon Resource Name (ARN) of the replicator.
    public var replicatorArn: Swift.String?
    /// Name of the replicator provided by the customer.
    public var replicatorName: Swift.String?
    /// State of the replicator.
    public var replicatorState: KafkaClientTypes.ReplicatorState?

    public init(
        replicatorArn: Swift.String? = nil,
        replicatorName: Swift.String? = nil,
        replicatorState: KafkaClientTypes.ReplicatorState? = nil
    )
    {
        self.replicatorArn = replicatorArn
        self.replicatorName = replicatorName
        self.replicatorState = replicatorState
    }
}

enum CreateReplicatorOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateVpcConnectionInput {

    static func urlPathProvider(_ value: CreateVpcConnectionInput) -> Swift.String? {
        return "/v1/vpc-connection"
    }
}

extension CreateVpcConnectionInput {

    static func write(value: CreateVpcConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authentication"].write(value.authentication)
        try writer["clientSubnets"].writeList(value.clientSubnets, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["securityGroups"].writeList(value.securityGroups, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["targetClusterArn"].write(value.targetClusterArn)
        try writer["vpcId"].write(value.vpcId)
    }
}

public struct CreateVpcConnectionInput {
    /// The authentication type of VPC connection.
    /// This member is required.
    public var authentication: Swift.String?
    /// The list of client subnets.
    /// This member is required.
    public var clientSubnets: [Swift.String]?
    /// The list of security groups.
    /// This member is required.
    public var securityGroups: [Swift.String]?
    /// A map of tags for the VPC connection.
    public var tags: [Swift.String:Swift.String]?
    /// The cluster Amazon Resource Name (ARN) for the VPC connection.
    /// This member is required.
    public var targetClusterArn: Swift.String?
    /// The VPC ID of VPC connection.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        authentication: Swift.String? = nil,
        clientSubnets: [Swift.String]? = nil,
        securityGroups: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetClusterArn: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.authentication = authentication
        self.clientSubnets = clientSubnets
        self.securityGroups = securityGroups
        self.tags = tags
        self.targetClusterArn = targetClusterArn
        self.vpcId = vpcId
    }
}

extension CreateVpcConnectionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateVpcConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVpcConnectionOutput()
        value.authentication = try reader["authentication"].readIfPresent()
        value.clientSubnets = try reader["clientSubnets"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["state"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcConnectionArn = try reader["vpcConnectionArn"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        return value
    }
}

public struct CreateVpcConnectionOutput {
    /// The authentication type of VPC connection.
    public var authentication: Swift.String?
    /// The list of client subnets.
    public var clientSubnets: [Swift.String]?
    /// The creation time of VPC connection.
    public var creationTime: ClientRuntime.Date?
    /// The list of security groups.
    public var securityGroups: [Swift.String]?
    /// The State of Vpc Connection.
    public var state: KafkaClientTypes.VpcConnectionState?
    /// A map of tags for the VPC connection.
    public var tags: [Swift.String:Swift.String]?
    /// The VPC connection ARN.
    public var vpcConnectionArn: Swift.String?
    /// The VPC ID of the VPC connection.
    public var vpcId: Swift.String?

    public init(
        authentication: Swift.String? = nil,
        clientSubnets: [Swift.String]? = nil,
        creationTime: ClientRuntime.Date? = nil,
        securityGroups: [Swift.String]? = nil,
        state: KafkaClientTypes.VpcConnectionState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConnectionArn: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.authentication = authentication
        self.clientSubnets = clientSubnets
        self.creationTime = creationTime
        self.securityGroups = securityGroups
        self.state = state
        self.tags = tags
        self.vpcConnectionArn = vpcConnectionArn
        self.vpcId = vpcId
    }
}

enum CreateVpcConnectionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension KafkaClientTypes {

    /// A type of an action required from the customer.
    public enum CustomerActionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionRecommended
        case criticalActionRequired
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomerActionStatus] {
            return [
                .actionRecommended,
                .criticalActionRequired,
                .none,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionRecommended: return "ACTION_RECOMMENDED"
            case .criticalActionRequired: return "CRITICAL_ACTION_REQUIRED"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeleteClusterInput {

    static func queryItemProvider(_ value: DeleteClusterInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let currentVersion = value.currentVersion {
            let currentVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "currentVersion".urlPercentEncoding(), value: Swift.String(currentVersion).urlPercentEncoding())
            items.append(currentVersionQueryItem)
        }
        return items
    }
}

extension DeleteClusterInput {

    static func urlPathProvider(_ value: DeleteClusterInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())"
    }
}

public struct DeleteClusterInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The current version of the MSK cluster.
    public var currentVersion: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
    }
}

extension DeleteClusterOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteClusterOutput()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

public struct DeleteClusterOutput {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
    public var state: KafkaClientTypes.ClusterState?

    public init(
        clusterArn: Swift.String? = nil,
        state: KafkaClientTypes.ClusterState? = nil
    )
    {
        self.clusterArn = clusterArn
        self.state = state
    }
}

enum DeleteClusterOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteClusterPolicyInput {

    static func urlPathProvider(_ value: DeleteClusterPolicyInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/policy"
    }
}

public struct DeleteClusterPolicyInput {
    /// The Amazon Resource Name (ARN) of the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

extension DeleteClusterPolicyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteClusterPolicyOutput {
        return DeleteClusterPolicyOutput()
    }
}

public struct DeleteClusterPolicyOutput {

    public init() { }
}

enum DeleteClusterPolicyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteConfigurationInput {

    static func urlPathProvider(_ value: DeleteConfigurationInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/configurations/\(arn.urlPercentEncoding())"
    }
}

public struct DeleteConfigurationInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension DeleteConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteConfigurationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

public struct DeleteConfigurationOutput {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration.
    public var arn: Swift.String?
    /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
    public var state: KafkaClientTypes.ConfigurationState?

    public init(
        arn: Swift.String? = nil,
        state: KafkaClientTypes.ConfigurationState? = nil
    )
    {
        self.arn = arn
        self.state = state
    }
}

enum DeleteConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteReplicatorInput {

    static func queryItemProvider(_ value: DeleteReplicatorInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let currentVersion = value.currentVersion {
            let currentVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "currentVersion".urlPercentEncoding(), value: Swift.String(currentVersion).urlPercentEncoding())
            items.append(currentVersionQueryItem)
        }
        return items
    }
}

extension DeleteReplicatorInput {

    static func urlPathProvider(_ value: DeleteReplicatorInput) -> Swift.String? {
        guard let replicatorArn = value.replicatorArn else {
            return nil
        }
        return "/replication/v1/replicators/\(replicatorArn.urlPercentEncoding())"
    }
}

public struct DeleteReplicatorInput {
    /// The current version of the replicator.
    public var currentVersion: Swift.String?
    /// The Amazon Resource Name (ARN) of the replicator to be deleted.
    /// This member is required.
    public var replicatorArn: Swift.String?

    public init(
        currentVersion: Swift.String? = nil,
        replicatorArn: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.replicatorArn = replicatorArn
    }
}

extension DeleteReplicatorOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteReplicatorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteReplicatorOutput()
        value.replicatorArn = try reader["replicatorArn"].readIfPresent()
        value.replicatorState = try reader["replicatorState"].readIfPresent()
        return value
    }
}

public struct DeleteReplicatorOutput {
    /// The Amazon Resource Name (ARN) of the replicator.
    public var replicatorArn: Swift.String?
    /// The state of the replicator.
    public var replicatorState: KafkaClientTypes.ReplicatorState?

    public init(
        replicatorArn: Swift.String? = nil,
        replicatorState: KafkaClientTypes.ReplicatorState? = nil
    )
    {
        self.replicatorArn = replicatorArn
        self.replicatorState = replicatorState
    }
}

enum DeleteReplicatorOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteVpcConnectionInput {

    static func urlPathProvider(_ value: DeleteVpcConnectionInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/vpc-connection/\(arn.urlPercentEncoding())"
    }
}

public struct DeleteVpcConnectionInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK VPC connection.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension DeleteVpcConnectionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteVpcConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVpcConnectionOutput()
        value.state = try reader["state"].readIfPresent()
        value.vpcConnectionArn = try reader["vpcConnectionArn"].readIfPresent()
        return value
    }
}

public struct DeleteVpcConnectionOutput {
    /// The state of the VPC connection.
    public var state: KafkaClientTypes.VpcConnectionState?
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK VPC connection.
    public var vpcConnectionArn: Swift.String?

    public init(
        state: KafkaClientTypes.VpcConnectionState? = nil,
        vpcConnectionArn: Swift.String? = nil
    )
    {
        self.state = state
        self.vpcConnectionArn = vpcConnectionArn
    }
}

enum DeleteVpcConnectionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeClusterInput {

    static func urlPathProvider(_ value: DescribeClusterInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())"
    }
}

public struct DescribeClusterInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

extension DescribeClusterOperationInput {

    static func urlPathProvider(_ value: DescribeClusterOperationInput) -> Swift.String? {
        guard let clusterOperationArn = value.clusterOperationArn else {
            return nil
        }
        return "/v1/operations/\(clusterOperationArn.urlPercentEncoding())"
    }
}

public struct DescribeClusterOperationInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies the MSK cluster operation.
    /// This member is required.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterOperationArn = clusterOperationArn
    }
}

extension DescribeClusterOperationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeClusterOperationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeClusterOperationOutput()
        value.clusterOperationInfo = try reader["clusterOperationInfo"].readIfPresent(with: KafkaClientTypes.ClusterOperationInfo.read(from:))
        return value
    }
}

public struct DescribeClusterOperationOutput {
    /// Cluster operation information
    public var clusterOperationInfo: KafkaClientTypes.ClusterOperationInfo?

    public init(
        clusterOperationInfo: KafkaClientTypes.ClusterOperationInfo? = nil
    )
    {
        self.clusterOperationInfo = clusterOperationInfo
    }
}

enum DescribeClusterOperationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeClusterOperationV2Input {

    static func urlPathProvider(_ value: DescribeClusterOperationV2Input) -> Swift.String? {
        guard let clusterOperationArn = value.clusterOperationArn else {
            return nil
        }
        return "/api/v2/operations/\(clusterOperationArn.urlPercentEncoding())"
    }
}

public struct DescribeClusterOperationV2Input {
    /// ARN of the cluster operation to describe.
    /// This member is required.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterOperationArn = clusterOperationArn
    }
}

extension DescribeClusterOperationV2Output {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeClusterOperationV2Output {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeClusterOperationV2Output()
        value.clusterOperationInfo = try reader["clusterOperationInfo"].readIfPresent(with: KafkaClientTypes.ClusterOperationV2.read(from:))
        return value
    }
}

public struct DescribeClusterOperationV2Output {
    /// Cluster operation information
    public var clusterOperationInfo: KafkaClientTypes.ClusterOperationV2?

    public init(
        clusterOperationInfo: KafkaClientTypes.ClusterOperationV2? = nil
    )
    {
        self.clusterOperationInfo = clusterOperationInfo
    }
}

enum DescribeClusterOperationV2OutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeClusterOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeClusterOutput()
        value.clusterInfo = try reader["clusterInfo"].readIfPresent(with: KafkaClientTypes.ClusterInfo.read(from:))
        return value
    }
}

public struct DescribeClusterOutput {
    /// The cluster information.
    public var clusterInfo: KafkaClientTypes.ClusterInfo?

    public init(
        clusterInfo: KafkaClientTypes.ClusterInfo? = nil
    )
    {
        self.clusterInfo = clusterInfo
    }
}

enum DescribeClusterOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeClusterV2Input {

    static func urlPathProvider(_ value: DescribeClusterV2Input) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/api/v2/clusters/\(clusterArn.urlPercentEncoding())"
    }
}

public struct DescribeClusterV2Input {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

extension DescribeClusterV2Output {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeClusterV2Output {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeClusterV2Output()
        value.clusterInfo = try reader["clusterInfo"].readIfPresent(with: KafkaClientTypes.Cluster.read(from:))
        return value
    }
}

public struct DescribeClusterV2Output {
    /// The cluster information.
    public var clusterInfo: KafkaClientTypes.Cluster?

    public init(
        clusterInfo: KafkaClientTypes.Cluster? = nil
    )
    {
        self.clusterInfo = clusterInfo
    }
}

enum DescribeClusterV2OutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeConfigurationInput {

    static func urlPathProvider(_ value: DescribeConfigurationInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/configurations/\(arn.urlPercentEncoding())"
    }
}

public struct DescribeConfigurationInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension DescribeConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConfigurationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.kafkaVersions = try reader["kafkaVersions"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.latestRevision = try reader["latestRevision"].readIfPresent(with: KafkaClientTypes.ConfigurationRevision.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

public struct DescribeConfigurationOutput {
    /// The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// The time when the configuration was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the configuration.
    public var description: Swift.String?
    /// The versions of Apache Kafka with which you can use this MSK configuration.
    public var kafkaVersions: [Swift.String]?
    /// Latest revision of the configuration.
    public var latestRevision: KafkaClientTypes.ConfigurationRevision?
    /// The name of the configuration.
    public var name: Swift.String?
    /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
    public var state: KafkaClientTypes.ConfigurationState?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        kafkaVersions: [Swift.String]? = nil,
        latestRevision: KafkaClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil,
        state: KafkaClientTypes.ConfigurationState? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.kafkaVersions = kafkaVersions
        self.latestRevision = latestRevision
        self.name = name
        self.state = state
    }
}

enum DescribeConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeConfigurationRevisionInput {

    static func urlPathProvider(_ value: DescribeConfigurationRevisionInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        guard let revision = value.revision else {
            return nil
        }
        return "/v1/configurations/\(arn.urlPercentEncoding())/revisions/\(revision)"
    }
}

public struct DescribeConfigurationRevisionInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
    /// This member is required.
    public var arn: Swift.String?
    /// A string that uniquely identifies a revision of an MSK configuration.
    /// This member is required.
    public var revision: Swift.Int?

    public init(
        arn: Swift.String? = nil,
        revision: Swift.Int? = nil
    )
    {
        self.arn = arn
        self.revision = revision
    }
}

extension DescribeConfigurationRevisionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeConfigurationRevisionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConfigurationRevisionOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        value.serverProperties = try reader["serverProperties"].readIfPresent()
        return value
    }
}

public struct DescribeConfigurationRevisionOutput {
    /// The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// The time when the configuration was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the configuration.
    public var description: Swift.String?
    /// The revision number.
    public var revision: Swift.Int?
    /// Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded. When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
    public var serverProperties: ClientRuntime.Data?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        revision: Swift.Int? = nil,
        serverProperties: ClientRuntime.Data? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.revision = revision
        self.serverProperties = serverProperties
    }
}

enum DescribeConfigurationRevisionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeReplicatorInput {

    static func urlPathProvider(_ value: DescribeReplicatorInput) -> Swift.String? {
        guard let replicatorArn = value.replicatorArn else {
            return nil
        }
        return "/replication/v1/replicators/\(replicatorArn.urlPercentEncoding())"
    }
}

public struct DescribeReplicatorInput {
    /// The Amazon Resource Name (ARN) of the replicator to be described.
    /// This member is required.
    public var replicatorArn: Swift.String?

    public init(
        replicatorArn: Swift.String? = nil
    )
    {
        self.replicatorArn = replicatorArn
    }
}

extension DescribeReplicatorOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeReplicatorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReplicatorOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.currentVersion = try reader["currentVersion"].readIfPresent()
        value.isReplicatorReference = try reader["isReplicatorReference"].readIfPresent()
        value.kafkaClusters = try reader["kafkaClusters"].readListIfPresent(memberReadingClosure: KafkaClientTypes.KafkaClusterDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.replicationInfoList = try reader["replicationInfoList"].readListIfPresent(memberReadingClosure: KafkaClientTypes.ReplicationInfoDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.replicatorArn = try reader["replicatorArn"].readIfPresent()
        value.replicatorDescription = try reader["replicatorDescription"].readIfPresent()
        value.replicatorName = try reader["replicatorName"].readIfPresent()
        value.replicatorResourceArn = try reader["replicatorResourceArn"].readIfPresent()
        value.replicatorState = try reader["replicatorState"].readIfPresent()
        value.serviceExecutionRoleArn = try reader["serviceExecutionRoleArn"].readIfPresent()
        value.stateInfo = try reader["stateInfo"].readIfPresent(with: KafkaClientTypes.ReplicationStateInfo.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct DescribeReplicatorOutput {
    /// The time when the replicator was created.
    public var creationTime: ClientRuntime.Date?
    /// The current version number of the replicator.
    public var currentVersion: Swift.String?
    /// Whether this resource is a replicator reference.
    public var isReplicatorReference: Swift.Bool?
    /// Kafka Clusters used in setting up sources / targets for replication.
    public var kafkaClusters: [KafkaClientTypes.KafkaClusterDescription]?
    /// A list of replication configurations, where each configuration targets a given source cluster to target cluster replication flow.
    public var replicationInfoList: [KafkaClientTypes.ReplicationInfoDescription]?
    /// The Amazon Resource Name (ARN) of the replicator.
    public var replicatorArn: Swift.String?
    /// The description of the replicator.
    public var replicatorDescription: Swift.String?
    /// The name of the replicator.
    public var replicatorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the replicator resource in the region where the replicator was created.
    public var replicatorResourceArn: Swift.String?
    /// State of the replicator.
    public var replicatorState: KafkaClientTypes.ReplicatorState?
    /// The Amazon Resource Name (ARN) of the IAM role used by the replicator to access resources in the customer's account (e.g source and target clusters)
    public var serviceExecutionRoleArn: Swift.String?
    /// Details about the state of the replicator.
    public var stateInfo: KafkaClientTypes.ReplicationStateInfo?
    /// List of tags attached to the Replicator.
    public var tags: [Swift.String:Swift.String]?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        currentVersion: Swift.String? = nil,
        isReplicatorReference: Swift.Bool? = nil,
        kafkaClusters: [KafkaClientTypes.KafkaClusterDescription]? = nil,
        replicationInfoList: [KafkaClientTypes.ReplicationInfoDescription]? = nil,
        replicatorArn: Swift.String? = nil,
        replicatorDescription: Swift.String? = nil,
        replicatorName: Swift.String? = nil,
        replicatorResourceArn: Swift.String? = nil,
        replicatorState: KafkaClientTypes.ReplicatorState? = nil,
        serviceExecutionRoleArn: Swift.String? = nil,
        stateInfo: KafkaClientTypes.ReplicationStateInfo? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.creationTime = creationTime
        self.currentVersion = currentVersion
        self.isReplicatorReference = isReplicatorReference
        self.kafkaClusters = kafkaClusters
        self.replicationInfoList = replicationInfoList
        self.replicatorArn = replicatorArn
        self.replicatorDescription = replicatorDescription
        self.replicatorName = replicatorName
        self.replicatorResourceArn = replicatorResourceArn
        self.replicatorState = replicatorState
        self.serviceExecutionRoleArn = serviceExecutionRoleArn
        self.stateInfo = stateInfo
        self.tags = tags
    }
}

enum DescribeReplicatorOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeVpcConnectionInput {

    static func urlPathProvider(_ value: DescribeVpcConnectionInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/vpc-connection/\(arn.urlPercentEncoding())"
    }
}

public struct DescribeVpcConnectionInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies a MSK VPC connection.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension DescribeVpcConnectionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeVpcConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVpcConnectionOutput()
        value.authentication = try reader["authentication"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["state"].readIfPresent()
        value.subnets = try reader["subnets"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targetClusterArn = try reader["targetClusterArn"].readIfPresent()
        value.vpcConnectionArn = try reader["vpcConnectionArn"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        return value
    }
}

public struct DescribeVpcConnectionOutput {
    /// The authentication type of VPC connection.
    public var authentication: Swift.String?
    /// The creation time of the VPC connection.
    public var creationTime: ClientRuntime.Date?
    /// The list of security groups for the VPC connection.
    public var securityGroups: [Swift.String]?
    /// The state of VPC connection.
    public var state: KafkaClientTypes.VpcConnectionState?
    /// The list of subnets for the VPC connection.
    public var subnets: [Swift.String]?
    /// A map of tags for the VPC connection.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK cluster.
    public var targetClusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) that uniquely identifies a MSK VPC connection.
    public var vpcConnectionArn: Swift.String?
    /// The VPC Id for the VPC connection.
    public var vpcId: Swift.String?

    public init(
        authentication: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        securityGroups: [Swift.String]? = nil,
        state: KafkaClientTypes.VpcConnectionState? = nil,
        subnets: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetClusterArn: Swift.String? = nil,
        vpcConnectionArn: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.authentication = authentication
        self.creationTime = creationTime
        self.securityGroups = securityGroups
        self.state = state
        self.subnets = subnets
        self.tags = tags
        self.targetClusterArn = targetClusterArn
        self.vpcConnectionArn = vpcConnectionArn
        self.vpcId = vpcId
    }
}

enum DescribeVpcConnectionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension KafkaClientTypes.EBSStorageInfo {

    static func write(value: KafkaClientTypes.EBSStorageInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["provisionedThroughput"].write(value.provisionedThroughput, with: KafkaClientTypes.ProvisionedThroughput.write(value:to:))
        try writer["volumeSize"].write(value.volumeSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.EBSStorageInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.EBSStorageInfo()
        value.provisionedThroughput = try reader["provisionedThroughput"].readIfPresent(with: KafkaClientTypes.ProvisionedThroughput.read(from:))
        value.volumeSize = try reader["volumeSize"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Contains information about the EBS storage volumes attached to Apache Kafka broker nodes.
    public struct EBSStorageInfo {
        /// EBS volume provisioned throughput information.
        public var provisionedThroughput: KafkaClientTypes.ProvisionedThroughput?
        /// The size in GiB of the EBS volume for the data drive on each broker node.
        public var volumeSize: Swift.Int?

        public init(
            provisionedThroughput: KafkaClientTypes.ProvisionedThroughput? = nil,
            volumeSize: Swift.Int? = nil
        )
        {
            self.provisionedThroughput = provisionedThroughput
            self.volumeSize = volumeSize
        }
    }

}

extension KafkaClientTypes.EncryptionAtRest {

    static func write(value: KafkaClientTypes.EncryptionAtRest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataVolumeKMSKeyId"].write(value.dataVolumeKMSKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.EncryptionAtRest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.EncryptionAtRest()
        value.dataVolumeKMSKeyId = try reader["dataVolumeKMSKeyId"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// The data-volume encryption details.
    public struct EncryptionAtRest {
        /// The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.
        /// This member is required.
        public var dataVolumeKMSKeyId: Swift.String?

        public init(
            dataVolumeKMSKeyId: Swift.String? = nil
        )
        {
            self.dataVolumeKMSKeyId = dataVolumeKMSKeyId
        }
    }

}

extension KafkaClientTypes.EncryptionInTransit {

    static func write(value: KafkaClientTypes.EncryptionInTransit?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientBroker"].write(value.clientBroker)
        try writer["inCluster"].write(value.inCluster)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.EncryptionInTransit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.EncryptionInTransit()
        value.clientBroker = try reader["clientBroker"].readIfPresent()
        value.inCluster = try reader["inCluster"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// The settings for encrypting data in transit.
    public struct EncryptionInTransit {
        /// Indicates the encryption setting for data in transit between clients and brokers. The following are the possible values. TLS means that client-broker communication is enabled with TLS only. TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data. PLAINTEXT means that client-broker communication is enabled in plaintext only. The default value is TLS_PLAINTEXT.
        public var clientBroker: KafkaClientTypes.ClientBroker?
        /// When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext. The default value is true.
        public var inCluster: Swift.Bool?

        public init(
            clientBroker: KafkaClientTypes.ClientBroker? = nil,
            inCluster: Swift.Bool? = nil
        )
        {
            self.clientBroker = clientBroker
            self.inCluster = inCluster
        }
    }

}

extension KafkaClientTypes.EncryptionInfo {

    static func write(value: KafkaClientTypes.EncryptionInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionAtRest"].write(value.encryptionAtRest, with: KafkaClientTypes.EncryptionAtRest.write(value:to:))
        try writer["encryptionInTransit"].write(value.encryptionInTransit, with: KafkaClientTypes.EncryptionInTransit.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.EncryptionInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.EncryptionInfo()
        value.encryptionAtRest = try reader["encryptionAtRest"].readIfPresent(with: KafkaClientTypes.EncryptionAtRest.read(from:))
        value.encryptionInTransit = try reader["encryptionInTransit"].readIfPresent(with: KafkaClientTypes.EncryptionInTransit.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Includes encryption-related information, such as the AWS KMS key used for encrypting data at rest and whether you want MSK to encrypt your data in transit.
    public struct EncryptionInfo {
        /// The data-volume encryption details.
        public var encryptionAtRest: KafkaClientTypes.EncryptionAtRest?
        /// The details for encryption in transit.
        public var encryptionInTransit: KafkaClientTypes.EncryptionInTransit?

        public init(
            encryptionAtRest: KafkaClientTypes.EncryptionAtRest? = nil,
            encryptionInTransit: KafkaClientTypes.EncryptionInTransit? = nil
        )
        {
            self.encryptionAtRest = encryptionAtRest
            self.encryptionInTransit = encryptionInTransit
        }
    }

}

extension KafkaClientTypes {

    /// Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see [Monitoring](https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html).
    public enum EnhancedMonitoring: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case perBroker
        case perTopicPerBroker
        case perTopicPerPartition
        case sdkUnknown(Swift.String)

        public static var allCases: [EnhancedMonitoring] {
            return [
                .default,
                .perBroker,
                .perTopicPerBroker,
                .perTopicPerPartition,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .perBroker: return "PER_BROKER"
            case .perTopicPerBroker: return "PER_TOPIC_PER_BROKER"
            case .perTopicPerPartition: return "PER_TOPIC_PER_PARTITION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaClientTypes.ErrorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ErrorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ErrorInfo()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorString = try reader["errorString"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Returns information about an error state of the cluster.
    public struct ErrorInfo {
        /// A number describing the error programmatically.
        public var errorCode: Swift.String?
        /// An optional field to provide more details about the error.
        public var errorString: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorString: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorString = errorString
        }
    }

}

extension KafkaClientTypes.Firehose {

    static func write(value: KafkaClientTypes.Firehose?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deliveryStream"].write(value.deliveryStream)
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.Firehose {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.Firehose()
        value.deliveryStream = try reader["deliveryStream"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    public struct Firehose {
        public var deliveryStream: Swift.String?
        /// This member is required.
        public var enabled: Swift.Bool?

        public init(
            deliveryStream: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.deliveryStream = deliveryStream
            self.enabled = enabled
        }
    }

}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.invalidParameter = try reader["invalidParameter"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Returns information about an error.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

extension GetBootstrapBrokersInput {

    static func urlPathProvider(_ value: GetBootstrapBrokersInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/bootstrap-brokers"
    }
}

public struct GetBootstrapBrokersInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

extension GetBootstrapBrokersOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetBootstrapBrokersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBootstrapBrokersOutput()
        value.bootstrapBrokerString = try reader["bootstrapBrokerString"].readIfPresent()
        value.bootstrapBrokerStringPublicSaslIam = try reader["bootstrapBrokerStringPublicSaslIam"].readIfPresent()
        value.bootstrapBrokerStringPublicSaslScram = try reader["bootstrapBrokerStringPublicSaslScram"].readIfPresent()
        value.bootstrapBrokerStringPublicTls = try reader["bootstrapBrokerStringPublicTls"].readIfPresent()
        value.bootstrapBrokerStringSaslIam = try reader["bootstrapBrokerStringSaslIam"].readIfPresent()
        value.bootstrapBrokerStringSaslScram = try reader["bootstrapBrokerStringSaslScram"].readIfPresent()
        value.bootstrapBrokerStringTls = try reader["bootstrapBrokerStringTls"].readIfPresent()
        value.bootstrapBrokerStringVpcConnectivitySaslIam = try reader["bootstrapBrokerStringVpcConnectivitySaslIam"].readIfPresent()
        value.bootstrapBrokerStringVpcConnectivitySaslScram = try reader["bootstrapBrokerStringVpcConnectivitySaslScram"].readIfPresent()
        value.bootstrapBrokerStringVpcConnectivityTls = try reader["bootstrapBrokerStringVpcConnectivityTls"].readIfPresent()
        return value
    }
}

public struct GetBootstrapBrokersOutput {
    /// A string containing one or more hostname:port pairs.
    public var bootstrapBrokerString: Swift.String?
    /// A string that contains one or more DNS names (or IP addresses) and SASL IAM port pairs.
    public var bootstrapBrokerStringPublicSaslIam: Swift.String?
    /// A string containing one or more DNS names (or IP) and Sasl Scram port pairs.
    public var bootstrapBrokerStringPublicSaslScram: Swift.String?
    /// A string containing one or more DNS names (or IP) and TLS port pairs.
    public var bootstrapBrokerStringPublicTls: Swift.String?
    /// A string that contains one or more DNS names (or IP addresses) and SASL IAM port pairs.
    public var bootstrapBrokerStringSaslIam: Swift.String?
    /// A string containing one or more DNS names (or IP) and Sasl Scram port pairs.
    public var bootstrapBrokerStringSaslScram: Swift.String?
    /// A string containing one or more DNS names (or IP) and TLS port pairs.
    public var bootstrapBrokerStringTls: Swift.String?
    /// A string containing one or more DNS names (or IP) and SASL/IAM port pairs for VPC connectivity.
    public var bootstrapBrokerStringVpcConnectivitySaslIam: Swift.String?
    /// A string containing one or more DNS names (or IP) and SASL/SCRAM port pairs for VPC connectivity.
    public var bootstrapBrokerStringVpcConnectivitySaslScram: Swift.String?
    /// A string containing one or more DNS names (or IP) and TLS port pairs for VPC connectivity.
    public var bootstrapBrokerStringVpcConnectivityTls: Swift.String?

    public init(
        bootstrapBrokerString: Swift.String? = nil,
        bootstrapBrokerStringPublicSaslIam: Swift.String? = nil,
        bootstrapBrokerStringPublicSaslScram: Swift.String? = nil,
        bootstrapBrokerStringPublicTls: Swift.String? = nil,
        bootstrapBrokerStringSaslIam: Swift.String? = nil,
        bootstrapBrokerStringSaslScram: Swift.String? = nil,
        bootstrapBrokerStringTls: Swift.String? = nil,
        bootstrapBrokerStringVpcConnectivitySaslIam: Swift.String? = nil,
        bootstrapBrokerStringVpcConnectivitySaslScram: Swift.String? = nil,
        bootstrapBrokerStringVpcConnectivityTls: Swift.String? = nil
    )
    {
        self.bootstrapBrokerString = bootstrapBrokerString
        self.bootstrapBrokerStringPublicSaslIam = bootstrapBrokerStringPublicSaslIam
        self.bootstrapBrokerStringPublicSaslScram = bootstrapBrokerStringPublicSaslScram
        self.bootstrapBrokerStringPublicTls = bootstrapBrokerStringPublicTls
        self.bootstrapBrokerStringSaslIam = bootstrapBrokerStringSaslIam
        self.bootstrapBrokerStringSaslScram = bootstrapBrokerStringSaslScram
        self.bootstrapBrokerStringTls = bootstrapBrokerStringTls
        self.bootstrapBrokerStringVpcConnectivitySaslIam = bootstrapBrokerStringVpcConnectivitySaslIam
        self.bootstrapBrokerStringVpcConnectivitySaslScram = bootstrapBrokerStringVpcConnectivitySaslScram
        self.bootstrapBrokerStringVpcConnectivityTls = bootstrapBrokerStringVpcConnectivityTls
    }
}

enum GetBootstrapBrokersOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetClusterPolicyInput {

    static func urlPathProvider(_ value: GetClusterPolicyInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/policy"
    }
}

public struct GetClusterPolicyInput {
    /// The Amazon Resource Name (ARN) of the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

extension GetClusterPolicyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetClusterPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetClusterPolicyOutput()
        value.currentVersion = try reader["currentVersion"].readIfPresent()
        value.policy = try reader["policy"].readIfPresent()
        return value
    }
}

public struct GetClusterPolicyOutput {
    /// The version of cluster policy.
    public var currentVersion: Swift.String?
    /// The cluster policy.
    public var policy: Swift.String?

    public init(
        currentVersion: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.policy = policy
    }
}

enum GetClusterPolicyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetCompatibleKafkaVersionsInput {

    static func queryItemProvider(_ value: GetCompatibleKafkaVersionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clusterArn = value.clusterArn {
            let clusterArnQueryItem = ClientRuntime.SDKURLQueryItem(name: "clusterArn".urlPercentEncoding(), value: Swift.String(clusterArn).urlPercentEncoding())
            items.append(clusterArnQueryItem)
        }
        return items
    }
}

extension GetCompatibleKafkaVersionsInput {

    static func urlPathProvider(_ value: GetCompatibleKafkaVersionsInput) -> Swift.String? {
        return "/v1/compatible-kafka-versions"
    }
}

public struct GetCompatibleKafkaVersionsInput {
    /// The Amazon Resource Name (ARN) of the cluster check.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

extension GetCompatibleKafkaVersionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetCompatibleKafkaVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCompatibleKafkaVersionsOutput()
        value.compatibleKafkaVersions = try reader["compatibleKafkaVersions"].readListIfPresent(memberReadingClosure: KafkaClientTypes.CompatibleKafkaVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct GetCompatibleKafkaVersionsOutput {
    /// A list of CompatibleKafkaVersion objects.
    public var compatibleKafkaVersions: [KafkaClientTypes.CompatibleKafkaVersion]?

    public init(
        compatibleKafkaVersions: [KafkaClientTypes.CompatibleKafkaVersion]? = nil
    )
    {
        self.compatibleKafkaVersions = compatibleKafkaVersions
    }
}

enum GetCompatibleKafkaVersionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension KafkaClientTypes.Iam {

    static func write(value: KafkaClientTypes.Iam?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.Iam {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.Iam()
        value.enabled = try reader["enabled"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Details for IAM access control.
    public struct Iam {
        /// Indicates whether IAM access control is enabled.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.invalidParameter = try reader["invalidParameter"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Returns information about an error.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

extension KafkaClientTypes.JmxExporter {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.JmxExporter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.JmxExporter()
        value.enabledInBroker = try reader["enabledInBroker"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Indicates whether you want to turn on or turn off the JMX Exporter.
    public struct JmxExporter {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        /// This member is required.
        public var enabledInBroker: Swift.Bool?

        public init(
            enabledInBroker: Swift.Bool? = nil
        )
        {
            self.enabledInBroker = enabledInBroker
        }
    }

}

extension KafkaClientTypes.JmxExporterInfo {

    static func write(value: KafkaClientTypes.JmxExporterInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabledInBroker"].write(value.enabledInBroker)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.JmxExporterInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.JmxExporterInfo()
        value.enabledInBroker = try reader["enabledInBroker"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Indicates whether you want to turn on or turn off the JMX Exporter.
    public struct JmxExporterInfo {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        /// This member is required.
        public var enabledInBroker: Swift.Bool?

        public init(
            enabledInBroker: Swift.Bool? = nil
        )
        {
            self.enabledInBroker = enabledInBroker
        }
    }

}

public enum KafkaClientTypes {}

extension KafkaClientTypes.KafkaCluster {

    static func write(value: KafkaClientTypes.KafkaCluster?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amazonMskCluster"].write(value.amazonMskCluster, with: KafkaClientTypes.AmazonMskCluster.write(value:to:))
        try writer["vpcConfig"].write(value.vpcConfig, with: KafkaClientTypes.KafkaClusterClientVpcConfig.write(value:to:))
    }
}

extension KafkaClientTypes {
    /// Information about Kafka Cluster to be used as source / target for replication.
    public struct KafkaCluster {
        /// Details of an Amazon MSK Cluster.
        /// This member is required.
        public var amazonMskCluster: KafkaClientTypes.AmazonMskCluster?
        /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        /// This member is required.
        public var vpcConfig: KafkaClientTypes.KafkaClusterClientVpcConfig?

        public init(
            amazonMskCluster: KafkaClientTypes.AmazonMskCluster? = nil,
            vpcConfig: KafkaClientTypes.KafkaClusterClientVpcConfig? = nil
        )
        {
            self.amazonMskCluster = amazonMskCluster
            self.vpcConfig = vpcConfig
        }
    }

}

extension KafkaClientTypes.KafkaClusterClientVpcConfig {

    static func write(value: KafkaClientTypes.KafkaClusterClientVpcConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.KafkaClusterClientVpcConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.KafkaClusterClientVpcConfig()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension KafkaClientTypes {
    /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
    public struct KafkaClusterClientVpcConfig {
        /// The security groups to attach to the ENIs for the broker nodes.
        public var securityGroupIds: [Swift.String]?
        /// The list of subnets in the client VPC to connect to.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension KafkaClientTypes.KafkaClusterDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.KafkaClusterDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.KafkaClusterDescription()
        value.amazonMskCluster = try reader["amazonMskCluster"].readIfPresent(with: KafkaClientTypes.AmazonMskCluster.read(from:))
        value.kafkaClusterAlias = try reader["kafkaClusterAlias"].readIfPresent()
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: KafkaClientTypes.KafkaClusterClientVpcConfig.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Information about Kafka Cluster used as source / target for replication.
    public struct KafkaClusterDescription {
        /// Details of an Amazon MSK Cluster.
        public var amazonMskCluster: KafkaClientTypes.AmazonMskCluster?
        /// The alias of the Kafka cluster. Used to prefix names of replicated topics.
        public var kafkaClusterAlias: Swift.String?
        /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        public var vpcConfig: KafkaClientTypes.KafkaClusterClientVpcConfig?

        public init(
            amazonMskCluster: KafkaClientTypes.AmazonMskCluster? = nil,
            kafkaClusterAlias: Swift.String? = nil,
            vpcConfig: KafkaClientTypes.KafkaClusterClientVpcConfig? = nil
        )
        {
            self.amazonMskCluster = amazonMskCluster
            self.kafkaClusterAlias = kafkaClusterAlias
            self.vpcConfig = vpcConfig
        }
    }

}

extension KafkaClientTypes.KafkaClusterSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.KafkaClusterSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.KafkaClusterSummary()
        value.amazonMskCluster = try reader["amazonMskCluster"].readIfPresent(with: KafkaClientTypes.AmazonMskCluster.read(from:))
        value.kafkaClusterAlias = try reader["kafkaClusterAlias"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Summarized information about Kafka Cluster used as source / target for replication.
    public struct KafkaClusterSummary {
        /// Details of an Amazon MSK Cluster.
        public var amazonMskCluster: KafkaClientTypes.AmazonMskCluster?
        /// The alias of the Kafka cluster. Used to prefix names of replicated topics.
        public var kafkaClusterAlias: Swift.String?

        public init(
            amazonMskCluster: KafkaClientTypes.AmazonMskCluster? = nil,
            kafkaClusterAlias: Swift.String? = nil
        )
        {
            self.amazonMskCluster = amazonMskCluster
            self.kafkaClusterAlias = kafkaClusterAlias
        }
    }

}

extension KafkaClientTypes.KafkaVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.KafkaVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.KafkaVersion()
        value.version = try reader["version"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    public struct KafkaVersion {
        public var status: KafkaClientTypes.KafkaVersionStatus?
        public var version: Swift.String?

        public init(
            status: KafkaClientTypes.KafkaVersionStatus? = nil,
            version: Swift.String? = nil
        )
        {
            self.status = status
            self.version = version
        }
    }

}

extension KafkaClientTypes {

    public enum KafkaVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deprecated
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaVersionStatus] {
            return [
                .active,
                .deprecated,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deprecated: return "DEPRECATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ListClientVpcConnectionsInput {

    static func queryItemProvider(_ value: ListClientVpcConnectionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListClientVpcConnectionsInput {

    static func urlPathProvider(_ value: ListClientVpcConnectionsInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/client-vpc-connections"
    }
}

public struct ListClientVpcConnectionsInput {
    /// The Amazon Resource Name (ARN) of the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListClientVpcConnectionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListClientVpcConnectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListClientVpcConnectionsOutput()
        value.clientVpcConnections = try reader["clientVpcConnections"].readListIfPresent(memberReadingClosure: KafkaClientTypes.ClientVpcConnection.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListClientVpcConnectionsOutput {
    /// List of client VPC connections.
    public var clientVpcConnections: [KafkaClientTypes.ClientVpcConnection]?
    /// The paginated results marker. When the result of a ListClientVpcConnections operation is truncated, the call returns NextToken in the response. To get another batch of configurations, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clientVpcConnections: [KafkaClientTypes.ClientVpcConnection]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clientVpcConnections = clientVpcConnections
        self.nextToken = nextToken
    }
}

enum ListClientVpcConnectionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListClusterOperationsInput {

    static func queryItemProvider(_ value: ListClusterOperationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListClusterOperationsInput {

    static func urlPathProvider(_ value: ListClusterOperationsInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/operations"
    }
}

public struct ListClusterOperationsInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListClusterOperationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListClusterOperationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListClusterOperationsOutput()
        value.clusterOperationInfoList = try reader["clusterOperationInfoList"].readListIfPresent(memberReadingClosure: KafkaClientTypes.ClusterOperationInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListClusterOperationsOutput {
    /// An array of cluster operation information objects.
    public var clusterOperationInfoList: [KafkaClientTypes.ClusterOperationInfo]?
    /// If the response of ListClusterOperations is truncated, it returns a NextToken in the response. This Nexttoken should be sent in the subsequent request to ListClusterOperations.
    public var nextToken: Swift.String?

    public init(
        clusterOperationInfoList: [KafkaClientTypes.ClusterOperationInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterOperationInfoList = clusterOperationInfoList
        self.nextToken = nextToken
    }
}

enum ListClusterOperationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListClusterOperationsV2Input {

    static func queryItemProvider(_ value: ListClusterOperationsV2Input) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListClusterOperationsV2Input {

    static func urlPathProvider(_ value: ListClusterOperationsV2Input) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/api/v2/clusters/\(clusterArn.urlPercentEncoding())/operations"
    }
}

public struct ListClusterOperationsV2Input {
    /// The arn of the cluster whose operations are being requested.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The maxResults of the query.
    public var maxResults: Swift.Int?
    /// The nextToken of the query.
    public var nextToken: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListClusterOperationsV2Output {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListClusterOperationsV2Output {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListClusterOperationsV2Output()
        value.clusterOperationInfoList = try reader["clusterOperationInfoList"].readListIfPresent(memberReadingClosure: KafkaClientTypes.ClusterOperationV2Summary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListClusterOperationsV2Output {
    /// An array of cluster operation information objects.
    public var clusterOperationInfoList: [KafkaClientTypes.ClusterOperationV2Summary]?
    /// If the response of ListClusterOperationsV2 is truncated, it returns a NextToken in the response. This NextToken should be sent in the subsequent request to ListClusterOperationsV2.
    public var nextToken: Swift.String?

    public init(
        clusterOperationInfoList: [KafkaClientTypes.ClusterOperationV2Summary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterOperationInfoList = clusterOperationInfoList
        self.nextToken = nextToken
    }
}

enum ListClusterOperationsV2OutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListClustersInput {

    static func queryItemProvider(_ value: ListClustersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let clusterNameFilter = value.clusterNameFilter {
            let clusterNameFilterQueryItem = ClientRuntime.SDKURLQueryItem(name: "clusterNameFilter".urlPercentEncoding(), value: Swift.String(clusterNameFilter).urlPercentEncoding())
            items.append(clusterNameFilterQueryItem)
        }
        return items
    }
}

extension ListClustersInput {

    static func urlPathProvider(_ value: ListClustersInput) -> Swift.String? {
        return "/v1/clusters"
    }
}

public struct ListClustersInput {
    /// Specify a prefix of the name of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.
    public var clusterNameFilter: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clusterNameFilter: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterNameFilter = clusterNameFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListClustersOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListClustersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListClustersOutput()
        value.clusterInfoList = try reader["clusterInfoList"].readListIfPresent(memberReadingClosure: KafkaClientTypes.ClusterInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListClustersOutput {
    /// Information on each of the MSK clusters in the response.
    public var clusterInfoList: [KafkaClientTypes.ClusterInfo]?
    /// The paginated results marker. When the result of a ListClusters operation is truncated, the call returns NextToken in the response. To get another batch of clusters, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clusterInfoList: [KafkaClientTypes.ClusterInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterInfoList = clusterInfoList
        self.nextToken = nextToken
    }
}

enum ListClustersOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListClustersV2Input {

    static func queryItemProvider(_ value: ListClustersV2Input) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clusterTypeFilter = value.clusterTypeFilter {
            let clusterTypeFilterQueryItem = ClientRuntime.SDKURLQueryItem(name: "clusterTypeFilter".urlPercentEncoding(), value: Swift.String(clusterTypeFilter).urlPercentEncoding())
            items.append(clusterTypeFilterQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let clusterNameFilter = value.clusterNameFilter {
            let clusterNameFilterQueryItem = ClientRuntime.SDKURLQueryItem(name: "clusterNameFilter".urlPercentEncoding(), value: Swift.String(clusterNameFilter).urlPercentEncoding())
            items.append(clusterNameFilterQueryItem)
        }
        return items
    }
}

extension ListClustersV2Input {

    static func urlPathProvider(_ value: ListClustersV2Input) -> Swift.String? {
        return "/api/v2/clusters"
    }
}

public struct ListClustersV2Input {
    /// Specify a prefix of the names of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.
    public var clusterNameFilter: Swift.String?
    /// Specify either PROVISIONED or SERVERLESS.
    public var clusterTypeFilter: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clusterNameFilter: Swift.String? = nil,
        clusterTypeFilter: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterNameFilter = clusterNameFilter
        self.clusterTypeFilter = clusterTypeFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListClustersV2Output {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListClustersV2Output {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListClustersV2Output()
        value.clusterInfoList = try reader["clusterInfoList"].readListIfPresent(memberReadingClosure: KafkaClientTypes.Cluster.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListClustersV2Output {
    /// Information on each of the MSK clusters in the response.
    public var clusterInfoList: [KafkaClientTypes.Cluster]?
    /// The paginated results marker. When the result of a ListClusters operation is truncated, the call returns NextToken in the response. To get another batch of clusters, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clusterInfoList: [KafkaClientTypes.Cluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterInfoList = clusterInfoList
        self.nextToken = nextToken
    }
}

enum ListClustersV2OutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListConfigurationRevisionsInput {

    static func queryItemProvider(_ value: ListConfigurationRevisionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConfigurationRevisionsInput {

    static func urlPathProvider(_ value: ListConfigurationRevisionsInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/configurations/\(arn.urlPercentEncoding())/revisions"
    }
}

public struct ListConfigurationRevisionsInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
    /// This member is required.
    public var arn: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListConfigurationRevisionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListConfigurationRevisionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConfigurationRevisionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.revisions = try reader["revisions"].readListIfPresent(memberReadingClosure: KafkaClientTypes.ConfigurationRevision.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListConfigurationRevisionsOutput {
    /// Paginated results marker.
    public var nextToken: Swift.String?
    /// List of ConfigurationRevision objects.
    public var revisions: [KafkaClientTypes.ConfigurationRevision]?

    public init(
        nextToken: Swift.String? = nil,
        revisions: [KafkaClientTypes.ConfigurationRevision]? = nil
    )
    {
        self.nextToken = nextToken
        self.revisions = revisions
    }
}

enum ListConfigurationRevisionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListConfigurationsInput {

    static func queryItemProvider(_ value: ListConfigurationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConfigurationsInput {

    static func urlPathProvider(_ value: ListConfigurationsInput) -> Swift.String? {
        return "/v1/configurations"
    }
}

public struct ListConfigurationsInput {
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListConfigurationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConfigurationsOutput()
        value.configurations = try reader["configurations"].readListIfPresent(memberReadingClosure: KafkaClientTypes.Configuration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListConfigurationsOutput {
    /// An array of MSK configurations.
    public var configurations: [KafkaClientTypes.Configuration]?
    /// The paginated results marker. When the result of a ListConfigurations operation is truncated, the call returns NextToken in the response. To get another batch of configurations, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        configurations: [KafkaClientTypes.Configuration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurations = configurations
        self.nextToken = nextToken
    }
}

enum ListConfigurationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListKafkaVersionsInput {

    static func queryItemProvider(_ value: ListKafkaVersionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKafkaVersionsInput {

    static func urlPathProvider(_ value: ListKafkaVersionsInput) -> Swift.String? {
        return "/v1/kafka-versions"
    }
}

public struct ListKafkaVersionsInput {
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListKafkaVersionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListKafkaVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKafkaVersionsOutput()
        value.kafkaVersions = try reader["kafkaVersions"].readListIfPresent(memberReadingClosure: KafkaClientTypes.KafkaVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListKafkaVersionsOutput {
    public var kafkaVersions: [KafkaClientTypes.KafkaVersion]?
    public var nextToken: Swift.String?

    public init(
        kafkaVersions: [KafkaClientTypes.KafkaVersion]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kafkaVersions = kafkaVersions
        self.nextToken = nextToken
    }
}

enum ListKafkaVersionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListNodesInput {

    static func queryItemProvider(_ value: ListNodesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListNodesInput {

    static func urlPathProvider(_ value: ListNodesInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/nodes"
    }
}

public struct ListNodesInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListNodesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListNodesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNodesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.nodeInfoList = try reader["nodeInfoList"].readListIfPresent(memberReadingClosure: KafkaClientTypes.NodeInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListNodesOutput {
    /// The paginated results marker. When the result of a ListNodes operation is truncated, the call returns NextToken in the response. To get another batch of nodes, provide this token in your next request.
    public var nextToken: Swift.String?
    /// List containing a NodeInfo object.
    public var nodeInfoList: [KafkaClientTypes.NodeInfo]?

    public init(
        nextToken: Swift.String? = nil,
        nodeInfoList: [KafkaClientTypes.NodeInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodeInfoList = nodeInfoList
    }
}

enum ListNodesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListReplicatorsInput {

    static func queryItemProvider(_ value: ListReplicatorsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let replicatorNameFilter = value.replicatorNameFilter {
            let replicatorNameFilterQueryItem = ClientRuntime.SDKURLQueryItem(name: "replicatorNameFilter".urlPercentEncoding(), value: Swift.String(replicatorNameFilter).urlPercentEncoding())
            items.append(replicatorNameFilterQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListReplicatorsInput {

    static func urlPathProvider(_ value: ListReplicatorsInput) -> Swift.String? {
        return "/replication/v1/replicators"
    }
}

public struct ListReplicatorsInput {
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// If the response of ListReplicators is truncated, it returns a NextToken in the response. This NextToken should be sent in the subsequent request to ListReplicators.
    public var nextToken: Swift.String?
    /// Returns replicators starting with given name.
    public var replicatorNameFilter: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        replicatorNameFilter: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.replicatorNameFilter = replicatorNameFilter
    }
}

extension ListReplicatorsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListReplicatorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReplicatorsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.replicators = try reader["replicators"].readListIfPresent(memberReadingClosure: KafkaClientTypes.ReplicatorSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListReplicatorsOutput {
    /// If the response of ListReplicators is truncated, it returns a NextToken in the response. This NextToken should be sent in the subsequent request to ListReplicators.
    public var nextToken: Swift.String?
    /// List containing information of each of the replicators in the account.
    public var replicators: [KafkaClientTypes.ReplicatorSummary]?

    public init(
        nextToken: Swift.String? = nil,
        replicators: [KafkaClientTypes.ReplicatorSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.replicators = replicators
    }
}

enum ListReplicatorsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListScramSecretsInput {

    static func queryItemProvider(_ value: ListScramSecretsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListScramSecretsInput {

    static func urlPathProvider(_ value: ListScramSecretsInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/scram-secrets"
    }
}

public struct ListScramSecretsInput {
    /// The arn of the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The maxResults of the query.
    public var maxResults: Swift.Int?
    /// The nextToken of the query.
    public var nextToken: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListScramSecretsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListScramSecretsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListScramSecretsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.secretArnList = try reader["secretArnList"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListScramSecretsOutput {
    /// Paginated results marker.
    public var nextToken: Swift.String?
    /// The list of scram secrets associated with the cluster.
    public var secretArnList: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        secretArnList: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.secretArnList = secretArnList
    }
}

enum ListScramSecretsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListVpcConnectionsInput {

    static func queryItemProvider(_ value: ListVpcConnectionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListVpcConnectionsInput {

    static func urlPathProvider(_ value: ListVpcConnectionsInput) -> Swift.String? {
        return "/v1/vpc-connections"
    }
}

public struct ListVpcConnectionsInput {
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListVpcConnectionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListVpcConnectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVpcConnectionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.vpcConnections = try reader["vpcConnections"].readListIfPresent(memberReadingClosure: KafkaClientTypes.VpcConnection.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListVpcConnectionsOutput {
    /// The paginated results marker. When the result of a ListClientVpcConnections operation is truncated, the call returns NextToken in the response. To get another batch of configurations, provide this token in your next request.
    public var nextToken: Swift.String?
    /// List of VPC connections.
    public var vpcConnections: [KafkaClientTypes.VpcConnection]?

    public init(
        nextToken: Swift.String? = nil,
        vpcConnections: [KafkaClientTypes.VpcConnection]? = nil
    )
    {
        self.nextToken = nextToken
        self.vpcConnections = vpcConnections
    }
}

enum ListVpcConnectionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension KafkaClientTypes.LoggingInfo {

    static func write(value: KafkaClientTypes.LoggingInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["brokerLogs"].write(value.brokerLogs, with: KafkaClientTypes.BrokerLogs.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.LoggingInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.LoggingInfo()
        value.brokerLogs = try reader["brokerLogs"].readIfPresent(with: KafkaClientTypes.BrokerLogs.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    public struct LoggingInfo {
        /// This member is required.
        public var brokerLogs: KafkaClientTypes.BrokerLogs?

        public init(
            brokerLogs: KafkaClientTypes.BrokerLogs? = nil
        )
        {
            self.brokerLogs = brokerLogs
        }
    }

}

extension KafkaClientTypes.MutableClusterInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.MutableClusterInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.MutableClusterInfo()
        value.brokerEBSVolumeInfo = try reader["brokerEBSVolumeInfo"].readListIfPresent(memberReadingClosure: KafkaClientTypes.BrokerEBSVolumeInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.configurationInfo = try reader["configurationInfo"].readIfPresent(with: KafkaClientTypes.ConfigurationInfo.read(from:))
        value.numberOfBrokerNodes = try reader["numberOfBrokerNodes"].readIfPresent()
        value.enhancedMonitoring = try reader["enhancedMonitoring"].readIfPresent()
        value.openMonitoring = try reader["openMonitoring"].readIfPresent(with: KafkaClientTypes.OpenMonitoring.read(from:))
        value.kafkaVersion = try reader["kafkaVersion"].readIfPresent()
        value.loggingInfo = try reader["loggingInfo"].readIfPresent(with: KafkaClientTypes.LoggingInfo.read(from:))
        value.instanceType = try reader["instanceType"].readIfPresent()
        value.clientAuthentication = try reader["clientAuthentication"].readIfPresent(with: KafkaClientTypes.ClientAuthentication.read(from:))
        value.encryptionInfo = try reader["encryptionInfo"].readIfPresent(with: KafkaClientTypes.EncryptionInfo.read(from:))
        value.connectivityInfo = try reader["connectivityInfo"].readIfPresent(with: KafkaClientTypes.ConnectivityInfo.read(from:))
        value.storageMode = try reader["storageMode"].readIfPresent()
        value.brokerCountUpdateInfo = try reader["brokerCountUpdateInfo"].readIfPresent(with: KafkaClientTypes.BrokerCountUpdateInfo.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Information about cluster attributes that can be updated via update APIs.
    public struct MutableClusterInfo {
        /// Describes brokers being changed during a broker count update.
        public var brokerCountUpdateInfo: KafkaClientTypes.BrokerCountUpdateInfo?
        /// Specifies the size of the EBS volume and the ID of the associated broker.
        public var brokerEBSVolumeInfo: [KafkaClientTypes.BrokerEBSVolumeInfo]?
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
        /// Information about the changes in the configuration of the brokers.
        public var configurationInfo: KafkaClientTypes.ConfigurationInfo?
        /// Information about the broker access configuration.
        public var connectivityInfo: KafkaClientTypes.ConnectivityInfo?
        /// Includes all encryption-related information.
        public var encryptionInfo: KafkaClientTypes.EncryptionInfo?
        /// Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.
        public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
        /// Information about the Amazon MSK broker type.
        public var instanceType: Swift.String?
        /// The Apache Kafka version.
        public var kafkaVersion: Swift.String?
        /// You can configure your MSK cluster to send broker logs to different destination types. This is a container for the configuration details related to broker logs.
        public var loggingInfo: KafkaClientTypes.LoggingInfo?
        /// The number of broker nodes in the cluster.
        public var numberOfBrokerNodes: Swift.Int?
        /// The settings for open monitoring.
        public var openMonitoring: KafkaClientTypes.OpenMonitoring?
        /// This controls storage mode for supported storage tiers.
        public var storageMode: KafkaClientTypes.StorageMode?

        public init(
            brokerCountUpdateInfo: KafkaClientTypes.BrokerCountUpdateInfo? = nil,
            brokerEBSVolumeInfo: [KafkaClientTypes.BrokerEBSVolumeInfo]? = nil,
            clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
            configurationInfo: KafkaClientTypes.ConfigurationInfo? = nil,
            connectivityInfo: KafkaClientTypes.ConnectivityInfo? = nil,
            encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil,
            enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
            instanceType: Swift.String? = nil,
            kafkaVersion: Swift.String? = nil,
            loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
            numberOfBrokerNodes: Swift.Int? = nil,
            openMonitoring: KafkaClientTypes.OpenMonitoring? = nil,
            storageMode: KafkaClientTypes.StorageMode? = nil
        )
        {
            self.brokerCountUpdateInfo = brokerCountUpdateInfo
            self.brokerEBSVolumeInfo = brokerEBSVolumeInfo
            self.clientAuthentication = clientAuthentication
            self.configurationInfo = configurationInfo
            self.connectivityInfo = connectivityInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.instanceType = instanceType
            self.kafkaVersion = kafkaVersion
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.storageMode = storageMode
        }
    }

}

extension KafkaClientTypes.NodeExporter {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.NodeExporter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.NodeExporter()
        value.enabledInBroker = try reader["enabledInBroker"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Indicates whether you want to turn on or turn off the Node Exporter.
    public struct NodeExporter {
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        /// This member is required.
        public var enabledInBroker: Swift.Bool?

        public init(
            enabledInBroker: Swift.Bool? = nil
        )
        {
            self.enabledInBroker = enabledInBroker
        }
    }

}

extension KafkaClientTypes.NodeExporterInfo {

    static func write(value: KafkaClientTypes.NodeExporterInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabledInBroker"].write(value.enabledInBroker)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.NodeExporterInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.NodeExporterInfo()
        value.enabledInBroker = try reader["enabledInBroker"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Indicates whether you want to turn on or turn off the Node Exporter.
    public struct NodeExporterInfo {
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        /// This member is required.
        public var enabledInBroker: Swift.Bool?

        public init(
            enabledInBroker: Swift.Bool? = nil
        )
        {
            self.enabledInBroker = enabledInBroker
        }
    }

}

extension KafkaClientTypes.NodeInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.NodeInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.NodeInfo()
        value.addedToClusterTime = try reader["addedToClusterTime"].readIfPresent()
        value.brokerNodeInfo = try reader["brokerNodeInfo"].readIfPresent(with: KafkaClientTypes.BrokerNodeInfo.read(from:))
        value.instanceType = try reader["instanceType"].readIfPresent()
        value.nodeARN = try reader["nodeARN"].readIfPresent()
        value.nodeType = try reader["nodeType"].readIfPresent()
        value.zookeeperNodeInfo = try reader["zookeeperNodeInfo"].readIfPresent(with: KafkaClientTypes.ZookeeperNodeInfo.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// The node information object.
    public struct NodeInfo {
        /// The start time.
        public var addedToClusterTime: Swift.String?
        /// The broker node info.
        public var brokerNodeInfo: KafkaClientTypes.BrokerNodeInfo?
        /// The instance type.
        public var instanceType: Swift.String?
        /// The Amazon Resource Name (ARN) of the node.
        public var nodeARN: Swift.String?
        /// The node type.
        public var nodeType: KafkaClientTypes.NodeType?
        /// The ZookeeperNodeInfo.
        public var zookeeperNodeInfo: KafkaClientTypes.ZookeeperNodeInfo?

        public init(
            addedToClusterTime: Swift.String? = nil,
            brokerNodeInfo: KafkaClientTypes.BrokerNodeInfo? = nil,
            instanceType: Swift.String? = nil,
            nodeARN: Swift.String? = nil,
            nodeType: KafkaClientTypes.NodeType? = nil,
            zookeeperNodeInfo: KafkaClientTypes.ZookeeperNodeInfo? = nil
        )
        {
            self.addedToClusterTime = addedToClusterTime
            self.brokerNodeInfo = brokerNodeInfo
            self.instanceType = instanceType
            self.nodeARN = nodeARN
            self.nodeType = nodeType
            self.zookeeperNodeInfo = zookeeperNodeInfo
        }
    }

}

extension KafkaClientTypes {

    /// The broker or Zookeeper node.
    public enum NodeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case broker
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeType] {
            return [
                .broker,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .broker: return "BROKER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.invalidParameter = try reader["invalidParameter"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Returns information about an error.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

extension KafkaClientTypes.OpenMonitoring {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.OpenMonitoring {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.OpenMonitoring()
        value.prometheus = try reader["prometheus"].readIfPresent(with: KafkaClientTypes.Prometheus.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// JMX and Node monitoring for the MSK cluster.
    public struct OpenMonitoring {
        /// Prometheus settings.
        /// This member is required.
        public var prometheus: KafkaClientTypes.Prometheus?

        public init(
            prometheus: KafkaClientTypes.Prometheus? = nil
        )
        {
            self.prometheus = prometheus
        }
    }

}

extension KafkaClientTypes.OpenMonitoringInfo {

    static func write(value: KafkaClientTypes.OpenMonitoringInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["prometheus"].write(value.prometheus, with: KafkaClientTypes.PrometheusInfo.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.OpenMonitoringInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.OpenMonitoringInfo()
        value.prometheus = try reader["prometheus"].readIfPresent(with: KafkaClientTypes.PrometheusInfo.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// JMX and Node monitoring for the MSK cluster.
    public struct OpenMonitoringInfo {
        /// Prometheus settings.
        /// This member is required.
        public var prometheus: KafkaClientTypes.PrometheusInfo?

        public init(
            prometheus: KafkaClientTypes.PrometheusInfo? = nil
        )
        {
            self.prometheus = prometheus
        }
    }

}

extension KafkaClientTypes.Prometheus {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.Prometheus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.Prometheus()
        value.jmxExporter = try reader["jmxExporter"].readIfPresent(with: KafkaClientTypes.JmxExporter.read(from:))
        value.nodeExporter = try reader["nodeExporter"].readIfPresent(with: KafkaClientTypes.NodeExporter.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Prometheus settings.
    public struct Prometheus {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        public var jmxExporter: KafkaClientTypes.JmxExporter?
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        public var nodeExporter: KafkaClientTypes.NodeExporter?

        public init(
            jmxExporter: KafkaClientTypes.JmxExporter? = nil,
            nodeExporter: KafkaClientTypes.NodeExporter? = nil
        )
        {
            self.jmxExporter = jmxExporter
            self.nodeExporter = nodeExporter
        }
    }

}

extension KafkaClientTypes.PrometheusInfo {

    static func write(value: KafkaClientTypes.PrometheusInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jmxExporter"].write(value.jmxExporter, with: KafkaClientTypes.JmxExporterInfo.write(value:to:))
        try writer["nodeExporter"].write(value.nodeExporter, with: KafkaClientTypes.NodeExporterInfo.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.PrometheusInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.PrometheusInfo()
        value.jmxExporter = try reader["jmxExporter"].readIfPresent(with: KafkaClientTypes.JmxExporterInfo.read(from:))
        value.nodeExporter = try reader["nodeExporter"].readIfPresent(with: KafkaClientTypes.NodeExporterInfo.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Prometheus settings.
    public struct PrometheusInfo {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        public var jmxExporter: KafkaClientTypes.JmxExporterInfo?
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        public var nodeExporter: KafkaClientTypes.NodeExporterInfo?

        public init(
            jmxExporter: KafkaClientTypes.JmxExporterInfo? = nil,
            nodeExporter: KafkaClientTypes.NodeExporterInfo? = nil
        )
        {
            self.jmxExporter = jmxExporter
            self.nodeExporter = nodeExporter
        }
    }

}

extension KafkaClientTypes.Provisioned {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.Provisioned {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.Provisioned()
        value.brokerNodeGroupInfo = try reader["brokerNodeGroupInfo"].readIfPresent(with: KafkaClientTypes.BrokerNodeGroupInfo.read(from:))
        value.currentBrokerSoftwareInfo = try reader["currentBrokerSoftwareInfo"].readIfPresent(with: KafkaClientTypes.BrokerSoftwareInfo.read(from:))
        value.clientAuthentication = try reader["clientAuthentication"].readIfPresent(with: KafkaClientTypes.ClientAuthentication.read(from:))
        value.encryptionInfo = try reader["encryptionInfo"].readIfPresent(with: KafkaClientTypes.EncryptionInfo.read(from:))
        value.enhancedMonitoring = try reader["enhancedMonitoring"].readIfPresent()
        value.openMonitoring = try reader["openMonitoring"].readIfPresent(with: KafkaClientTypes.OpenMonitoringInfo.read(from:))
        value.loggingInfo = try reader["loggingInfo"].readIfPresent(with: KafkaClientTypes.LoggingInfo.read(from:))
        value.numberOfBrokerNodes = try reader["numberOfBrokerNodes"].readIfPresent()
        value.zookeeperConnectString = try reader["zookeeperConnectString"].readIfPresent()
        value.zookeeperConnectStringTls = try reader["zookeeperConnectStringTls"].readIfPresent()
        value.storageMode = try reader["storageMode"].readIfPresent()
        value.customerActionStatus = try reader["customerActionStatus"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Provisioned cluster.
    public struct Provisioned {
        /// Information about the brokers.
        /// This member is required.
        public var brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo?
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
        /// Information about the Apache Kafka version deployed on the brokers.
        public var currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo?
        /// Determines if there is an action required from the customer.
        public var customerActionStatus: KafkaClientTypes.CustomerActionStatus?
        /// Includes all encryption-related information.
        public var encryptionInfo: KafkaClientTypes.EncryptionInfo?
        /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
        public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
        /// Log delivery information for the cluster.
        public var loggingInfo: KafkaClientTypes.LoggingInfo?
        /// The number of broker nodes in the cluster.
        /// This member is required.
        public var numberOfBrokerNodes: Swift.Int?
        /// The settings for open monitoring.
        public var openMonitoring: KafkaClientTypes.OpenMonitoringInfo?
        /// This controls storage mode for supported storage tiers.
        public var storageMode: KafkaClientTypes.StorageMode?
        /// The connection string to use to connect to the Apache ZooKeeper cluster.
        public var zookeeperConnectString: Swift.String?
        /// The connection string to use to connect to the Apache ZooKeeper cluster on a TLS port.
        public var zookeeperConnectStringTls: Swift.String?

        public init(
            brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo? = nil,
            clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
            currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo? = nil,
            customerActionStatus: KafkaClientTypes.CustomerActionStatus? = nil,
            encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil,
            enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
            loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
            numberOfBrokerNodes: Swift.Int? = nil,
            openMonitoring: KafkaClientTypes.OpenMonitoringInfo? = nil,
            storageMode: KafkaClientTypes.StorageMode? = nil,
            zookeeperConnectString: Swift.String? = nil,
            zookeeperConnectStringTls: Swift.String? = nil
        )
        {
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.customerActionStatus = customerActionStatus
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.storageMode = storageMode
            self.zookeeperConnectString = zookeeperConnectString
            self.zookeeperConnectStringTls = zookeeperConnectStringTls
        }
    }

}

extension KafkaClientTypes.ProvisionedRequest {

    static func write(value: KafkaClientTypes.ProvisionedRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["brokerNodeGroupInfo"].write(value.brokerNodeGroupInfo, with: KafkaClientTypes.BrokerNodeGroupInfo.write(value:to:))
        try writer["clientAuthentication"].write(value.clientAuthentication, with: KafkaClientTypes.ClientAuthentication.write(value:to:))
        try writer["configurationInfo"].write(value.configurationInfo, with: KafkaClientTypes.ConfigurationInfo.write(value:to:))
        try writer["encryptionInfo"].write(value.encryptionInfo, with: KafkaClientTypes.EncryptionInfo.write(value:to:))
        try writer["enhancedMonitoring"].write(value.enhancedMonitoring)
        try writer["kafkaVersion"].write(value.kafkaVersion)
        try writer["loggingInfo"].write(value.loggingInfo, with: KafkaClientTypes.LoggingInfo.write(value:to:))
        try writer["numberOfBrokerNodes"].write(value.numberOfBrokerNodes)
        try writer["openMonitoring"].write(value.openMonitoring, with: KafkaClientTypes.OpenMonitoringInfo.write(value:to:))
        try writer["storageMode"].write(value.storageMode)
    }
}

extension KafkaClientTypes {
    /// Provisioned cluster request.
    public struct ProvisionedRequest {
        /// Information about the brokers.
        /// This member is required.
        public var brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo?
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
        /// Represents the configuration that you want Amazon MSK to use for the brokers in a cluster.
        public var configurationInfo: KafkaClientTypes.ConfigurationInfo?
        /// Includes all encryption-related information.
        public var encryptionInfo: KafkaClientTypes.EncryptionInfo?
        /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
        public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
        /// The Apache Kafka version that you want for the cluster.
        /// This member is required.
        public var kafkaVersion: Swift.String?
        /// Log delivery information for the cluster.
        public var loggingInfo: KafkaClientTypes.LoggingInfo?
        /// The number of broker nodes in the cluster.
        /// This member is required.
        public var numberOfBrokerNodes: Swift.Int?
        /// The settings for open monitoring.
        public var openMonitoring: KafkaClientTypes.OpenMonitoringInfo?
        /// This controls storage mode for supported storage tiers.
        public var storageMode: KafkaClientTypes.StorageMode?

        public init(
            brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo? = nil,
            clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
            configurationInfo: KafkaClientTypes.ConfigurationInfo? = nil,
            encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil,
            enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
            kafkaVersion: Swift.String? = nil,
            loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
            numberOfBrokerNodes: Swift.Int? = nil,
            openMonitoring: KafkaClientTypes.OpenMonitoringInfo? = nil,
            storageMode: KafkaClientTypes.StorageMode? = nil
        )
        {
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.configurationInfo = configurationInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.kafkaVersion = kafkaVersion
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.storageMode = storageMode
        }
    }

}

extension KafkaClientTypes.ProvisionedThroughput {

    static func write(value: KafkaClientTypes.ProvisionedThroughput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["volumeThroughput"].write(value.volumeThroughput)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ProvisionedThroughput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ProvisionedThroughput()
        value.enabled = try reader["enabled"].readIfPresent()
        value.volumeThroughput = try reader["volumeThroughput"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Contains information about provisioned throughput for EBS storage volumes attached to kafka broker nodes.
    public struct ProvisionedThroughput {
        /// Provisioned throughput is enabled or not.
        public var enabled: Swift.Bool?
        /// Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second.
        public var volumeThroughput: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            volumeThroughput: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.volumeThroughput = volumeThroughput
        }
    }

}

extension KafkaClientTypes.PublicAccess {

    static func write(value: KafkaClientTypes.PublicAccess?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.PublicAccess {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.PublicAccess()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Public access control for brokers.
    public struct PublicAccess {
        /// The value DISABLED indicates that public access is turned off. SERVICE_PROVIDED_EIPS indicates that public access is turned on.
        public var type: Swift.String?

        public init(
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension PutClusterPolicyInput {

    static func urlPathProvider(_ value: PutClusterPolicyInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/policy"
    }
}

extension PutClusterPolicyInput {

    static func write(value: PutClusterPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["currentVersion"].write(value.currentVersion)
        try writer["policy"].write(value.policy)
    }
}

public struct PutClusterPolicyInput {
    /// The Amazon Resource Name (ARN) of the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The policy version.
    public var currentVersion: Swift.String?
    /// The policy.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.policy = policy
    }
}

extension PutClusterPolicyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutClusterPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutClusterPolicyOutput()
        value.currentVersion = try reader["currentVersion"].readIfPresent()
        return value
    }
}

public struct PutClusterPolicyOutput {
    /// The policy version.
    public var currentVersion: Swift.String?

    public init(
        currentVersion: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
    }
}

enum PutClusterPolicyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension RebootBrokerInput {

    static func urlPathProvider(_ value: RebootBrokerInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/reboot-broker"
    }
}

extension RebootBrokerInput {

    static func write(value: RebootBrokerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["brokerIds"].writeList(value.brokerIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

/// Reboots a node.
public struct RebootBrokerInput {
    /// The list of broker IDs to be rebooted. The reboot-broker operation supports rebooting one broker at a time.
    /// This member is required.
    public var brokerIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the cluster to be updated.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        brokerIds: [Swift.String]? = nil,
        clusterArn: Swift.String? = nil
    )
    {
        self.brokerIds = brokerIds
        self.clusterArn = clusterArn
    }
}

extension RebootBrokerOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> RebootBrokerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RebootBrokerOutput()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterOperationArn = try reader["clusterOperationArn"].readIfPresent()
        return value
    }
}

public struct RebootBrokerOutput {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

enum RebootBrokerOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension RejectClientVpcConnectionInput {

    static func urlPathProvider(_ value: RejectClientVpcConnectionInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/client-vpc-connection"
    }
}

extension RejectClientVpcConnectionInput {

    static func write(value: RejectClientVpcConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vpcConnectionArn"].write(value.vpcConnectionArn)
    }
}

public struct RejectClientVpcConnectionInput {
    /// The Amazon Resource Name (ARN) of the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The VPC connection ARN.
    /// This member is required.
    public var vpcConnectionArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        vpcConnectionArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.vpcConnectionArn = vpcConnectionArn
    }
}

extension RejectClientVpcConnectionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> RejectClientVpcConnectionOutput {
        return RejectClientVpcConnectionOutput()
    }
}

public struct RejectClientVpcConnectionOutput {

    public init() { }
}

enum RejectClientVpcConnectionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension KafkaClientTypes.ReplicationInfo {

    static func write(value: KafkaClientTypes.ReplicationInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["consumerGroupReplication"].write(value.consumerGroupReplication, with: KafkaClientTypes.ConsumerGroupReplication.write(value:to:))
        try writer["sourceKafkaClusterArn"].write(value.sourceKafkaClusterArn)
        try writer["targetCompressionType"].write(value.targetCompressionType)
        try writer["targetKafkaClusterArn"].write(value.targetKafkaClusterArn)
        try writer["topicReplication"].write(value.topicReplication, with: KafkaClientTypes.TopicReplication.write(value:to:))
    }
}

extension KafkaClientTypes {
    /// Specifies configuration for replication between a source and target Kafka cluster.
    public struct ReplicationInfo {
        /// Configuration relating to consumer group replication.
        /// This member is required.
        public var consumerGroupReplication: KafkaClientTypes.ConsumerGroupReplication?
        /// The ARN of the source Kafka cluster.
        /// This member is required.
        public var sourceKafkaClusterArn: Swift.String?
        /// The compression type to use when producing records to target cluster.
        /// This member is required.
        public var targetCompressionType: KafkaClientTypes.TargetCompressionType?
        /// The ARN of the target Kafka cluster.
        /// This member is required.
        public var targetKafkaClusterArn: Swift.String?
        /// Configuration relating to topic replication.
        /// This member is required.
        public var topicReplication: KafkaClientTypes.TopicReplication?

        public init(
            consumerGroupReplication: KafkaClientTypes.ConsumerGroupReplication? = nil,
            sourceKafkaClusterArn: Swift.String? = nil,
            targetCompressionType: KafkaClientTypes.TargetCompressionType? = nil,
            targetKafkaClusterArn: Swift.String? = nil,
            topicReplication: KafkaClientTypes.TopicReplication? = nil
        )
        {
            self.consumerGroupReplication = consumerGroupReplication
            self.sourceKafkaClusterArn = sourceKafkaClusterArn
            self.targetCompressionType = targetCompressionType
            self.targetKafkaClusterArn = targetKafkaClusterArn
            self.topicReplication = topicReplication
        }
    }

}

extension KafkaClientTypes.ReplicationInfoDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ReplicationInfoDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ReplicationInfoDescription()
        value.consumerGroupReplication = try reader["consumerGroupReplication"].readIfPresent(with: KafkaClientTypes.ConsumerGroupReplication.read(from:))
        value.sourceKafkaClusterAlias = try reader["sourceKafkaClusterAlias"].readIfPresent()
        value.targetCompressionType = try reader["targetCompressionType"].readIfPresent()
        value.targetKafkaClusterAlias = try reader["targetKafkaClusterAlias"].readIfPresent()
        value.topicReplication = try reader["topicReplication"].readIfPresent(with: KafkaClientTypes.TopicReplication.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Specifies configuration for replication between a source and target Kafka cluster (sourceKafkaClusterAlias -> targetKafkaClusterAlias)
    public struct ReplicationInfoDescription {
        /// Configuration relating to consumer group replication.
        public var consumerGroupReplication: KafkaClientTypes.ConsumerGroupReplication?
        /// The alias of the source Kafka cluster.
        public var sourceKafkaClusterAlias: Swift.String?
        /// The compression type to use when producing records to target cluster.
        public var targetCompressionType: KafkaClientTypes.TargetCompressionType?
        /// The alias of the target Kafka cluster.
        public var targetKafkaClusterAlias: Swift.String?
        /// Configuration relating to topic replication.
        public var topicReplication: KafkaClientTypes.TopicReplication?

        public init(
            consumerGroupReplication: KafkaClientTypes.ConsumerGroupReplication? = nil,
            sourceKafkaClusterAlias: Swift.String? = nil,
            targetCompressionType: KafkaClientTypes.TargetCompressionType? = nil,
            targetKafkaClusterAlias: Swift.String? = nil,
            topicReplication: KafkaClientTypes.TopicReplication? = nil
        )
        {
            self.consumerGroupReplication = consumerGroupReplication
            self.sourceKafkaClusterAlias = sourceKafkaClusterAlias
            self.targetCompressionType = targetCompressionType
            self.targetKafkaClusterAlias = targetKafkaClusterAlias
            self.topicReplication = topicReplication
        }
    }

}

extension KafkaClientTypes.ReplicationInfoSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ReplicationInfoSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ReplicationInfoSummary()
        value.sourceKafkaClusterAlias = try reader["sourceKafkaClusterAlias"].readIfPresent()
        value.targetKafkaClusterAlias = try reader["targetKafkaClusterAlias"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Summarized information of replication between clusters.
    public struct ReplicationInfoSummary {
        /// The alias of the source Kafka cluster.
        public var sourceKafkaClusterAlias: Swift.String?
        /// The alias of the target Kafka cluster.
        public var targetKafkaClusterAlias: Swift.String?

        public init(
            sourceKafkaClusterAlias: Swift.String? = nil,
            targetKafkaClusterAlias: Swift.String? = nil
        )
        {
            self.sourceKafkaClusterAlias = sourceKafkaClusterAlias
            self.targetKafkaClusterAlias = targetKafkaClusterAlias
        }
    }

}

extension KafkaClientTypes.ReplicationStartingPosition {

    static func write(value: KafkaClientTypes.ReplicationStartingPosition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ReplicationStartingPosition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ReplicationStartingPosition()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Configuration for specifying the position in the topics to start replicating from.
    public struct ReplicationStartingPosition {
        /// The type of replication starting position.
        public var type: KafkaClientTypes.ReplicationStartingPositionType?

        public init(
            type: KafkaClientTypes.ReplicationStartingPositionType? = nil
        )
        {
            self.type = type
        }
    }

}

extension KafkaClientTypes {

    /// The type of replication starting position.
    public enum ReplicationStartingPositionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case earliest
        case latest
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationStartingPositionType] {
            return [
                .earliest,
                .latest,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .earliest: return "EARLIEST"
            case .latest: return "LATEST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaClientTypes.ReplicationStateInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ReplicationStateInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ReplicationStateInfo()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Details about the state of a replicator
    public struct ReplicationStateInfo {
        /// Code that describes the current state of the replicator.
        public var code: Swift.String?
        /// Message that describes the state of the replicator.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension KafkaClientTypes {

    /// The state of a replicator.
    public enum ReplicatorState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case running
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicatorState] {
            return [
                .creating,
                .deleting,
                .failed,
                .running,
                .updating,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaClientTypes.ReplicatorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ReplicatorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ReplicatorSummary()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.currentVersion = try reader["currentVersion"].readIfPresent()
        value.isReplicatorReference = try reader["isReplicatorReference"].readIfPresent()
        value.kafkaClustersSummary = try reader["kafkaClustersSummary"].readListIfPresent(memberReadingClosure: KafkaClientTypes.KafkaClusterSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.replicationInfoSummaryList = try reader["replicationInfoSummaryList"].readListIfPresent(memberReadingClosure: KafkaClientTypes.ReplicationInfoSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.replicatorArn = try reader["replicatorArn"].readIfPresent()
        value.replicatorName = try reader["replicatorName"].readIfPresent()
        value.replicatorResourceArn = try reader["replicatorResourceArn"].readIfPresent()
        value.replicatorState = try reader["replicatorState"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Information about a replicator.
    public struct ReplicatorSummary {
        /// The time the replicator was created.
        public var creationTime: ClientRuntime.Date?
        /// The current version of the replicator.
        public var currentVersion: Swift.String?
        /// Whether this resource is a replicator reference.
        public var isReplicatorReference: Swift.Bool?
        /// Kafka Clusters used in setting up sources / targets for replication.
        public var kafkaClustersSummary: [KafkaClientTypes.KafkaClusterSummary]?
        /// A list of summarized information of replications between clusters.
        public var replicationInfoSummaryList: [KafkaClientTypes.ReplicationInfoSummary]?
        /// The Amazon Resource Name (ARN) of the replicator.
        public var replicatorArn: Swift.String?
        /// The name of the replicator.
        public var replicatorName: Swift.String?
        /// The Amazon Resource Name (ARN) of the replicator resource in the region where the replicator was created.
        public var replicatorResourceArn: Swift.String?
        /// State of the replicator.
        public var replicatorState: KafkaClientTypes.ReplicatorState?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            currentVersion: Swift.String? = nil,
            isReplicatorReference: Swift.Bool? = nil,
            kafkaClustersSummary: [KafkaClientTypes.KafkaClusterSummary]? = nil,
            replicationInfoSummaryList: [KafkaClientTypes.ReplicationInfoSummary]? = nil,
            replicatorArn: Swift.String? = nil,
            replicatorName: Swift.String? = nil,
            replicatorResourceArn: Swift.String? = nil,
            replicatorState: KafkaClientTypes.ReplicatorState? = nil
        )
        {
            self.creationTime = creationTime
            self.currentVersion = currentVersion
            self.isReplicatorReference = isReplicatorReference
            self.kafkaClustersSummary = kafkaClustersSummary
            self.replicationInfoSummaryList = replicationInfoSummaryList
            self.replicatorArn = replicatorArn
            self.replicatorName = replicatorName
            self.replicatorResourceArn = replicatorResourceArn
            self.replicatorState = replicatorState
        }
    }

}

extension KafkaClientTypes.S3 {

    static func write(value: KafkaClientTypes.S3?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["enabled"].write(value.enabled)
        try writer["prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.S3 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.S3()
        value.bucket = try reader["bucket"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        value.`prefix` = try reader["prefix"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    public struct S3 {
        public var bucket: Swift.String?
        /// This member is required.
        public var enabled: Swift.Bool?
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.`prefix` = `prefix`
        }
    }

}

extension KafkaClientTypes.Sasl {

    static func write(value: KafkaClientTypes.Sasl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["iam"].write(value.iam, with: KafkaClientTypes.Iam.write(value:to:))
        try writer["scram"].write(value.scram, with: KafkaClientTypes.Scram.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.Sasl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.Sasl()
        value.scram = try reader["scram"].readIfPresent(with: KafkaClientTypes.Scram.read(from:))
        value.iam = try reader["iam"].readIfPresent(with: KafkaClientTypes.Iam.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Details for client authentication using SASL.
    public struct Sasl {
        /// Indicates whether IAM access control is enabled.
        public var iam: KafkaClientTypes.Iam?
        /// Details for SASL/SCRAM client authentication.
        public var scram: KafkaClientTypes.Scram?

        public init(
            iam: KafkaClientTypes.Iam? = nil,
            scram: KafkaClientTypes.Scram? = nil
        )
        {
            self.iam = iam
            self.scram = scram
        }
    }

}

extension KafkaClientTypes.Scram {

    static func write(value: KafkaClientTypes.Scram?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.Scram {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.Scram()
        value.enabled = try reader["enabled"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Details for SASL/SCRAM client authentication.
    public struct Scram {
        /// SASL/SCRAM authentication is enabled or not.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension KafkaClientTypes.Serverless {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.Serverless {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.Serverless()
        value.vpcConfigs = try reader["vpcConfigs"].readListIfPresent(memberReadingClosure: KafkaClientTypes.VpcConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.clientAuthentication = try reader["clientAuthentication"].readIfPresent(with: KafkaClientTypes.ServerlessClientAuthentication.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Serverless cluster.
    public struct Serverless {
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ServerlessClientAuthentication?
        /// The configuration of the Amazon VPCs for the cluster.
        /// This member is required.
        public var vpcConfigs: [KafkaClientTypes.VpcConfig]?

        public init(
            clientAuthentication: KafkaClientTypes.ServerlessClientAuthentication? = nil,
            vpcConfigs: [KafkaClientTypes.VpcConfig]? = nil
        )
        {
            self.clientAuthentication = clientAuthentication
            self.vpcConfigs = vpcConfigs
        }
    }

}

extension KafkaClientTypes.ServerlessClientAuthentication {

    static func write(value: KafkaClientTypes.ServerlessClientAuthentication?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sasl"].write(value.sasl, with: KafkaClientTypes.ServerlessSasl.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ServerlessClientAuthentication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ServerlessClientAuthentication()
        value.sasl = try reader["sasl"].readIfPresent(with: KafkaClientTypes.ServerlessSasl.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Includes all client authentication information.
    public struct ServerlessClientAuthentication {
        /// Details for ClientAuthentication using SASL.
        public var sasl: KafkaClientTypes.ServerlessSasl?

        public init(
            sasl: KafkaClientTypes.ServerlessSasl? = nil
        )
        {
            self.sasl = sasl
        }
    }

}

extension KafkaClientTypes.ServerlessRequest {

    static func write(value: KafkaClientTypes.ServerlessRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientAuthentication"].write(value.clientAuthentication, with: KafkaClientTypes.ServerlessClientAuthentication.write(value:to:))
        try writer["vpcConfigs"].writeList(value.vpcConfigs, memberWritingClosure: KafkaClientTypes.VpcConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension KafkaClientTypes {
    /// Serverless cluster request.
    public struct ServerlessRequest {
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ServerlessClientAuthentication?
        /// The configuration of the Amazon VPCs for the cluster.
        /// This member is required.
        public var vpcConfigs: [KafkaClientTypes.VpcConfig]?

        public init(
            clientAuthentication: KafkaClientTypes.ServerlessClientAuthentication? = nil,
            vpcConfigs: [KafkaClientTypes.VpcConfig]? = nil
        )
        {
            self.clientAuthentication = clientAuthentication
            self.vpcConfigs = vpcConfigs
        }
    }

}

extension KafkaClientTypes.ServerlessSasl {

    static func write(value: KafkaClientTypes.ServerlessSasl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["iam"].write(value.iam, with: KafkaClientTypes.Iam.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ServerlessSasl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ServerlessSasl()
        value.iam = try reader["iam"].readIfPresent(with: KafkaClientTypes.Iam.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Details for client authentication using SASL.
    public struct ServerlessSasl {
        /// Indicates whether IAM access control is enabled.
        public var iam: KafkaClientTypes.Iam?

        public init(
            iam: KafkaClientTypes.Iam? = nil
        )
        {
            self.iam = iam
        }
    }

}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.invalidParameter = try reader["invalidParameter"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Returns information about an error.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

extension KafkaClientTypes.StateInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.StateInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.StateInfo()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    public struct StateInfo {
        public var code: Swift.String?
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension KafkaClientTypes.StorageInfo {

    static func write(value: KafkaClientTypes.StorageInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ebsStorageInfo"].write(value.ebsStorageInfo, with: KafkaClientTypes.EBSStorageInfo.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.StorageInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.StorageInfo()
        value.ebsStorageInfo = try reader["ebsStorageInfo"].readIfPresent(with: KafkaClientTypes.EBSStorageInfo.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Contains information about storage volumes attached to MSK broker nodes.
    public struct StorageInfo {
        /// EBS volume information.
        public var ebsStorageInfo: KafkaClientTypes.EBSStorageInfo?

        public init(
            ebsStorageInfo: KafkaClientTypes.EBSStorageInfo? = nil
        )
        {
            self.ebsStorageInfo = ebsStorageInfo
        }
    }

}

extension KafkaClientTypes {

    /// Controls storage mode for various supported storage tiers.
    public enum StorageMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case local
        case tiered
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageMode] {
            return [
                .local,
                .tiered,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .local: return "LOCAL"
            case .tiered: return "TIERED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pair for the resource tag.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension KafkaClientTypes {

    /// The type of compression to use producing records to the target cluster.
    public enum TargetCompressionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gzip
        case lz4
        case `none`
        case snappy
        case zstd
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetCompressionType] {
            return [
                .gzip,
                .lz4,
                .none,
                .snappy,
                .zstd,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .lz4: return "LZ4"
            case .none: return "NONE"
            case .snappy: return "SNAPPY"
            case .zstd: return "ZSTD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaClientTypes.Tls {

    static func write(value: KafkaClientTypes.Tls?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateAuthorityArnList"].writeList(value.certificateAuthorityArnList, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.Tls {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.Tls()
        value.certificateAuthorityArnList = try reader["certificateAuthorityArnList"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.enabled = try reader["enabled"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Details for client authentication using TLS.
    public struct Tls {
        /// List of ACM Certificate Authority ARNs.
        public var certificateAuthorityArnList: [Swift.String]?
        /// Specifies whether you want to turn on or turn off TLS authentication.
        public var enabled: Swift.Bool?

        public init(
            certificateAuthorityArnList: [Swift.String]? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.certificateAuthorityArnList = certificateAuthorityArnList
            self.enabled = enabled
        }
    }

}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.invalidParameter = try reader["invalidParameter"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Returns information about an error.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

extension KafkaClientTypes.TopicReplication {

    static func write(value: KafkaClientTypes.TopicReplication?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["copyAccessControlListsForTopics"].write(value.copyAccessControlListsForTopics)
        try writer["copyTopicConfigurations"].write(value.copyTopicConfigurations)
        try writer["detectAndCopyNewTopics"].write(value.detectAndCopyNewTopics)
        try writer["startingPosition"].write(value.startingPosition, with: KafkaClientTypes.ReplicationStartingPosition.write(value:to:))
        try writer["topicsToExclude"].writeList(value.topicsToExclude, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["topicsToReplicate"].writeList(value.topicsToReplicate, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.TopicReplication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.TopicReplication()
        value.copyAccessControlListsForTopics = try reader["copyAccessControlListsForTopics"].readIfPresent()
        value.copyTopicConfigurations = try reader["copyTopicConfigurations"].readIfPresent()
        value.detectAndCopyNewTopics = try reader["detectAndCopyNewTopics"].readIfPresent()
        value.startingPosition = try reader["startingPosition"].readIfPresent(with: KafkaClientTypes.ReplicationStartingPosition.read(from:))
        value.topicsToExclude = try reader["topicsToExclude"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.topicsToReplicate = try reader["topicsToReplicate"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension KafkaClientTypes {
    /// Details about topic replication.
    public struct TopicReplication {
        /// Whether to periodically configure remote topic ACLs to match their corresponding upstream topics.
        public var copyAccessControlListsForTopics: Swift.Bool?
        /// Whether to periodically configure remote topics to match their corresponding upstream topics.
        public var copyTopicConfigurations: Swift.Bool?
        /// Whether to periodically check for new topics and partitions.
        public var detectAndCopyNewTopics: Swift.Bool?
        /// Configuration for specifying the position in the topics to start replicating from.
        public var startingPosition: KafkaClientTypes.ReplicationStartingPosition?
        /// List of regular expression patterns indicating the topics that should not be replicated.
        public var topicsToExclude: [Swift.String]?
        /// List of regular expression patterns indicating the topics to copy.
        /// This member is required.
        public var topicsToReplicate: [Swift.String]?

        public init(
            copyAccessControlListsForTopics: Swift.Bool? = nil,
            copyTopicConfigurations: Swift.Bool? = nil,
            detectAndCopyNewTopics: Swift.Bool? = nil,
            startingPosition: KafkaClientTypes.ReplicationStartingPosition? = nil,
            topicsToExclude: [Swift.String]? = nil,
            topicsToReplicate: [Swift.String]? = nil
        )
        {
            self.copyAccessControlListsForTopics = copyAccessControlListsForTopics
            self.copyTopicConfigurations = copyTopicConfigurations
            self.detectAndCopyNewTopics = detectAndCopyNewTopics
            self.startingPosition = startingPosition
            self.topicsToExclude = topicsToExclude
            self.topicsToReplicate = topicsToReplicate
        }
    }

}

extension KafkaClientTypes.TopicReplicationUpdate {

    static func write(value: KafkaClientTypes.TopicReplicationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["copyAccessControlListsForTopics"].write(value.copyAccessControlListsForTopics)
        try writer["copyTopicConfigurations"].write(value.copyTopicConfigurations)
        try writer["detectAndCopyNewTopics"].write(value.detectAndCopyNewTopics)
        try writer["topicsToExclude"].writeList(value.topicsToExclude, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["topicsToReplicate"].writeList(value.topicsToReplicate, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension KafkaClientTypes {
    /// Details for updating the topic replication of a replicator.
    public struct TopicReplicationUpdate {
        /// Whether to periodically configure remote topic ACLs to match their corresponding upstream topics.
        /// This member is required.
        public var copyAccessControlListsForTopics: Swift.Bool?
        /// Whether to periodically configure remote topics to match their corresponding upstream topics.
        /// This member is required.
        public var copyTopicConfigurations: Swift.Bool?
        /// Whether to periodically check for new topics and partitions.
        /// This member is required.
        public var detectAndCopyNewTopics: Swift.Bool?
        /// List of regular expression patterns indicating the topics that should not be replicated.
        /// This member is required.
        public var topicsToExclude: [Swift.String]?
        /// List of regular expression patterns indicating the topics to copy.
        /// This member is required.
        public var topicsToReplicate: [Swift.String]?

        public init(
            copyAccessControlListsForTopics: Swift.Bool? = nil,
            copyTopicConfigurations: Swift.Bool? = nil,
            detectAndCopyNewTopics: Swift.Bool? = nil,
            topicsToExclude: [Swift.String]? = nil,
            topicsToReplicate: [Swift.String]? = nil
        )
        {
            self.copyAccessControlListsForTopics = copyAccessControlListsForTopics
            self.copyTopicConfigurations = copyTopicConfigurations
            self.detectAndCopyNewTopics = detectAndCopyNewTopics
            self.topicsToExclude = topicsToExclude
            self.topicsToReplicate = topicsToReplicate
        }
    }

}

extension KafkaClientTypes.Unauthenticated {

    static func write(value: KafkaClientTypes.Unauthenticated?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.Unauthenticated {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.Unauthenticated()
        value.enabled = try reader["enabled"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    public struct Unauthenticated {
        /// Specifies whether you want to turn on or turn off unauthenticated traffic to your cluster.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.invalidParameter = try reader["invalidParameter"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Returns information about an error.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

extension KafkaClientTypes.UnprocessedScramSecret {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.UnprocessedScramSecret {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.UnprocessedScramSecret()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.secretArn = try reader["secretArn"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Error info for scram secret associate/disassociate failure.
    public struct UnprocessedScramSecret {
        /// Error code for associate/disassociate failure.
        public var errorCode: Swift.String?
        /// Error message for associate/disassociate failure.
        public var errorMessage: Swift.String?
        /// AWS Secrets Manager secret ARN.
        public var secretArn: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            secretArn: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.secretArn = secretArn
        }
    }

}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag keys must be unique for a given cluster. In addition, the following restrictions apply:
    ///
    /// * Each tag key must be unique. If you add a tag with a key that's already in use, your new tag overwrites the existing key-value pair.
    ///
    /// * You can't start a tag key with aws: because this prefix is reserved for use by AWS. AWS creates tags that begin with this prefix on your behalf, but you can't edit or delete them.
    ///
    /// * Tag keys must be between 1 and 128 Unicode characters in length.
    ///
    /// * Tag keys must consist of the following characters: Unicode letters, digits, white space, and the following special characters: _ . / = + - @.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateBrokerCountInput {

    static func urlPathProvider(_ value: UpdateBrokerCountInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/nodes/count"
    }
}

extension UpdateBrokerCountInput {

    static func write(value: UpdateBrokerCountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["currentVersion"].write(value.currentVersion)
        try writer["targetNumberOfBrokerNodes"].write(value.targetNumberOfBrokerNodes)
    }
}

public struct UpdateBrokerCountInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The version of cluster to update from. A successful operation will then generate a new version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The number of broker nodes that you want the cluster to have after this operation completes successfully.
    /// This member is required.
    public var targetNumberOfBrokerNodes: Swift.Int?

    public init(
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        targetNumberOfBrokerNodes: Swift.Int? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.targetNumberOfBrokerNodes = targetNumberOfBrokerNodes
    }
}

extension UpdateBrokerCountOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateBrokerCountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBrokerCountOutput()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterOperationArn = try reader["clusterOperationArn"].readIfPresent()
        return value
    }
}

public struct UpdateBrokerCountOutput {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

enum UpdateBrokerCountOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateBrokerStorageInput {

    static func urlPathProvider(_ value: UpdateBrokerStorageInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/nodes/storage"
    }
}

extension UpdateBrokerStorageInput {

    static func write(value: UpdateBrokerStorageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["currentVersion"].write(value.currentVersion)
        try writer["targetBrokerEBSVolumeInfo"].writeList(value.targetBrokerEBSVolumeInfo, memberWritingClosure: KafkaClientTypes.BrokerEBSVolumeInfo.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct UpdateBrokerStorageInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The version of cluster to update from. A successful operation will then generate a new version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// Describes the target volume size and the ID of the broker to apply the update to.
    /// This member is required.
    public var targetBrokerEBSVolumeInfo: [KafkaClientTypes.BrokerEBSVolumeInfo]?

    public init(
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        targetBrokerEBSVolumeInfo: [KafkaClientTypes.BrokerEBSVolumeInfo]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.targetBrokerEBSVolumeInfo = targetBrokerEBSVolumeInfo
    }
}

extension UpdateBrokerStorageOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateBrokerStorageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBrokerStorageOutput()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterOperationArn = try reader["clusterOperationArn"].readIfPresent()
        return value
    }
}

public struct UpdateBrokerStorageOutput {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

enum UpdateBrokerStorageOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateBrokerTypeInput {

    static func urlPathProvider(_ value: UpdateBrokerTypeInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/nodes/type"
    }
}

extension UpdateBrokerTypeInput {

    static func write(value: UpdateBrokerTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["currentVersion"].write(value.currentVersion)
        try writer["targetInstanceType"].write(value.targetInstanceType)
    }
}

public struct UpdateBrokerTypeInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The cluster version that you want to change. After this operation completes successfully, the cluster will have a new version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The Amazon MSK broker type that you want all of the brokers in this cluster to be.
    /// This member is required.
    public var targetInstanceType: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        targetInstanceType: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.targetInstanceType = targetInstanceType
    }
}

extension UpdateBrokerTypeOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateBrokerTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBrokerTypeOutput()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterOperationArn = try reader["clusterOperationArn"].readIfPresent()
        return value
    }
}

public struct UpdateBrokerTypeOutput {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

enum UpdateBrokerTypeOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateClusterConfigurationInput {

    static func urlPathProvider(_ value: UpdateClusterConfigurationInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/configuration"
    }
}

extension UpdateClusterConfigurationInput {

    static func write(value: UpdateClusterConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configurationInfo"].write(value.configurationInfo, with: KafkaClientTypes.ConfigurationInfo.write(value:to:))
        try writer["currentVersion"].write(value.currentVersion)
    }
}

public struct UpdateClusterConfigurationInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// Represents the configuration that you want MSK to use for the brokers in a cluster.
    /// This member is required.
    public var configurationInfo: KafkaClientTypes.ConfigurationInfo?
    /// The version of the cluster that needs to be updated.
    /// This member is required.
    public var currentVersion: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        configurationInfo: KafkaClientTypes.ConfigurationInfo? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.configurationInfo = configurationInfo
        self.currentVersion = currentVersion
    }
}

extension UpdateClusterConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateClusterConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateClusterConfigurationOutput()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterOperationArn = try reader["clusterOperationArn"].readIfPresent()
        return value
    }
}

public struct UpdateClusterConfigurationOutput {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

enum UpdateClusterConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateClusterKafkaVersionInput {

    static func urlPathProvider(_ value: UpdateClusterKafkaVersionInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/version"
    }
}

extension UpdateClusterKafkaVersionInput {

    static func write(value: UpdateClusterKafkaVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configurationInfo"].write(value.configurationInfo, with: KafkaClientTypes.ConfigurationInfo.write(value:to:))
        try writer["currentVersion"].write(value.currentVersion)
        try writer["targetKafkaVersion"].write(value.targetKafkaVersion)
    }
}

public struct UpdateClusterKafkaVersionInput {
    /// The Amazon Resource Name (ARN) of the cluster to be updated.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The custom configuration that should be applied on the new version of cluster.
    public var configurationInfo: KafkaClientTypes.ConfigurationInfo?
    /// Current cluster version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// Target Kafka version.
    /// This member is required.
    public var targetKafkaVersion: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        configurationInfo: KafkaClientTypes.ConfigurationInfo? = nil,
        currentVersion: Swift.String? = nil,
        targetKafkaVersion: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.configurationInfo = configurationInfo
        self.currentVersion = currentVersion
        self.targetKafkaVersion = targetKafkaVersion
    }
}

extension UpdateClusterKafkaVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateClusterKafkaVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateClusterKafkaVersionOutput()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterOperationArn = try reader["clusterOperationArn"].readIfPresent()
        return value
    }
}

public struct UpdateClusterKafkaVersionOutput {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

enum UpdateClusterKafkaVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateConfigurationInput {

    static func urlPathProvider(_ value: UpdateConfigurationInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/configurations/\(arn.urlPercentEncoding())"
    }
}

extension UpdateConfigurationInput {

    static func write(value: UpdateConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["serverProperties"].write(value.serverProperties)
    }
}

public struct UpdateConfigurationInput {
    /// The Amazon Resource Name (ARN) of the configuration.
    /// This member is required.
    public var arn: Swift.String?
    /// The description of the configuration revision.
    public var description: Swift.String?
    /// Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded. When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
    /// This member is required.
    public var serverProperties: ClientRuntime.Data?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        serverProperties: ClientRuntime.Data? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.serverProperties = serverProperties
    }
}

extension UpdateConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConfigurationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.latestRevision = try reader["latestRevision"].readIfPresent(with: KafkaClientTypes.ConfigurationRevision.read(from:))
        return value
    }
}

public struct UpdateConfigurationOutput {
    /// The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// Latest revision of the configuration.
    public var latestRevision: KafkaClientTypes.ConfigurationRevision?

    public init(
        arn: Swift.String? = nil,
        latestRevision: KafkaClientTypes.ConfigurationRevision? = nil
    )
    {
        self.arn = arn
        self.latestRevision = latestRevision
    }
}

enum UpdateConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateConnectivityInput {

    static func urlPathProvider(_ value: UpdateConnectivityInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/connectivity"
    }
}

extension UpdateConnectivityInput {

    static func write(value: UpdateConnectivityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectivityInfo"].write(value.connectivityInfo, with: KafkaClientTypes.ConnectivityInfo.write(value:to:))
        try writer["currentVersion"].write(value.currentVersion)
    }
}

/// Request body for UpdateConnectivity.
public struct UpdateConnectivityInput {
    /// The Amazon Resource Name (ARN) of the configuration.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// Information about the broker access configuration.
    /// This member is required.
    public var connectivityInfo: KafkaClientTypes.ConnectivityInfo?
    /// The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
    /// This member is required.
    public var currentVersion: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        connectivityInfo: KafkaClientTypes.ConnectivityInfo? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.connectivityInfo = connectivityInfo
        self.currentVersion = currentVersion
    }
}

extension UpdateConnectivityOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateConnectivityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConnectivityOutput()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterOperationArn = try reader["clusterOperationArn"].readIfPresent()
        return value
    }
}

public struct UpdateConnectivityOutput {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

enum UpdateConnectivityOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateMonitoringInput {

    static func urlPathProvider(_ value: UpdateMonitoringInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/monitoring"
    }
}

extension UpdateMonitoringInput {

    static func write(value: UpdateMonitoringInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["currentVersion"].write(value.currentVersion)
        try writer["enhancedMonitoring"].write(value.enhancedMonitoring)
        try writer["loggingInfo"].write(value.loggingInfo, with: KafkaClientTypes.LoggingInfo.write(value:to:))
        try writer["openMonitoring"].write(value.openMonitoring, with: KafkaClientTypes.OpenMonitoringInfo.write(value:to:))
    }
}

/// Request body for UpdateMonitoring.
public struct UpdateMonitoringInput {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.
    public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
    public var loggingInfo: KafkaClientTypes.LoggingInfo?
    /// The settings for open monitoring.
    public var openMonitoring: KafkaClientTypes.OpenMonitoringInfo?

    public init(
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
        loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
        openMonitoring: KafkaClientTypes.OpenMonitoringInfo? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.enhancedMonitoring = enhancedMonitoring
        self.loggingInfo = loggingInfo
        self.openMonitoring = openMonitoring
    }
}

extension UpdateMonitoringOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateMonitoringOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMonitoringOutput()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterOperationArn = try reader["clusterOperationArn"].readIfPresent()
        return value
    }
}

public struct UpdateMonitoringOutput {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

enum UpdateMonitoringOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateReplicationInfoInput {

    static func urlPathProvider(_ value: UpdateReplicationInfoInput) -> Swift.String? {
        guard let replicatorArn = value.replicatorArn else {
            return nil
        }
        return "/replication/v1/replicators/\(replicatorArn.urlPercentEncoding())/replication-info"
    }
}

extension UpdateReplicationInfoInput {

    static func write(value: UpdateReplicationInfoInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["consumerGroupReplication"].write(value.consumerGroupReplication, with: KafkaClientTypes.ConsumerGroupReplicationUpdate.write(value:to:))
        try writer["currentVersion"].write(value.currentVersion)
        try writer["sourceKafkaClusterArn"].write(value.sourceKafkaClusterArn)
        try writer["targetKafkaClusterArn"].write(value.targetKafkaClusterArn)
        try writer["topicReplication"].write(value.topicReplication, with: KafkaClientTypes.TopicReplicationUpdate.write(value:to:))
    }
}

/// Update information relating to replication between a given source and target Kafka cluster.
public struct UpdateReplicationInfoInput {
    /// Updated consumer group replication information.
    public var consumerGroupReplication: KafkaClientTypes.ConsumerGroupReplicationUpdate?
    /// Current replicator version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The Amazon Resource Name (ARN) of the replicator to be updated.
    /// This member is required.
    public var replicatorArn: Swift.String?
    /// The ARN of the source Kafka cluster.
    /// This member is required.
    public var sourceKafkaClusterArn: Swift.String?
    /// The ARN of the target Kafka cluster.
    /// This member is required.
    public var targetKafkaClusterArn: Swift.String?
    /// Updated topic replication information.
    public var topicReplication: KafkaClientTypes.TopicReplicationUpdate?

    public init(
        consumerGroupReplication: KafkaClientTypes.ConsumerGroupReplicationUpdate? = nil,
        currentVersion: Swift.String? = nil,
        replicatorArn: Swift.String? = nil,
        sourceKafkaClusterArn: Swift.String? = nil,
        targetKafkaClusterArn: Swift.String? = nil,
        topicReplication: KafkaClientTypes.TopicReplicationUpdate? = nil
    )
    {
        self.consumerGroupReplication = consumerGroupReplication
        self.currentVersion = currentVersion
        self.replicatorArn = replicatorArn
        self.sourceKafkaClusterArn = sourceKafkaClusterArn
        self.targetKafkaClusterArn = targetKafkaClusterArn
        self.topicReplication = topicReplication
    }
}

extension UpdateReplicationInfoOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateReplicationInfoOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateReplicationInfoOutput()
        value.replicatorArn = try reader["replicatorArn"].readIfPresent()
        value.replicatorState = try reader["replicatorState"].readIfPresent()
        return value
    }
}

public struct UpdateReplicationInfoOutput {
    /// The Amazon Resource Name (ARN) of the replicator.
    public var replicatorArn: Swift.String?
    /// State of the replicator.
    public var replicatorState: KafkaClientTypes.ReplicatorState?

    public init(
        replicatorArn: Swift.String? = nil,
        replicatorState: KafkaClientTypes.ReplicatorState? = nil
    )
    {
        self.replicatorArn = replicatorArn
        self.replicatorState = replicatorState
    }
}

enum UpdateReplicationInfoOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateSecurityInput {

    static func urlPathProvider(_ value: UpdateSecurityInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/security"
    }
}

extension UpdateSecurityInput {

    static func write(value: UpdateSecurityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientAuthentication"].write(value.clientAuthentication, with: KafkaClientTypes.ClientAuthentication.write(value:to:))
        try writer["currentVersion"].write(value.currentVersion)
        try writer["encryptionInfo"].write(value.encryptionInfo, with: KafkaClientTypes.EncryptionInfo.write(value:to:))
    }
}

public struct UpdateSecurityInput {
    /// Includes all client authentication related information.
    public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// Includes all encryption-related information.
    public var encryptionInfo: KafkaClientTypes.EncryptionInfo?

    public init(
        clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil
    )
    {
        self.clientAuthentication = clientAuthentication
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.encryptionInfo = encryptionInfo
    }
}

extension UpdateSecurityOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateSecurityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSecurityOutput()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterOperationArn = try reader["clusterOperationArn"].readIfPresent()
        return value
    }
}

public struct UpdateSecurityOutput {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

enum UpdateSecurityOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateStorageInput {

    static func urlPathProvider(_ value: UpdateStorageInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/storage"
    }
}

extension UpdateStorageInput {

    static func write(value: UpdateStorageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["currentVersion"].write(value.currentVersion)
        try writer["provisionedThroughput"].write(value.provisionedThroughput, with: KafkaClientTypes.ProvisionedThroughput.write(value:to:))
        try writer["storageMode"].write(value.storageMode)
        try writer["volumeSizeGB"].write(value.volumeSizeGB)
    }
}

/// Request object for UpdateStorage api. Its used to update the storage attributes for the cluster.
public struct UpdateStorageInput {
    /// The Amazon Resource Name (ARN) of the cluster to be updated.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The version of cluster to update from. A successful operation will then generate a new version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// EBS volume provisioned throughput information.
    public var provisionedThroughput: KafkaClientTypes.ProvisionedThroughput?
    /// Controls storage mode for supported storage tiers.
    public var storageMode: KafkaClientTypes.StorageMode?
    /// size of the EBS volume to update.
    public var volumeSizeGB: Swift.Int?

    public init(
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        provisionedThroughput: KafkaClientTypes.ProvisionedThroughput? = nil,
        storageMode: KafkaClientTypes.StorageMode? = nil,
        volumeSizeGB: Swift.Int? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.provisionedThroughput = provisionedThroughput
        self.storageMode = storageMode
        self.volumeSizeGB = volumeSizeGB
    }
}

extension UpdateStorageOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateStorageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateStorageOutput()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.clusterOperationArn = try reader["clusterOperationArn"].readIfPresent()
        return value
    }
}

public struct UpdateStorageOutput {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

enum UpdateStorageOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension KafkaClientTypes.UserIdentity {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.UserIdentity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.UserIdentity()
        value.type = try reader["type"].readIfPresent()
        value.principalId = try reader["principalId"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Description of the requester that calls the API operation.
    public struct UserIdentity {
        /// A unique identifier for the requester that calls the API operation.
        public var principalId: Swift.String?
        /// The identity type of the requester that calls the API operation.
        public var type: KafkaClientTypes.UserIdentityType?

        public init(
            principalId: Swift.String? = nil,
            type: KafkaClientTypes.UserIdentityType? = nil
        )
        {
            self.principalId = principalId
            self.type = type
        }
    }

}

extension KafkaClientTypes {

    /// The identity type of the requester that calls the API operation.
    public enum UserIdentityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsaccount
        case awsservice
        case sdkUnknown(Swift.String)

        public static var allCases: [UserIdentityType] {
            return [
                .awsaccount,
                .awsservice,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsaccount: return "AWSACCOUNT"
            case .awsservice: return "AWSSERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaClientTypes.VpcConfig {

    static func write(value: KafkaClientTypes.VpcConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.VpcConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.VpcConfig()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension KafkaClientTypes {
    /// The configuration of the Amazon VPCs for the cluster.
    public struct VpcConfig {
        /// The IDs of the security groups associated with the cluster.
        public var securityGroupIds: [Swift.String]?
        /// The IDs of the subnets associated with the cluster.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension KafkaClientTypes.VpcConnection {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.VpcConnection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.VpcConnection()
        value.vpcConnectionArn = try reader["vpcConnectionArn"].readIfPresent()
        value.targetClusterArn = try reader["targetClusterArn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.authentication = try reader["authentication"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// The VPC connection object.
    public struct VpcConnection {
        /// Information about the auth scheme of Vpc Connection.
        public var authentication: Swift.String?
        /// Creation time of the Vpc Connection.
        public var creationTime: ClientRuntime.Date?
        /// State of the Vpc Connection.
        public var state: KafkaClientTypes.VpcConnectionState?
        /// The ARN that identifies the Cluster which the Vpc Connection belongs to.
        /// This member is required.
        public var targetClusterArn: Swift.String?
        /// The ARN that identifies the Vpc Connection.
        /// This member is required.
        public var vpcConnectionArn: Swift.String?
        /// The vpcId that belongs to the Vpc Connection.
        public var vpcId: Swift.String?

        public init(
            authentication: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            state: KafkaClientTypes.VpcConnectionState? = nil,
            targetClusterArn: Swift.String? = nil,
            vpcConnectionArn: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.authentication = authentication
            self.creationTime = creationTime
            self.state = state
            self.targetClusterArn = targetClusterArn
            self.vpcConnectionArn = vpcConnectionArn
            self.vpcId = vpcId
        }
    }

}

extension KafkaClientTypes.VpcConnectionInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.VpcConnectionInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.VpcConnectionInfo()
        value.vpcConnectionArn = try reader["vpcConnectionArn"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        value.userIdentity = try reader["userIdentity"].readIfPresent(with: KafkaClientTypes.UserIdentity.read(from:))
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension KafkaClientTypes {
    /// Description of the VPC connection.
    public struct VpcConnectionInfo {
        /// The time when Amazon MSK creates the VPC Connnection.
        public var creationTime: ClientRuntime.Date?
        /// The owner of the VPC Connection.
        public var owner: Swift.String?
        /// Description of the requester that calls the API operation.
        public var userIdentity: KafkaClientTypes.UserIdentity?
        /// The Amazon Resource Name (ARN) of the VPC connection.
        public var vpcConnectionArn: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            owner: Swift.String? = nil,
            userIdentity: KafkaClientTypes.UserIdentity? = nil,
            vpcConnectionArn: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.owner = owner
            self.userIdentity = userIdentity
            self.vpcConnectionArn = vpcConnectionArn
        }
    }

}

extension KafkaClientTypes.VpcConnectionInfoServerless {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.VpcConnectionInfoServerless {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.VpcConnectionInfoServerless()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.owner = try reader["owner"].readIfPresent()
        value.userIdentity = try reader["userIdentity"].readIfPresent(with: KafkaClientTypes.UserIdentity.read(from:))
        value.vpcConnectionArn = try reader["vpcConnectionArn"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Description of the VPC connection.
    public struct VpcConnectionInfoServerless {
        /// The time when Amazon MSK creates the VPC Connnection.
        public var creationTime: ClientRuntime.Date?
        /// The owner of the VPC Connection.
        public var owner: Swift.String?
        /// Description of the requester that calls the API operation.
        public var userIdentity: KafkaClientTypes.UserIdentity?
        /// The Amazon Resource Name (ARN) of the VPC connection.
        public var vpcConnectionArn: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            owner: Swift.String? = nil,
            userIdentity: KafkaClientTypes.UserIdentity? = nil,
            vpcConnectionArn: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.owner = owner
            self.userIdentity = userIdentity
            self.vpcConnectionArn = vpcConnectionArn
        }
    }

}

extension KafkaClientTypes {

    /// The state of a VPC connection.
    public enum VpcConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case deactivating
        case deleting
        case failed
        case inactive
        case rejected
        case rejecting
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcConnectionState] {
            return [
                .available,
                .creating,
                .deactivating,
                .deleting,
                .failed,
                .inactive,
                .rejected,
                .rejecting,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deactivating: return "DEACTIVATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .rejected: return "REJECTED"
            case .rejecting: return "REJECTING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaClientTypes.VpcConnectivity {

    static func write(value: KafkaClientTypes.VpcConnectivity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientAuthentication"].write(value.clientAuthentication, with: KafkaClientTypes.VpcConnectivityClientAuthentication.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.VpcConnectivity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.VpcConnectivity()
        value.clientAuthentication = try reader["clientAuthentication"].readIfPresent(with: KafkaClientTypes.VpcConnectivityClientAuthentication.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// VPC connectivity access control for brokers.
    public struct VpcConnectivity {
        /// Includes all client authentication information for VPC connectivity.
        public var clientAuthentication: KafkaClientTypes.VpcConnectivityClientAuthentication?

        public init(
            clientAuthentication: KafkaClientTypes.VpcConnectivityClientAuthentication? = nil
        )
        {
            self.clientAuthentication = clientAuthentication
        }
    }

}

extension KafkaClientTypes.VpcConnectivityClientAuthentication {

    static func write(value: KafkaClientTypes.VpcConnectivityClientAuthentication?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sasl"].write(value.sasl, with: KafkaClientTypes.VpcConnectivitySasl.write(value:to:))
        try writer["tls"].write(value.tls, with: KafkaClientTypes.VpcConnectivityTls.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.VpcConnectivityClientAuthentication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.VpcConnectivityClientAuthentication()
        value.sasl = try reader["sasl"].readIfPresent(with: KafkaClientTypes.VpcConnectivitySasl.read(from:))
        value.tls = try reader["tls"].readIfPresent(with: KafkaClientTypes.VpcConnectivityTls.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Includes all client authentication information for VPC connectivity.
    public struct VpcConnectivityClientAuthentication {
        /// SASL authentication type details for VPC connectivity.
        public var sasl: KafkaClientTypes.VpcConnectivitySasl?
        /// TLS authentication type details for VPC connectivity.
        public var tls: KafkaClientTypes.VpcConnectivityTls?

        public init(
            sasl: KafkaClientTypes.VpcConnectivitySasl? = nil,
            tls: KafkaClientTypes.VpcConnectivityTls? = nil
        )
        {
            self.sasl = sasl
            self.tls = tls
        }
    }

}

extension KafkaClientTypes.VpcConnectivityIam {

    static func write(value: KafkaClientTypes.VpcConnectivityIam?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.VpcConnectivityIam {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.VpcConnectivityIam()
        value.enabled = try reader["enabled"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Details for IAM access control for VPC connectivity.
    public struct VpcConnectivityIam {
        /// SASL/IAM authentication is on or off for VPC connectivity.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension KafkaClientTypes.VpcConnectivitySasl {

    static func write(value: KafkaClientTypes.VpcConnectivitySasl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["iam"].write(value.iam, with: KafkaClientTypes.VpcConnectivityIam.write(value:to:))
        try writer["scram"].write(value.scram, with: KafkaClientTypes.VpcConnectivityScram.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.VpcConnectivitySasl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.VpcConnectivitySasl()
        value.scram = try reader["scram"].readIfPresent(with: KafkaClientTypes.VpcConnectivityScram.read(from:))
        value.iam = try reader["iam"].readIfPresent(with: KafkaClientTypes.VpcConnectivityIam.read(from:))
        return value
    }
}

extension KafkaClientTypes {
    /// Details for SASL client authentication for VPC connectivity.
    public struct VpcConnectivitySasl {
        /// Details for SASL/IAM client authentication for VPC connectivity.
        public var iam: KafkaClientTypes.VpcConnectivityIam?
        /// Details for SASL/SCRAM client authentication for VPC connectivity.
        public var scram: KafkaClientTypes.VpcConnectivityScram?

        public init(
            iam: KafkaClientTypes.VpcConnectivityIam? = nil,
            scram: KafkaClientTypes.VpcConnectivityScram? = nil
        )
        {
            self.iam = iam
            self.scram = scram
        }
    }

}

extension KafkaClientTypes.VpcConnectivityScram {

    static func write(value: KafkaClientTypes.VpcConnectivityScram?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.VpcConnectivityScram {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.VpcConnectivityScram()
        value.enabled = try reader["enabled"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Details for SASL/SCRAM client authentication for VPC connectivity.
    public struct VpcConnectivityScram {
        /// SASL/SCRAM authentication is on or off for VPC connectivity.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension KafkaClientTypes.VpcConnectivityTls {

    static func write(value: KafkaClientTypes.VpcConnectivityTls?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.VpcConnectivityTls {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.VpcConnectivityTls()
        value.enabled = try reader["enabled"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Details for TLS client authentication for VPC connectivity.
    public struct VpcConnectivityTls {
        /// TLS authentication is on or off for VPC connectivity.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension KafkaClientTypes.ZookeeperNodeInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaClientTypes.ZookeeperNodeInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaClientTypes.ZookeeperNodeInfo()
        value.attachedENIId = try reader["attachedENIId"].readIfPresent()
        value.clientVpcIpAddress = try reader["clientVpcIpAddress"].readIfPresent()
        value.endpoints = try reader["endpoints"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.zookeeperId = try reader["zookeeperId"].readIfPresent()
        value.zookeeperVersion = try reader["zookeeperVersion"].readIfPresent()
        return value
    }
}

extension KafkaClientTypes {
    /// Zookeeper node information.
    public struct ZookeeperNodeInfo {
        /// The attached elastic network interface of the broker.
        public var attachedENIId: Swift.String?
        /// The virtual private cloud (VPC) IP address of the client.
        public var clientVpcIpAddress: Swift.String?
        /// Endpoints for accessing the ZooKeeper.
        public var endpoints: [Swift.String]?
        /// The role-specific ID for Zookeeper.
        public var zookeeperId: Swift.Double?
        /// The version of Zookeeper.
        public var zookeeperVersion: Swift.String?

        public init(
            attachedENIId: Swift.String? = nil,
            clientVpcIpAddress: Swift.String? = nil,
            endpoints: [Swift.String]? = nil,
            zookeeperId: Swift.Double? = nil,
            zookeeperVersion: Swift.String? = nil
        )
        {
            self.attachedENIId = attachedENIId
            self.clientVpcIpAddress = clientVpcIpAddress
            self.endpoints = endpoints
            self.zookeeperId = zookeeperId
            self.zookeeperVersion = zookeeperVersion
        }
    }

}
