// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.invalidParameter = output.invalidParameter
            self.properties.message = output.message
        } else {
            self.properties.invalidParameter = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returns information about an error.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let invalidParameter: Swift.String?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchAssociateScramSecretInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretArnList = "secretArnList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretArnList = secretArnList {
            var secretArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secretArnList)
            for __string0 in secretArnList {
                try secretArnListContainer.encode(__string0)
            }
        }
    }
}

extension BatchAssociateScramSecretInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/scram-secrets"
    }
}

/// Associates sasl scram secrets to cluster.
public struct BatchAssociateScramSecretInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster to be updated.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// List of AWS Secrets Manager secret ARNs.
    /// This member is required.
    public var secretArnList: [Swift.String]?

    public init(
        clusterArn: Swift.String? = nil,
        secretArnList: [Swift.String]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.secretArnList = secretArnList
    }
}

struct BatchAssociateScramSecretInputBody: Swift.Equatable {
    let secretArnList: [Swift.String]?
}

extension BatchAssociateScramSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretArnList = "secretArnList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .secretArnList)
        var secretArnListDecoded0:[Swift.String]? = nil
        if let secretArnListContainer = secretArnListContainer {
            secretArnListDecoded0 = [Swift.String]()
            for string0 in secretArnListContainer {
                if let string0 = string0 {
                    secretArnListDecoded0?.append(string0)
                }
            }
        }
        secretArnList = secretArnListDecoded0
    }
}

extension BatchAssociateScramSecretOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchAssociateScramSecretOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.unprocessedScramSecrets = output.unprocessedScramSecrets
        } else {
            self.clusterArn = nil
            self.unprocessedScramSecrets = nil
        }
    }
}

public struct BatchAssociateScramSecretOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// List of errors when associating secrets to cluster.
    public var unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]?

    public init(
        clusterArn: Swift.String? = nil,
        unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.unprocessedScramSecrets = unprocessedScramSecrets
    }
}

struct BatchAssociateScramSecretOutputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]?
}

extension BatchAssociateScramSecretOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case unprocessedScramSecrets = "unprocessedScramSecrets"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let unprocessedScramSecretsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.UnprocessedScramSecret?].self, forKey: .unprocessedScramSecrets)
        var unprocessedScramSecretsDecoded0:[KafkaClientTypes.UnprocessedScramSecret]? = nil
        if let unprocessedScramSecretsContainer = unprocessedScramSecretsContainer {
            unprocessedScramSecretsDecoded0 = [KafkaClientTypes.UnprocessedScramSecret]()
            for structure0 in unprocessedScramSecretsContainer {
                if let structure0 = structure0 {
                    unprocessedScramSecretsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedScramSecrets = unprocessedScramSecretsDecoded0
    }
}

enum BatchAssociateScramSecretOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchDisassociateScramSecretInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretArnList = "secretArnList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretArnList = secretArnList {
            var secretArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secretArnList)
            for __string0 in secretArnList {
                try secretArnListContainer.encode(__string0)
            }
        }
    }
}

extension BatchDisassociateScramSecretInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/scram-secrets"
    }
}

/// Disassociates sasl scram secrets to cluster.
public struct BatchDisassociateScramSecretInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster to be updated.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// List of AWS Secrets Manager secret ARNs.
    /// This member is required.
    public var secretArnList: [Swift.String]?

    public init(
        clusterArn: Swift.String? = nil,
        secretArnList: [Swift.String]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.secretArnList = secretArnList
    }
}

struct BatchDisassociateScramSecretInputBody: Swift.Equatable {
    let secretArnList: [Swift.String]?
}

extension BatchDisassociateScramSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretArnList = "secretArnList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .secretArnList)
        var secretArnListDecoded0:[Swift.String]? = nil
        if let secretArnListContainer = secretArnListContainer {
            secretArnListDecoded0 = [Swift.String]()
            for string0 in secretArnListContainer {
                if let string0 = string0 {
                    secretArnListDecoded0?.append(string0)
                }
            }
        }
        secretArnList = secretArnListDecoded0
    }
}

extension BatchDisassociateScramSecretOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDisassociateScramSecretOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.unprocessedScramSecrets = output.unprocessedScramSecrets
        } else {
            self.clusterArn = nil
            self.unprocessedScramSecrets = nil
        }
    }
}

public struct BatchDisassociateScramSecretOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// List of errors when disassociating secrets to cluster.
    public var unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]?

    public init(
        clusterArn: Swift.String? = nil,
        unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.unprocessedScramSecrets = unprocessedScramSecrets
    }
}

struct BatchDisassociateScramSecretOutputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]?
}

extension BatchDisassociateScramSecretOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case unprocessedScramSecrets = "unprocessedScramSecrets"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let unprocessedScramSecretsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.UnprocessedScramSecret?].self, forKey: .unprocessedScramSecrets)
        var unprocessedScramSecretsDecoded0:[KafkaClientTypes.UnprocessedScramSecret]? = nil
        if let unprocessedScramSecretsContainer = unprocessedScramSecretsContainer {
            unprocessedScramSecretsDecoded0 = [KafkaClientTypes.UnprocessedScramSecret]()
            for structure0 in unprocessedScramSecretsContainer {
                if let structure0 = structure0 {
                    unprocessedScramSecretsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedScramSecrets = unprocessedScramSecretsDecoded0
    }
}

enum BatchDisassociateScramSecretOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KafkaClientTypes {
    /// The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed. Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.
    public enum BrokerAZDistribution: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [BrokerAZDistribution] {
            return [
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BrokerAZDistribution(rawValue: rawValue) ?? BrokerAZDistribution.sdkUnknown(rawValue)
        }
    }
}

extension KafkaClientTypes.BrokerEBSVolumeInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kafkaBrokerNodeId = "kafkaBrokerNodeId"
        case provisionedThroughput = "provisionedThroughput"
        case volumeSizeGB = "volumeSizeGB"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kafkaBrokerNodeId = self.kafkaBrokerNodeId {
            try encodeContainer.encode(kafkaBrokerNodeId, forKey: .kafkaBrokerNodeId)
        }
        if let provisionedThroughput = self.provisionedThroughput {
            try encodeContainer.encode(provisionedThroughput, forKey: .provisionedThroughput)
        }
        if let volumeSizeGB = self.volumeSizeGB {
            try encodeContainer.encode(volumeSizeGB, forKey: .volumeSizeGB)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kafkaBrokerNodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kafkaBrokerNodeId)
        kafkaBrokerNodeId = kafkaBrokerNodeIdDecoded
        let provisionedThroughputDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ProvisionedThroughput.self, forKey: .provisionedThroughput)
        provisionedThroughput = provisionedThroughputDecoded
        let volumeSizeGBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSizeGB)
        volumeSizeGB = volumeSizeGBDecoded
    }
}

extension KafkaClientTypes {
    /// Specifies the EBS volume upgrade information. The broker identifier must be set to the keyword ALL. This means the changes apply to all the brokers in the cluster.
    public struct BrokerEBSVolumeInfo: Swift.Equatable {
        /// The ID of the broker to update.
        /// This member is required.
        public var kafkaBrokerNodeId: Swift.String?
        /// EBS volume provisioned throughput information.
        public var provisionedThroughput: KafkaClientTypes.ProvisionedThroughput?
        /// Size of the EBS volume to update.
        public var volumeSizeGB: Swift.Int?

        public init(
            kafkaBrokerNodeId: Swift.String? = nil,
            provisionedThroughput: KafkaClientTypes.ProvisionedThroughput? = nil,
            volumeSizeGB: Swift.Int? = nil
        )
        {
            self.kafkaBrokerNodeId = kafkaBrokerNodeId
            self.provisionedThroughput = provisionedThroughput
            self.volumeSizeGB = volumeSizeGB
        }
    }

}

extension KafkaClientTypes.BrokerLogs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogs = "cloudWatchLogs"
        case firehose = "firehose"
        case s3 = "s3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = self.cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let firehose = self.firehose {
            try encodeContainer.encode(firehose, forKey: .firehose)
        }
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.CloudWatchLogs.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
        let firehoseDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Firehose.self, forKey: .firehose)
        firehose = firehoseDecoded
        let s3Decoded = try containerValues.decodeIfPresent(KafkaClientTypes.S3.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension KafkaClientTypes {
    public struct BrokerLogs: Swift.Equatable {
        public var cloudWatchLogs: KafkaClientTypes.CloudWatchLogs?
        public var firehose: KafkaClientTypes.Firehose?
        public var s3: KafkaClientTypes.S3?

        public init(
            cloudWatchLogs: KafkaClientTypes.CloudWatchLogs? = nil,
            firehose: KafkaClientTypes.Firehose? = nil,
            s3: KafkaClientTypes.S3? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.firehose = firehose
            self.s3 = s3
        }
    }

}

extension KafkaClientTypes.BrokerNodeGroupInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerAZDistribution = "brokerAZDistribution"
        case clientSubnets = "clientSubnets"
        case connectivityInfo = "connectivityInfo"
        case instanceType = "instanceType"
        case securityGroups = "securityGroups"
        case storageInfo = "storageInfo"
        case zoneIds = "zoneIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerAZDistribution = self.brokerAZDistribution {
            try encodeContainer.encode(brokerAZDistribution.rawValue, forKey: .brokerAZDistribution)
        }
        if let clientSubnets = clientSubnets {
            var clientSubnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientSubnets)
            for __string0 in clientSubnets {
                try clientSubnetsContainer.encode(__string0)
            }
        }
        if let connectivityInfo = self.connectivityInfo {
            try encodeContainer.encode(connectivityInfo, forKey: .connectivityInfo)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for __string0 in securityGroups {
                try securityGroupsContainer.encode(__string0)
            }
        }
        if let storageInfo = self.storageInfo {
            try encodeContainer.encode(storageInfo, forKey: .storageInfo)
        }
        if let zoneIds = zoneIds {
            var zoneIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .zoneIds)
            for __string0 in zoneIds {
                try zoneIdsContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerAZDistributionDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerAZDistribution.self, forKey: .brokerAZDistribution)
        brokerAZDistribution = brokerAZDistributionDecoded
        let clientSubnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientSubnets)
        var clientSubnetsDecoded0:[Swift.String]? = nil
        if let clientSubnetsContainer = clientSubnetsContainer {
            clientSubnetsDecoded0 = [Swift.String]()
            for string0 in clientSubnetsContainer {
                if let string0 = string0 {
                    clientSubnetsDecoded0?.append(string0)
                }
            }
        }
        clientSubnets = clientSubnetsDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let storageInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.StorageInfo.self, forKey: .storageInfo)
        storageInfo = storageInfoDecoded
        let connectivityInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConnectivityInfo.self, forKey: .connectivityInfo)
        connectivityInfo = connectivityInfoDecoded
        let zoneIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .zoneIds)
        var zoneIdsDecoded0:[Swift.String]? = nil
        if let zoneIdsContainer = zoneIdsContainer {
            zoneIdsDecoded0 = [Swift.String]()
            for string0 in zoneIdsContainer {
                if let string0 = string0 {
                    zoneIdsDecoded0?.append(string0)
                }
            }
        }
        zoneIds = zoneIdsDecoded0
    }
}

extension KafkaClientTypes {
    /// Describes the setup to be used for Apache Kafka broker nodes in the cluster.
    public struct BrokerNodeGroupInfo: Swift.Equatable {
        /// The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed. Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.
        public var brokerAZDistribution: KafkaClientTypes.BrokerAZDistribution?
        /// The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't occupy the Availability Zone with ID use use1-az3.
        /// This member is required.
        public var clientSubnets: [Swift.String]?
        /// Information about the broker access configuration.
        public var connectivityInfo: KafkaClientTypes.ConnectivityInfo?
        /// The type of Amazon EC2 instances to use for Apache Kafka brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge, kafka.m5.4xlarge, kafka.m5.12xlarge, and kafka.m5.24xlarge.
        /// This member is required.
        public var instanceType: Swift.String?
        /// The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC.
        public var securityGroups: [Swift.String]?
        /// Contains information about storage volumes attached to MSK broker nodes.
        public var storageInfo: KafkaClientTypes.StorageInfo?
        /// The list of zoneIds for the cluster in the virtual private cloud (VPC).
        public var zoneIds: [Swift.String]?

        public init(
            brokerAZDistribution: KafkaClientTypes.BrokerAZDistribution? = nil,
            clientSubnets: [Swift.String]? = nil,
            connectivityInfo: KafkaClientTypes.ConnectivityInfo? = nil,
            instanceType: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            storageInfo: KafkaClientTypes.StorageInfo? = nil,
            zoneIds: [Swift.String]? = nil
        )
        {
            self.brokerAZDistribution = brokerAZDistribution
            self.clientSubnets = clientSubnets
            self.connectivityInfo = connectivityInfo
            self.instanceType = instanceType
            self.securityGroups = securityGroups
            self.storageInfo = storageInfo
            self.zoneIds = zoneIds
        }
    }

}

extension KafkaClientTypes.BrokerNodeInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedENIId = "attachedENIId"
        case brokerId = "brokerId"
        case clientSubnet = "clientSubnet"
        case clientVpcIpAddress = "clientVpcIpAddress"
        case currentBrokerSoftwareInfo = "currentBrokerSoftwareInfo"
        case endpoints = "endpoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedENIId = self.attachedENIId {
            try encodeContainer.encode(attachedENIId, forKey: .attachedENIId)
        }
        if let brokerId = self.brokerId {
            try encodeContainer.encode(brokerId, forKey: .brokerId)
        }
        if let clientSubnet = self.clientSubnet {
            try encodeContainer.encode(clientSubnet, forKey: .clientSubnet)
        }
        if let clientVpcIpAddress = self.clientVpcIpAddress {
            try encodeContainer.encode(clientVpcIpAddress, forKey: .clientVpcIpAddress)
        }
        if let currentBrokerSoftwareInfo = self.currentBrokerSoftwareInfo {
            try encodeContainer.encode(currentBrokerSoftwareInfo, forKey: .currentBrokerSoftwareInfo)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for __string0 in endpoints {
                try endpointsContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedENIIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachedENIId)
        attachedENIId = attachedENIIdDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let clientSubnetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSubnet)
        clientSubnet = clientSubnetDecoded
        let clientVpcIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientVpcIpAddress)
        clientVpcIpAddress = clientVpcIpAddressDecoded
        let currentBrokerSoftwareInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerSoftwareInfo.self, forKey: .currentBrokerSoftwareInfo)
        currentBrokerSoftwareInfo = currentBrokerSoftwareInfoDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .endpoints)
        var endpointsDecoded0:[Swift.String]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Swift.String]()
            for string0 in endpointsContainer {
                if let string0 = string0 {
                    endpointsDecoded0?.append(string0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension KafkaClientTypes {
    /// BrokerNodeInfo
    public struct BrokerNodeInfo: Swift.Equatable {
        /// The attached elastic network interface of the broker.
        public var attachedENIId: Swift.String?
        /// The ID of the broker.
        public var brokerId: Swift.Double?
        /// The client subnet to which this broker node belongs.
        public var clientSubnet: Swift.String?
        /// The virtual private cloud (VPC) of the client.
        public var clientVpcIpAddress: Swift.String?
        /// Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.
        public var currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo?
        /// Endpoints for accessing the broker.
        public var endpoints: [Swift.String]?

        public init(
            attachedENIId: Swift.String? = nil,
            brokerId: Swift.Double? = nil,
            clientSubnet: Swift.String? = nil,
            clientVpcIpAddress: Swift.String? = nil,
            currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo? = nil,
            endpoints: [Swift.String]? = nil
        )
        {
            self.attachedENIId = attachedENIId
            self.brokerId = brokerId
            self.clientSubnet = clientSubnet
            self.clientVpcIpAddress = clientVpcIpAddress
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.endpoints = endpoints
        }
    }

}

extension KafkaClientTypes.BrokerSoftwareInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationArn = "configurationArn"
        case configurationRevision = "configurationRevision"
        case kafkaVersion = "kafkaVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationArn = self.configurationArn {
            try encodeContainer.encode(configurationArn, forKey: .configurationArn)
        }
        if let configurationRevision = self.configurationRevision {
            try encodeContainer.encode(configurationRevision, forKey: .configurationRevision)
        }
        if let kafkaVersion = self.kafkaVersion {
            try encodeContainer.encode(kafkaVersion, forKey: .kafkaVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationArn)
        configurationArn = configurationArnDecoded
        let configurationRevisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .configurationRevision)
        configurationRevision = configurationRevisionDecoded
        let kafkaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kafkaVersion)
        kafkaVersion = kafkaVersionDecoded
    }
}

extension KafkaClientTypes {
    /// Information about the current software installed on the cluster.
    public struct BrokerSoftwareInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.
        public var configurationArn: Swift.String?
        /// The revision of the configuration to use. This field isn't visible in this preview release.
        public var configurationRevision: Swift.Int?
        /// The version of Apache Kafka.
        public var kafkaVersion: Swift.String?

        public init(
            configurationArn: Swift.String? = nil,
            configurationRevision: Swift.Int? = nil,
            kafkaVersion: Swift.String? = nil
        )
        {
            self.configurationArn = configurationArn
            self.configurationRevision = configurationRevision
            self.kafkaVersion = kafkaVersion
        }
    }

}

extension KafkaClientTypes.ClientAuthentication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sasl = "sasl"
        case tls = "tls"
        case unauthenticated = "unauthenticated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sasl = self.sasl {
            try encodeContainer.encode(sasl, forKey: .sasl)
        }
        if let tls = self.tls {
            try encodeContainer.encode(tls, forKey: .tls)
        }
        if let unauthenticated = self.unauthenticated {
            try encodeContainer.encode(unauthenticated, forKey: .unauthenticated)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let saslDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Sasl.self, forKey: .sasl)
        sasl = saslDecoded
        let tlsDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Tls.self, forKey: .tls)
        tls = tlsDecoded
        let unauthenticatedDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Unauthenticated.self, forKey: .unauthenticated)
        unauthenticated = unauthenticatedDecoded
    }
}

extension KafkaClientTypes {
    /// Includes all client authentication information.
    public struct ClientAuthentication: Swift.Equatable {
        /// Details for ClientAuthentication using SASL.
        public var sasl: KafkaClientTypes.Sasl?
        /// Details for ClientAuthentication using TLS.
        public var tls: KafkaClientTypes.Tls?
        /// Contains information about unauthenticated traffic to the cluster.
        public var unauthenticated: KafkaClientTypes.Unauthenticated?

        public init(
            sasl: KafkaClientTypes.Sasl? = nil,
            tls: KafkaClientTypes.Tls? = nil,
            unauthenticated: KafkaClientTypes.Unauthenticated? = nil
        )
        {
            self.sasl = sasl
            self.tls = tls
            self.unauthenticated = unauthenticated
        }
    }

}

extension KafkaClientTypes {
    /// Client-broker encryption in transit setting.
    public enum ClientBroker: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plaintext
        case tls
        case tlsPlaintext
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientBroker] {
            return [
                .plaintext,
                .tls,
                .tlsPlaintext,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "PLAINTEXT"
            case .tls: return "TLS"
            case .tlsPlaintext: return "TLS_PLAINTEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClientBroker(rawValue: rawValue) ?? ClientBroker.sdkUnknown(rawValue)
        }
    }
}

extension KafkaClientTypes.ClientVpcConnection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authentication = "authentication"
        case creationTime = "creationTime"
        case owner = "owner"
        case state = "state"
        case vpcConnectionArn = "vpcConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authentication = self.authentication {
            try encodeContainer.encode(authentication, forKey: .authentication)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let vpcConnectionArn = self.vpcConnectionArn {
            try encodeContainer.encode(vpcConnectionArn, forKey: .vpcConnectionArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authentication)
        authentication = authenticationDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.VpcConnectionState.self, forKey: .state)
        state = stateDecoded
        let vpcConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectionArn)
        vpcConnectionArn = vpcConnectionArnDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension KafkaClientTypes {
    /// The client VPC connection object.
    public struct ClientVpcConnection: Swift.Equatable {
        /// Information about the auth scheme of Vpc Connection.
        public var authentication: Swift.String?
        /// Creation time of the Vpc Connection.
        public var creationTime: ClientRuntime.Date?
        /// The Owner of the Vpc Connection.
        public var owner: Swift.String?
        /// State of the Vpc Connection.
        public var state: KafkaClientTypes.VpcConnectionState?
        /// The ARN that identifies the Vpc Connection.
        /// This member is required.
        public var vpcConnectionArn: Swift.String?

        public init(
            authentication: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            owner: Swift.String? = nil,
            state: KafkaClientTypes.VpcConnectionState? = nil,
            vpcConnectionArn: Swift.String? = nil
        )
        {
            self.authentication = authentication
            self.creationTime = creationTime
            self.owner = owner
            self.state = state
            self.vpcConnectionArn = vpcConnectionArn
        }
    }

}

extension KafkaClientTypes.CloudWatchLogs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "enabled"
        case logGroup = "logGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let logGroup = self.logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let logGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
    }
}

extension KafkaClientTypes {
    public struct CloudWatchLogs: Swift.Equatable {
        /// This member is required.
        public var enabled: Swift.Bool?
        public var logGroup: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            logGroup: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.logGroup = logGroup
        }
    }

}

extension KafkaClientTypes.Cluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeOperationArn = "activeOperationArn"
        case clusterArn = "clusterArn"
        case clusterName = "clusterName"
        case clusterType = "clusterType"
        case creationTime = "creationTime"
        case currentVersion = "currentVersion"
        case provisioned = "provisioned"
        case serverless = "serverless"
        case state = "state"
        case stateInfo = "stateInfo"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeOperationArn = self.activeOperationArn {
            try encodeContainer.encode(activeOperationArn, forKey: .activeOperationArn)
        }
        if let clusterArn = self.clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let clusterType = self.clusterType {
            try encodeContainer.encode(clusterType.rawValue, forKey: .clusterType)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let provisioned = self.provisioned {
            try encodeContainer.encode(provisioned, forKey: .provisioned)
        }
        if let serverless = self.serverless {
            try encodeContainer.encode(serverless, forKey: .serverless)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateInfo = self.stateInfo {
            try encodeContainer.encode(stateInfo, forKey: .stateInfo)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeOperationArn)
        activeOperationArn = activeOperationArnDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterType.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterState.self, forKey: .state)
        state = stateDecoded
        let stateInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.StateInfo.self, forKey: .stateInfo)
        stateInfo = stateInfoDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let provisionedDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Provisioned.self, forKey: .provisioned)
        provisioned = provisionedDecoded
        let serverlessDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Serverless.self, forKey: .serverless)
        serverless = serverlessDecoded
    }
}

extension KafkaClientTypes {
    /// Returns information about a cluster.
    public struct Cluster: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that uniquely identifies a cluster operation.
        public var activeOperationArn: Swift.String?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public var clusterArn: Swift.String?
        /// The name of the cluster.
        public var clusterName: Swift.String?
        /// Cluster Type.
        public var clusterType: KafkaClientTypes.ClusterType?
        /// The time when the cluster was created.
        public var creationTime: ClientRuntime.Date?
        /// The current version of the MSK cluster.
        public var currentVersion: Swift.String?
        /// Information about the provisioned cluster.
        public var provisioned: KafkaClientTypes.Provisioned?
        /// Information about the serverless cluster.
        public var serverless: KafkaClientTypes.Serverless?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public var state: KafkaClientTypes.ClusterState?
        /// State Info for the Amazon MSK cluster.
        public var stateInfo: KafkaClientTypes.StateInfo?
        /// Tags attached to the cluster.
        public var tags: [Swift.String:Swift.String]?

        public init(
            activeOperationArn: Swift.String? = nil,
            clusterArn: Swift.String? = nil,
            clusterName: Swift.String? = nil,
            clusterType: KafkaClientTypes.ClusterType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            currentVersion: Swift.String? = nil,
            provisioned: KafkaClientTypes.Provisioned? = nil,
            serverless: KafkaClientTypes.Serverless? = nil,
            state: KafkaClientTypes.ClusterState? = nil,
            stateInfo: KafkaClientTypes.StateInfo? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeOperationArn = activeOperationArn
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.creationTime = creationTime
            self.currentVersion = currentVersion
            self.provisioned = provisioned
            self.serverless = serverless
            self.state = state
            self.stateInfo = stateInfo
            self.tags = tags
        }
    }

}

extension KafkaClientTypes.ClusterInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeOperationArn = "activeOperationArn"
        case brokerNodeGroupInfo = "brokerNodeGroupInfo"
        case clientAuthentication = "clientAuthentication"
        case clusterArn = "clusterArn"
        case clusterName = "clusterName"
        case creationTime = "creationTime"
        case currentBrokerSoftwareInfo = "currentBrokerSoftwareInfo"
        case currentVersion = "currentVersion"
        case encryptionInfo = "encryptionInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
        case state = "state"
        case stateInfo = "stateInfo"
        case storageMode = "storageMode"
        case tags = "tags"
        case zookeeperConnectString = "zookeeperConnectString"
        case zookeeperConnectStringTls = "zookeeperConnectStringTls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeOperationArn = self.activeOperationArn {
            try encodeContainer.encode(activeOperationArn, forKey: .activeOperationArn)
        }
        if let brokerNodeGroupInfo = self.brokerNodeGroupInfo {
            try encodeContainer.encode(brokerNodeGroupInfo, forKey: .brokerNodeGroupInfo)
        }
        if let clientAuthentication = self.clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let clusterArn = self.clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let currentBrokerSoftwareInfo = self.currentBrokerSoftwareInfo {
            try encodeContainer.encode(currentBrokerSoftwareInfo, forKey: .currentBrokerSoftwareInfo)
        }
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let encryptionInfo = self.encryptionInfo {
            try encodeContainer.encode(encryptionInfo, forKey: .encryptionInfo)
        }
        if let enhancedMonitoring = self.enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let loggingInfo = self.loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let numberOfBrokerNodes = self.numberOfBrokerNodes {
            try encodeContainer.encode(numberOfBrokerNodes, forKey: .numberOfBrokerNodes)
        }
        if let openMonitoring = self.openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateInfo = self.stateInfo {
            try encodeContainer.encode(stateInfo, forKey: .stateInfo)
        }
        if let storageMode = self.storageMode {
            try encodeContainer.encode(storageMode.rawValue, forKey: .storageMode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let zookeeperConnectString = self.zookeeperConnectString {
            try encodeContainer.encode(zookeeperConnectString, forKey: .zookeeperConnectString)
        }
        if let zookeeperConnectStringTls = self.zookeeperConnectStringTls {
            try encodeContainer.encode(zookeeperConnectStringTls, forKey: .zookeeperConnectStringTls)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeOperationArn)
        activeOperationArn = activeOperationArnDecoded
        let brokerNodeGroupInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerNodeGroupInfo.self, forKey: .brokerNodeGroupInfo)
        brokerNodeGroupInfo = brokerNodeGroupInfoDecoded
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let currentBrokerSoftwareInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerSoftwareInfo.self, forKey: .currentBrokerSoftwareInfo)
        currentBrokerSoftwareInfo = currentBrokerSoftwareInfoDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let encryptionInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionInfo.self, forKey: .encryptionInfo)
        encryptionInfo = encryptionInfoDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.OpenMonitoring.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let numberOfBrokerNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfBrokerNodes)
        numberOfBrokerNodes = numberOfBrokerNodesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterState.self, forKey: .state)
        state = stateDecoded
        let stateInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.StateInfo.self, forKey: .stateInfo)
        stateInfo = stateInfoDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let zookeeperConnectStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zookeeperConnectString)
        zookeeperConnectString = zookeeperConnectStringDecoded
        let zookeeperConnectStringTlsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zookeeperConnectStringTls)
        zookeeperConnectStringTls = zookeeperConnectStringTlsDecoded
        let storageModeDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.StorageMode.self, forKey: .storageMode)
        storageMode = storageModeDecoded
    }
}

extension KafkaClientTypes {
    /// Returns information about a cluster.
    public struct ClusterInfo: Swift.Equatable {
        /// Arn of active cluster operation.
        public var activeOperationArn: Swift.String?
        /// Information about the broker nodes.
        public var brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo?
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public var clusterArn: Swift.String?
        /// The name of the cluster.
        public var clusterName: Swift.String?
        /// The time when the cluster was created.
        public var creationTime: ClientRuntime.Date?
        /// Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.
        public var currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo?
        /// The current version of the MSK cluster.
        public var currentVersion: Swift.String?
        /// Includes all encryption-related information.
        public var encryptionInfo: KafkaClientTypes.EncryptionInfo?
        /// Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see [Monitoring](https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html).
        public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
        public var loggingInfo: KafkaClientTypes.LoggingInfo?
        /// The number of broker nodes in the cluster.
        public var numberOfBrokerNodes: Swift.Int?
        /// Settings for open monitoring using Prometheus.
        public var openMonitoring: KafkaClientTypes.OpenMonitoring?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public var state: KafkaClientTypes.ClusterState?
        public var stateInfo: KafkaClientTypes.StateInfo?
        /// This controls storage mode for supported storage tiers.
        public var storageMode: KafkaClientTypes.StorageMode?
        /// Tags attached to the cluster.
        public var tags: [Swift.String:Swift.String]?
        /// The connection string to use to connect to the Apache ZooKeeper cluster.
        public var zookeeperConnectString: Swift.String?
        /// The connection string to use to connect to zookeeper cluster on Tls port.
        public var zookeeperConnectStringTls: Swift.String?

        public init(
            activeOperationArn: Swift.String? = nil,
            brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo? = nil,
            clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
            clusterArn: Swift.String? = nil,
            clusterName: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo? = nil,
            currentVersion: Swift.String? = nil,
            encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil,
            enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
            loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
            numberOfBrokerNodes: Swift.Int? = nil,
            openMonitoring: KafkaClientTypes.OpenMonitoring? = nil,
            state: KafkaClientTypes.ClusterState? = nil,
            stateInfo: KafkaClientTypes.StateInfo? = nil,
            storageMode: KafkaClientTypes.StorageMode? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            zookeeperConnectString: Swift.String? = nil,
            zookeeperConnectStringTls: Swift.String? = nil
        )
        {
            self.activeOperationArn = activeOperationArn
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.creationTime = creationTime
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.currentVersion = currentVersion
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.state = state
            self.stateInfo = stateInfo
            self.storageMode = storageMode
            self.tags = tags
            self.zookeeperConnectString = zookeeperConnectString
            self.zookeeperConnectStringTls = zookeeperConnectStringTls
        }
    }

}

extension KafkaClientTypes.ClusterOperationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestId = "clientRequestId"
        case clusterArn = "clusterArn"
        case creationTime = "creationTime"
        case endTime = "endTime"
        case errorInfo = "errorInfo"
        case operationArn = "operationArn"
        case operationState = "operationState"
        case operationSteps = "operationSteps"
        case operationType = "operationType"
        case sourceClusterInfo = "sourceClusterInfo"
        case targetClusterInfo = "targetClusterInfo"
        case vpcConnectionInfo = "vpcConnectionInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestId = self.clientRequestId {
            try encodeContainer.encode(clientRequestId, forKey: .clientRequestId)
        }
        if let clusterArn = self.clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let operationArn = self.operationArn {
            try encodeContainer.encode(operationArn, forKey: .operationArn)
        }
        if let operationState = self.operationState {
            try encodeContainer.encode(operationState, forKey: .operationState)
        }
        if let operationSteps = operationSteps {
            var operationStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operationSteps)
            for clusteroperationstep0 in operationSteps {
                try operationStepsContainer.encode(clusteroperationstep0)
            }
        }
        if let operationType = self.operationType {
            try encodeContainer.encode(operationType, forKey: .operationType)
        }
        if let sourceClusterInfo = self.sourceClusterInfo {
            try encodeContainer.encode(sourceClusterInfo, forKey: .sourceClusterInfo)
        }
        if let targetClusterInfo = self.targetClusterInfo {
            try encodeContainer.encode(targetClusterInfo, forKey: .targetClusterInfo)
        }
        if let vpcConnectionInfo = self.vpcConnectionInfo {
            try encodeContainer.encode(vpcConnectionInfo, forKey: .vpcConnectionInfo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestId)
        clientRequestId = clientRequestIdDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let operationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationArn)
        operationArn = operationArnDecoded
        let operationStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationState)
        operationState = operationStateDecoded
        let operationStepsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.ClusterOperationStep?].self, forKey: .operationSteps)
        var operationStepsDecoded0:[KafkaClientTypes.ClusterOperationStep]? = nil
        if let operationStepsContainer = operationStepsContainer {
            operationStepsDecoded0 = [KafkaClientTypes.ClusterOperationStep]()
            for structure0 in operationStepsContainer {
                if let structure0 = structure0 {
                    operationStepsDecoded0?.append(structure0)
                }
            }
        }
        operationSteps = operationStepsDecoded0
        let operationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationType)
        operationType = operationTypeDecoded
        let sourceClusterInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.MutableClusterInfo.self, forKey: .sourceClusterInfo)
        sourceClusterInfo = sourceClusterInfoDecoded
        let targetClusterInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.MutableClusterInfo.self, forKey: .targetClusterInfo)
        targetClusterInfo = targetClusterInfoDecoded
        let vpcConnectionInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.VpcConnectionInfo.self, forKey: .vpcConnectionInfo)
        vpcConnectionInfo = vpcConnectionInfoDecoded
    }
}

extension KafkaClientTypes {
    /// Returns information about a cluster operation.
    public struct ClusterOperationInfo: Swift.Equatable {
        /// The ID of the API request that triggered this operation.
        public var clientRequestId: Swift.String?
        /// ARN of the cluster.
        public var clusterArn: Swift.String?
        /// The time that the operation was created.
        public var creationTime: ClientRuntime.Date?
        /// The time at which the operation finished.
        public var endTime: ClientRuntime.Date?
        /// Describes the error if the operation fails.
        public var errorInfo: KafkaClientTypes.ErrorInfo?
        /// ARN of the cluster operation.
        public var operationArn: Swift.String?
        /// State of the cluster operation.
        public var operationState: Swift.String?
        /// Steps completed during the operation.
        public var operationSteps: [KafkaClientTypes.ClusterOperationStep]?
        /// Type of the cluster operation.
        public var operationType: Swift.String?
        /// Information about cluster attributes before a cluster is updated.
        public var sourceClusterInfo: KafkaClientTypes.MutableClusterInfo?
        /// Information about cluster attributes after a cluster is updated.
        public var targetClusterInfo: KafkaClientTypes.MutableClusterInfo?
        /// Description of the VPC connection for CreateVpcConnection and DeleteVpcConnection operations.
        public var vpcConnectionInfo: KafkaClientTypes.VpcConnectionInfo?

        public init(
            clientRequestId: Swift.String? = nil,
            clusterArn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            endTime: ClientRuntime.Date? = nil,
            errorInfo: KafkaClientTypes.ErrorInfo? = nil,
            operationArn: Swift.String? = nil,
            operationState: Swift.String? = nil,
            operationSteps: [KafkaClientTypes.ClusterOperationStep]? = nil,
            operationType: Swift.String? = nil,
            sourceClusterInfo: KafkaClientTypes.MutableClusterInfo? = nil,
            targetClusterInfo: KafkaClientTypes.MutableClusterInfo? = nil,
            vpcConnectionInfo: KafkaClientTypes.VpcConnectionInfo? = nil
        )
        {
            self.clientRequestId = clientRequestId
            self.clusterArn = clusterArn
            self.creationTime = creationTime
            self.endTime = endTime
            self.errorInfo = errorInfo
            self.operationArn = operationArn
            self.operationState = operationState
            self.operationSteps = operationSteps
            self.operationType = operationType
            self.sourceClusterInfo = sourceClusterInfo
            self.targetClusterInfo = targetClusterInfo
            self.vpcConnectionInfo = vpcConnectionInfo
        }
    }

}

extension KafkaClientTypes.ClusterOperationStep: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stepInfo = "stepInfo"
        case stepName = "stepName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stepInfo = self.stepInfo {
            try encodeContainer.encode(stepInfo, forKey: .stepInfo)
        }
        if let stepName = self.stepName {
            try encodeContainer.encode(stepName, forKey: .stepName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterOperationStepInfo.self, forKey: .stepInfo)
        stepInfo = stepInfoDecoded
        let stepNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepName)
        stepName = stepNameDecoded
    }
}

extension KafkaClientTypes {
    /// Step taken during a cluster operation.
    public struct ClusterOperationStep: Swift.Equatable {
        /// Information about the step and its status.
        public var stepInfo: KafkaClientTypes.ClusterOperationStepInfo?
        /// The name of the step.
        public var stepName: Swift.String?

        public init(
            stepInfo: KafkaClientTypes.ClusterOperationStepInfo? = nil,
            stepName: Swift.String? = nil
        )
        {
            self.stepInfo = stepInfo
            self.stepName = stepName
        }
    }

}

extension KafkaClientTypes.ClusterOperationStepInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stepStatus = "stepStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stepStatus = self.stepStatus {
            try encodeContainer.encode(stepStatus, forKey: .stepStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepStatus)
        stepStatus = stepStatusDecoded
    }
}

extension KafkaClientTypes {
    /// State information about the operation step.
    public struct ClusterOperationStepInfo: Swift.Equatable {
        /// The steps current status.
        public var stepStatus: Swift.String?

        public init(
            stepStatus: Swift.String? = nil
        )
        {
            self.stepStatus = stepStatus
        }
    }

}

extension KafkaClientTypes.ClusterOperationV2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterType = "clusterType"
        case endTime = "endTime"
        case errorInfo = "errorInfo"
        case operationArn = "operationArn"
        case operationState = "operationState"
        case operationType = "operationType"
        case provisioned = "provisioned"
        case serverless = "serverless"
        case startTime = "startTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterArn = self.clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let clusterType = self.clusterType {
            try encodeContainer.encode(clusterType.rawValue, forKey: .clusterType)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let operationArn = self.operationArn {
            try encodeContainer.encode(operationArn, forKey: .operationArn)
        }
        if let operationState = self.operationState {
            try encodeContainer.encode(operationState, forKey: .operationState)
        }
        if let operationType = self.operationType {
            try encodeContainer.encode(operationType, forKey: .operationType)
        }
        if let provisioned = self.provisioned {
            try encodeContainer.encode(provisioned, forKey: .provisioned)
        }
        if let serverless = self.serverless {
            try encodeContainer.encode(serverless, forKey: .serverless)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterType.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let operationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationArn)
        operationArn = operationArnDecoded
        let operationStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationState)
        operationState = operationStateDecoded
        let operationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationType)
        operationType = operationTypeDecoded
        let provisionedDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterOperationV2Provisioned.self, forKey: .provisioned)
        provisioned = provisionedDecoded
        let serverlessDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterOperationV2Serverless.self, forKey: .serverless)
        serverless = serverlessDecoded
    }
}

extension KafkaClientTypes {
    /// Returns information about a cluster operation.
    public struct ClusterOperationV2: Swift.Equatable {
        /// ARN of the cluster.
        public var clusterArn: Swift.String?
        /// Type of the backend cluster.
        public var clusterType: KafkaClientTypes.ClusterType?
        /// The time at which the operation finished.
        public var endTime: ClientRuntime.Date?
        /// If cluster operation failed from an error, it describes the error.
        public var errorInfo: KafkaClientTypes.ErrorInfo?
        /// ARN of the cluster operation.
        public var operationArn: Swift.String?
        /// State of the cluster operation.
        public var operationState: Swift.String?
        /// Type of the cluster operation.
        public var operationType: Swift.String?
        /// Properties of a provisioned cluster.
        public var provisioned: KafkaClientTypes.ClusterOperationV2Provisioned?
        /// Properties of a serverless cluster.
        public var serverless: KafkaClientTypes.ClusterOperationV2Serverless?
        /// The time at which operation was started.
        public var startTime: ClientRuntime.Date?

        public init(
            clusterArn: Swift.String? = nil,
            clusterType: KafkaClientTypes.ClusterType? = nil,
            endTime: ClientRuntime.Date? = nil,
            errorInfo: KafkaClientTypes.ErrorInfo? = nil,
            operationArn: Swift.String? = nil,
            operationState: Swift.String? = nil,
            operationType: Swift.String? = nil,
            provisioned: KafkaClientTypes.ClusterOperationV2Provisioned? = nil,
            serverless: KafkaClientTypes.ClusterOperationV2Serverless? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.clusterArn = clusterArn
            self.clusterType = clusterType
            self.endTime = endTime
            self.errorInfo = errorInfo
            self.operationArn = operationArn
            self.operationState = operationState
            self.operationType = operationType
            self.provisioned = provisioned
            self.serverless = serverless
            self.startTime = startTime
        }
    }

}

extension KafkaClientTypes.ClusterOperationV2Provisioned: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationSteps = "operationSteps"
        case sourceClusterInfo = "sourceClusterInfo"
        case targetClusterInfo = "targetClusterInfo"
        case vpcConnectionInfo = "vpcConnectionInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationSteps = operationSteps {
            var operationStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operationSteps)
            for clusteroperationstep0 in operationSteps {
                try operationStepsContainer.encode(clusteroperationstep0)
            }
        }
        if let sourceClusterInfo = self.sourceClusterInfo {
            try encodeContainer.encode(sourceClusterInfo, forKey: .sourceClusterInfo)
        }
        if let targetClusterInfo = self.targetClusterInfo {
            try encodeContainer.encode(targetClusterInfo, forKey: .targetClusterInfo)
        }
        if let vpcConnectionInfo = self.vpcConnectionInfo {
            try encodeContainer.encode(vpcConnectionInfo, forKey: .vpcConnectionInfo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationStepsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.ClusterOperationStep?].self, forKey: .operationSteps)
        var operationStepsDecoded0:[KafkaClientTypes.ClusterOperationStep]? = nil
        if let operationStepsContainer = operationStepsContainer {
            operationStepsDecoded0 = [KafkaClientTypes.ClusterOperationStep]()
            for structure0 in operationStepsContainer {
                if let structure0 = structure0 {
                    operationStepsDecoded0?.append(structure0)
                }
            }
        }
        operationSteps = operationStepsDecoded0
        let sourceClusterInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.MutableClusterInfo.self, forKey: .sourceClusterInfo)
        sourceClusterInfo = sourceClusterInfoDecoded
        let targetClusterInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.MutableClusterInfo.self, forKey: .targetClusterInfo)
        targetClusterInfo = targetClusterInfoDecoded
        let vpcConnectionInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.VpcConnectionInfo.self, forKey: .vpcConnectionInfo)
        vpcConnectionInfo = vpcConnectionInfoDecoded
    }
}

extension KafkaClientTypes {
    /// Returns information about a provisioned cluster operation.
    public struct ClusterOperationV2Provisioned: Swift.Equatable {
        /// Steps completed during the operation.
        public var operationSteps: [KafkaClientTypes.ClusterOperationStep]?
        /// Information about cluster attributes before a cluster is updated.
        public var sourceClusterInfo: KafkaClientTypes.MutableClusterInfo?
        /// Information about cluster attributes after a cluster is updated.
        public var targetClusterInfo: KafkaClientTypes.MutableClusterInfo?
        /// Description of the VPC connection for CreateVpcConnection and DeleteVpcConnection operations.
        public var vpcConnectionInfo: KafkaClientTypes.VpcConnectionInfo?

        public init(
            operationSteps: [KafkaClientTypes.ClusterOperationStep]? = nil,
            sourceClusterInfo: KafkaClientTypes.MutableClusterInfo? = nil,
            targetClusterInfo: KafkaClientTypes.MutableClusterInfo? = nil,
            vpcConnectionInfo: KafkaClientTypes.VpcConnectionInfo? = nil
        )
        {
            self.operationSteps = operationSteps
            self.sourceClusterInfo = sourceClusterInfo
            self.targetClusterInfo = targetClusterInfo
            self.vpcConnectionInfo = vpcConnectionInfo
        }
    }

}

extension KafkaClientTypes.ClusterOperationV2Serverless: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcConnectionInfo = "vpcConnectionInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcConnectionInfo = self.vpcConnectionInfo {
            try encodeContainer.encode(vpcConnectionInfo, forKey: .vpcConnectionInfo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectionInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.VpcConnectionInfoServerless.self, forKey: .vpcConnectionInfo)
        vpcConnectionInfo = vpcConnectionInfoDecoded
    }
}

extension KafkaClientTypes {
    /// Returns information about a serverless cluster operation.
    public struct ClusterOperationV2Serverless: Swift.Equatable {
        /// Description of the VPC connection for CreateVpcConnection and DeleteVpcConnection operations.
        public var vpcConnectionInfo: KafkaClientTypes.VpcConnectionInfoServerless?

        public init(
            vpcConnectionInfo: KafkaClientTypes.VpcConnectionInfoServerless? = nil
        )
        {
            self.vpcConnectionInfo = vpcConnectionInfo
        }
    }

}

extension KafkaClientTypes.ClusterOperationV2Summary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterType = "clusterType"
        case endTime = "endTime"
        case operationArn = "operationArn"
        case operationState = "operationState"
        case operationType = "operationType"
        case startTime = "startTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterArn = self.clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let clusterType = self.clusterType {
            try encodeContainer.encode(clusterType.rawValue, forKey: .clusterType)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let operationArn = self.operationArn {
            try encodeContainer.encode(operationArn, forKey: .operationArn)
        }
        if let operationState = self.operationState {
            try encodeContainer.encode(operationState, forKey: .operationState)
        }
        if let operationType = self.operationType {
            try encodeContainer.encode(operationType, forKey: .operationType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterType.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let operationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationArn)
        operationArn = operationArnDecoded
        let operationStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationState)
        operationState = operationStateDecoded
        let operationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationType)
        operationType = operationTypeDecoded
    }
}

extension KafkaClientTypes {
    /// Returns information about a cluster operation.
    public struct ClusterOperationV2Summary: Swift.Equatable {
        /// ARN of the cluster.
        public var clusterArn: Swift.String?
        /// Type of the backend cluster.
        public var clusterType: KafkaClientTypes.ClusterType?
        /// The time at which the operation finished.
        public var endTime: ClientRuntime.Date?
        /// ARN of the cluster operation.
        public var operationArn: Swift.String?
        /// State of the cluster operation.
        public var operationState: Swift.String?
        /// Type of the cluster operation.
        public var operationType: Swift.String?
        /// The time at which operation was started.
        public var startTime: ClientRuntime.Date?

        public init(
            clusterArn: Swift.String? = nil,
            clusterType: KafkaClientTypes.ClusterType? = nil,
            endTime: ClientRuntime.Date? = nil,
            operationArn: Swift.String? = nil,
            operationState: Swift.String? = nil,
            operationType: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.clusterArn = clusterArn
            self.clusterType = clusterType
            self.endTime = endTime
            self.operationArn = operationArn
            self.operationState = operationState
            self.operationType = operationType
            self.startTime = startTime
        }
    }

}

extension KafkaClientTypes {
    /// The state of the Apache Kafka cluster.
    public enum ClusterState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case healing
        case maintenance
        case rebootingBroker
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .healing,
                .maintenance,
                .rebootingBroker,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .healing: return "HEALING"
            case .maintenance: return "MAINTENANCE"
            case .rebootingBroker: return "REBOOTING_BROKER"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClusterState(rawValue: rawValue) ?? ClusterState.sdkUnknown(rawValue)
        }
    }
}

extension KafkaClientTypes {
    /// The type of cluster.
    public enum ClusterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case provisioned
        case serverless
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterType] {
            return [
                .provisioned,
                .serverless,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .provisioned: return "PROVISIONED"
            case .serverless: return "SERVERLESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClusterType(rawValue: rawValue) ?? ClusterType.sdkUnknown(rawValue)
        }
    }
}

extension KafkaClientTypes.CompatibleKafkaVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceVersion = "sourceVersion"
        case targetVersions = "targetVersions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let targetVersions = targetVersions {
            var targetVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetVersions)
            for __string0 in targetVersions {
                try targetVersionsContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let targetVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetVersions)
        var targetVersionsDecoded0:[Swift.String]? = nil
        if let targetVersionsContainer = targetVersionsContainer {
            targetVersionsDecoded0 = [Swift.String]()
            for string0 in targetVersionsContainer {
                if let string0 = string0 {
                    targetVersionsDecoded0?.append(string0)
                }
            }
        }
        targetVersions = targetVersionsDecoded0
    }
}

extension KafkaClientTypes {
    /// Contains source Apache Kafka versions and compatible target Apache Kafka versions.
    public struct CompatibleKafkaVersion: Swift.Equatable {
        /// An Apache Kafka version.
        public var sourceVersion: Swift.String?
        /// A list of Apache Kafka versions.
        public var targetVersions: [Swift.String]?

        public init(
            sourceVersion: Swift.String? = nil,
            targetVersions: [Swift.String]? = nil
        )
        {
            self.sourceVersion = sourceVersion
            self.targetVersions = targetVersions
        }
    }

}

extension KafkaClientTypes.Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case creationTime = "creationTime"
        case description = "description"
        case kafkaVersions = "kafkaVersions"
        case latestRevision = "latestRevision"
        case name = "name"
        case state = "state"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kafkaVersions = kafkaVersions {
            var kafkaVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .kafkaVersions)
            for __string0 in kafkaVersions {
                try kafkaVersionsContainer.encode(__string0)
            }
        }
        if let latestRevision = self.latestRevision {
            try encodeContainer.encode(latestRevision, forKey: .latestRevision)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kafkaVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .kafkaVersions)
        var kafkaVersionsDecoded0:[Swift.String]? = nil
        if let kafkaVersionsContainer = kafkaVersionsContainer {
            kafkaVersionsDecoded0 = [Swift.String]()
            for string0 in kafkaVersionsContainer {
                if let string0 = string0 {
                    kafkaVersionsDecoded0?.append(string0)
                }
            }
        }
        kafkaVersions = kafkaVersionsDecoded0
        let latestRevisionDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension KafkaClientTypes {
    /// Represents an MSK Configuration.
    public struct Configuration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the configuration was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The description of the configuration.
        /// This member is required.
        public var description: Swift.String?
        /// An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.
        /// This member is required.
        public var kafkaVersions: [Swift.String]?
        /// Latest revision of the configuration.
        /// This member is required.
        public var latestRevision: KafkaClientTypes.ConfigurationRevision?
        /// The name of the configuration.
        /// This member is required.
        public var name: Swift.String?
        /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
        /// This member is required.
        public var state: KafkaClientTypes.ConfigurationState?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            kafkaVersions: [Swift.String]? = nil,
            latestRevision: KafkaClientTypes.ConfigurationRevision? = nil,
            name: Swift.String? = nil,
            state: KafkaClientTypes.ConfigurationState? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.kafkaVersions = kafkaVersions
            self.latestRevision = latestRevision
            self.name = name
            self.state = state
        }
    }

}

extension KafkaClientTypes.ConfigurationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case revision = "revision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension KafkaClientTypes {
    /// Specifies the configuration to use for the brokers.
    public struct ConfigurationInfo: Swift.Equatable {
        /// ARN of the configuration to use.
        /// This member is required.
        public var arn: Swift.String?
        /// The revision of the configuration to use.
        /// This member is required.
        public var revision: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            revision: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.revision = revision
        }
    }

}

extension KafkaClientTypes.ConfigurationRevision: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "creationTime"
        case description = "description"
        case revision = "revision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension KafkaClientTypes {
    /// Describes a configuration revision.
    public struct ConfigurationRevision: Swift.Equatable {
        /// The time when the configuration revision was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The description of the configuration revision.
        public var description: Swift.String?
        /// The revision number.
        /// This member is required.
        public var revision: Swift.Int?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            revision: Swift.Int? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.revision = revision
        }
    }

}

extension KafkaClientTypes {
    /// The state of a configuration.
    public enum ConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleteFailed
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationState] {
            return [
                .active,
                .deleteFailed,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationState(rawValue: rawValue) ?? ConfigurationState.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.invalidParameter = output.invalidParameter
            self.properties.message = output.message
        } else {
            self.properties.invalidParameter = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returns information about an error.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let invalidParameter: Swift.String?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaClientTypes.ConnectivityInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicAccess = "publicAccess"
        case vpcConnectivity = "vpcConnectivity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let publicAccess = self.publicAccess {
            try encodeContainer.encode(publicAccess, forKey: .publicAccess)
        }
        if let vpcConnectivity = self.vpcConnectivity {
            try encodeContainer.encode(vpcConnectivity, forKey: .vpcConnectivity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicAccessDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.PublicAccess.self, forKey: .publicAccess)
        publicAccess = publicAccessDecoded
        let vpcConnectivityDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.VpcConnectivity.self, forKey: .vpcConnectivity)
        vpcConnectivity = vpcConnectivityDecoded
    }
}

extension KafkaClientTypes {
    /// Information about the broker access configuration.
    public struct ConnectivityInfo: Swift.Equatable {
        /// Public access control for brokers.
        public var publicAccess: KafkaClientTypes.PublicAccess?
        /// VPC connectivity access control for brokers.
        public var vpcConnectivity: KafkaClientTypes.VpcConnectivity?

        public init(
            publicAccess: KafkaClientTypes.PublicAccess? = nil,
            vpcConnectivity: KafkaClientTypes.VpcConnectivity? = nil
        )
        {
            self.publicAccess = publicAccess
            self.vpcConnectivity = vpcConnectivity
        }
    }

}

extension CreateClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerNodeGroupInfo = "brokerNodeGroupInfo"
        case clientAuthentication = "clientAuthentication"
        case clusterName = "clusterName"
        case configurationInfo = "configurationInfo"
        case encryptionInfo = "encryptionInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case kafkaVersion = "kafkaVersion"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
        case storageMode = "storageMode"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerNodeGroupInfo = self.brokerNodeGroupInfo {
            try encodeContainer.encode(brokerNodeGroupInfo, forKey: .brokerNodeGroupInfo)
        }
        if let clientAuthentication = self.clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let configurationInfo = self.configurationInfo {
            try encodeContainer.encode(configurationInfo, forKey: .configurationInfo)
        }
        if let encryptionInfo = self.encryptionInfo {
            try encodeContainer.encode(encryptionInfo, forKey: .encryptionInfo)
        }
        if let enhancedMonitoring = self.enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let kafkaVersion = self.kafkaVersion {
            try encodeContainer.encode(kafkaVersion, forKey: .kafkaVersion)
        }
        if let loggingInfo = self.loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let numberOfBrokerNodes = self.numberOfBrokerNodes {
            try encodeContainer.encode(numberOfBrokerNodes, forKey: .numberOfBrokerNodes)
        }
        if let openMonitoring = self.openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
        if let storageMode = self.storageMode {
            try encodeContainer.encode(storageMode.rawValue, forKey: .storageMode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/clusters"
    }
}

public struct CreateClusterInput: Swift.Equatable {
    /// Information about the broker nodes in the cluster.
    /// This member is required.
    public var brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo?
    /// Includes all client authentication related information.
    public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
    /// The name of the cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// Represents the configuration that you want MSK to use for the brokers in a cluster.
    public var configurationInfo: KafkaClientTypes.ConfigurationInfo?
    /// Includes all encryption-related information.
    public var encryptionInfo: KafkaClientTypes.EncryptionInfo?
    /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
    public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
    /// The version of Apache Kafka.
    /// This member is required.
    public var kafkaVersion: Swift.String?
    public var loggingInfo: KafkaClientTypes.LoggingInfo?
    /// The number of broker nodes in the cluster.
    /// This member is required.
    public var numberOfBrokerNodes: Swift.Int?
    /// The settings for open monitoring.
    public var openMonitoring: KafkaClientTypes.OpenMonitoringInfo?
    /// This controls storage mode for supported storage tiers.
    public var storageMode: KafkaClientTypes.StorageMode?
    /// Create tags when creating the cluster.
    public var tags: [Swift.String:Swift.String]?

    public init(
        brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo? = nil,
        clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
        clusterName: Swift.String? = nil,
        configurationInfo: KafkaClientTypes.ConfigurationInfo? = nil,
        encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil,
        enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
        kafkaVersion: Swift.String? = nil,
        loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
        numberOfBrokerNodes: Swift.Int? = nil,
        openMonitoring: KafkaClientTypes.OpenMonitoringInfo? = nil,
        storageMode: KafkaClientTypes.StorageMode? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.brokerNodeGroupInfo = brokerNodeGroupInfo
        self.clientAuthentication = clientAuthentication
        self.clusterName = clusterName
        self.configurationInfo = configurationInfo
        self.encryptionInfo = encryptionInfo
        self.enhancedMonitoring = enhancedMonitoring
        self.kafkaVersion = kafkaVersion
        self.loggingInfo = loggingInfo
        self.numberOfBrokerNodes = numberOfBrokerNodes
        self.openMonitoring = openMonitoring
        self.storageMode = storageMode
        self.tags = tags
    }
}

struct CreateClusterInputBody: Swift.Equatable {
    let brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo?
    let clientAuthentication: KafkaClientTypes.ClientAuthentication?
    let clusterName: Swift.String?
    let configurationInfo: KafkaClientTypes.ConfigurationInfo?
    let encryptionInfo: KafkaClientTypes.EncryptionInfo?
    let enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
    let openMonitoring: KafkaClientTypes.OpenMonitoringInfo?
    let kafkaVersion: Swift.String?
    let loggingInfo: KafkaClientTypes.LoggingInfo?
    let numberOfBrokerNodes: Swift.Int?
    let tags: [Swift.String:Swift.String]?
    let storageMode: KafkaClientTypes.StorageMode?
}

extension CreateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerNodeGroupInfo = "brokerNodeGroupInfo"
        case clientAuthentication = "clientAuthentication"
        case clusterName = "clusterName"
        case configurationInfo = "configurationInfo"
        case encryptionInfo = "encryptionInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case kafkaVersion = "kafkaVersion"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
        case storageMode = "storageMode"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerNodeGroupInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerNodeGroupInfo.self, forKey: .brokerNodeGroupInfo)
        brokerNodeGroupInfo = brokerNodeGroupInfoDecoded
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let configurationInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationInfo.self, forKey: .configurationInfo)
        configurationInfo = configurationInfoDecoded
        let encryptionInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionInfo.self, forKey: .encryptionInfo)
        encryptionInfo = encryptionInfoDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.OpenMonitoringInfo.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let kafkaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kafkaVersion)
        kafkaVersion = kafkaVersionDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let numberOfBrokerNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfBrokerNodes)
        numberOfBrokerNodes = numberOfBrokerNodesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let storageModeDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.StorageMode.self, forKey: .storageMode)
        storageMode = storageModeDecoded
    }
}

extension CreateClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterName = output.clusterName
            self.state = output.state
        } else {
            self.clusterArn = nil
            self.clusterName = nil
            self.state = nil
        }
    }
}

public struct CreateClusterOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The name of the MSK cluster.
    public var clusterName: Swift.String?
    /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
    public var state: KafkaClientTypes.ClusterState?

    public init(
        clusterArn: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        state: KafkaClientTypes.ClusterState? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterName = clusterName
        self.state = state
    }
}

struct CreateClusterOutputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let clusterName: Swift.String?
    let state: KafkaClientTypes.ClusterState?
}

extension CreateClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterName = "clusterName"
        case state = "state"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterState.self, forKey: .state)
        state = stateDecoded
    }
}

enum CreateClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateClusterV2Input: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "clusterName"
        case provisioned = "provisioned"
        case serverless = "serverless"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let provisioned = self.provisioned {
            try encodeContainer.encode(provisioned, forKey: .provisioned)
        }
        if let serverless = self.serverless {
            try encodeContainer.encode(serverless, forKey: .serverless)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateClusterV2Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v2/clusters"
    }
}

public struct CreateClusterV2Input: Swift.Equatable {
    /// The name of the cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// Information about the provisioned cluster.
    public var provisioned: KafkaClientTypes.ProvisionedRequest?
    /// Information about the serverless cluster.
    public var serverless: KafkaClientTypes.ServerlessRequest?
    /// A map of tags that you want the cluster to have.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clusterName: Swift.String? = nil,
        provisioned: KafkaClientTypes.ProvisionedRequest? = nil,
        serverless: KafkaClientTypes.ServerlessRequest? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clusterName = clusterName
        self.provisioned = provisioned
        self.serverless = serverless
        self.tags = tags
    }
}

struct CreateClusterV2InputBody: Swift.Equatable {
    let clusterName: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let provisioned: KafkaClientTypes.ProvisionedRequest?
    let serverless: KafkaClientTypes.ServerlessRequest?
}

extension CreateClusterV2InputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "clusterName"
        case provisioned = "provisioned"
        case serverless = "serverless"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let provisionedDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ProvisionedRequest.self, forKey: .provisioned)
        provisioned = provisionedDecoded
        let serverlessDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ServerlessRequest.self, forKey: .serverless)
        serverless = serverlessDecoded
    }
}

extension CreateClusterV2Output: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateClusterV2OutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterName = output.clusterName
            self.clusterType = output.clusterType
            self.state = output.state
        } else {
            self.clusterArn = nil
            self.clusterName = nil
            self.clusterType = nil
            self.state = nil
        }
    }
}

public struct CreateClusterV2Output: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The name of the MSK cluster.
    public var clusterName: Swift.String?
    /// The type of the cluster. The possible states are PROVISIONED or SERVERLESS.
    public var clusterType: KafkaClientTypes.ClusterType?
    /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
    public var state: KafkaClientTypes.ClusterState?

    public init(
        clusterArn: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        clusterType: KafkaClientTypes.ClusterType? = nil,
        state: KafkaClientTypes.ClusterState? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterName = clusterName
        self.clusterType = clusterType
        self.state = state
    }
}

struct CreateClusterV2OutputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let clusterName: Swift.String?
    let state: KafkaClientTypes.ClusterState?
    let clusterType: KafkaClientTypes.ClusterType?
}

extension CreateClusterV2OutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterName = "clusterName"
        case clusterType = "clusterType"
        case state = "state"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterState.self, forKey: .state)
        state = stateDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterType.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
    }
}

enum CreateClusterV2OutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case kafkaVersions = "kafkaVersions"
        case name = "name"
        case serverProperties = "serverProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kafkaVersions = kafkaVersions {
            var kafkaVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .kafkaVersions)
            for __string0 in kafkaVersions {
                try kafkaVersionsContainer.encode(__string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverProperties = self.serverProperties {
            try encodeContainer.encode(serverProperties.base64EncodedString(), forKey: .serverProperties)
        }
    }
}

extension CreateConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/configurations"
    }
}

public struct CreateConfigurationInput: Swift.Equatable {
    /// The description of the configuration.
    public var description: Swift.String?
    /// The versions of Apache Kafka with which you can use this MSK configuration.
    public var kafkaVersions: [Swift.String]?
    /// The name of the configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded. When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
    /// This member is required.
    public var serverProperties: ClientRuntime.Data?

    public init(
        description: Swift.String? = nil,
        kafkaVersions: [Swift.String]? = nil,
        name: Swift.String? = nil,
        serverProperties: ClientRuntime.Data? = nil
    )
    {
        self.description = description
        self.kafkaVersions = kafkaVersions
        self.name = name
        self.serverProperties = serverProperties
    }
}

struct CreateConfigurationInputBody: Swift.Equatable {
    let description: Swift.String?
    let kafkaVersions: [Swift.String]?
    let name: Swift.String?
    let serverProperties: ClientRuntime.Data?
}

extension CreateConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case kafkaVersions = "kafkaVersions"
        case name = "name"
        case serverProperties = "serverProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kafkaVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .kafkaVersions)
        var kafkaVersionsDecoded0:[Swift.String]? = nil
        if let kafkaVersionsContainer = kafkaVersionsContainer {
            kafkaVersionsDecoded0 = [Swift.String]()
            for string0 in kafkaVersionsContainer {
                if let string0 = string0 {
                    kafkaVersionsDecoded0?.append(string0)
                }
            }
        }
        kafkaVersions = kafkaVersionsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let serverPropertiesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .serverProperties)
        serverProperties = serverPropertiesDecoded
    }
}

extension CreateConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.state = output.state
        } else {
            self.arn = nil
            self.creationTime = nil
            self.latestRevision = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct CreateConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// The time when the configuration was created.
    public var creationTime: ClientRuntime.Date?
    /// Latest revision of the configuration.
    public var latestRevision: KafkaClientTypes.ConfigurationRevision?
    /// The name of the configuration.
    public var name: Swift.String?
    /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
    public var state: KafkaClientTypes.ConfigurationState?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        latestRevision: KafkaClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil,
        state: KafkaClientTypes.ConfigurationState? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.latestRevision = latestRevision
        self.name = name
        self.state = state
    }
}

struct CreateConfigurationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let latestRevision: KafkaClientTypes.ConfigurationRevision?
    let name: Swift.String?
    let state: KafkaClientTypes.ConfigurationState?
}

extension CreateConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case creationTime = "creationTime"
        case latestRevision = "latestRevision"
        case name = "name"
        case state = "state"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationState.self, forKey: .state)
        state = stateDecoded
    }
}

enum CreateConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVpcConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authentication = "authentication"
        case clientSubnets = "clientSubnets"
        case securityGroups = "securityGroups"
        case tags = "tags"
        case targetClusterArn = "targetClusterArn"
        case vpcId = "vpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authentication = self.authentication {
            try encodeContainer.encode(authentication, forKey: .authentication)
        }
        if let clientSubnets = clientSubnets {
            var clientSubnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientSubnets)
            for __string0 in clientSubnets {
                try clientSubnetsContainer.encode(__string0)
            }
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for __string0 in securityGroups {
                try securityGroupsContainer.encode(__string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetClusterArn = self.targetClusterArn {
            try encodeContainer.encode(targetClusterArn, forKey: .targetClusterArn)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension CreateVpcConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/vpc-connection"
    }
}

public struct CreateVpcConnectionInput: Swift.Equatable {
    /// The authentication type of VPC connection.
    /// This member is required.
    public var authentication: Swift.String?
    /// The list of client subnets.
    /// This member is required.
    public var clientSubnets: [Swift.String]?
    /// The list of security groups.
    /// This member is required.
    public var securityGroups: [Swift.String]?
    /// A map of tags for the VPC connection.
    public var tags: [Swift.String:Swift.String]?
    /// The cluster Amazon Resource Name (ARN) for the VPC connection.
    /// This member is required.
    public var targetClusterArn: Swift.String?
    /// The VPC ID of VPC connection.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        authentication: Swift.String? = nil,
        clientSubnets: [Swift.String]? = nil,
        securityGroups: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetClusterArn: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.authentication = authentication
        self.clientSubnets = clientSubnets
        self.securityGroups = securityGroups
        self.tags = tags
        self.targetClusterArn = targetClusterArn
        self.vpcId = vpcId
    }
}

struct CreateVpcConnectionInputBody: Swift.Equatable {
    let targetClusterArn: Swift.String?
    let authentication: Swift.String?
    let vpcId: Swift.String?
    let clientSubnets: [Swift.String]?
    let securityGroups: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateVpcConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authentication = "authentication"
        case clientSubnets = "clientSubnets"
        case securityGroups = "securityGroups"
        case tags = "tags"
        case targetClusterArn = "targetClusterArn"
        case vpcId = "vpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetClusterArn)
        targetClusterArn = targetClusterArnDecoded
        let authenticationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authentication)
        authentication = authenticationDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let clientSubnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientSubnets)
        var clientSubnetsDecoded0:[Swift.String]? = nil
        if let clientSubnetsContainer = clientSubnetsContainer {
            clientSubnetsDecoded0 = [Swift.String]()
            for string0 in clientSubnetsContainer {
                if let string0 = string0 {
                    clientSubnetsDecoded0?.append(string0)
                }
            }
        }
        clientSubnets = clientSubnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVpcConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVpcConnectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.authentication = output.authentication
            self.clientSubnets = output.clientSubnets
            self.creationTime = output.creationTime
            self.securityGroups = output.securityGroups
            self.state = output.state
            self.tags = output.tags
            self.vpcConnectionArn = output.vpcConnectionArn
            self.vpcId = output.vpcId
        } else {
            self.authentication = nil
            self.clientSubnets = nil
            self.creationTime = nil
            self.securityGroups = nil
            self.state = nil
            self.tags = nil
            self.vpcConnectionArn = nil
            self.vpcId = nil
        }
    }
}

public struct CreateVpcConnectionOutput: Swift.Equatable {
    /// The authentication type of VPC connection.
    public var authentication: Swift.String?
    /// The list of client subnets.
    public var clientSubnets: [Swift.String]?
    /// The creation time of VPC connection.
    public var creationTime: ClientRuntime.Date?
    /// The list of security groups.
    public var securityGroups: [Swift.String]?
    /// The State of Vpc Connection.
    public var state: KafkaClientTypes.VpcConnectionState?
    /// A map of tags for the VPC connection.
    public var tags: [Swift.String:Swift.String]?
    /// The VPC connection ARN.
    public var vpcConnectionArn: Swift.String?
    /// The VPC ID of the VPC connection.
    public var vpcId: Swift.String?

    public init(
        authentication: Swift.String? = nil,
        clientSubnets: [Swift.String]? = nil,
        creationTime: ClientRuntime.Date? = nil,
        securityGroups: [Swift.String]? = nil,
        state: KafkaClientTypes.VpcConnectionState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConnectionArn: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.authentication = authentication
        self.clientSubnets = clientSubnets
        self.creationTime = creationTime
        self.securityGroups = securityGroups
        self.state = state
        self.tags = tags
        self.vpcConnectionArn = vpcConnectionArn
        self.vpcId = vpcId
    }
}

struct CreateVpcConnectionOutputBody: Swift.Equatable {
    let vpcConnectionArn: Swift.String?
    let state: KafkaClientTypes.VpcConnectionState?
    let authentication: Swift.String?
    let vpcId: Swift.String?
    let clientSubnets: [Swift.String]?
    let securityGroups: [Swift.String]?
    let creationTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension CreateVpcConnectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authentication = "authentication"
        case clientSubnets = "clientSubnets"
        case creationTime = "creationTime"
        case securityGroups = "securityGroups"
        case state = "state"
        case tags = "tags"
        case vpcConnectionArn = "vpcConnectionArn"
        case vpcId = "vpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectionArn)
        vpcConnectionArn = vpcConnectionArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.VpcConnectionState.self, forKey: .state)
        state = stateDecoded
        let authenticationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authentication)
        authentication = authenticationDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let clientSubnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientSubnets)
        var clientSubnetsDecoded0:[Swift.String]? = nil
        if let clientSubnetsContainer = clientSubnetsContainer {
            clientSubnetsDecoded0 = [Swift.String]()
            for string0 in clientSubnetsContainer {
                if let string0 = string0 {
                    clientSubnetsDecoded0?.append(string0)
                }
            }
        }
        clientSubnets = clientSubnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateVpcConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteClusterInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let currentVersion = currentVersion {
                let currentVersionQueryItem = ClientRuntime.URLQueryItem(name: "currentVersion".urlPercentEncoding(), value: Swift.String(currentVersion).urlPercentEncoding())
                items.append(currentVersionQueryItem)
            }
            return items
        }
    }
}

extension DeleteClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())"
    }
}

public struct DeleteClusterInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The current version of the MSK cluster.
    public var currentVersion: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
    }
}

struct DeleteClusterInputBody: Swift.Equatable {
}

extension DeleteClusterInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.state = output.state
        } else {
            self.clusterArn = nil
            self.state = nil
        }
    }
}

public struct DeleteClusterOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
    public var state: KafkaClientTypes.ClusterState?

    public init(
        clusterArn: Swift.String? = nil,
        state: KafkaClientTypes.ClusterState? = nil
    )
    {
        self.clusterArn = clusterArn
        self.state = state
    }
}

struct DeleteClusterOutputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let state: KafkaClientTypes.ClusterState?
}

extension DeleteClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case state = "state"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterState.self, forKey: .state)
        state = stateDecoded
    }
}

enum DeleteClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteClusterPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/policy"
    }
}

public struct DeleteClusterPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

struct DeleteClusterPolicyInputBody: Swift.Equatable {
}

extension DeleteClusterPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteClusterPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteClusterPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteClusterPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/v1/configurations/\(arn.urlPercentEncoding())"
    }
}

public struct DeleteConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteConfigurationInputBody: Swift.Equatable {
}

extension DeleteConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.state = output.state
        } else {
            self.arn = nil
            self.state = nil
        }
    }
}

public struct DeleteConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration.
    public var arn: Swift.String?
    /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
    public var state: KafkaClientTypes.ConfigurationState?

    public init(
        arn: Swift.String? = nil,
        state: KafkaClientTypes.ConfigurationState? = nil
    )
    {
        self.arn = arn
        self.state = state
    }
}

struct DeleteConfigurationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let state: KafkaClientTypes.ConfigurationState?
}

extension DeleteConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case state = "state"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationState.self, forKey: .state)
        state = stateDecoded
    }
}

enum DeleteConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVpcConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/v1/vpc-connection/\(arn.urlPercentEncoding())"
    }
}

public struct DeleteVpcConnectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK VPC connection.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteVpcConnectionInputBody: Swift.Equatable {
}

extension DeleteVpcConnectionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVpcConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteVpcConnectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
            self.vpcConnectionArn = output.vpcConnectionArn
        } else {
            self.state = nil
            self.vpcConnectionArn = nil
        }
    }
}

public struct DeleteVpcConnectionOutput: Swift.Equatable {
    /// The state of the VPC connection.
    public var state: KafkaClientTypes.VpcConnectionState?
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK VPC connection.
    public var vpcConnectionArn: Swift.String?

    public init(
        state: KafkaClientTypes.VpcConnectionState? = nil,
        vpcConnectionArn: Swift.String? = nil
    )
    {
        self.state = state
        self.vpcConnectionArn = vpcConnectionArn
    }
}

struct DeleteVpcConnectionOutputBody: Swift.Equatable {
    let vpcConnectionArn: Swift.String?
    let state: KafkaClientTypes.VpcConnectionState?
}

extension DeleteVpcConnectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "state"
        case vpcConnectionArn = "vpcConnectionArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectionArn)
        vpcConnectionArn = vpcConnectionArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.VpcConnectionState.self, forKey: .state)
        state = stateDecoded
    }
}

enum DeleteVpcConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())"
    }
}

public struct DescribeClusterInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

struct DescribeClusterInputBody: Swift.Equatable {
}

extension DescribeClusterInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeClusterOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterOperationArn = clusterOperationArn else {
            return nil
        }
        return "/v1/operations/\(clusterOperationArn.urlPercentEncoding())"
    }
}

public struct DescribeClusterOperationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the MSK cluster operation.
    /// This member is required.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterOperationArn = clusterOperationArn
    }
}

struct DescribeClusterOperationInputBody: Swift.Equatable {
}

extension DescribeClusterOperationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeClusterOperationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeClusterOperationOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterOperationInfo = output.clusterOperationInfo
        } else {
            self.clusterOperationInfo = nil
        }
    }
}

public struct DescribeClusterOperationOutput: Swift.Equatable {
    /// Cluster operation information
    public var clusterOperationInfo: KafkaClientTypes.ClusterOperationInfo?

    public init(
        clusterOperationInfo: KafkaClientTypes.ClusterOperationInfo? = nil
    )
    {
        self.clusterOperationInfo = clusterOperationInfo
    }
}

struct DescribeClusterOperationOutputBody: Swift.Equatable {
    let clusterOperationInfo: KafkaClientTypes.ClusterOperationInfo?
}

extension DescribeClusterOperationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterOperationInfo = "clusterOperationInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterOperationInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterOperationInfo.self, forKey: .clusterOperationInfo)
        clusterOperationInfo = clusterOperationInfoDecoded
    }
}

enum DescribeClusterOperationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeClusterOperationV2Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterOperationArn = clusterOperationArn else {
            return nil
        }
        return "/api/v2/operations/\(clusterOperationArn.urlPercentEncoding())"
    }
}

public struct DescribeClusterOperationV2Input: Swift.Equatable {
    /// ARN of the cluster operation to describe.
    /// This member is required.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterOperationArn = clusterOperationArn
    }
}

struct DescribeClusterOperationV2InputBody: Swift.Equatable {
}

extension DescribeClusterOperationV2InputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeClusterOperationV2Output: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeClusterOperationV2OutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterOperationInfo = output.clusterOperationInfo
        } else {
            self.clusterOperationInfo = nil
        }
    }
}

public struct DescribeClusterOperationV2Output: Swift.Equatable {
    /// Cluster operation information
    public var clusterOperationInfo: KafkaClientTypes.ClusterOperationV2?

    public init(
        clusterOperationInfo: KafkaClientTypes.ClusterOperationV2? = nil
    )
    {
        self.clusterOperationInfo = clusterOperationInfo
    }
}

struct DescribeClusterOperationV2OutputBody: Swift.Equatable {
    let clusterOperationInfo: KafkaClientTypes.ClusterOperationV2?
}

extension DescribeClusterOperationV2OutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterOperationInfo = "clusterOperationInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterOperationInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterOperationV2.self, forKey: .clusterOperationInfo)
        clusterOperationInfo = clusterOperationInfoDecoded
    }
}

enum DescribeClusterOperationV2OutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterInfo = output.clusterInfo
        } else {
            self.clusterInfo = nil
        }
    }
}

public struct DescribeClusterOutput: Swift.Equatable {
    /// The cluster information.
    public var clusterInfo: KafkaClientTypes.ClusterInfo?

    public init(
        clusterInfo: KafkaClientTypes.ClusterInfo? = nil
    )
    {
        self.clusterInfo = clusterInfo
    }
}

struct DescribeClusterOutputBody: Swift.Equatable {
    let clusterInfo: KafkaClientTypes.ClusterInfo?
}

extension DescribeClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterInfo = "clusterInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterInfo.self, forKey: .clusterInfo)
        clusterInfo = clusterInfoDecoded
    }
}

enum DescribeClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeClusterV2Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/api/v2/clusters/\(clusterArn.urlPercentEncoding())"
    }
}

public struct DescribeClusterV2Input: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

struct DescribeClusterV2InputBody: Swift.Equatable {
}

extension DescribeClusterV2InputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeClusterV2Output: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeClusterV2OutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterInfo = output.clusterInfo
        } else {
            self.clusterInfo = nil
        }
    }
}

public struct DescribeClusterV2Output: Swift.Equatable {
    /// The cluster information.
    public var clusterInfo: KafkaClientTypes.Cluster?

    public init(
        clusterInfo: KafkaClientTypes.Cluster? = nil
    )
    {
        self.clusterInfo = clusterInfo
    }
}

struct DescribeClusterV2OutputBody: Swift.Equatable {
    let clusterInfo: KafkaClientTypes.Cluster?
}

extension DescribeClusterV2OutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterInfo = "clusterInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Cluster.self, forKey: .clusterInfo)
        clusterInfo = clusterInfoDecoded
    }
}

enum DescribeClusterV2OutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/v1/configurations/\(arn.urlPercentEncoding())"
    }
}

public struct DescribeConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DescribeConfigurationInputBody: Swift.Equatable {
}

extension DescribeConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.kafkaVersions = output.kafkaVersions
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.state = output.state
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.kafkaVersions = nil
            self.latestRevision = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct DescribeConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// The time when the configuration was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the configuration.
    public var description: Swift.String?
    /// The versions of Apache Kafka with which you can use this MSK configuration.
    public var kafkaVersions: [Swift.String]?
    /// Latest revision of the configuration.
    public var latestRevision: KafkaClientTypes.ConfigurationRevision?
    /// The name of the configuration.
    public var name: Swift.String?
    /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
    public var state: KafkaClientTypes.ConfigurationState?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        kafkaVersions: [Swift.String]? = nil,
        latestRevision: KafkaClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil,
        state: KafkaClientTypes.ConfigurationState? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.kafkaVersions = kafkaVersions
        self.latestRevision = latestRevision
        self.name = name
        self.state = state
    }
}

struct DescribeConfigurationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let description: Swift.String?
    let kafkaVersions: [Swift.String]?
    let latestRevision: KafkaClientTypes.ConfigurationRevision?
    let name: Swift.String?
    let state: KafkaClientTypes.ConfigurationState?
}

extension DescribeConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case creationTime = "creationTime"
        case description = "description"
        case kafkaVersions = "kafkaVersions"
        case latestRevision = "latestRevision"
        case name = "name"
        case state = "state"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kafkaVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .kafkaVersions)
        var kafkaVersionsDecoded0:[Swift.String]? = nil
        if let kafkaVersionsContainer = kafkaVersionsContainer {
            kafkaVersionsDecoded0 = [Swift.String]()
            for string0 in kafkaVersionsContainer {
                if let string0 = string0 {
                    kafkaVersionsDecoded0?.append(string0)
                }
            }
        }
        kafkaVersions = kafkaVersionsDecoded0
        let latestRevisionDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationState.self, forKey: .state)
        state = stateDecoded
    }
}

enum DescribeConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConfigurationRevisionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        guard let revision = revision else {
            return nil
        }
        return "/v1/configurations/\(arn.urlPercentEncoding())/revisions/\(revision)"
    }
}

public struct DescribeConfigurationRevisionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
    /// This member is required.
    public var arn: Swift.String?
    /// A string that uniquely identifies a revision of an MSK configuration.
    /// This member is required.
    public var revision: Swift.Int?

    public init(
        arn: Swift.String? = nil,
        revision: Swift.Int? = nil
    )
    {
        self.arn = arn
        self.revision = revision
    }
}

struct DescribeConfigurationRevisionInputBody: Swift.Equatable {
}

extension DescribeConfigurationRevisionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeConfigurationRevisionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConfigurationRevisionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.revision = output.revision
            self.serverProperties = output.serverProperties
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.revision = nil
            self.serverProperties = nil
        }
    }
}

public struct DescribeConfigurationRevisionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// The time when the configuration was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the configuration.
    public var description: Swift.String?
    /// The revision number.
    public var revision: Swift.Int?
    /// Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded. When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
    public var serverProperties: ClientRuntime.Data?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        revision: Swift.Int? = nil,
        serverProperties: ClientRuntime.Data? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.revision = revision
        self.serverProperties = serverProperties
    }
}

struct DescribeConfigurationRevisionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let description: Swift.String?
    let revision: Swift.Int?
    let serverProperties: ClientRuntime.Data?
}

extension DescribeConfigurationRevisionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case creationTime = "creationTime"
        case description = "description"
        case revision = "revision"
        case serverProperties = "serverProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
        let serverPropertiesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .serverProperties)
        serverProperties = serverPropertiesDecoded
    }
}

enum DescribeConfigurationRevisionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeVpcConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/v1/vpc-connection/\(arn.urlPercentEncoding())"
    }
}

public struct DescribeVpcConnectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies a MSK VPC connection.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DescribeVpcConnectionInputBody: Swift.Equatable {
}

extension DescribeVpcConnectionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVpcConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeVpcConnectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.authentication = output.authentication
            self.creationTime = output.creationTime
            self.securityGroups = output.securityGroups
            self.state = output.state
            self.subnets = output.subnets
            self.tags = output.tags
            self.targetClusterArn = output.targetClusterArn
            self.vpcConnectionArn = output.vpcConnectionArn
            self.vpcId = output.vpcId
        } else {
            self.authentication = nil
            self.creationTime = nil
            self.securityGroups = nil
            self.state = nil
            self.subnets = nil
            self.tags = nil
            self.targetClusterArn = nil
            self.vpcConnectionArn = nil
            self.vpcId = nil
        }
    }
}

public struct DescribeVpcConnectionOutput: Swift.Equatable {
    /// The authentication type of VPC connection.
    public var authentication: Swift.String?
    /// The creation time of the VPC connection.
    public var creationTime: ClientRuntime.Date?
    /// The list of security groups for the VPC connection.
    public var securityGroups: [Swift.String]?
    /// The state of VPC connection.
    public var state: KafkaClientTypes.VpcConnectionState?
    /// The list of subnets for the VPC connection.
    public var subnets: [Swift.String]?
    /// A map of tags for the VPC connection.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK cluster.
    public var targetClusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) that uniquely identifies a MSK VPC connection.
    public var vpcConnectionArn: Swift.String?
    /// The VPC Id for the VPC connection.
    public var vpcId: Swift.String?

    public init(
        authentication: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        securityGroups: [Swift.String]? = nil,
        state: KafkaClientTypes.VpcConnectionState? = nil,
        subnets: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetClusterArn: Swift.String? = nil,
        vpcConnectionArn: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.authentication = authentication
        self.creationTime = creationTime
        self.securityGroups = securityGroups
        self.state = state
        self.subnets = subnets
        self.tags = tags
        self.targetClusterArn = targetClusterArn
        self.vpcConnectionArn = vpcConnectionArn
        self.vpcId = vpcId
    }
}

struct DescribeVpcConnectionOutputBody: Swift.Equatable {
    let vpcConnectionArn: Swift.String?
    let targetClusterArn: Swift.String?
    let state: KafkaClientTypes.VpcConnectionState?
    let authentication: Swift.String?
    let vpcId: Swift.String?
    let subnets: [Swift.String]?
    let securityGroups: [Swift.String]?
    let creationTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeVpcConnectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authentication = "authentication"
        case creationTime = "creationTime"
        case securityGroups = "securityGroups"
        case state = "state"
        case subnets = "subnets"
        case tags = "tags"
        case targetClusterArn = "targetClusterArn"
        case vpcConnectionArn = "vpcConnectionArn"
        case vpcId = "vpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectionArn)
        vpcConnectionArn = vpcConnectionArnDecoded
        let targetClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetClusterArn)
        targetClusterArn = targetClusterArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.VpcConnectionState.self, forKey: .state)
        state = stateDecoded
        let authenticationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authentication)
        authentication = authenticationDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeVpcConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KafkaClientTypes.EBSStorageInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedThroughput = "provisionedThroughput"
        case volumeSize = "volumeSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let provisionedThroughput = self.provisionedThroughput {
            try encodeContainer.encode(provisionedThroughput, forKey: .provisionedThroughput)
        }
        if let volumeSize = self.volumeSize {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedThroughputDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ProvisionedThroughput.self, forKey: .provisionedThroughput)
        provisionedThroughput = provisionedThroughputDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
    }
}

extension KafkaClientTypes {
    /// Contains information about the EBS storage volumes attached to Apache Kafka broker nodes.
    public struct EBSStorageInfo: Swift.Equatable {
        /// EBS volume provisioned throughput information.
        public var provisionedThroughput: KafkaClientTypes.ProvisionedThroughput?
        /// The size in GiB of the EBS volume for the data drive on each broker node.
        public var volumeSize: Swift.Int?

        public init(
            provisionedThroughput: KafkaClientTypes.ProvisionedThroughput? = nil,
            volumeSize: Swift.Int? = nil
        )
        {
            self.provisionedThroughput = provisionedThroughput
            self.volumeSize = volumeSize
        }
    }

}

extension KafkaClientTypes.EncryptionAtRest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataVolumeKMSKeyId = "dataVolumeKMSKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataVolumeKMSKeyId = self.dataVolumeKMSKeyId {
            try encodeContainer.encode(dataVolumeKMSKeyId, forKey: .dataVolumeKMSKeyId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataVolumeKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataVolumeKMSKeyId)
        dataVolumeKMSKeyId = dataVolumeKMSKeyIdDecoded
    }
}

extension KafkaClientTypes {
    /// The data-volume encryption details.
    public struct EncryptionAtRest: Swift.Equatable {
        /// The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.
        /// This member is required.
        public var dataVolumeKMSKeyId: Swift.String?

        public init(
            dataVolumeKMSKeyId: Swift.String? = nil
        )
        {
            self.dataVolumeKMSKeyId = dataVolumeKMSKeyId
        }
    }

}

extension KafkaClientTypes.EncryptionInTransit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientBroker = "clientBroker"
        case inCluster = "inCluster"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientBroker = self.clientBroker {
            try encodeContainer.encode(clientBroker.rawValue, forKey: .clientBroker)
        }
        if let inCluster = self.inCluster {
            try encodeContainer.encode(inCluster, forKey: .inCluster)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientBrokerDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClientBroker.self, forKey: .clientBroker)
        clientBroker = clientBrokerDecoded
        let inClusterDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inCluster)
        inCluster = inClusterDecoded
    }
}

extension KafkaClientTypes {
    /// The settings for encrypting data in transit.
    public struct EncryptionInTransit: Swift.Equatable {
        /// Indicates the encryption setting for data in transit between clients and brokers. The following are the possible values. TLS means that client-broker communication is enabled with TLS only. TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data. PLAINTEXT means that client-broker communication is enabled in plaintext only. The default value is TLS_PLAINTEXT.
        public var clientBroker: KafkaClientTypes.ClientBroker?
        /// When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext. The default value is true.
        public var inCluster: Swift.Bool?

        public init(
            clientBroker: KafkaClientTypes.ClientBroker? = nil,
            inCluster: Swift.Bool? = nil
        )
        {
            self.clientBroker = clientBroker
            self.inCluster = inCluster
        }
    }

}

extension KafkaClientTypes.EncryptionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionAtRest = "encryptionAtRest"
        case encryptionInTransit = "encryptionInTransit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionAtRest = self.encryptionAtRest {
            try encodeContainer.encode(encryptionAtRest, forKey: .encryptionAtRest)
        }
        if let encryptionInTransit = self.encryptionInTransit {
            try encodeContainer.encode(encryptionInTransit, forKey: .encryptionInTransit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionAtRestDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionAtRest.self, forKey: .encryptionAtRest)
        encryptionAtRest = encryptionAtRestDecoded
        let encryptionInTransitDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionInTransit.self, forKey: .encryptionInTransit)
        encryptionInTransit = encryptionInTransitDecoded
    }
}

extension KafkaClientTypes {
    /// Includes encryption-related information, such as the AWS KMS key used for encrypting data at rest and whether you want MSK to encrypt your data in transit.
    public struct EncryptionInfo: Swift.Equatable {
        /// The data-volume encryption details.
        public var encryptionAtRest: KafkaClientTypes.EncryptionAtRest?
        /// The details for encryption in transit.
        public var encryptionInTransit: KafkaClientTypes.EncryptionInTransit?

        public init(
            encryptionAtRest: KafkaClientTypes.EncryptionAtRest? = nil,
            encryptionInTransit: KafkaClientTypes.EncryptionInTransit? = nil
        )
        {
            self.encryptionAtRest = encryptionAtRest
            self.encryptionInTransit = encryptionInTransit
        }
    }

}

extension KafkaClientTypes {
    /// Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see [Monitoring](https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html).
    public enum EnhancedMonitoring: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case perBroker
        case perTopicPerBroker
        case perTopicPerPartition
        case sdkUnknown(Swift.String)

        public static var allCases: [EnhancedMonitoring] {
            return [
                .default,
                .perBroker,
                .perTopicPerBroker,
                .perTopicPerPartition,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .perBroker: return "PER_BROKER"
            case .perTopicPerBroker: return "PER_TOPIC_PER_BROKER"
            case .perTopicPerPartition: return "PER_TOPIC_PER_PARTITION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnhancedMonitoring(rawValue: rawValue) ?? EnhancedMonitoring.sdkUnknown(rawValue)
        }
    }
}

extension KafkaClientTypes.ErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case errorString = "errorString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorString = self.errorString {
            try encodeContainer.encode(errorString, forKey: .errorString)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorString)
        errorString = errorStringDecoded
    }
}

extension KafkaClientTypes {
    /// Returns information about an error state of the cluster.
    public struct ErrorInfo: Swift.Equatable {
        /// A number describing the error programmatically.
        public var errorCode: Swift.String?
        /// An optional field to provide more details about the error.
        public var errorString: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorString: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorString = errorString
        }
    }

}

extension KafkaClientTypes.Firehose: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryStream = "deliveryStream"
        case enabled = "enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStream = self.deliveryStream {
            try encodeContainer.encode(deliveryStream, forKey: .deliveryStream)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryStream)
        deliveryStream = deliveryStreamDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension KafkaClientTypes {
    public struct Firehose: Swift.Equatable {
        public var deliveryStream: Swift.String?
        /// This member is required.
        public var enabled: Swift.Bool?

        public init(
            deliveryStream: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.deliveryStream = deliveryStream
            self.enabled = enabled
        }
    }

}

extension ForbiddenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.invalidParameter = output.invalidParameter
            self.properties.message = output.message
        } else {
            self.properties.invalidParameter = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returns information about an error.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let invalidParameter: Swift.String?
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetBootstrapBrokersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/bootstrap-brokers"
    }
}

public struct GetBootstrapBrokersInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

struct GetBootstrapBrokersInputBody: Swift.Equatable {
}

extension GetBootstrapBrokersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBootstrapBrokersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBootstrapBrokersOutputBody = try responseDecoder.decode(responseBody: data)
            self.bootstrapBrokerString = output.bootstrapBrokerString
            self.bootstrapBrokerStringPublicSaslIam = output.bootstrapBrokerStringPublicSaslIam
            self.bootstrapBrokerStringPublicSaslScram = output.bootstrapBrokerStringPublicSaslScram
            self.bootstrapBrokerStringPublicTls = output.bootstrapBrokerStringPublicTls
            self.bootstrapBrokerStringSaslIam = output.bootstrapBrokerStringSaslIam
            self.bootstrapBrokerStringSaslScram = output.bootstrapBrokerStringSaslScram
            self.bootstrapBrokerStringTls = output.bootstrapBrokerStringTls
            self.bootstrapBrokerStringVpcConnectivitySaslIam = output.bootstrapBrokerStringVpcConnectivitySaslIam
            self.bootstrapBrokerStringVpcConnectivitySaslScram = output.bootstrapBrokerStringVpcConnectivitySaslScram
            self.bootstrapBrokerStringVpcConnectivityTls = output.bootstrapBrokerStringVpcConnectivityTls
        } else {
            self.bootstrapBrokerString = nil
            self.bootstrapBrokerStringPublicSaslIam = nil
            self.bootstrapBrokerStringPublicSaslScram = nil
            self.bootstrapBrokerStringPublicTls = nil
            self.bootstrapBrokerStringSaslIam = nil
            self.bootstrapBrokerStringSaslScram = nil
            self.bootstrapBrokerStringTls = nil
            self.bootstrapBrokerStringVpcConnectivitySaslIam = nil
            self.bootstrapBrokerStringVpcConnectivitySaslScram = nil
            self.bootstrapBrokerStringVpcConnectivityTls = nil
        }
    }
}

public struct GetBootstrapBrokersOutput: Swift.Equatable {
    /// A string containing one or more hostname:port pairs.
    public var bootstrapBrokerString: Swift.String?
    /// A string that contains one or more DNS names (or IP addresses) and SASL IAM port pairs.
    public var bootstrapBrokerStringPublicSaslIam: Swift.String?
    /// A string containing one or more DNS names (or IP) and Sasl Scram port pairs.
    public var bootstrapBrokerStringPublicSaslScram: Swift.String?
    /// A string containing one or more DNS names (or IP) and TLS port pairs.
    public var bootstrapBrokerStringPublicTls: Swift.String?
    /// A string that contains one or more DNS names (or IP addresses) and SASL IAM port pairs.
    public var bootstrapBrokerStringSaslIam: Swift.String?
    /// A string containing one or more DNS names (or IP) and Sasl Scram port pairs.
    public var bootstrapBrokerStringSaslScram: Swift.String?
    /// A string containing one or more DNS names (or IP) and TLS port pairs.
    public var bootstrapBrokerStringTls: Swift.String?
    /// A string containing one or more DNS names (or IP) and SASL/IAM port pairs for VPC connectivity.
    public var bootstrapBrokerStringVpcConnectivitySaslIam: Swift.String?
    /// A string containing one or more DNS names (or IP) and SASL/SCRAM port pairs for VPC connectivity.
    public var bootstrapBrokerStringVpcConnectivitySaslScram: Swift.String?
    /// A string containing one or more DNS names (or IP) and TLS port pairs for VPC connectivity.
    public var bootstrapBrokerStringVpcConnectivityTls: Swift.String?

    public init(
        bootstrapBrokerString: Swift.String? = nil,
        bootstrapBrokerStringPublicSaslIam: Swift.String? = nil,
        bootstrapBrokerStringPublicSaslScram: Swift.String? = nil,
        bootstrapBrokerStringPublicTls: Swift.String? = nil,
        bootstrapBrokerStringSaslIam: Swift.String? = nil,
        bootstrapBrokerStringSaslScram: Swift.String? = nil,
        bootstrapBrokerStringTls: Swift.String? = nil,
        bootstrapBrokerStringVpcConnectivitySaslIam: Swift.String? = nil,
        bootstrapBrokerStringVpcConnectivitySaslScram: Swift.String? = nil,
        bootstrapBrokerStringVpcConnectivityTls: Swift.String? = nil
    )
    {
        self.bootstrapBrokerString = bootstrapBrokerString
        self.bootstrapBrokerStringPublicSaslIam = bootstrapBrokerStringPublicSaslIam
        self.bootstrapBrokerStringPublicSaslScram = bootstrapBrokerStringPublicSaslScram
        self.bootstrapBrokerStringPublicTls = bootstrapBrokerStringPublicTls
        self.bootstrapBrokerStringSaslIam = bootstrapBrokerStringSaslIam
        self.bootstrapBrokerStringSaslScram = bootstrapBrokerStringSaslScram
        self.bootstrapBrokerStringTls = bootstrapBrokerStringTls
        self.bootstrapBrokerStringVpcConnectivitySaslIam = bootstrapBrokerStringVpcConnectivitySaslIam
        self.bootstrapBrokerStringVpcConnectivitySaslScram = bootstrapBrokerStringVpcConnectivitySaslScram
        self.bootstrapBrokerStringVpcConnectivityTls = bootstrapBrokerStringVpcConnectivityTls
    }
}

struct GetBootstrapBrokersOutputBody: Swift.Equatable {
    let bootstrapBrokerString: Swift.String?
    let bootstrapBrokerStringTls: Swift.String?
    let bootstrapBrokerStringSaslScram: Swift.String?
    let bootstrapBrokerStringSaslIam: Swift.String?
    let bootstrapBrokerStringPublicTls: Swift.String?
    let bootstrapBrokerStringPublicSaslScram: Swift.String?
    let bootstrapBrokerStringPublicSaslIam: Swift.String?
    let bootstrapBrokerStringVpcConnectivityTls: Swift.String?
    let bootstrapBrokerStringVpcConnectivitySaslScram: Swift.String?
    let bootstrapBrokerStringVpcConnectivitySaslIam: Swift.String?
}

extension GetBootstrapBrokersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bootstrapBrokerString = "bootstrapBrokerString"
        case bootstrapBrokerStringPublicSaslIam = "bootstrapBrokerStringPublicSaslIam"
        case bootstrapBrokerStringPublicSaslScram = "bootstrapBrokerStringPublicSaslScram"
        case bootstrapBrokerStringPublicTls = "bootstrapBrokerStringPublicTls"
        case bootstrapBrokerStringSaslIam = "bootstrapBrokerStringSaslIam"
        case bootstrapBrokerStringSaslScram = "bootstrapBrokerStringSaslScram"
        case bootstrapBrokerStringTls = "bootstrapBrokerStringTls"
        case bootstrapBrokerStringVpcConnectivitySaslIam = "bootstrapBrokerStringVpcConnectivitySaslIam"
        case bootstrapBrokerStringVpcConnectivitySaslScram = "bootstrapBrokerStringVpcConnectivitySaslScram"
        case bootstrapBrokerStringVpcConnectivityTls = "bootstrapBrokerStringVpcConnectivityTls"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bootstrapBrokerStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerString)
        bootstrapBrokerString = bootstrapBrokerStringDecoded
        let bootstrapBrokerStringTlsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerStringTls)
        bootstrapBrokerStringTls = bootstrapBrokerStringTlsDecoded
        let bootstrapBrokerStringSaslScramDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerStringSaslScram)
        bootstrapBrokerStringSaslScram = bootstrapBrokerStringSaslScramDecoded
        let bootstrapBrokerStringSaslIamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerStringSaslIam)
        bootstrapBrokerStringSaslIam = bootstrapBrokerStringSaslIamDecoded
        let bootstrapBrokerStringPublicTlsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerStringPublicTls)
        bootstrapBrokerStringPublicTls = bootstrapBrokerStringPublicTlsDecoded
        let bootstrapBrokerStringPublicSaslScramDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerStringPublicSaslScram)
        bootstrapBrokerStringPublicSaslScram = bootstrapBrokerStringPublicSaslScramDecoded
        let bootstrapBrokerStringPublicSaslIamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerStringPublicSaslIam)
        bootstrapBrokerStringPublicSaslIam = bootstrapBrokerStringPublicSaslIamDecoded
        let bootstrapBrokerStringVpcConnectivityTlsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerStringVpcConnectivityTls)
        bootstrapBrokerStringVpcConnectivityTls = bootstrapBrokerStringVpcConnectivityTlsDecoded
        let bootstrapBrokerStringVpcConnectivitySaslScramDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerStringVpcConnectivitySaslScram)
        bootstrapBrokerStringVpcConnectivitySaslScram = bootstrapBrokerStringVpcConnectivitySaslScramDecoded
        let bootstrapBrokerStringVpcConnectivitySaslIamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerStringVpcConnectivitySaslIam)
        bootstrapBrokerStringVpcConnectivitySaslIam = bootstrapBrokerStringVpcConnectivitySaslIamDecoded
    }
}

enum GetBootstrapBrokersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetClusterPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/policy"
    }
}

public struct GetClusterPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

struct GetClusterPolicyInputBody: Swift.Equatable {
}

extension GetClusterPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetClusterPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetClusterPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.currentVersion = output.currentVersion
            self.policy = output.policy
        } else {
            self.currentVersion = nil
            self.policy = nil
        }
    }
}

public struct GetClusterPolicyOutput: Swift.Equatable {
    /// The version of cluster policy.
    public var currentVersion: Swift.String?
    /// The cluster policy.
    public var policy: Swift.String?

    public init(
        currentVersion: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.policy = policy
    }
}

struct GetClusterPolicyOutputBody: Swift.Equatable {
    let currentVersion: Swift.String?
    let policy: Swift.String?
}

extension GetClusterPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case policy = "policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetClusterPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCompatibleKafkaVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clusterArn = clusterArn {
                let clusterArnQueryItem = ClientRuntime.URLQueryItem(name: "clusterArn".urlPercentEncoding(), value: Swift.String(clusterArn).urlPercentEncoding())
                items.append(clusterArnQueryItem)
            }
            return items
        }
    }
}

extension GetCompatibleKafkaVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/compatible-kafka-versions"
    }
}

public struct GetCompatibleKafkaVersionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster check.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

struct GetCompatibleKafkaVersionsInputBody: Swift.Equatable {
}

extension GetCompatibleKafkaVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCompatibleKafkaVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCompatibleKafkaVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.compatibleKafkaVersions = output.compatibleKafkaVersions
        } else {
            self.compatibleKafkaVersions = nil
        }
    }
}

public struct GetCompatibleKafkaVersionsOutput: Swift.Equatable {
    /// A list of CompatibleKafkaVersion objects.
    public var compatibleKafkaVersions: [KafkaClientTypes.CompatibleKafkaVersion]?

    public init(
        compatibleKafkaVersions: [KafkaClientTypes.CompatibleKafkaVersion]? = nil
    )
    {
        self.compatibleKafkaVersions = compatibleKafkaVersions
    }
}

struct GetCompatibleKafkaVersionsOutputBody: Swift.Equatable {
    let compatibleKafkaVersions: [KafkaClientTypes.CompatibleKafkaVersion]?
}

extension GetCompatibleKafkaVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleKafkaVersions = "compatibleKafkaVersions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compatibleKafkaVersionsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.CompatibleKafkaVersion?].self, forKey: .compatibleKafkaVersions)
        var compatibleKafkaVersionsDecoded0:[KafkaClientTypes.CompatibleKafkaVersion]? = nil
        if let compatibleKafkaVersionsContainer = compatibleKafkaVersionsContainer {
            compatibleKafkaVersionsDecoded0 = [KafkaClientTypes.CompatibleKafkaVersion]()
            for structure0 in compatibleKafkaVersionsContainer {
                if let structure0 = structure0 {
                    compatibleKafkaVersionsDecoded0?.append(structure0)
                }
            }
        }
        compatibleKafkaVersions = compatibleKafkaVersionsDecoded0
    }
}

enum GetCompatibleKafkaVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KafkaClientTypes.Iam: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension KafkaClientTypes {
    /// Details for IAM access control.
    public struct Iam: Swift.Equatable {
        /// Indicates whether IAM access control is enabled.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension InternalServerErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.invalidParameter = output.invalidParameter
            self.properties.message = output.message
        } else {
            self.properties.invalidParameter = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returns information about an error.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let invalidParameter: Swift.String?
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaClientTypes.JmxExporter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledInBroker = "enabledInBroker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledInBroker = self.enabledInBroker {
            try encodeContainer.encode(enabledInBroker, forKey: .enabledInBroker)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledInBrokerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabledInBroker)
        enabledInBroker = enabledInBrokerDecoded
    }
}

extension KafkaClientTypes {
    /// Indicates whether you want to turn on or turn off the JMX Exporter.
    public struct JmxExporter: Swift.Equatable {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        /// This member is required.
        public var enabledInBroker: Swift.Bool?

        public init(
            enabledInBroker: Swift.Bool? = nil
        )
        {
            self.enabledInBroker = enabledInBroker
        }
    }

}

extension KafkaClientTypes.JmxExporterInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledInBroker = "enabledInBroker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledInBroker = self.enabledInBroker {
            try encodeContainer.encode(enabledInBroker, forKey: .enabledInBroker)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledInBrokerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabledInBroker)
        enabledInBroker = enabledInBrokerDecoded
    }
}

extension KafkaClientTypes {
    /// Indicates whether you want to turn on or turn off the JMX Exporter.
    public struct JmxExporterInfo: Swift.Equatable {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        /// This member is required.
        public var enabledInBroker: Swift.Bool?

        public init(
            enabledInBroker: Swift.Bool? = nil
        )
        {
            self.enabledInBroker = enabledInBroker
        }
    }

}

extension KafkaClientTypes.KafkaVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
        case version = "version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.KafkaVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension KafkaClientTypes {
    public struct KafkaVersion: Swift.Equatable {
        public var status: KafkaClientTypes.KafkaVersionStatus?
        public var version: Swift.String?

        public init(
            status: KafkaClientTypes.KafkaVersionStatus? = nil,
            version: Swift.String? = nil
        )
        {
            self.status = status
            self.version = version
        }
    }

}

extension KafkaClientTypes {
    public enum KafkaVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deprecated
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaVersionStatus] {
            return [
                .active,
                .deprecated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deprecated: return "DEPRECATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KafkaVersionStatus(rawValue: rawValue) ?? KafkaVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ListClientVpcConnectionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListClientVpcConnectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/client-vpc-connections"
    }
}

public struct ListClientVpcConnectionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClientVpcConnectionsInputBody: Swift.Equatable {
}

extension ListClientVpcConnectionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListClientVpcConnectionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListClientVpcConnectionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientVpcConnections = output.clientVpcConnections
            self.nextToken = output.nextToken
        } else {
            self.clientVpcConnections = nil
            self.nextToken = nil
        }
    }
}

public struct ListClientVpcConnectionsOutput: Swift.Equatable {
    /// List of client VPC connections.
    public var clientVpcConnections: [KafkaClientTypes.ClientVpcConnection]?
    /// The paginated results marker. When the result of a ListClientVpcConnections operation is truncated, the call returns NextToken in the response. To get another batch of configurations, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clientVpcConnections: [KafkaClientTypes.ClientVpcConnection]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clientVpcConnections = clientVpcConnections
        self.nextToken = nextToken
    }
}

struct ListClientVpcConnectionsOutputBody: Swift.Equatable {
    let clientVpcConnections: [KafkaClientTypes.ClientVpcConnection]?
    let nextToken: Swift.String?
}

extension ListClientVpcConnectionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientVpcConnections = "clientVpcConnections"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientVpcConnectionsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.ClientVpcConnection?].self, forKey: .clientVpcConnections)
        var clientVpcConnectionsDecoded0:[KafkaClientTypes.ClientVpcConnection]? = nil
        if let clientVpcConnectionsContainer = clientVpcConnectionsContainer {
            clientVpcConnectionsDecoded0 = [KafkaClientTypes.ClientVpcConnection]()
            for structure0 in clientVpcConnectionsContainer {
                if let structure0 = structure0 {
                    clientVpcConnectionsDecoded0?.append(structure0)
                }
            }
        }
        clientVpcConnections = clientVpcConnectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListClientVpcConnectionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListClusterOperationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListClusterOperationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/operations"
    }
}

public struct ListClusterOperationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClusterOperationsInputBody: Swift.Equatable {
}

extension ListClusterOperationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListClusterOperationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListClusterOperationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterOperationInfoList = output.clusterOperationInfoList
            self.nextToken = output.nextToken
        } else {
            self.clusterOperationInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListClusterOperationsOutput: Swift.Equatable {
    /// An array of cluster operation information objects.
    public var clusterOperationInfoList: [KafkaClientTypes.ClusterOperationInfo]?
    /// If the response of ListClusterOperations is truncated, it returns a NextToken in the response. This Nexttoken should be sent in the subsequent request to ListClusterOperations.
    public var nextToken: Swift.String?

    public init(
        clusterOperationInfoList: [KafkaClientTypes.ClusterOperationInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterOperationInfoList = clusterOperationInfoList
        self.nextToken = nextToken
    }
}

struct ListClusterOperationsOutputBody: Swift.Equatable {
    let clusterOperationInfoList: [KafkaClientTypes.ClusterOperationInfo]?
    let nextToken: Swift.String?
}

extension ListClusterOperationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterOperationInfoList = "clusterOperationInfoList"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterOperationInfoListContainer = try containerValues.decodeIfPresent([KafkaClientTypes.ClusterOperationInfo?].self, forKey: .clusterOperationInfoList)
        var clusterOperationInfoListDecoded0:[KafkaClientTypes.ClusterOperationInfo]? = nil
        if let clusterOperationInfoListContainer = clusterOperationInfoListContainer {
            clusterOperationInfoListDecoded0 = [KafkaClientTypes.ClusterOperationInfo]()
            for structure0 in clusterOperationInfoListContainer {
                if let structure0 = structure0 {
                    clusterOperationInfoListDecoded0?.append(structure0)
                }
            }
        }
        clusterOperationInfoList = clusterOperationInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListClusterOperationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListClusterOperationsV2Input: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListClusterOperationsV2Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/api/v2/clusters/\(clusterArn.urlPercentEncoding())/operations"
    }
}

public struct ListClusterOperationsV2Input: Swift.Equatable {
    /// The arn of the cluster whose operations are being requested.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The maxResults of the query.
    public var maxResults: Swift.Int?
    /// The nextToken of the query.
    public var nextToken: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClusterOperationsV2InputBody: Swift.Equatable {
}

extension ListClusterOperationsV2InputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListClusterOperationsV2Output: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListClusterOperationsV2OutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterOperationInfoList = output.clusterOperationInfoList
            self.nextToken = output.nextToken
        } else {
            self.clusterOperationInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListClusterOperationsV2Output: Swift.Equatable {
    /// An array of cluster operation information objects.
    public var clusterOperationInfoList: [KafkaClientTypes.ClusterOperationV2Summary]?
    /// If the response of ListClusterOperationsV2 is truncated, it returns a NextToken in the response. This NextToken should be sent in the subsequent request to ListClusterOperationsV2.
    public var nextToken: Swift.String?

    public init(
        clusterOperationInfoList: [KafkaClientTypes.ClusterOperationV2Summary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterOperationInfoList = clusterOperationInfoList
        self.nextToken = nextToken
    }
}

struct ListClusterOperationsV2OutputBody: Swift.Equatable {
    let clusterOperationInfoList: [KafkaClientTypes.ClusterOperationV2Summary]?
    let nextToken: Swift.String?
}

extension ListClusterOperationsV2OutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterOperationInfoList = "clusterOperationInfoList"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterOperationInfoListContainer = try containerValues.decodeIfPresent([KafkaClientTypes.ClusterOperationV2Summary?].self, forKey: .clusterOperationInfoList)
        var clusterOperationInfoListDecoded0:[KafkaClientTypes.ClusterOperationV2Summary]? = nil
        if let clusterOperationInfoListContainer = clusterOperationInfoListContainer {
            clusterOperationInfoListDecoded0 = [KafkaClientTypes.ClusterOperationV2Summary]()
            for structure0 in clusterOperationInfoListContainer {
                if let structure0 = structure0 {
                    clusterOperationInfoListDecoded0?.append(structure0)
                }
            }
        }
        clusterOperationInfoList = clusterOperationInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListClusterOperationsV2OutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListClustersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let clusterNameFilter = clusterNameFilter {
                let clusterNameFilterQueryItem = ClientRuntime.URLQueryItem(name: "clusterNameFilter".urlPercentEncoding(), value: Swift.String(clusterNameFilter).urlPercentEncoding())
                items.append(clusterNameFilterQueryItem)
            }
            return items
        }
    }
}

extension ListClustersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/clusters"
    }
}

public struct ListClustersInput: Swift.Equatable {
    /// Specify a prefix of the name of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.
    public var clusterNameFilter: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clusterNameFilter: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterNameFilter = clusterNameFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClustersInputBody: Swift.Equatable {
}

extension ListClustersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListClustersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListClustersOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterInfoList = output.clusterInfoList
            self.nextToken = output.nextToken
        } else {
            self.clusterInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListClustersOutput: Swift.Equatable {
    /// Information on each of the MSK clusters in the response.
    public var clusterInfoList: [KafkaClientTypes.ClusterInfo]?
    /// The paginated results marker. When the result of a ListClusters operation is truncated, the call returns NextToken in the response. To get another batch of clusters, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clusterInfoList: [KafkaClientTypes.ClusterInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterInfoList = clusterInfoList
        self.nextToken = nextToken
    }
}

struct ListClustersOutputBody: Swift.Equatable {
    let clusterInfoList: [KafkaClientTypes.ClusterInfo]?
    let nextToken: Swift.String?
}

extension ListClustersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterInfoList = "clusterInfoList"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterInfoListContainer = try containerValues.decodeIfPresent([KafkaClientTypes.ClusterInfo?].self, forKey: .clusterInfoList)
        var clusterInfoListDecoded0:[KafkaClientTypes.ClusterInfo]? = nil
        if let clusterInfoListContainer = clusterInfoListContainer {
            clusterInfoListDecoded0 = [KafkaClientTypes.ClusterInfo]()
            for structure0 in clusterInfoListContainer {
                if let structure0 = structure0 {
                    clusterInfoListDecoded0?.append(structure0)
                }
            }
        }
        clusterInfoList = clusterInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListClustersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListClustersV2Input: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clusterTypeFilter = clusterTypeFilter {
                let clusterTypeFilterQueryItem = ClientRuntime.URLQueryItem(name: "clusterTypeFilter".urlPercentEncoding(), value: Swift.String(clusterTypeFilter).urlPercentEncoding())
                items.append(clusterTypeFilterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let clusterNameFilter = clusterNameFilter {
                let clusterNameFilterQueryItem = ClientRuntime.URLQueryItem(name: "clusterNameFilter".urlPercentEncoding(), value: Swift.String(clusterNameFilter).urlPercentEncoding())
                items.append(clusterNameFilterQueryItem)
            }
            return items
        }
    }
}

extension ListClustersV2Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v2/clusters"
    }
}

public struct ListClustersV2Input: Swift.Equatable {
    /// Specify a prefix of the names of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.
    public var clusterNameFilter: Swift.String?
    /// Specify either PROVISIONED or SERVERLESS.
    public var clusterTypeFilter: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clusterNameFilter: Swift.String? = nil,
        clusterTypeFilter: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterNameFilter = clusterNameFilter
        self.clusterTypeFilter = clusterTypeFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClustersV2InputBody: Swift.Equatable {
}

extension ListClustersV2InputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListClustersV2Output: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListClustersV2OutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterInfoList = output.clusterInfoList
            self.nextToken = output.nextToken
        } else {
            self.clusterInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListClustersV2Output: Swift.Equatable {
    /// Information on each of the MSK clusters in the response.
    public var clusterInfoList: [KafkaClientTypes.Cluster]?
    /// The paginated results marker. When the result of a ListClusters operation is truncated, the call returns NextToken in the response. To get another batch of clusters, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clusterInfoList: [KafkaClientTypes.Cluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterInfoList = clusterInfoList
        self.nextToken = nextToken
    }
}

struct ListClustersV2OutputBody: Swift.Equatable {
    let clusterInfoList: [KafkaClientTypes.Cluster]?
    let nextToken: Swift.String?
}

extension ListClustersV2OutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterInfoList = "clusterInfoList"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterInfoListContainer = try containerValues.decodeIfPresent([KafkaClientTypes.Cluster?].self, forKey: .clusterInfoList)
        var clusterInfoListDecoded0:[KafkaClientTypes.Cluster]? = nil
        if let clusterInfoListContainer = clusterInfoListContainer {
            clusterInfoListDecoded0 = [KafkaClientTypes.Cluster]()
            for structure0 in clusterInfoListContainer {
                if let structure0 = structure0 {
                    clusterInfoListDecoded0?.append(structure0)
                }
            }
        }
        clusterInfoList = clusterInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListClustersV2OutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConfigurationRevisionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListConfigurationRevisionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/v1/configurations/\(arn.urlPercentEncoding())/revisions"
    }
}

public struct ListConfigurationRevisionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
    /// This member is required.
    public var arn: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationRevisionsInputBody: Swift.Equatable {
}

extension ListConfigurationRevisionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationRevisionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConfigurationRevisionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.revisions = output.revisions
        } else {
            self.nextToken = nil
            self.revisions = nil
        }
    }
}

public struct ListConfigurationRevisionsOutput: Swift.Equatable {
    /// Paginated results marker.
    public var nextToken: Swift.String?
    /// List of ConfigurationRevision objects.
    public var revisions: [KafkaClientTypes.ConfigurationRevision]?

    public init(
        nextToken: Swift.String? = nil,
        revisions: [KafkaClientTypes.ConfigurationRevision]? = nil
    )
    {
        self.nextToken = nextToken
        self.revisions = revisions
    }
}

struct ListConfigurationRevisionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let revisions: [KafkaClientTypes.ConfigurationRevision]?
}

extension ListConfigurationRevisionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case revisions = "revisions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let revisionsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.ConfigurationRevision?].self, forKey: .revisions)
        var revisionsDecoded0:[KafkaClientTypes.ConfigurationRevision]? = nil
        if let revisionsContainer = revisionsContainer {
            revisionsDecoded0 = [KafkaClientTypes.ConfigurationRevision]()
            for structure0 in revisionsContainer {
                if let structure0 = structure0 {
                    revisionsDecoded0?.append(structure0)
                }
            }
        }
        revisions = revisionsDecoded0
    }
}

enum ListConfigurationRevisionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/configurations"
    }
}

public struct ListConfigurationsInput: Swift.Equatable {
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationsInputBody: Swift.Equatable {
}

extension ListConfigurationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurations = output.configurations
            self.nextToken = output.nextToken
        } else {
            self.configurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationsOutput: Swift.Equatable {
    /// An array of MSK configurations.
    public var configurations: [KafkaClientTypes.Configuration]?
    /// The paginated results marker. When the result of a ListConfigurations operation is truncated, the call returns NextToken in the response. To get another batch of configurations, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        configurations: [KafkaClientTypes.Configuration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurations = configurations
        self.nextToken = nextToken
    }
}

struct ListConfigurationsOutputBody: Swift.Equatable {
    let configurations: [KafkaClientTypes.Configuration]?
    let nextToken: Swift.String?
}

extension ListConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations = "configurations"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.Configuration?].self, forKey: .configurations)
        var configurationsDecoded0:[KafkaClientTypes.Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [KafkaClientTypes.Configuration]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListKafkaVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListKafkaVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/kafka-versions"
    }
}

public struct ListKafkaVersionsInput: Swift.Equatable {
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKafkaVersionsInputBody: Swift.Equatable {
}

extension ListKafkaVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListKafkaVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKafkaVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.kafkaVersions = output.kafkaVersions
            self.nextToken = output.nextToken
        } else {
            self.kafkaVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListKafkaVersionsOutput: Swift.Equatable {
    public var kafkaVersions: [KafkaClientTypes.KafkaVersion]?
    public var nextToken: Swift.String?

    public init(
        kafkaVersions: [KafkaClientTypes.KafkaVersion]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kafkaVersions = kafkaVersions
        self.nextToken = nextToken
    }
}

struct ListKafkaVersionsOutputBody: Swift.Equatable {
    let kafkaVersions: [KafkaClientTypes.KafkaVersion]?
    let nextToken: Swift.String?
}

extension ListKafkaVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kafkaVersions = "kafkaVersions"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kafkaVersionsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.KafkaVersion?].self, forKey: .kafkaVersions)
        var kafkaVersionsDecoded0:[KafkaClientTypes.KafkaVersion]? = nil
        if let kafkaVersionsContainer = kafkaVersionsContainer {
            kafkaVersionsDecoded0 = [KafkaClientTypes.KafkaVersion]()
            for structure0 in kafkaVersionsContainer {
                if let structure0 = structure0 {
                    kafkaVersionsDecoded0?.append(structure0)
                }
            }
        }
        kafkaVersions = kafkaVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListKafkaVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNodesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListNodesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/nodes"
    }
}

public struct ListNodesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNodesInputBody: Swift.Equatable {
}

extension ListNodesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListNodesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNodesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.nodeInfoList = output.nodeInfoList
        } else {
            self.nextToken = nil
            self.nodeInfoList = nil
        }
    }
}

public struct ListNodesOutput: Swift.Equatable {
    /// The paginated results marker. When the result of a ListNodes operation is truncated, the call returns NextToken in the response. To get another batch of nodes, provide this token in your next request.
    public var nextToken: Swift.String?
    /// List containing a NodeInfo object.
    public var nodeInfoList: [KafkaClientTypes.NodeInfo]?

    public init(
        nextToken: Swift.String? = nil,
        nodeInfoList: [KafkaClientTypes.NodeInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodeInfoList = nodeInfoList
    }
}

struct ListNodesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let nodeInfoList: [KafkaClientTypes.NodeInfo]?
}

extension ListNodesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case nodeInfoList = "nodeInfoList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let nodeInfoListContainer = try containerValues.decodeIfPresent([KafkaClientTypes.NodeInfo?].self, forKey: .nodeInfoList)
        var nodeInfoListDecoded0:[KafkaClientTypes.NodeInfo]? = nil
        if let nodeInfoListContainer = nodeInfoListContainer {
            nodeInfoListDecoded0 = [KafkaClientTypes.NodeInfo]()
            for structure0 in nodeInfoListContainer {
                if let structure0 = structure0 {
                    nodeInfoListDecoded0?.append(structure0)
                }
            }
        }
        nodeInfoList = nodeInfoListDecoded0
    }
}

enum ListNodesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListScramSecretsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListScramSecretsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/scram-secrets"
    }
}

public struct ListScramSecretsInput: Swift.Equatable {
    /// The arn of the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The maxResults of the query.
    public var maxResults: Swift.Int?
    /// The nextToken of the query.
    public var nextToken: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListScramSecretsInputBody: Swift.Equatable {
}

extension ListScramSecretsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListScramSecretsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListScramSecretsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.secretArnList = output.secretArnList
        } else {
            self.nextToken = nil
            self.secretArnList = nil
        }
    }
}

public struct ListScramSecretsOutput: Swift.Equatable {
    /// Paginated results marker.
    public var nextToken: Swift.String?
    /// The list of scram secrets associated with the cluster.
    public var secretArnList: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        secretArnList: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.secretArnList = secretArnList
    }
}

struct ListScramSecretsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let secretArnList: [Swift.String]?
}

extension ListScramSecretsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case secretArnList = "secretArnList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let secretArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .secretArnList)
        var secretArnListDecoded0:[Swift.String]? = nil
        if let secretArnListContainer = secretArnListContainer {
            secretArnListDecoded0 = [Swift.String]()
            for string0 in secretArnListContainer {
                if let string0 = string0 {
                    secretArnListDecoded0?.append(string0)
                }
            }
        }
        secretArnList = secretArnListDecoded0
    }
}

enum ListScramSecretsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVpcConnectionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListVpcConnectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/vpc-connections"
    }
}

public struct ListVpcConnectionsInput: Swift.Equatable {
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVpcConnectionsInputBody: Swift.Equatable {
}

extension ListVpcConnectionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVpcConnectionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVpcConnectionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vpcConnections = output.vpcConnections
        } else {
            self.nextToken = nil
            self.vpcConnections = nil
        }
    }
}

public struct ListVpcConnectionsOutput: Swift.Equatable {
    /// The paginated results marker. When the result of a ListClientVpcConnections operation is truncated, the call returns NextToken in the response. To get another batch of configurations, provide this token in your next request.
    public var nextToken: Swift.String?
    /// List of VPC connections.
    public var vpcConnections: [KafkaClientTypes.VpcConnection]?

    public init(
        nextToken: Swift.String? = nil,
        vpcConnections: [KafkaClientTypes.VpcConnection]? = nil
    )
    {
        self.nextToken = nextToken
        self.vpcConnections = vpcConnections
    }
}

struct ListVpcConnectionsOutputBody: Swift.Equatable {
    let vpcConnections: [KafkaClientTypes.VpcConnection]?
    let nextToken: Swift.String?
}

extension ListVpcConnectionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case vpcConnections = "vpcConnections"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectionsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.VpcConnection?].self, forKey: .vpcConnections)
        var vpcConnectionsDecoded0:[KafkaClientTypes.VpcConnection]? = nil
        if let vpcConnectionsContainer = vpcConnectionsContainer {
            vpcConnectionsDecoded0 = [KafkaClientTypes.VpcConnection]()
            for structure0 in vpcConnectionsContainer {
                if let structure0 = structure0 {
                    vpcConnectionsDecoded0?.append(structure0)
                }
            }
        }
        vpcConnections = vpcConnectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListVpcConnectionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KafkaClientTypes.LoggingInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerLogs = "brokerLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerLogs = self.brokerLogs {
            try encodeContainer.encode(brokerLogs, forKey: .brokerLogs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerLogsDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerLogs.self, forKey: .brokerLogs)
        brokerLogs = brokerLogsDecoded
    }
}

extension KafkaClientTypes {
    public struct LoggingInfo: Swift.Equatable {
        /// This member is required.
        public var brokerLogs: KafkaClientTypes.BrokerLogs?

        public init(
            brokerLogs: KafkaClientTypes.BrokerLogs? = nil
        )
        {
            self.brokerLogs = brokerLogs
        }
    }

}

extension KafkaClientTypes.MutableClusterInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerEBSVolumeInfo = "brokerEBSVolumeInfo"
        case clientAuthentication = "clientAuthentication"
        case configurationInfo = "configurationInfo"
        case connectivityInfo = "connectivityInfo"
        case encryptionInfo = "encryptionInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case instanceType = "instanceType"
        case kafkaVersion = "kafkaVersion"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
        case storageMode = "storageMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerEBSVolumeInfo = brokerEBSVolumeInfo {
            var brokerEBSVolumeInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .brokerEBSVolumeInfo)
            for brokerebsvolumeinfo0 in brokerEBSVolumeInfo {
                try brokerEBSVolumeInfoContainer.encode(brokerebsvolumeinfo0)
            }
        }
        if let clientAuthentication = self.clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let configurationInfo = self.configurationInfo {
            try encodeContainer.encode(configurationInfo, forKey: .configurationInfo)
        }
        if let connectivityInfo = self.connectivityInfo {
            try encodeContainer.encode(connectivityInfo, forKey: .connectivityInfo)
        }
        if let encryptionInfo = self.encryptionInfo {
            try encodeContainer.encode(encryptionInfo, forKey: .encryptionInfo)
        }
        if let enhancedMonitoring = self.enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let kafkaVersion = self.kafkaVersion {
            try encodeContainer.encode(kafkaVersion, forKey: .kafkaVersion)
        }
        if let loggingInfo = self.loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let numberOfBrokerNodes = self.numberOfBrokerNodes {
            try encodeContainer.encode(numberOfBrokerNodes, forKey: .numberOfBrokerNodes)
        }
        if let openMonitoring = self.openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
        if let storageMode = self.storageMode {
            try encodeContainer.encode(storageMode.rawValue, forKey: .storageMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerEBSVolumeInfoContainer = try containerValues.decodeIfPresent([KafkaClientTypes.BrokerEBSVolumeInfo?].self, forKey: .brokerEBSVolumeInfo)
        var brokerEBSVolumeInfoDecoded0:[KafkaClientTypes.BrokerEBSVolumeInfo]? = nil
        if let brokerEBSVolumeInfoContainer = brokerEBSVolumeInfoContainer {
            brokerEBSVolumeInfoDecoded0 = [KafkaClientTypes.BrokerEBSVolumeInfo]()
            for structure0 in brokerEBSVolumeInfoContainer {
                if let structure0 = structure0 {
                    brokerEBSVolumeInfoDecoded0?.append(structure0)
                }
            }
        }
        brokerEBSVolumeInfo = brokerEBSVolumeInfoDecoded0
        let configurationInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationInfo.self, forKey: .configurationInfo)
        configurationInfo = configurationInfoDecoded
        let numberOfBrokerNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfBrokerNodes)
        numberOfBrokerNodes = numberOfBrokerNodesDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.OpenMonitoring.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let kafkaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kafkaVersion)
        kafkaVersion = kafkaVersionDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
        let encryptionInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionInfo.self, forKey: .encryptionInfo)
        encryptionInfo = encryptionInfoDecoded
        let connectivityInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConnectivityInfo.self, forKey: .connectivityInfo)
        connectivityInfo = connectivityInfoDecoded
        let storageModeDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.StorageMode.self, forKey: .storageMode)
        storageMode = storageModeDecoded
    }
}

extension KafkaClientTypes {
    /// Information about cluster attributes that can be updated via update APIs.
    public struct MutableClusterInfo: Swift.Equatable {
        /// Specifies the size of the EBS volume and the ID of the associated broker.
        public var brokerEBSVolumeInfo: [KafkaClientTypes.BrokerEBSVolumeInfo]?
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
        /// Information about the changes in the configuration of the brokers.
        public var configurationInfo: KafkaClientTypes.ConfigurationInfo?
        /// Information about the broker access configuration.
        public var connectivityInfo: KafkaClientTypes.ConnectivityInfo?
        /// Includes all encryption-related information.
        public var encryptionInfo: KafkaClientTypes.EncryptionInfo?
        /// Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.
        public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
        /// Information about the Amazon MSK broker type.
        public var instanceType: Swift.String?
        /// The Apache Kafka version.
        public var kafkaVersion: Swift.String?
        /// You can configure your MSK cluster to send broker logs to different destination types. This is a container for the configuration details related to broker logs.
        public var loggingInfo: KafkaClientTypes.LoggingInfo?
        /// The number of broker nodes in the cluster.
        public var numberOfBrokerNodes: Swift.Int?
        /// The settings for open monitoring.
        public var openMonitoring: KafkaClientTypes.OpenMonitoring?
        /// This controls storage mode for supported storage tiers.
        public var storageMode: KafkaClientTypes.StorageMode?

        public init(
            brokerEBSVolumeInfo: [KafkaClientTypes.BrokerEBSVolumeInfo]? = nil,
            clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
            configurationInfo: KafkaClientTypes.ConfigurationInfo? = nil,
            connectivityInfo: KafkaClientTypes.ConnectivityInfo? = nil,
            encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil,
            enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
            instanceType: Swift.String? = nil,
            kafkaVersion: Swift.String? = nil,
            loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
            numberOfBrokerNodes: Swift.Int? = nil,
            openMonitoring: KafkaClientTypes.OpenMonitoring? = nil,
            storageMode: KafkaClientTypes.StorageMode? = nil
        )
        {
            self.brokerEBSVolumeInfo = brokerEBSVolumeInfo
            self.clientAuthentication = clientAuthentication
            self.configurationInfo = configurationInfo
            self.connectivityInfo = connectivityInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.instanceType = instanceType
            self.kafkaVersion = kafkaVersion
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.storageMode = storageMode
        }
    }

}

extension KafkaClientTypes.NodeExporter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledInBroker = "enabledInBroker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledInBroker = self.enabledInBroker {
            try encodeContainer.encode(enabledInBroker, forKey: .enabledInBroker)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledInBrokerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabledInBroker)
        enabledInBroker = enabledInBrokerDecoded
    }
}

extension KafkaClientTypes {
    /// Indicates whether you want to turn on or turn off the Node Exporter.
    public struct NodeExporter: Swift.Equatable {
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        /// This member is required.
        public var enabledInBroker: Swift.Bool?

        public init(
            enabledInBroker: Swift.Bool? = nil
        )
        {
            self.enabledInBroker = enabledInBroker
        }
    }

}

extension KafkaClientTypes.NodeExporterInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledInBroker = "enabledInBroker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledInBroker = self.enabledInBroker {
            try encodeContainer.encode(enabledInBroker, forKey: .enabledInBroker)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledInBrokerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabledInBroker)
        enabledInBroker = enabledInBrokerDecoded
    }
}

extension KafkaClientTypes {
    /// Indicates whether you want to turn on or turn off the Node Exporter.
    public struct NodeExporterInfo: Swift.Equatable {
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        /// This member is required.
        public var enabledInBroker: Swift.Bool?

        public init(
            enabledInBroker: Swift.Bool? = nil
        )
        {
            self.enabledInBroker = enabledInBroker
        }
    }

}

extension KafkaClientTypes.NodeInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addedToClusterTime = "addedToClusterTime"
        case brokerNodeInfo = "brokerNodeInfo"
        case instanceType = "instanceType"
        case nodeARN = "nodeARN"
        case nodeType = "nodeType"
        case zookeeperNodeInfo = "zookeeperNodeInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addedToClusterTime = self.addedToClusterTime {
            try encodeContainer.encode(addedToClusterTime, forKey: .addedToClusterTime)
        }
        if let brokerNodeInfo = self.brokerNodeInfo {
            try encodeContainer.encode(brokerNodeInfo, forKey: .brokerNodeInfo)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let nodeARN = self.nodeARN {
            try encodeContainer.encode(nodeARN, forKey: .nodeARN)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType.rawValue, forKey: .nodeType)
        }
        if let zookeeperNodeInfo = self.zookeeperNodeInfo {
            try encodeContainer.encode(zookeeperNodeInfo, forKey: .zookeeperNodeInfo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addedToClusterTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addedToClusterTime)
        addedToClusterTime = addedToClusterTimeDecoded
        let brokerNodeInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerNodeInfo.self, forKey: .brokerNodeInfo)
        brokerNodeInfo = brokerNodeInfoDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let nodeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeARN)
        nodeARN = nodeARNDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.NodeType.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let zookeeperNodeInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ZookeeperNodeInfo.self, forKey: .zookeeperNodeInfo)
        zookeeperNodeInfo = zookeeperNodeInfoDecoded
    }
}

extension KafkaClientTypes {
    /// The node information object.
    public struct NodeInfo: Swift.Equatable {
        /// The start time.
        public var addedToClusterTime: Swift.String?
        /// The broker node info.
        public var brokerNodeInfo: KafkaClientTypes.BrokerNodeInfo?
        /// The instance type.
        public var instanceType: Swift.String?
        /// The Amazon Resource Name (ARN) of the node.
        public var nodeARN: Swift.String?
        /// The node type.
        public var nodeType: KafkaClientTypes.NodeType?
        /// The ZookeeperNodeInfo.
        public var zookeeperNodeInfo: KafkaClientTypes.ZookeeperNodeInfo?

        public init(
            addedToClusterTime: Swift.String? = nil,
            brokerNodeInfo: KafkaClientTypes.BrokerNodeInfo? = nil,
            instanceType: Swift.String? = nil,
            nodeARN: Swift.String? = nil,
            nodeType: KafkaClientTypes.NodeType? = nil,
            zookeeperNodeInfo: KafkaClientTypes.ZookeeperNodeInfo? = nil
        )
        {
            self.addedToClusterTime = addedToClusterTime
            self.brokerNodeInfo = brokerNodeInfo
            self.instanceType = instanceType
            self.nodeARN = nodeARN
            self.nodeType = nodeType
            self.zookeeperNodeInfo = zookeeperNodeInfo
        }
    }

}

extension KafkaClientTypes {
    /// The broker or Zookeeper node.
    public enum NodeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case broker
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeType] {
            return [
                .broker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .broker: return "BROKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NodeType(rawValue: rawValue) ?? NodeType.sdkUnknown(rawValue)
        }
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.invalidParameter = output.invalidParameter
            self.properties.message = output.message
        } else {
            self.properties.invalidParameter = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returns information about an error.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let invalidParameter: Swift.String?
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaClientTypes.OpenMonitoring: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case prometheus = "prometheus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let prometheus = self.prometheus {
            try encodeContainer.encode(prometheus, forKey: .prometheus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prometheusDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Prometheus.self, forKey: .prometheus)
        prometheus = prometheusDecoded
    }
}

extension KafkaClientTypes {
    /// JMX and Node monitoring for the MSK cluster.
    public struct OpenMonitoring: Swift.Equatable {
        /// Prometheus settings.
        /// This member is required.
        public var prometheus: KafkaClientTypes.Prometheus?

        public init(
            prometheus: KafkaClientTypes.Prometheus? = nil
        )
        {
            self.prometheus = prometheus
        }
    }

}

extension KafkaClientTypes.OpenMonitoringInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case prometheus = "prometheus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let prometheus = self.prometheus {
            try encodeContainer.encode(prometheus, forKey: .prometheus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prometheusDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.PrometheusInfo.self, forKey: .prometheus)
        prometheus = prometheusDecoded
    }
}

extension KafkaClientTypes {
    /// JMX and Node monitoring for the MSK cluster.
    public struct OpenMonitoringInfo: Swift.Equatable {
        /// Prometheus settings.
        /// This member is required.
        public var prometheus: KafkaClientTypes.PrometheusInfo?

        public init(
            prometheus: KafkaClientTypes.PrometheusInfo? = nil
        )
        {
            self.prometheus = prometheus
        }
    }

}

extension KafkaClientTypes.Prometheus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jmxExporter = "jmxExporter"
        case nodeExporter = "nodeExporter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jmxExporter = self.jmxExporter {
            try encodeContainer.encode(jmxExporter, forKey: .jmxExporter)
        }
        if let nodeExporter = self.nodeExporter {
            try encodeContainer.encode(nodeExporter, forKey: .nodeExporter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jmxExporterDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.JmxExporter.self, forKey: .jmxExporter)
        jmxExporter = jmxExporterDecoded
        let nodeExporterDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.NodeExporter.self, forKey: .nodeExporter)
        nodeExporter = nodeExporterDecoded
    }
}

extension KafkaClientTypes {
    /// Prometheus settings.
    public struct Prometheus: Swift.Equatable {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        public var jmxExporter: KafkaClientTypes.JmxExporter?
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        public var nodeExporter: KafkaClientTypes.NodeExporter?

        public init(
            jmxExporter: KafkaClientTypes.JmxExporter? = nil,
            nodeExporter: KafkaClientTypes.NodeExporter? = nil
        )
        {
            self.jmxExporter = jmxExporter
            self.nodeExporter = nodeExporter
        }
    }

}

extension KafkaClientTypes.PrometheusInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jmxExporter = "jmxExporter"
        case nodeExporter = "nodeExporter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jmxExporter = self.jmxExporter {
            try encodeContainer.encode(jmxExporter, forKey: .jmxExporter)
        }
        if let nodeExporter = self.nodeExporter {
            try encodeContainer.encode(nodeExporter, forKey: .nodeExporter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jmxExporterDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.JmxExporterInfo.self, forKey: .jmxExporter)
        jmxExporter = jmxExporterDecoded
        let nodeExporterDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.NodeExporterInfo.self, forKey: .nodeExporter)
        nodeExporter = nodeExporterDecoded
    }
}

extension KafkaClientTypes {
    /// Prometheus settings.
    public struct PrometheusInfo: Swift.Equatable {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        public var jmxExporter: KafkaClientTypes.JmxExporterInfo?
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        public var nodeExporter: KafkaClientTypes.NodeExporterInfo?

        public init(
            jmxExporter: KafkaClientTypes.JmxExporterInfo? = nil,
            nodeExporter: KafkaClientTypes.NodeExporterInfo? = nil
        )
        {
            self.jmxExporter = jmxExporter
            self.nodeExporter = nodeExporter
        }
    }

}

extension KafkaClientTypes.Provisioned: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerNodeGroupInfo = "brokerNodeGroupInfo"
        case clientAuthentication = "clientAuthentication"
        case currentBrokerSoftwareInfo = "currentBrokerSoftwareInfo"
        case encryptionInfo = "encryptionInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
        case storageMode = "storageMode"
        case zookeeperConnectString = "zookeeperConnectString"
        case zookeeperConnectStringTls = "zookeeperConnectStringTls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerNodeGroupInfo = self.brokerNodeGroupInfo {
            try encodeContainer.encode(brokerNodeGroupInfo, forKey: .brokerNodeGroupInfo)
        }
        if let clientAuthentication = self.clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let currentBrokerSoftwareInfo = self.currentBrokerSoftwareInfo {
            try encodeContainer.encode(currentBrokerSoftwareInfo, forKey: .currentBrokerSoftwareInfo)
        }
        if let encryptionInfo = self.encryptionInfo {
            try encodeContainer.encode(encryptionInfo, forKey: .encryptionInfo)
        }
        if let enhancedMonitoring = self.enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let loggingInfo = self.loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let numberOfBrokerNodes = self.numberOfBrokerNodes {
            try encodeContainer.encode(numberOfBrokerNodes, forKey: .numberOfBrokerNodes)
        }
        if let openMonitoring = self.openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
        if let storageMode = self.storageMode {
            try encodeContainer.encode(storageMode.rawValue, forKey: .storageMode)
        }
        if let zookeeperConnectString = self.zookeeperConnectString {
            try encodeContainer.encode(zookeeperConnectString, forKey: .zookeeperConnectString)
        }
        if let zookeeperConnectStringTls = self.zookeeperConnectStringTls {
            try encodeContainer.encode(zookeeperConnectStringTls, forKey: .zookeeperConnectStringTls)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerNodeGroupInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerNodeGroupInfo.self, forKey: .brokerNodeGroupInfo)
        brokerNodeGroupInfo = brokerNodeGroupInfoDecoded
        let currentBrokerSoftwareInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerSoftwareInfo.self, forKey: .currentBrokerSoftwareInfo)
        currentBrokerSoftwareInfo = currentBrokerSoftwareInfoDecoded
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
        let encryptionInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionInfo.self, forKey: .encryptionInfo)
        encryptionInfo = encryptionInfoDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.OpenMonitoringInfo.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let numberOfBrokerNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfBrokerNodes)
        numberOfBrokerNodes = numberOfBrokerNodesDecoded
        let zookeeperConnectStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zookeeperConnectString)
        zookeeperConnectString = zookeeperConnectStringDecoded
        let zookeeperConnectStringTlsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zookeeperConnectStringTls)
        zookeeperConnectStringTls = zookeeperConnectStringTlsDecoded
        let storageModeDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.StorageMode.self, forKey: .storageMode)
        storageMode = storageModeDecoded
    }
}

extension KafkaClientTypes {
    /// Provisioned cluster.
    public struct Provisioned: Swift.Equatable {
        /// Information about the brokers.
        /// This member is required.
        public var brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo?
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
        /// Information about the Apache Kafka version deployed on the brokers.
        public var currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo?
        /// Includes all encryption-related information.
        public var encryptionInfo: KafkaClientTypes.EncryptionInfo?
        /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
        public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
        /// Log delivery information for the cluster.
        public var loggingInfo: KafkaClientTypes.LoggingInfo?
        /// The number of broker nodes in the cluster.
        /// This member is required.
        public var numberOfBrokerNodes: Swift.Int?
        /// The settings for open monitoring.
        public var openMonitoring: KafkaClientTypes.OpenMonitoringInfo?
        /// This controls storage mode for supported storage tiers.
        public var storageMode: KafkaClientTypes.StorageMode?
        /// The connection string to use to connect to the Apache ZooKeeper cluster.
        public var zookeeperConnectString: Swift.String?
        /// The connection string to use to connect to the Apache ZooKeeper cluster on a TLS port.
        public var zookeeperConnectStringTls: Swift.String?

        public init(
            brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo? = nil,
            clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
            currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo? = nil,
            encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil,
            enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
            loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
            numberOfBrokerNodes: Swift.Int? = nil,
            openMonitoring: KafkaClientTypes.OpenMonitoringInfo? = nil,
            storageMode: KafkaClientTypes.StorageMode? = nil,
            zookeeperConnectString: Swift.String? = nil,
            zookeeperConnectStringTls: Swift.String? = nil
        )
        {
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.storageMode = storageMode
            self.zookeeperConnectString = zookeeperConnectString
            self.zookeeperConnectStringTls = zookeeperConnectStringTls
        }
    }

}

extension KafkaClientTypes.ProvisionedRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerNodeGroupInfo = "brokerNodeGroupInfo"
        case clientAuthentication = "clientAuthentication"
        case configurationInfo = "configurationInfo"
        case encryptionInfo = "encryptionInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case kafkaVersion = "kafkaVersion"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
        case storageMode = "storageMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerNodeGroupInfo = self.brokerNodeGroupInfo {
            try encodeContainer.encode(brokerNodeGroupInfo, forKey: .brokerNodeGroupInfo)
        }
        if let clientAuthentication = self.clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let configurationInfo = self.configurationInfo {
            try encodeContainer.encode(configurationInfo, forKey: .configurationInfo)
        }
        if let encryptionInfo = self.encryptionInfo {
            try encodeContainer.encode(encryptionInfo, forKey: .encryptionInfo)
        }
        if let enhancedMonitoring = self.enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let kafkaVersion = self.kafkaVersion {
            try encodeContainer.encode(kafkaVersion, forKey: .kafkaVersion)
        }
        if let loggingInfo = self.loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let numberOfBrokerNodes = self.numberOfBrokerNodes {
            try encodeContainer.encode(numberOfBrokerNodes, forKey: .numberOfBrokerNodes)
        }
        if let openMonitoring = self.openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
        if let storageMode = self.storageMode {
            try encodeContainer.encode(storageMode.rawValue, forKey: .storageMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerNodeGroupInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerNodeGroupInfo.self, forKey: .brokerNodeGroupInfo)
        brokerNodeGroupInfo = brokerNodeGroupInfoDecoded
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
        let configurationInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationInfo.self, forKey: .configurationInfo)
        configurationInfo = configurationInfoDecoded
        let encryptionInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionInfo.self, forKey: .encryptionInfo)
        encryptionInfo = encryptionInfoDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.OpenMonitoringInfo.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let kafkaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kafkaVersion)
        kafkaVersion = kafkaVersionDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let numberOfBrokerNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfBrokerNodes)
        numberOfBrokerNodes = numberOfBrokerNodesDecoded
        let storageModeDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.StorageMode.self, forKey: .storageMode)
        storageMode = storageModeDecoded
    }
}

extension KafkaClientTypes {
    /// Provisioned cluster request.
    public struct ProvisionedRequest: Swift.Equatable {
        /// Information about the brokers.
        /// This member is required.
        public var brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo?
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
        /// Represents the configuration that you want Amazon MSK to use for the brokers in a cluster.
        public var configurationInfo: KafkaClientTypes.ConfigurationInfo?
        /// Includes all encryption-related information.
        public var encryptionInfo: KafkaClientTypes.EncryptionInfo?
        /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
        public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
        /// The Apache Kafka version that you want for the cluster.
        /// This member is required.
        public var kafkaVersion: Swift.String?
        /// Log delivery information for the cluster.
        public var loggingInfo: KafkaClientTypes.LoggingInfo?
        /// The number of broker nodes in the cluster.
        /// This member is required.
        public var numberOfBrokerNodes: Swift.Int?
        /// The settings for open monitoring.
        public var openMonitoring: KafkaClientTypes.OpenMonitoringInfo?
        /// This controls storage mode for supported storage tiers.
        public var storageMode: KafkaClientTypes.StorageMode?

        public init(
            brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo? = nil,
            clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
            configurationInfo: KafkaClientTypes.ConfigurationInfo? = nil,
            encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil,
            enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
            kafkaVersion: Swift.String? = nil,
            loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
            numberOfBrokerNodes: Swift.Int? = nil,
            openMonitoring: KafkaClientTypes.OpenMonitoringInfo? = nil,
            storageMode: KafkaClientTypes.StorageMode? = nil
        )
        {
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.configurationInfo = configurationInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.kafkaVersion = kafkaVersion
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.storageMode = storageMode
        }
    }

}

extension KafkaClientTypes.ProvisionedThroughput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "enabled"
        case volumeThroughput = "volumeThroughput"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let volumeThroughput = self.volumeThroughput {
            try encodeContainer.encode(volumeThroughput, forKey: .volumeThroughput)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let volumeThroughputDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeThroughput)
        volumeThroughput = volumeThroughputDecoded
    }
}

extension KafkaClientTypes {
    /// Contains information about provisioned throughput for EBS storage volumes attached to kafka broker nodes.
    public struct ProvisionedThroughput: Swift.Equatable {
        /// Provisioned throughput is enabled or not.
        public var enabled: Swift.Bool?
        /// Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second.
        public var volumeThroughput: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            volumeThroughput: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.volumeThroughput = volumeThroughput
        }
    }

}

extension KafkaClientTypes.PublicAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension KafkaClientTypes {
    /// Public access control for brokers.
    public struct PublicAccess: Swift.Equatable {
        /// The value DISABLED indicates that public access is turned off. SERVICE_PROVIDED_EIPS indicates that public access is turned on.
        public var type: Swift.String?

        public init(
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension PutClusterPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case policy = "policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutClusterPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/policy"
    }
}

public struct PutClusterPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The policy version.
    public var currentVersion: Swift.String?
    /// The policy.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.policy = policy
    }
}

struct PutClusterPolicyInputBody: Swift.Equatable {
    let currentVersion: Swift.String?
    let policy: Swift.String?
}

extension PutClusterPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case policy = "policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutClusterPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutClusterPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.currentVersion = output.currentVersion
        } else {
            self.currentVersion = nil
        }
    }
}

public struct PutClusterPolicyOutput: Swift.Equatable {
    /// The policy version.
    public var currentVersion: Swift.String?

    public init(
        currentVersion: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
    }
}

struct PutClusterPolicyOutputBody: Swift.Equatable {
    let currentVersion: Swift.String?
}

extension PutClusterPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

enum PutClusterPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RebootBrokerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerIds = "brokerIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerIds = brokerIds {
            var brokerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .brokerIds)
            for __string0 in brokerIds {
                try brokerIdsContainer.encode(__string0)
            }
        }
    }
}

extension RebootBrokerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/reboot-broker"
    }
}

/// Reboots a node.
public struct RebootBrokerInput: Swift.Equatable {
    /// The list of broker IDs to be rebooted. The reboot-broker operation supports rebooting one broker at a time.
    /// This member is required.
    public var brokerIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the cluster to be updated.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        brokerIds: [Swift.String]? = nil,
        clusterArn: Swift.String? = nil
    )
    {
        self.brokerIds = brokerIds
        self.clusterArn = clusterArn
    }
}

struct RebootBrokerInputBody: Swift.Equatable {
    let brokerIds: [Swift.String]?
}

extension RebootBrokerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerIds = "brokerIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .brokerIds)
        var brokerIdsDecoded0:[Swift.String]? = nil
        if let brokerIdsContainer = brokerIdsContainer {
            brokerIdsDecoded0 = [Swift.String]()
            for string0 in brokerIdsContainer {
                if let string0 = string0 {
                    brokerIdsDecoded0?.append(string0)
                }
            }
        }
        brokerIds = brokerIdsDecoded0
    }
}

extension RebootBrokerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RebootBrokerOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct RebootBrokerOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct RebootBrokerOutputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let clusterOperationArn: Swift.String?
}

extension RebootBrokerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

enum RebootBrokerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RejectClientVpcConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcConnectionArn = "vpcConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcConnectionArn = self.vpcConnectionArn {
            try encodeContainer.encode(vpcConnectionArn, forKey: .vpcConnectionArn)
        }
    }
}

extension RejectClientVpcConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/client-vpc-connection"
    }
}

public struct RejectClientVpcConnectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The VPC connection ARN.
    /// This member is required.
    public var vpcConnectionArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        vpcConnectionArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.vpcConnectionArn = vpcConnectionArn
    }
}

struct RejectClientVpcConnectionInputBody: Swift.Equatable {
    let vpcConnectionArn: Swift.String?
}

extension RejectClientVpcConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcConnectionArn = "vpcConnectionArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectionArn)
        vpcConnectionArn = vpcConnectionArnDecoded
    }
}

extension RejectClientVpcConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RejectClientVpcConnectionOutput: Swift.Equatable {

    public init() { }
}

enum RejectClientVpcConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KafkaClientTypes.S3: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "bucket"
        case enabled = "enabled"
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension KafkaClientTypes {
    public struct S3: Swift.Equatable {
        public var bucket: Swift.String?
        /// This member is required.
        public var enabled: Swift.Bool?
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.`prefix` = `prefix`
        }
    }

}

extension KafkaClientTypes.Sasl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iam = "iam"
        case scram = "scram"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iam = self.iam {
            try encodeContainer.encode(iam, forKey: .iam)
        }
        if let scram = self.scram {
            try encodeContainer.encode(scram, forKey: .scram)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scramDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Scram.self, forKey: .scram)
        scram = scramDecoded
        let iamDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Iam.self, forKey: .iam)
        iam = iamDecoded
    }
}

extension KafkaClientTypes {
    /// Details for client authentication using SASL.
    public struct Sasl: Swift.Equatable {
        /// Indicates whether IAM access control is enabled.
        public var iam: KafkaClientTypes.Iam?
        /// Details for SASL/SCRAM client authentication.
        public var scram: KafkaClientTypes.Scram?

        public init(
            iam: KafkaClientTypes.Iam? = nil,
            scram: KafkaClientTypes.Scram? = nil
        )
        {
            self.iam = iam
            self.scram = scram
        }
    }

}

extension KafkaClientTypes.Scram: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension KafkaClientTypes {
    /// Details for SASL/SCRAM client authentication.
    public struct Scram: Swift.Equatable {
        /// SASL/SCRAM authentication is enabled or not.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension KafkaClientTypes.Serverless: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAuthentication = "clientAuthentication"
        case vpcConfigs = "vpcConfigs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAuthentication = self.clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let vpcConfigs = vpcConfigs {
            var vpcConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcConfigs)
            for vpcconfig0 in vpcConfigs {
                try vpcConfigsContainer.encode(vpcconfig0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConfigsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.VpcConfig?].self, forKey: .vpcConfigs)
        var vpcConfigsDecoded0:[KafkaClientTypes.VpcConfig]? = nil
        if let vpcConfigsContainer = vpcConfigsContainer {
            vpcConfigsDecoded0 = [KafkaClientTypes.VpcConfig]()
            for structure0 in vpcConfigsContainer {
                if let structure0 = structure0 {
                    vpcConfigsDecoded0?.append(structure0)
                }
            }
        }
        vpcConfigs = vpcConfigsDecoded0
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ServerlessClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
    }
}

extension KafkaClientTypes {
    /// Serverless cluster.
    public struct Serverless: Swift.Equatable {
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ServerlessClientAuthentication?
        /// The configuration of the Amazon VPCs for the cluster.
        /// This member is required.
        public var vpcConfigs: [KafkaClientTypes.VpcConfig]?

        public init(
            clientAuthentication: KafkaClientTypes.ServerlessClientAuthentication? = nil,
            vpcConfigs: [KafkaClientTypes.VpcConfig]? = nil
        )
        {
            self.clientAuthentication = clientAuthentication
            self.vpcConfigs = vpcConfigs
        }
    }

}

extension KafkaClientTypes.ServerlessClientAuthentication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sasl = "sasl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sasl = self.sasl {
            try encodeContainer.encode(sasl, forKey: .sasl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let saslDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ServerlessSasl.self, forKey: .sasl)
        sasl = saslDecoded
    }
}

extension KafkaClientTypes {
    /// Includes all client authentication information.
    public struct ServerlessClientAuthentication: Swift.Equatable {
        /// Details for ClientAuthentication using SASL.
        public var sasl: KafkaClientTypes.ServerlessSasl?

        public init(
            sasl: KafkaClientTypes.ServerlessSasl? = nil
        )
        {
            self.sasl = sasl
        }
    }

}

extension KafkaClientTypes.ServerlessRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAuthentication = "clientAuthentication"
        case vpcConfigs = "vpcConfigs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAuthentication = self.clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let vpcConfigs = vpcConfigs {
            var vpcConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcConfigs)
            for vpcconfig0 in vpcConfigs {
                try vpcConfigsContainer.encode(vpcconfig0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConfigsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.VpcConfig?].self, forKey: .vpcConfigs)
        var vpcConfigsDecoded0:[KafkaClientTypes.VpcConfig]? = nil
        if let vpcConfigsContainer = vpcConfigsContainer {
            vpcConfigsDecoded0 = [KafkaClientTypes.VpcConfig]()
            for structure0 in vpcConfigsContainer {
                if let structure0 = structure0 {
                    vpcConfigsDecoded0?.append(structure0)
                }
            }
        }
        vpcConfigs = vpcConfigsDecoded0
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ServerlessClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
    }
}

extension KafkaClientTypes {
    /// Serverless cluster request.
    public struct ServerlessRequest: Swift.Equatable {
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ServerlessClientAuthentication?
        /// The configuration of the Amazon VPCs for the cluster.
        /// This member is required.
        public var vpcConfigs: [KafkaClientTypes.VpcConfig]?

        public init(
            clientAuthentication: KafkaClientTypes.ServerlessClientAuthentication? = nil,
            vpcConfigs: [KafkaClientTypes.VpcConfig]? = nil
        )
        {
            self.clientAuthentication = clientAuthentication
            self.vpcConfigs = vpcConfigs
        }
    }

}

extension KafkaClientTypes.ServerlessSasl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iam = "iam"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iam = self.iam {
            try encodeContainer.encode(iam, forKey: .iam)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Iam.self, forKey: .iam)
        iam = iamDecoded
    }
}

extension KafkaClientTypes {
    /// Details for client authentication using SASL.
    public struct ServerlessSasl: Swift.Equatable {
        /// Indicates whether IAM access control is enabled.
        public var iam: KafkaClientTypes.Iam?

        public init(
            iam: KafkaClientTypes.Iam? = nil
        )
        {
            self.iam = iam
        }
    }

}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.invalidParameter = output.invalidParameter
            self.properties.message = output.message
        } else {
            self.properties.invalidParameter = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returns information about an error.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let invalidParameter: Swift.String?
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaClientTypes.StateInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case message = "message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaClientTypes {
    public struct StateInfo: Swift.Equatable {
        public var code: Swift.String?
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension KafkaClientTypes.StorageInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsStorageInfo = "ebsStorageInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsStorageInfo = self.ebsStorageInfo {
            try encodeContainer.encode(ebsStorageInfo, forKey: .ebsStorageInfo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ebsStorageInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EBSStorageInfo.self, forKey: .ebsStorageInfo)
        ebsStorageInfo = ebsStorageInfoDecoded
    }
}

extension KafkaClientTypes {
    /// Contains information about storage volumes attached to MSK broker nodes.
    public struct StorageInfo: Swift.Equatable {
        /// EBS volume information.
        public var ebsStorageInfo: KafkaClientTypes.EBSStorageInfo?

        public init(
            ebsStorageInfo: KafkaClientTypes.EBSStorageInfo? = nil
        )
        {
            self.ebsStorageInfo = ebsStorageInfo
        }
    }

}

extension KafkaClientTypes {
    /// Controls storage mode for various supported storage tiers.
    public enum StorageMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case local
        case tiered
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageMode] {
            return [
                .local,
                .tiered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .local: return "LOCAL"
            case .tiered: return "TIERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageMode(rawValue: rawValue) ?? StorageMode.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pair for the resource tag.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KafkaClientTypes.Tls: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArnList = "certificateAuthorityArnList"
        case enabled = "enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArnList = certificateAuthorityArnList {
            var certificateAuthorityArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateAuthorityArnList)
            for __string0 in certificateAuthorityArnList {
                try certificateAuthorityArnListContainer.encode(__string0)
            }
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .certificateAuthorityArnList)
        var certificateAuthorityArnListDecoded0:[Swift.String]? = nil
        if let certificateAuthorityArnListContainer = certificateAuthorityArnListContainer {
            certificateAuthorityArnListDecoded0 = [Swift.String]()
            for string0 in certificateAuthorityArnListContainer {
                if let string0 = string0 {
                    certificateAuthorityArnListDecoded0?.append(string0)
                }
            }
        }
        certificateAuthorityArnList = certificateAuthorityArnListDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension KafkaClientTypes {
    /// Details for client authentication using TLS.
    public struct Tls: Swift.Equatable {
        /// List of ACM Certificate Authority ARNs.
        public var certificateAuthorityArnList: [Swift.String]?
        /// Specifies whether you want to turn on or turn off TLS authentication.
        public var enabled: Swift.Bool?

        public init(
            certificateAuthorityArnList: [Swift.String]? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.certificateAuthorityArnList = certificateAuthorityArnList
            self.enabled = enabled
        }
    }

}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.invalidParameter = output.invalidParameter
            self.properties.message = output.message
        } else {
            self.properties.invalidParameter = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returns information about an error.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let invalidParameter: Swift.String?
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaClientTypes.Unauthenticated: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension KafkaClientTypes {
    public struct Unauthenticated: Swift.Equatable {
        /// Specifies whether you want to turn on or turn off unauthenticated traffic to your cluster.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension UnauthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.invalidParameter = output.invalidParameter
            self.properties.message = output.message
        } else {
            self.properties.invalidParameter = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returns information about an error.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter that caused the error.
        public internal(set) var invalidParameter: Swift.String? = nil
        /// The description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidParameter = invalidParameter
        self.properties.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let invalidParameter: Swift.String?
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaClientTypes.UnprocessedScramSecret: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case errorMessage = "errorMessage"
        case secretArn = "secretArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
    }
}

extension KafkaClientTypes {
    /// Error info for scram secret associate/disassociate failure.
    public struct UnprocessedScramSecret: Swift.Equatable {
        /// Error code for associate/disassociate failure.
        public var errorCode: Swift.String?
        /// Error message for associate/disassociate failure.
        public var errorMessage: Swift.String?
        /// AWS Secrets Manager secret ARN.
        public var secretArn: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            secretArn: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.secretArn = secretArn
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag keys must be unique for a given cluster. In addition, the following restrictions apply:
    ///
    /// * Each tag key must be unique. If you add a tag with a key that's already in use, your new tag overwrites the existing key-value pair.
    ///
    /// * You can't start a tag key with aws: because this prefix is reserved for use by AWS. AWS creates tags that begin with this prefix on your behalf, but you can't edit or delete them.
    ///
    /// * Tag keys must be between 1 and 128 Unicode characters in length.
    ///
    /// * Tag keys must consist of the following characters: Unicode letters, digits, white space, and the following special characters: _ . / = + - @.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBrokerCountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case targetNumberOfBrokerNodes = "targetNumberOfBrokerNodes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let targetNumberOfBrokerNodes = self.targetNumberOfBrokerNodes {
            try encodeContainer.encode(targetNumberOfBrokerNodes, forKey: .targetNumberOfBrokerNodes)
        }
    }
}

extension UpdateBrokerCountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/nodes/count"
    }
}

public struct UpdateBrokerCountInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The version of cluster to update from. A successful operation will then generate a new version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The number of broker nodes that you want the cluster to have after this operation completes successfully.
    /// This member is required.
    public var targetNumberOfBrokerNodes: Swift.Int?

    public init(
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        targetNumberOfBrokerNodes: Swift.Int? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.targetNumberOfBrokerNodes = targetNumberOfBrokerNodes
    }
}

struct UpdateBrokerCountInputBody: Swift.Equatable {
    let currentVersion: Swift.String?
    let targetNumberOfBrokerNodes: Swift.Int?
}

extension UpdateBrokerCountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case targetNumberOfBrokerNodes = "targetNumberOfBrokerNodes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let targetNumberOfBrokerNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetNumberOfBrokerNodes)
        targetNumberOfBrokerNodes = targetNumberOfBrokerNodesDecoded
    }
}

extension UpdateBrokerCountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBrokerCountOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateBrokerCountOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateBrokerCountOutputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let clusterOperationArn: Swift.String?
}

extension UpdateBrokerCountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

enum UpdateBrokerCountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBrokerStorageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case targetBrokerEBSVolumeInfo = "targetBrokerEBSVolumeInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let targetBrokerEBSVolumeInfo = targetBrokerEBSVolumeInfo {
            var targetBrokerEBSVolumeInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetBrokerEBSVolumeInfo)
            for brokerebsvolumeinfo0 in targetBrokerEBSVolumeInfo {
                try targetBrokerEBSVolumeInfoContainer.encode(brokerebsvolumeinfo0)
            }
        }
    }
}

extension UpdateBrokerStorageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/nodes/storage"
    }
}

public struct UpdateBrokerStorageInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The version of cluster to update from. A successful operation will then generate a new version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// Describes the target volume size and the ID of the broker to apply the update to.
    /// This member is required.
    public var targetBrokerEBSVolumeInfo: [KafkaClientTypes.BrokerEBSVolumeInfo]?

    public init(
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        targetBrokerEBSVolumeInfo: [KafkaClientTypes.BrokerEBSVolumeInfo]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.targetBrokerEBSVolumeInfo = targetBrokerEBSVolumeInfo
    }
}

struct UpdateBrokerStorageInputBody: Swift.Equatable {
    let currentVersion: Swift.String?
    let targetBrokerEBSVolumeInfo: [KafkaClientTypes.BrokerEBSVolumeInfo]?
}

extension UpdateBrokerStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case targetBrokerEBSVolumeInfo = "targetBrokerEBSVolumeInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let targetBrokerEBSVolumeInfoContainer = try containerValues.decodeIfPresent([KafkaClientTypes.BrokerEBSVolumeInfo?].self, forKey: .targetBrokerEBSVolumeInfo)
        var targetBrokerEBSVolumeInfoDecoded0:[KafkaClientTypes.BrokerEBSVolumeInfo]? = nil
        if let targetBrokerEBSVolumeInfoContainer = targetBrokerEBSVolumeInfoContainer {
            targetBrokerEBSVolumeInfoDecoded0 = [KafkaClientTypes.BrokerEBSVolumeInfo]()
            for structure0 in targetBrokerEBSVolumeInfoContainer {
                if let structure0 = structure0 {
                    targetBrokerEBSVolumeInfoDecoded0?.append(structure0)
                }
            }
        }
        targetBrokerEBSVolumeInfo = targetBrokerEBSVolumeInfoDecoded0
    }
}

extension UpdateBrokerStorageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBrokerStorageOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateBrokerStorageOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateBrokerStorageOutputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let clusterOperationArn: Swift.String?
}

extension UpdateBrokerStorageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

enum UpdateBrokerStorageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBrokerTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case targetInstanceType = "targetInstanceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let targetInstanceType = self.targetInstanceType {
            try encodeContainer.encode(targetInstanceType, forKey: .targetInstanceType)
        }
    }
}

extension UpdateBrokerTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/nodes/type"
    }
}

public struct UpdateBrokerTypeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The cluster version that you want to change. After this operation completes successfully, the cluster will have a new version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The Amazon MSK broker type that you want all of the brokers in this cluster to be.
    /// This member is required.
    public var targetInstanceType: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        targetInstanceType: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.targetInstanceType = targetInstanceType
    }
}

struct UpdateBrokerTypeInputBody: Swift.Equatable {
    let currentVersion: Swift.String?
    let targetInstanceType: Swift.String?
}

extension UpdateBrokerTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case targetInstanceType = "targetInstanceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let targetInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetInstanceType)
        targetInstanceType = targetInstanceTypeDecoded
    }
}

extension UpdateBrokerTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBrokerTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateBrokerTypeOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateBrokerTypeOutputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let clusterOperationArn: Swift.String?
}

extension UpdateBrokerTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

enum UpdateBrokerTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateClusterConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationInfo = "configurationInfo"
        case currentVersion = "currentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationInfo = self.configurationInfo {
            try encodeContainer.encode(configurationInfo, forKey: .configurationInfo)
        }
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
    }
}

extension UpdateClusterConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/configuration"
    }
}

public struct UpdateClusterConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// Represents the configuration that you want MSK to use for the brokers in a cluster.
    /// This member is required.
    public var configurationInfo: KafkaClientTypes.ConfigurationInfo?
    /// The version of the cluster that needs to be updated.
    /// This member is required.
    public var currentVersion: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        configurationInfo: KafkaClientTypes.ConfigurationInfo? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.configurationInfo = configurationInfo
        self.currentVersion = currentVersion
    }
}

struct UpdateClusterConfigurationInputBody: Swift.Equatable {
    let configurationInfo: KafkaClientTypes.ConfigurationInfo?
    let currentVersion: Swift.String?
}

extension UpdateClusterConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationInfo = "configurationInfo"
        case currentVersion = "currentVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationInfo.self, forKey: .configurationInfo)
        configurationInfo = configurationInfoDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension UpdateClusterConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateClusterConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateClusterConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateClusterConfigurationOutputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let clusterOperationArn: Swift.String?
}

extension UpdateClusterConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

enum UpdateClusterConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateClusterKafkaVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationInfo = "configurationInfo"
        case currentVersion = "currentVersion"
        case targetKafkaVersion = "targetKafkaVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationInfo = self.configurationInfo {
            try encodeContainer.encode(configurationInfo, forKey: .configurationInfo)
        }
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let targetKafkaVersion = self.targetKafkaVersion {
            try encodeContainer.encode(targetKafkaVersion, forKey: .targetKafkaVersion)
        }
    }
}

extension UpdateClusterKafkaVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/version"
    }
}

public struct UpdateClusterKafkaVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster to be updated.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The custom configuration that should be applied on the new version of cluster.
    public var configurationInfo: KafkaClientTypes.ConfigurationInfo?
    /// Current cluster version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// Target Kafka version.
    /// This member is required.
    public var targetKafkaVersion: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        configurationInfo: KafkaClientTypes.ConfigurationInfo? = nil,
        currentVersion: Swift.String? = nil,
        targetKafkaVersion: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.configurationInfo = configurationInfo
        self.currentVersion = currentVersion
        self.targetKafkaVersion = targetKafkaVersion
    }
}

struct UpdateClusterKafkaVersionInputBody: Swift.Equatable {
    let configurationInfo: KafkaClientTypes.ConfigurationInfo?
    let currentVersion: Swift.String?
    let targetKafkaVersion: Swift.String?
}

extension UpdateClusterKafkaVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationInfo = "configurationInfo"
        case currentVersion = "currentVersion"
        case targetKafkaVersion = "targetKafkaVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationInfo.self, forKey: .configurationInfo)
        configurationInfo = configurationInfoDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let targetKafkaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetKafkaVersion)
        targetKafkaVersion = targetKafkaVersionDecoded
    }
}

extension UpdateClusterKafkaVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateClusterKafkaVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateClusterKafkaVersionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateClusterKafkaVersionOutputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let clusterOperationArn: Swift.String?
}

extension UpdateClusterKafkaVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

enum UpdateClusterKafkaVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case serverProperties = "serverProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let serverProperties = self.serverProperties {
            try encodeContainer.encode(serverProperties.base64EncodedString(), forKey: .serverProperties)
        }
    }
}

extension UpdateConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/v1/configurations/\(arn.urlPercentEncoding())"
    }
}

public struct UpdateConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration.
    /// This member is required.
    public var arn: Swift.String?
    /// The description of the configuration revision.
    public var description: Swift.String?
    /// Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded. When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
    /// This member is required.
    public var serverProperties: ClientRuntime.Data?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        serverProperties: ClientRuntime.Data? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.serverProperties = serverProperties
    }
}

struct UpdateConfigurationInputBody: Swift.Equatable {
    let description: Swift.String?
    let serverProperties: ClientRuntime.Data?
}

extension UpdateConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case serverProperties = "serverProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverPropertiesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .serverProperties)
        serverProperties = serverPropertiesDecoded
    }
}

extension UpdateConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.latestRevision = output.latestRevision
        } else {
            self.arn = nil
            self.latestRevision = nil
        }
    }
}

public struct UpdateConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// Latest revision of the configuration.
    public var latestRevision: KafkaClientTypes.ConfigurationRevision?

    public init(
        arn: Swift.String? = nil,
        latestRevision: KafkaClientTypes.ConfigurationRevision? = nil
    )
    {
        self.arn = arn
        self.latestRevision = latestRevision
    }
}

struct UpdateConfigurationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let latestRevision: KafkaClientTypes.ConfigurationRevision?
}

extension UpdateConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case latestRevision = "latestRevision"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
    }
}

enum UpdateConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConnectivityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectivityInfo = "connectivityInfo"
        case currentVersion = "currentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectivityInfo = self.connectivityInfo {
            try encodeContainer.encode(connectivityInfo, forKey: .connectivityInfo)
        }
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
    }
}

extension UpdateConnectivityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/connectivity"
    }
}

/// Request body for UpdateConnectivity.
public struct UpdateConnectivityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// Information about the broker access configuration.
    /// This member is required.
    public var connectivityInfo: KafkaClientTypes.ConnectivityInfo?
    /// The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
    /// This member is required.
    public var currentVersion: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        connectivityInfo: KafkaClientTypes.ConnectivityInfo? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.connectivityInfo = connectivityInfo
        self.currentVersion = currentVersion
    }
}

struct UpdateConnectivityInputBody: Swift.Equatable {
    let connectivityInfo: KafkaClientTypes.ConnectivityInfo?
    let currentVersion: Swift.String?
}

extension UpdateConnectivityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectivityInfo = "connectivityInfo"
        case currentVersion = "currentVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectivityInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConnectivityInfo.self, forKey: .connectivityInfo)
        connectivityInfo = connectivityInfoDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension UpdateConnectivityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConnectivityOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateConnectivityOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateConnectivityOutputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let clusterOperationArn: Swift.String?
}

extension UpdateConnectivityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

enum UpdateConnectivityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMonitoringInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case enhancedMonitoring = "enhancedMonitoring"
        case loggingInfo = "loggingInfo"
        case openMonitoring = "openMonitoring"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let enhancedMonitoring = self.enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let loggingInfo = self.loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let openMonitoring = self.openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
    }
}

extension UpdateMonitoringInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/monitoring"
    }
}

/// Request body for UpdateMonitoring.
public struct UpdateMonitoringInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.
    public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
    public var loggingInfo: KafkaClientTypes.LoggingInfo?
    /// The settings for open monitoring.
    public var openMonitoring: KafkaClientTypes.OpenMonitoringInfo?

    public init(
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
        loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
        openMonitoring: KafkaClientTypes.OpenMonitoringInfo? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.enhancedMonitoring = enhancedMonitoring
        self.loggingInfo = loggingInfo
        self.openMonitoring = openMonitoring
    }
}

struct UpdateMonitoringInputBody: Swift.Equatable {
    let currentVersion: Swift.String?
    let enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
    let openMonitoring: KafkaClientTypes.OpenMonitoringInfo?
    let loggingInfo: KafkaClientTypes.LoggingInfo?
}

extension UpdateMonitoringInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case enhancedMonitoring = "enhancedMonitoring"
        case loggingInfo = "loggingInfo"
        case openMonitoring = "openMonitoring"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.OpenMonitoringInfo.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
    }
}

extension UpdateMonitoringOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMonitoringOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateMonitoringOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateMonitoringOutputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let clusterOperationArn: Swift.String?
}

extension UpdateMonitoringOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

enum UpdateMonitoringOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSecurityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAuthentication = "clientAuthentication"
        case currentVersion = "currentVersion"
        case encryptionInfo = "encryptionInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAuthentication = self.clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let encryptionInfo = self.encryptionInfo {
            try encodeContainer.encode(encryptionInfo, forKey: .encryptionInfo)
        }
    }
}

extension UpdateSecurityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/security"
    }
}

public struct UpdateSecurityInput: Swift.Equatable {
    /// Includes all client authentication related information.
    public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// Includes all encryption-related information.
    public var encryptionInfo: KafkaClientTypes.EncryptionInfo?

    public init(
        clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil
    )
    {
        self.clientAuthentication = clientAuthentication
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.encryptionInfo = encryptionInfo
    }
}

struct UpdateSecurityInputBody: Swift.Equatable {
    let clientAuthentication: KafkaClientTypes.ClientAuthentication?
    let currentVersion: Swift.String?
    let encryptionInfo: KafkaClientTypes.EncryptionInfo?
}

extension UpdateSecurityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAuthentication = "clientAuthentication"
        case currentVersion = "currentVersion"
        case encryptionInfo = "encryptionInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let encryptionInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionInfo.self, forKey: .encryptionInfo)
        encryptionInfo = encryptionInfoDecoded
    }
}

extension UpdateSecurityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSecurityOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateSecurityOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateSecurityOutputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let clusterOperationArn: Swift.String?
}

extension UpdateSecurityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

enum UpdateSecurityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateStorageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case provisionedThroughput = "provisionedThroughput"
        case storageMode = "storageMode"
        case volumeSizeGB = "volumeSizeGB"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let provisionedThroughput = self.provisionedThroughput {
            try encodeContainer.encode(provisionedThroughput, forKey: .provisionedThroughput)
        }
        if let storageMode = self.storageMode {
            try encodeContainer.encode(storageMode.rawValue, forKey: .storageMode)
        }
        if let volumeSizeGB = self.volumeSizeGB {
            try encodeContainer.encode(volumeSizeGB, forKey: .volumeSizeGB)
        }
    }
}

extension UpdateStorageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/v1/clusters/\(clusterArn.urlPercentEncoding())/storage"
    }
}

/// Request object for UpdateStorage api. Its used to update the storage attributes for the cluster.
public struct UpdateStorageInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster to be updated.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The version of cluster to update from. A successful operation will then generate a new version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// EBS volume provisioned throughput information.
    public var provisionedThroughput: KafkaClientTypes.ProvisionedThroughput?
    /// Controls storage mode for supported storage tiers.
    public var storageMode: KafkaClientTypes.StorageMode?
    /// size of the EBS volume to update.
    public var volumeSizeGB: Swift.Int?

    public init(
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        provisionedThroughput: KafkaClientTypes.ProvisionedThroughput? = nil,
        storageMode: KafkaClientTypes.StorageMode? = nil,
        volumeSizeGB: Swift.Int? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.provisionedThroughput = provisionedThroughput
        self.storageMode = storageMode
        self.volumeSizeGB = volumeSizeGB
    }
}

struct UpdateStorageInputBody: Swift.Equatable {
    let currentVersion: Swift.String?
    let provisionedThroughput: KafkaClientTypes.ProvisionedThroughput?
    let storageMode: KafkaClientTypes.StorageMode?
    let volumeSizeGB: Swift.Int?
}

extension UpdateStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case provisionedThroughput = "provisionedThroughput"
        case storageMode = "storageMode"
        case volumeSizeGB = "volumeSizeGB"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let provisionedThroughputDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ProvisionedThroughput.self, forKey: .provisionedThroughput)
        provisionedThroughput = provisionedThroughputDecoded
        let storageModeDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.StorageMode.self, forKey: .storageMode)
        storageMode = storageModeDecoded
        let volumeSizeGBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSizeGB)
        volumeSizeGB = volumeSizeGBDecoded
    }
}

extension UpdateStorageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateStorageOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateStorageOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateStorageOutputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let clusterOperationArn: Swift.String?
}

extension UpdateStorageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

enum UpdateStorageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KafkaClientTypes.UserIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principalId = "principalId"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.UserIdentityType.self, forKey: .type)
        type = typeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension KafkaClientTypes {
    /// Description of the requester that calls the API operation.
    public struct UserIdentity: Swift.Equatable {
        /// A unique identifier for the requester that calls the API operation.
        public var principalId: Swift.String?
        /// The identity type of the requester that calls the API operation.
        public var type: KafkaClientTypes.UserIdentityType?

        public init(
            principalId: Swift.String? = nil,
            type: KafkaClientTypes.UserIdentityType? = nil
        )
        {
            self.principalId = principalId
            self.type = type
        }
    }

}

extension KafkaClientTypes {
    /// The identity type of the requester that calls the API operation.
    public enum UserIdentityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsaccount
        case awsservice
        case sdkUnknown(Swift.String)

        public static var allCases: [UserIdentityType] {
            return [
                .awsaccount,
                .awsservice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsaccount: return "AWSACCOUNT"
            case .awsservice: return "AWSSERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserIdentityType(rawValue: rawValue) ?? UserIdentityType.sdkUnknown(rawValue)
        }
    }
}

extension KafkaClientTypes.VpcConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for __string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(__string0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for __string0 in subnetIds {
                try subnetIdsContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension KafkaClientTypes {
    /// The configuration of the Amazon VPCs for the cluster.
    public struct VpcConfig: Swift.Equatable {
        /// The IDs of the security groups associated with the cluster.
        public var securityGroupIds: [Swift.String]?
        /// The IDs of the subnets associated with the cluster.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension KafkaClientTypes.VpcConnection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authentication = "authentication"
        case creationTime = "creationTime"
        case state = "state"
        case targetClusterArn = "targetClusterArn"
        case vpcConnectionArn = "vpcConnectionArn"
        case vpcId = "vpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authentication = self.authentication {
            try encodeContainer.encode(authentication, forKey: .authentication)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let targetClusterArn = self.targetClusterArn {
            try encodeContainer.encode(targetClusterArn, forKey: .targetClusterArn)
        }
        if let vpcConnectionArn = self.vpcConnectionArn {
            try encodeContainer.encode(vpcConnectionArn, forKey: .vpcConnectionArn)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectionArn)
        vpcConnectionArn = vpcConnectionArnDecoded
        let targetClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetClusterArn)
        targetClusterArn = targetClusterArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let authenticationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authentication)
        authentication = authenticationDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.VpcConnectionState.self, forKey: .state)
        state = stateDecoded
    }
}

extension KafkaClientTypes {
    /// The VPC connection object.
    public struct VpcConnection: Swift.Equatable {
        /// Information about the auth scheme of Vpc Connection.
        public var authentication: Swift.String?
        /// Creation time of the Vpc Connection.
        public var creationTime: ClientRuntime.Date?
        /// State of the Vpc Connection.
        public var state: KafkaClientTypes.VpcConnectionState?
        /// The ARN that identifies the Cluster which the Vpc Connection belongs to.
        /// This member is required.
        public var targetClusterArn: Swift.String?
        /// The ARN that identifies the Vpc Connection.
        /// This member is required.
        public var vpcConnectionArn: Swift.String?
        /// The vpcId that belongs to the Vpc Connection.
        public var vpcId: Swift.String?

        public init(
            authentication: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            state: KafkaClientTypes.VpcConnectionState? = nil,
            targetClusterArn: Swift.String? = nil,
            vpcConnectionArn: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.authentication = authentication
            self.creationTime = creationTime
            self.state = state
            self.targetClusterArn = targetClusterArn
            self.vpcConnectionArn = vpcConnectionArn
            self.vpcId = vpcId
        }
    }

}

extension KafkaClientTypes.VpcConnectionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "creationTime"
        case owner = "owner"
        case userIdentity = "userIdentity"
        case vpcConnectionArn = "vpcConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let userIdentity = self.userIdentity {
            try encodeContainer.encode(userIdentity, forKey: .userIdentity)
        }
        if let vpcConnectionArn = self.vpcConnectionArn {
            try encodeContainer.encode(vpcConnectionArn, forKey: .vpcConnectionArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectionArn)
        vpcConnectionArn = vpcConnectionArnDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let userIdentityDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.UserIdentity.self, forKey: .userIdentity)
        userIdentity = userIdentityDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension KafkaClientTypes {
    /// Description of the VPC connection.
    public struct VpcConnectionInfo: Swift.Equatable {
        /// The time when Amazon MSK creates the VPC Connnection.
        public var creationTime: ClientRuntime.Date?
        /// The owner of the VPC Connection.
        public var owner: Swift.String?
        /// Description of the requester that calls the API operation.
        public var userIdentity: KafkaClientTypes.UserIdentity?
        /// The Amazon Resource Name (ARN) of the VPC connection.
        public var vpcConnectionArn: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            owner: Swift.String? = nil,
            userIdentity: KafkaClientTypes.UserIdentity? = nil,
            vpcConnectionArn: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.owner = owner
            self.userIdentity = userIdentity
            self.vpcConnectionArn = vpcConnectionArn
        }
    }

}

extension KafkaClientTypes.VpcConnectionInfoServerless: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "creationTime"
        case owner = "owner"
        case userIdentity = "userIdentity"
        case vpcConnectionArn = "vpcConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let userIdentity = self.userIdentity {
            try encodeContainer.encode(userIdentity, forKey: .userIdentity)
        }
        if let vpcConnectionArn = self.vpcConnectionArn {
            try encodeContainer.encode(vpcConnectionArn, forKey: .vpcConnectionArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let userIdentityDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.UserIdentity.self, forKey: .userIdentity)
        userIdentity = userIdentityDecoded
        let vpcConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectionArn)
        vpcConnectionArn = vpcConnectionArnDecoded
    }
}

extension KafkaClientTypes {
    /// Description of the VPC connection.
    public struct VpcConnectionInfoServerless: Swift.Equatable {
        /// The time when Amazon MSK creates the VPC Connnection.
        public var creationTime: ClientRuntime.Date?
        /// The owner of the VPC Connection.
        public var owner: Swift.String?
        /// Description of the requester that calls the API operation.
        public var userIdentity: KafkaClientTypes.UserIdentity?
        /// The Amazon Resource Name (ARN) of the VPC connection.
        public var vpcConnectionArn: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            owner: Swift.String? = nil,
            userIdentity: KafkaClientTypes.UserIdentity? = nil,
            vpcConnectionArn: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.owner = owner
            self.userIdentity = userIdentity
            self.vpcConnectionArn = vpcConnectionArn
        }
    }

}

extension KafkaClientTypes {
    /// The state of a VPC connection.
    public enum VpcConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deactivating
        case deleting
        case failed
        case inactive
        case rejected
        case rejecting
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcConnectionState] {
            return [
                .available,
                .creating,
                .deactivating,
                .deleting,
                .failed,
                .inactive,
                .rejected,
                .rejecting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deactivating: return "DEACTIVATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .rejected: return "REJECTED"
            case .rejecting: return "REJECTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VpcConnectionState(rawValue: rawValue) ?? VpcConnectionState.sdkUnknown(rawValue)
        }
    }
}

extension KafkaClientTypes.VpcConnectivity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAuthentication = "clientAuthentication"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAuthentication = self.clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.VpcConnectivityClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
    }
}

extension KafkaClientTypes {
    /// VPC connectivity access control for brokers.
    public struct VpcConnectivity: Swift.Equatable {
        /// Includes all client authentication information for VPC connectivity.
        public var clientAuthentication: KafkaClientTypes.VpcConnectivityClientAuthentication?

        public init(
            clientAuthentication: KafkaClientTypes.VpcConnectivityClientAuthentication? = nil
        )
        {
            self.clientAuthentication = clientAuthentication
        }
    }

}

extension KafkaClientTypes.VpcConnectivityClientAuthentication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sasl = "sasl"
        case tls = "tls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sasl = self.sasl {
            try encodeContainer.encode(sasl, forKey: .sasl)
        }
        if let tls = self.tls {
            try encodeContainer.encode(tls, forKey: .tls)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let saslDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.VpcConnectivitySasl.self, forKey: .sasl)
        sasl = saslDecoded
        let tlsDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.VpcConnectivityTls.self, forKey: .tls)
        tls = tlsDecoded
    }
}

extension KafkaClientTypes {
    /// Includes all client authentication information for VPC connectivity.
    public struct VpcConnectivityClientAuthentication: Swift.Equatable {
        /// SASL authentication type details for VPC connectivity.
        public var sasl: KafkaClientTypes.VpcConnectivitySasl?
        /// TLS authentication type details for VPC connectivity.
        public var tls: KafkaClientTypes.VpcConnectivityTls?

        public init(
            sasl: KafkaClientTypes.VpcConnectivitySasl? = nil,
            tls: KafkaClientTypes.VpcConnectivityTls? = nil
        )
        {
            self.sasl = sasl
            self.tls = tls
        }
    }

}

extension KafkaClientTypes.VpcConnectivityIam: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension KafkaClientTypes {
    /// Details for IAM access control for VPC connectivity.
    public struct VpcConnectivityIam: Swift.Equatable {
        /// SASL/IAM authentication is on or off for VPC connectivity.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension KafkaClientTypes.VpcConnectivitySasl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iam = "iam"
        case scram = "scram"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iam = self.iam {
            try encodeContainer.encode(iam, forKey: .iam)
        }
        if let scram = self.scram {
            try encodeContainer.encode(scram, forKey: .scram)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scramDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.VpcConnectivityScram.self, forKey: .scram)
        scram = scramDecoded
        let iamDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.VpcConnectivityIam.self, forKey: .iam)
        iam = iamDecoded
    }
}

extension KafkaClientTypes {
    /// Details for SASL client authentication for VPC connectivity.
    public struct VpcConnectivitySasl: Swift.Equatable {
        /// Details for SASL/IAM client authentication for VPC connectivity.
        public var iam: KafkaClientTypes.VpcConnectivityIam?
        /// Details for SASL/SCRAM client authentication for VPC connectivity.
        public var scram: KafkaClientTypes.VpcConnectivityScram?

        public init(
            iam: KafkaClientTypes.VpcConnectivityIam? = nil,
            scram: KafkaClientTypes.VpcConnectivityScram? = nil
        )
        {
            self.iam = iam
            self.scram = scram
        }
    }

}

extension KafkaClientTypes.VpcConnectivityScram: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension KafkaClientTypes {
    /// Details for SASL/SCRAM client authentication for VPC connectivity.
    public struct VpcConnectivityScram: Swift.Equatable {
        /// SASL/SCRAM authentication is on or off for VPC connectivity.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension KafkaClientTypes.VpcConnectivityTls: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension KafkaClientTypes {
    /// Details for TLS client authentication for VPC connectivity.
    public struct VpcConnectivityTls: Swift.Equatable {
        /// TLS authentication is on or off for VPC connectivity.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension KafkaClientTypes.ZookeeperNodeInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedENIId = "attachedENIId"
        case clientVpcIpAddress = "clientVpcIpAddress"
        case endpoints = "endpoints"
        case zookeeperId = "zookeeperId"
        case zookeeperVersion = "zookeeperVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedENIId = self.attachedENIId {
            try encodeContainer.encode(attachedENIId, forKey: .attachedENIId)
        }
        if let clientVpcIpAddress = self.clientVpcIpAddress {
            try encodeContainer.encode(clientVpcIpAddress, forKey: .clientVpcIpAddress)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for __string0 in endpoints {
                try endpointsContainer.encode(__string0)
            }
        }
        if let zookeeperId = self.zookeeperId {
            try encodeContainer.encode(zookeeperId, forKey: .zookeeperId)
        }
        if let zookeeperVersion = self.zookeeperVersion {
            try encodeContainer.encode(zookeeperVersion, forKey: .zookeeperVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedENIIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachedENIId)
        attachedENIId = attachedENIIdDecoded
        let clientVpcIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientVpcIpAddress)
        clientVpcIpAddress = clientVpcIpAddressDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .endpoints)
        var endpointsDecoded0:[Swift.String]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Swift.String]()
            for string0 in endpointsContainer {
                if let string0 = string0 {
                    endpointsDecoded0?.append(string0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let zookeeperIdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .zookeeperId)
        zookeeperId = zookeeperIdDecoded
        let zookeeperVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zookeeperVersion)
        zookeeperVersion = zookeeperVersionDecoded
    }
}

extension KafkaClientTypes {
    /// Zookeeper node information.
    public struct ZookeeperNodeInfo: Swift.Equatable {
        /// The attached elastic network interface of the broker.
        public var attachedENIId: Swift.String?
        /// The virtual private cloud (VPC) IP address of the client.
        public var clientVpcIpAddress: Swift.String?
        /// Endpoints for accessing the ZooKeeper.
        public var endpoints: [Swift.String]?
        /// The role-specific ID for Zookeeper.
        public var zookeeperId: Swift.Double?
        /// The version of Zookeeper.
        public var zookeeperVersion: Swift.String?

        public init(
            attachedENIId: Swift.String? = nil,
            clientVpcIpAddress: Swift.String? = nil,
            endpoints: [Swift.String]? = nil,
            zookeeperId: Swift.Double? = nil,
            zookeeperVersion: Swift.String? = nil
        )
        {
            self.attachedENIId = attachedENIId
            self.clientVpcIpAddress = clientVpcIpAddress
            self.endpoints = endpoints
            self.zookeeperId = zookeeperId
            self.zookeeperVersion = zookeeperVersion
        }
    }

}
