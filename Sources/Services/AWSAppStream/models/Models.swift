// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AppStreamClientTypes.AccessEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointType = "EndpointType"
        case vpceId = "VpceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let vpceId = self.vpceId {
            try encodeContainer.encode(vpceId, forKey: .vpceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AccessEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let vpceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceId)
        vpceId = vpceIdDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes an interface VPC endpoint (interface endpoint) that lets you create a private connection between the virtual private cloud (VPC) that you specify and AppStream 2.0. When you specify an interface endpoint for a stack, users of the stack can connect to AppStream 2.0 only through that endpoint. When you specify an interface endpoint for an image builder, administrators can connect to the image builder only through that endpoint.
    public struct AccessEndpoint: Swift.Equatable {
        /// The type of interface endpoint.
        /// This member is required.
        public var endpointType: AppStreamClientTypes.AccessEndpointType?
        /// The identifier (ID) of the VPC in which the interface endpoint is used.
        public var vpceId: Swift.String?

        public init(
            endpointType: AppStreamClientTypes.AccessEndpointType? = nil,
            vpceId: Swift.String? = nil
        )
        {
            self.endpointType = endpointType
            self.vpceId = vpceId
        }
    }

}

extension AppStreamClientTypes {
    public enum AccessEndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case streaming
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessEndpointType] {
            return [
                .streaming,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .streaming: return "STREAMING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessEndpointType(rawValue: rawValue) ?? AccessEndpointType.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum Action: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clipboardCopyFromLocalDevice
        case clipboardCopyToLocalDevice
        case domainPasswordSignin
        case domainSmartCardSignin
        case fileDownload
        case fileUpload
        case printingToLocalDevice
        case sdkUnknown(Swift.String)

        public static var allCases: [Action] {
            return [
                .clipboardCopyFromLocalDevice,
                .clipboardCopyToLocalDevice,
                .domainPasswordSignin,
                .domainSmartCardSignin,
                .fileDownload,
                .fileUpload,
                .printingToLocalDevice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clipboardCopyFromLocalDevice: return "CLIPBOARD_COPY_FROM_LOCAL_DEVICE"
            case .clipboardCopyToLocalDevice: return "CLIPBOARD_COPY_TO_LOCAL_DEVICE"
            case .domainPasswordSignin: return "DOMAIN_PASSWORD_SIGNIN"
            case .domainSmartCardSignin: return "DOMAIN_SMART_CARD_SIGNIN"
            case .fileDownload: return "FILE_DOWNLOAD"
            case .fileUpload: return "FILE_UPLOAD"
            case .printingToLocalDevice: return "PRINTING_TO_LOCAL_DEVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Action(rawValue: rawValue) ?? Action.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.AppBlock: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockErrors = "AppBlockErrors"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case name = "Name"
        case packagingType = "PackagingType"
        case postSetupScriptDetails = "PostSetupScriptDetails"
        case setupScriptDetails = "SetupScriptDetails"
        case sourceS3Location = "SourceS3Location"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBlockErrors = appBlockErrors {
            var appBlockErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appBlockErrors)
            for errordetails0 in appBlockErrors {
                try appBlockErrorsContainer.encode(errordetails0)
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packagingType = self.packagingType {
            try encodeContainer.encode(packagingType.rawValue, forKey: .packagingType)
        }
        if let postSetupScriptDetails = self.postSetupScriptDetails {
            try encodeContainer.encode(postSetupScriptDetails, forKey: .postSetupScriptDetails)
        }
        if let setupScriptDetails = self.setupScriptDetails {
            try encodeContainer.encode(setupScriptDetails, forKey: .setupScriptDetails)
        }
        if let sourceS3Location = self.sourceS3Location {
            try encodeContainer.encode(sourceS3Location, forKey: .sourceS3Location)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let sourceS3LocationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.S3Location.self, forKey: .sourceS3Location)
        sourceS3Location = sourceS3LocationDecoded
        let setupScriptDetailsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ScriptDetails.self, forKey: .setupScriptDetails)
        setupScriptDetails = setupScriptDetailsDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let postSetupScriptDetailsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ScriptDetails.self, forKey: .postSetupScriptDetails)
        postSetupScriptDetails = postSetupScriptDetailsDecoded
        let packagingTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PackagingType.self, forKey: .packagingType)
        packagingType = packagingTypeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppBlockState.self, forKey: .state)
        state = stateDecoded
        let appBlockErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.ErrorDetails?].self, forKey: .appBlockErrors)
        var appBlockErrorsDecoded0:[AppStreamClientTypes.ErrorDetails]? = nil
        if let appBlockErrorsContainer = appBlockErrorsContainer {
            appBlockErrorsDecoded0 = [AppStreamClientTypes.ErrorDetails]()
            for structure0 in appBlockErrorsContainer {
                if let structure0 = structure0 {
                    appBlockErrorsDecoded0?.append(structure0)
                }
            }
        }
        appBlockErrors = appBlockErrorsDecoded0
    }
}

extension AppStreamClientTypes {
    /// Describes an app block. App blocks are an Amazon AppStream 2.0 resource that stores the details about the virtual hard disk in an S3 bucket. It also stores the setup script with details about how to mount the virtual hard disk. The virtual hard disk includes the application binaries and other files necessary to launch your applications. Multiple applications can be assigned to a single app block. This is only supported for Elastic fleets.
    public struct AppBlock: Swift.Equatable {
        /// The errors of the app block.
        public var appBlockErrors: [AppStreamClientTypes.ErrorDetails]?
        /// The ARN of the app block.
        /// This member is required.
        public var arn: Swift.String?
        /// The created time of the app block.
        public var createdTime: ClientRuntime.Date?
        /// The description of the app block.
        public var description: Swift.String?
        /// The display name of the app block.
        public var displayName: Swift.String?
        /// The name of the app block.
        /// This member is required.
        public var name: Swift.String?
        /// The packaging type of the app block.
        public var packagingType: AppStreamClientTypes.PackagingType?
        /// The post setup script details of the app block. This only applies to app blocks with PackagingType APPSTREAM2.
        public var postSetupScriptDetails: AppStreamClientTypes.ScriptDetails?
        /// The setup script details of the app block. This only applies to app blocks with PackagingType CUSTOM.
        public var setupScriptDetails: AppStreamClientTypes.ScriptDetails?
        /// The source S3 location of the app block.
        public var sourceS3Location: AppStreamClientTypes.S3Location?
        /// The state of the app block. An app block with AppStream 2.0 packaging will be in the INACTIVE state if no application package (VHD) is assigned to it. After an application package (VHD) is created by an app block builder for an app block, it becomes ACTIVE. Custom app blocks are always in the ACTIVE state and no action is required to use them.
        public var state: AppStreamClientTypes.AppBlockState?

        public init(
            appBlockErrors: [AppStreamClientTypes.ErrorDetails]? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            name: Swift.String? = nil,
            packagingType: AppStreamClientTypes.PackagingType? = nil,
            postSetupScriptDetails: AppStreamClientTypes.ScriptDetails? = nil,
            setupScriptDetails: AppStreamClientTypes.ScriptDetails? = nil,
            sourceS3Location: AppStreamClientTypes.S3Location? = nil,
            state: AppStreamClientTypes.AppBlockState? = nil
        )
        {
            self.appBlockErrors = appBlockErrors
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.name = name
            self.packagingType = packagingType
            self.postSetupScriptDetails = postSetupScriptDetails
            self.setupScriptDetails = setupScriptDetails
            self.sourceS3Location = sourceS3Location
            self.state = state
        }
    }

}

extension AppStreamClientTypes.AppBlockBuilder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case appBlockBuilderErrors = "AppBlockBuilderErrors"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case instanceType = "InstanceType"
        case name = "Name"
        case platform = "Platform"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpoint0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpoint0)
            }
        }
        if let appBlockBuilderErrors = appBlockBuilderErrors {
            var appBlockBuilderErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appBlockBuilderErrors)
            for resourceerror0 in appBlockBuilderErrors {
                try appBlockBuilderErrorsContainer.encode(resourceerror0)
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let enableDefaultInternetAccess = self.enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = self.stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppBlockBuilderPlatformType.self, forKey: .platform)
        platform = platformDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppBlockBuilderState.self, forKey: .state)
        state = stateDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let appBlockBuilderErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.ResourceError?].self, forKey: .appBlockBuilderErrors)
        var appBlockBuilderErrorsDecoded0:[AppStreamClientTypes.ResourceError]? = nil
        if let appBlockBuilderErrorsContainer = appBlockBuilderErrorsContainer {
            appBlockBuilderErrorsDecoded0 = [AppStreamClientTypes.ResourceError]()
            for structure0 in appBlockBuilderErrorsContainer {
                if let structure0 = structure0 {
                    appBlockBuilderErrorsDecoded0?.append(structure0)
                }
            }
        }
        appBlockBuilderErrors = appBlockBuilderErrorsDecoded0
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppBlockBuilderStateChangeReason.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
    }
}

extension AppStreamClientTypes {
    /// Describes an app block builder.
    public struct AppBlockBuilder: Swift.Equatable {
        /// The list of interface VPC endpoint (interface endpoint) objects. Administrators can connect to the app block builder only through the specified endpoints.
        public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
        /// The app block builder errors.
        public var appBlockBuilderErrors: [AppStreamClientTypes.ResourceError]?
        /// The ARN of the app block builder.
        /// This member is required.
        public var arn: Swift.String?
        /// The creation time of the app block builder.
        public var createdTime: ClientRuntime.Date?
        /// The description of the app block builder.
        public var description: Swift.String?
        /// The display name of the app block builder.
        public var displayName: Swift.String?
        /// Indicates whether default internet access is enabled for the app block builder.
        public var enableDefaultInternetAccess: Swift.Bool?
        /// The ARN of the IAM role that is applied to the app block builder.
        public var iamRoleArn: Swift.String?
        /// The instance type of the app block builder.
        /// This member is required.
        public var instanceType: Swift.String?
        /// The name of the app block builder.
        /// This member is required.
        public var name: Swift.String?
        /// The platform of the app block builder. WINDOWS_SERVER_2019 is the only valid value.
        /// This member is required.
        public var platform: AppStreamClientTypes.AppBlockBuilderPlatformType?
        /// The state of the app block builder.
        /// This member is required.
        public var state: AppStreamClientTypes.AppBlockBuilderState?
        /// The state change reason.
        public var stateChangeReason: AppStreamClientTypes.AppBlockBuilderStateChangeReason?
        /// The VPC configuration for the app block builder.
        /// This member is required.
        public var vpcConfig: AppStreamClientTypes.VpcConfig?

        public init(
            accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
            appBlockBuilderErrors: [AppStreamClientTypes.ResourceError]? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            enableDefaultInternetAccess: Swift.Bool? = nil,
            iamRoleArn: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            name: Swift.String? = nil,
            platform: AppStreamClientTypes.AppBlockBuilderPlatformType? = nil,
            state: AppStreamClientTypes.AppBlockBuilderState? = nil,
            stateChangeReason: AppStreamClientTypes.AppBlockBuilderStateChangeReason? = nil,
            vpcConfig: AppStreamClientTypes.VpcConfig? = nil
        )
        {
            self.accessEndpoints = accessEndpoints
            self.appBlockBuilderErrors = appBlockBuilderErrors
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.iamRoleArn = iamRoleArn
            self.instanceType = instanceType
            self.name = name
            self.platform = platform
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.vpcConfig = vpcConfig
        }
    }

}

extension AppStreamClientTypes.AppBlockBuilderAppBlockAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case appBlockBuilderName = "AppBlockBuilderName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBlockArn = self.appBlockArn {
            try encodeContainer.encode(appBlockArn, forKey: .appBlockArn)
        }
        if let appBlockBuilderName = self.appBlockBuilderName {
            try encodeContainer.encode(appBlockBuilderName, forKey: .appBlockBuilderName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlockArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBlockArn)
        appBlockArn = appBlockArnDecoded
        let appBlockBuilderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBlockBuilderName)
        appBlockBuilderName = appBlockBuilderNameDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes an association between an app block builder and app block.
    public struct AppBlockBuilderAppBlockAssociation: Swift.Equatable {
        /// The ARN of the app block.
        /// This member is required.
        public var appBlockArn: Swift.String?
        /// The name of the app block builder.
        /// This member is required.
        public var appBlockBuilderName: Swift.String?

        public init(
            appBlockArn: Swift.String? = nil,
            appBlockBuilderName: Swift.String? = nil
        )
        {
            self.appBlockArn = appBlockArn
            self.appBlockBuilderName = appBlockBuilderName
        }
    }

}

extension AppStreamClientTypes {
    public enum AppBlockBuilderAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessEndpoints
        case iamRoleArn
        case vpcConfigurationSecurityGroupIds
        case sdkUnknown(Swift.String)

        public static var allCases: [AppBlockBuilderAttribute] {
            return [
                .accessEndpoints,
                .iamRoleArn,
                .vpcConfigurationSecurityGroupIds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessEndpoints: return "ACCESS_ENDPOINTS"
            case .iamRoleArn: return "IAM_ROLE_ARN"
            case .vpcConfigurationSecurityGroupIds: return "VPC_CONFIGURATION_SECURITY_GROUP_IDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppBlockBuilderAttribute(rawValue: rawValue) ?? AppBlockBuilderAttribute.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum AppBlockBuilderPlatformType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case windowsServer2019
        case sdkUnknown(Swift.String)

        public static var allCases: [AppBlockBuilderPlatformType] {
            return [
                .windowsServer2019,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .windowsServer2019: return "WINDOWS_SERVER_2019"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppBlockBuilderPlatformType(rawValue: rawValue) ?? AppBlockBuilderPlatformType.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum AppBlockBuilderState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case running
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [AppBlockBuilderState] {
            return [
                .running,
                .starting,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppBlockBuilderState(rawValue: rawValue) ?? AppBlockBuilderState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.AppBlockBuilderStateChangeReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppBlockBuilderStateChangeReasonCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the reason why the last app block builder state change occurred.
    public struct AppBlockBuilderStateChangeReason: Swift.Equatable {
        /// The state change reason code.
        public var code: AppStreamClientTypes.AppBlockBuilderStateChangeReasonCode?
        /// The state change reason message.
        public var message: Swift.String?

        public init(
            code: AppStreamClientTypes.AppBlockBuilderStateChangeReasonCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension AppStreamClientTypes {
    public enum AppBlockBuilderStateChangeReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [AppBlockBuilderStateChangeReasonCode] {
            return [
                .internalError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppBlockBuilderStateChangeReasonCode(rawValue: rawValue) ?? AppBlockBuilderStateChangeReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum AppBlockState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AppBlockState] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppBlockState(rawValue: rawValue) ?? AppBlockState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum AppVisibility: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case associated
        case sdkUnknown(Swift.String)

        public static var allCases: [AppVisibility] {
            return [
                .all,
                .associated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .associated: return "ASSOCIATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppVisibility(rawValue: rawValue) ?? AppVisibility.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.Application: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case enabled = "Enabled"
        case iconS3Location = "IconS3Location"
        case iconURL = "IconURL"
        case instanceFamilies = "InstanceFamilies"
        case launchParameters = "LaunchParameters"
        case launchPath = "LaunchPath"
        case metadata = "Metadata"
        case name = "Name"
        case platforms = "Platforms"
        case workingDirectory = "WorkingDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBlockArn = self.appBlockArn {
            try encodeContainer.encode(appBlockArn, forKey: .appBlockArn)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let iconS3Location = self.iconS3Location {
            try encodeContainer.encode(iconS3Location, forKey: .iconS3Location)
        }
        if let iconURL = self.iconURL {
            try encodeContainer.encode(iconURL, forKey: .iconURL)
        }
        if let instanceFamilies = instanceFamilies {
            var instanceFamiliesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceFamilies)
            for string0 in instanceFamilies {
                try instanceFamiliesContainer.encode(string0)
            }
        }
        if let launchParameters = self.launchParameters {
            try encodeContainer.encode(launchParameters, forKey: .launchParameters)
        }
        if let launchPath = self.launchPath {
            try encodeContainer.encode(launchPath, forKey: .launchPath)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, metadata0) in metadata {
                try metadataContainer.encode(metadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platforms = platforms {
            var platformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platforms)
            for platformtype0 in platforms {
                try platformsContainer.encode(platformtype0.rawValue)
            }
        }
        if let workingDirectory = self.workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let iconURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iconURL)
        iconURL = iconURLDecoded
        let launchPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchPath)
        launchPath = launchPathDecoded
        let launchParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchParameters)
        launchParameters = launchParametersDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?[key0] = string0
                }
            }
        }
        metadata = metadataDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let appBlockArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBlockArn)
        appBlockArn = appBlockArnDecoded
        let iconS3LocationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.S3Location.self, forKey: .iconS3Location)
        iconS3Location = iconS3LocationDecoded
        let platformsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.PlatformType?].self, forKey: .platforms)
        var platformsDecoded0:[AppStreamClientTypes.PlatformType]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [AppStreamClientTypes.PlatformType]()
            for enum0 in platformsContainer {
                if let enum0 = enum0 {
                    platformsDecoded0?.append(enum0)
                }
            }
        }
        platforms = platformsDecoded0
        let instanceFamiliesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceFamilies)
        var instanceFamiliesDecoded0:[Swift.String]? = nil
        if let instanceFamiliesContainer = instanceFamiliesContainer {
            instanceFamiliesDecoded0 = [Swift.String]()
            for string0 in instanceFamiliesContainer {
                if let string0 = string0 {
                    instanceFamiliesDecoded0?.append(string0)
                }
            }
        }
        instanceFamilies = instanceFamiliesDecoded0
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes an application in the application catalog.
    public struct Application: Swift.Equatable {
        /// The app block ARN of the application.
        public var appBlockArn: Swift.String?
        /// The ARN of the application.
        public var arn: Swift.String?
        /// The time at which the application was created within the app block.
        public var createdTime: ClientRuntime.Date?
        /// The description of the application.
        public var description: Swift.String?
        /// The application name to display.
        public var displayName: Swift.String?
        /// If there is a problem, the application can be disabled after image creation.
        public var enabled: Swift.Bool
        /// The S3 location of the application icon.
        public var iconS3Location: AppStreamClientTypes.S3Location?
        /// The URL for the application icon. This URL might be time-limited.
        public var iconURL: Swift.String?
        /// The instance families for the application.
        public var instanceFamilies: [Swift.String]?
        /// The arguments that are passed to the application at launch.
        public var launchParameters: Swift.String?
        /// The path to the application executable in the instance.
        public var launchPath: Swift.String?
        /// Additional attributes that describe the application.
        public var metadata: [Swift.String:Swift.String]?
        /// The name of the application.
        public var name: Swift.String?
        /// The platforms on which the application can run.
        public var platforms: [AppStreamClientTypes.PlatformType]?
        /// The working directory for the application.
        public var workingDirectory: Swift.String?

        public init(
            appBlockArn: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            enabled: Swift.Bool = false,
            iconS3Location: AppStreamClientTypes.S3Location? = nil,
            iconURL: Swift.String? = nil,
            instanceFamilies: [Swift.String]? = nil,
            launchParameters: Swift.String? = nil,
            launchPath: Swift.String? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            platforms: [AppStreamClientTypes.PlatformType]? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.appBlockArn = appBlockArn
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.enabled = enabled
            self.iconS3Location = iconS3Location
            self.iconURL = iconURL
            self.instanceFamilies = instanceFamilies
            self.launchParameters = launchParameters
            self.launchPath = launchPath
            self.metadata = metadata
            self.name = name
            self.platforms = platforms
            self.workingDirectory = workingDirectory
        }
    }

}

extension AppStreamClientTypes {
    public enum ApplicationAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case launchParameters
        case workingDirectory
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationAttribute] {
            return [
                .launchParameters,
                .workingDirectory,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .launchParameters: return "LAUNCH_PARAMETERS"
            case .workingDirectory: return "WORKING_DIRECTORY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationAttribute(rawValue: rawValue) ?? ApplicationAttribute.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.ApplicationFleetAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case fleetName = "FleetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let fleetName = self.fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the application fleet association.
    public struct ApplicationFleetAssociation: Swift.Equatable {
        /// The ARN of the application associated with the fleet.
        /// This member is required.
        public var applicationArn: Swift.String?
        /// The name of the fleet associated with the application.
        /// This member is required.
        public var fleetName: Swift.String?

        public init(
            applicationArn: Swift.String? = nil,
            fleetName: Swift.String? = nil
        )
        {
            self.applicationArn = applicationArn
            self.fleetName = fleetName
        }
    }

}

extension AppStreamClientTypes.ApplicationSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case settingsGroup = "SettingsGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let settingsGroup = self.settingsGroup {
            try encodeContainer.encode(settingsGroup, forKey: .settingsGroup)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let settingsGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingsGroup)
        settingsGroup = settingsGroupDecoded
    }
}

extension AppStreamClientTypes {
    /// The persistent application settings for users of a stack.
    public struct ApplicationSettings: Swift.Equatable {
        /// Enables or disables persistent application settings for users during their streaming sessions.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The path prefix for the S3 bucket where usersâ€™ persistent application settings are stored. You can allow the same persistent application settings to be used across multiple stacks by specifying the same settings group for each stack.
        public var settingsGroup: Swift.String?

        public init(
            enabled: Swift.Bool = false,
            settingsGroup: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.settingsGroup = settingsGroup
        }
    }

}

extension AppStreamClientTypes.ApplicationSettingsResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case s3BucketName = "S3BucketName"
        case settingsGroup = "SettingsGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let settingsGroup = self.settingsGroup {
            try encodeContainer.encode(settingsGroup, forKey: .settingsGroup)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let settingsGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingsGroup)
        settingsGroup = settingsGroupDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the persistent application settings for users of a stack.
    public struct ApplicationSettingsResponse: Swift.Equatable {
        /// Specifies whether persistent application settings are enabled for users during their streaming sessions.
        public var enabled: Swift.Bool
        /// The S3 bucket where usersâ€™ persistent application settings are stored. When persistent application settings are enabled for the first time for an account in an AWS Region, an S3 bucket is created. The bucket is unique to the AWS account and the Region.
        public var s3BucketName: Swift.String?
        /// The path prefix for the S3 bucket where usersâ€™ persistent application settings are stored.
        public var settingsGroup: Swift.String?

        public init(
            enabled: Swift.Bool = false,
            s3BucketName: Swift.String? = nil,
            settingsGroup: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.s3BucketName = s3BucketName
            self.settingsGroup = settingsGroup
        }
    }

}

extension AssociateAppBlockBuilderAppBlockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case appBlockBuilderName = "AppBlockBuilderName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBlockArn = self.appBlockArn {
            try encodeContainer.encode(appBlockArn, forKey: .appBlockArn)
        }
        if let appBlockBuilderName = self.appBlockBuilderName {
            try encodeContainer.encode(appBlockBuilderName, forKey: .appBlockBuilderName)
        }
    }
}

extension AssociateAppBlockBuilderAppBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateAppBlockBuilderAppBlockInput: Swift.Equatable {
    /// The ARN of the app block.
    /// This member is required.
    public var appBlockArn: Swift.String?
    /// The name of the app block builder.
    /// This member is required.
    public var appBlockBuilderName: Swift.String?

    public init(
        appBlockArn: Swift.String? = nil,
        appBlockBuilderName: Swift.String? = nil
    )
    {
        self.appBlockArn = appBlockArn
        self.appBlockBuilderName = appBlockBuilderName
    }
}

struct AssociateAppBlockBuilderAppBlockInputBody: Swift.Equatable {
    let appBlockArn: Swift.String?
    let appBlockBuilderName: Swift.String?
}

extension AssociateAppBlockBuilderAppBlockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case appBlockBuilderName = "AppBlockBuilderName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlockArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBlockArn)
        appBlockArn = appBlockArnDecoded
        let appBlockBuilderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBlockBuilderName)
        appBlockBuilderName = appBlockBuilderNameDecoded
    }
}

extension AssociateAppBlockBuilderAppBlockOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateAppBlockBuilderAppBlockOutputBody = try responseDecoder.decode(responseBody: data)
            self.appBlockBuilderAppBlockAssociation = output.appBlockBuilderAppBlockAssociation
        } else {
            self.appBlockBuilderAppBlockAssociation = nil
        }
    }
}

public struct AssociateAppBlockBuilderAppBlockOutput: Swift.Equatable {
    /// The list of app block builders associated with app blocks.
    public var appBlockBuilderAppBlockAssociation: AppStreamClientTypes.AppBlockBuilderAppBlockAssociation?

    public init(
        appBlockBuilderAppBlockAssociation: AppStreamClientTypes.AppBlockBuilderAppBlockAssociation? = nil
    )
    {
        self.appBlockBuilderAppBlockAssociation = appBlockBuilderAppBlockAssociation
    }
}

struct AssociateAppBlockBuilderAppBlockOutputBody: Swift.Equatable {
    let appBlockBuilderAppBlockAssociation: AppStreamClientTypes.AppBlockBuilderAppBlockAssociation?
}

extension AssociateAppBlockBuilderAppBlockOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockBuilderAppBlockAssociation = "AppBlockBuilderAppBlockAssociation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlockBuilderAppBlockAssociationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppBlockBuilderAppBlockAssociation.self, forKey: .appBlockBuilderAppBlockAssociation)
        appBlockBuilderAppBlockAssociation = appBlockBuilderAppBlockAssociationDecoded
    }
}

enum AssociateAppBlockBuilderAppBlockOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateApplicationFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case fleetName = "FleetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let fleetName = self.fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
    }
}

extension AssociateApplicationFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateApplicationFleetInput: Swift.Equatable {
    /// The ARN of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        fleetName: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.fleetName = fleetName
    }
}

struct AssociateApplicationFleetInputBody: Swift.Equatable {
    let fleetName: Swift.String?
    let applicationArn: Swift.String?
}

extension AssociateApplicationFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case fleetName = "FleetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension AssociateApplicationFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateApplicationFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationFleetAssociation = output.applicationFleetAssociation
        } else {
            self.applicationFleetAssociation = nil
        }
    }
}

public struct AssociateApplicationFleetOutput: Swift.Equatable {
    /// If fleet name is specified, this returns the list of applications that are associated to it. If application ARN is specified, this returns the list of fleets to which it is associated.
    public var applicationFleetAssociation: AppStreamClientTypes.ApplicationFleetAssociation?

    public init(
        applicationFleetAssociation: AppStreamClientTypes.ApplicationFleetAssociation? = nil
    )
    {
        self.applicationFleetAssociation = applicationFleetAssociation
    }
}

struct AssociateApplicationFleetOutputBody: Swift.Equatable {
    let applicationFleetAssociation: AppStreamClientTypes.ApplicationFleetAssociation?
}

extension AssociateApplicationFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationFleetAssociation = "ApplicationFleetAssociation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationFleetAssociationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ApplicationFleetAssociation.self, forKey: .applicationFleetAssociation)
        applicationFleetAssociation = applicationFleetAssociationDecoded
    }
}

enum AssociateApplicationFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateApplicationToEntitlementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIdentifier = "ApplicationIdentifier"
        case entitlementName = "EntitlementName"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationIdentifier = self.applicationIdentifier {
            try encodeContainer.encode(applicationIdentifier, forKey: .applicationIdentifier)
        }
        if let entitlementName = self.entitlementName {
            try encodeContainer.encode(entitlementName, forKey: .entitlementName)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

extension AssociateApplicationToEntitlementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateApplicationToEntitlementInput: Swift.Equatable {
    /// The identifier of the application.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The name of the entitlement.
    /// This member is required.
    public var entitlementName: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        applicationIdentifier: Swift.String? = nil,
        entitlementName: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.entitlementName = entitlementName
        self.stackName = stackName
    }
}

struct AssociateApplicationToEntitlementInputBody: Swift.Equatable {
    let stackName: Swift.String?
    let entitlementName: Swift.String?
    let applicationIdentifier: Swift.String?
}

extension AssociateApplicationToEntitlementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIdentifier = "ApplicationIdentifier"
        case entitlementName = "EntitlementName"
        case stackName = "StackName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let entitlementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementName)
        entitlementName = entitlementNameDecoded
        let applicationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationIdentifier)
        applicationIdentifier = applicationIdentifierDecoded
    }
}

extension AssociateApplicationToEntitlementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateApplicationToEntitlementOutput: Swift.Equatable {

    public init() { }
}

enum AssociateApplicationToEntitlementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntitlementNotFoundException": return try await EntitlementNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetName = self.fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

extension AssociateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        fleetName: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.fleetName = fleetName
        self.stackName = stackName
    }
}

struct AssociateFleetInputBody: Swift.Equatable {
    let fleetName: Swift.String?
    let stackName: Swift.String?
}

extension AssociateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
    }
}

extension AssociateFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateFleetOutput: Swift.Equatable {

    public init() { }
}

enum AssociateFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncompatibleImageException": return try await IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppStreamClientTypes {
    public enum AuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case api
        case awsAd
        case saml
        case userpool
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .api,
                .awsAd,
                .saml,
                .userpool,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .api: return "API"
            case .awsAd: return "AWS_AD"
            case .saml: return "SAML"
            case .userpool: return "USERPOOL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationType(rawValue: rawValue) ?? AuthenticationType.sdkUnknown(rawValue)
        }
    }
}

extension BatchAssociateUserStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userStackAssociations = userStackAssociations {
            var userStackAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userStackAssociations)
            for userstackassociation0 in userStackAssociations {
                try userStackAssociationsContainer.encode(userstackassociation0)
            }
        }
    }
}

extension BatchAssociateUserStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchAssociateUserStackInput: Swift.Equatable {
    /// The list of UserStackAssociation objects.
    /// This member is required.
    public var userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?

    public init(
        userStackAssociations: [AppStreamClientTypes.UserStackAssociation]? = nil
    )
    {
        self.userStackAssociations = userStackAssociations
    }
}

struct BatchAssociateUserStackInputBody: Swift.Equatable {
    let userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?
}

extension BatchAssociateUserStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserStackAssociation?].self, forKey: .userStackAssociations)
        var userStackAssociationsDecoded0:[AppStreamClientTypes.UserStackAssociation]? = nil
        if let userStackAssociationsContainer = userStackAssociationsContainer {
            userStackAssociationsDecoded0 = [AppStreamClientTypes.UserStackAssociation]()
            for structure0 in userStackAssociationsContainer {
                if let structure0 = structure0 {
                    userStackAssociationsDecoded0?.append(structure0)
                }
            }
        }
        userStackAssociations = userStackAssociationsDecoded0
    }
}

extension BatchAssociateUserStackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchAssociateUserStackOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchAssociateUserStackOutput: Swift.Equatable {
    /// The list of UserStackAssociationError objects.
    public var errors: [AppStreamClientTypes.UserStackAssociationError]?

    public init(
        errors: [AppStreamClientTypes.UserStackAssociationError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchAssociateUserStackOutputBody: Swift.Equatable {
    let errors: [AppStreamClientTypes.UserStackAssociationError]?
}

extension BatchAssociateUserStackOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserStackAssociationError?].self, forKey: .errors)
        var errorsDecoded0:[AppStreamClientTypes.UserStackAssociationError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AppStreamClientTypes.UserStackAssociationError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchAssociateUserStackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchDisassociateUserStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userStackAssociations = userStackAssociations {
            var userStackAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userStackAssociations)
            for userstackassociation0 in userStackAssociations {
                try userStackAssociationsContainer.encode(userstackassociation0)
            }
        }
    }
}

extension BatchDisassociateUserStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchDisassociateUserStackInput: Swift.Equatable {
    /// The list of UserStackAssociation objects.
    /// This member is required.
    public var userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?

    public init(
        userStackAssociations: [AppStreamClientTypes.UserStackAssociation]? = nil
    )
    {
        self.userStackAssociations = userStackAssociations
    }
}

struct BatchDisassociateUserStackInputBody: Swift.Equatable {
    let userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?
}

extension BatchDisassociateUserStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserStackAssociation?].self, forKey: .userStackAssociations)
        var userStackAssociationsDecoded0:[AppStreamClientTypes.UserStackAssociation]? = nil
        if let userStackAssociationsContainer = userStackAssociationsContainer {
            userStackAssociationsDecoded0 = [AppStreamClientTypes.UserStackAssociation]()
            for structure0 in userStackAssociationsContainer {
                if let structure0 = structure0 {
                    userStackAssociationsDecoded0?.append(structure0)
                }
            }
        }
        userStackAssociations = userStackAssociationsDecoded0
    }
}

extension BatchDisassociateUserStackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDisassociateUserStackOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDisassociateUserStackOutput: Swift.Equatable {
    /// The list of UserStackAssociationError objects.
    public var errors: [AppStreamClientTypes.UserStackAssociationError]?

    public init(
        errors: [AppStreamClientTypes.UserStackAssociationError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDisassociateUserStackOutputBody: Swift.Equatable {
    let errors: [AppStreamClientTypes.UserStackAssociationError]?
}

extension BatchDisassociateUserStackOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserStackAssociationError?].self, forKey: .errors)
        var errorsDecoded0:[AppStreamClientTypes.UserStackAssociationError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AppStreamClientTypes.UserStackAssociationError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchDisassociateUserStackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppStreamClientTypes.CertificateBasedAuthProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = self.certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.CertificateBasedAuthStatus.self, forKey: .status)
        status = statusDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

extension AppStreamClientTypes {
    /// The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory domain-joined streaming instances. Fallback is turned on by default when certificate-based authentication is Enabled . Fallback allows users to log in using their AD domain password if certificate-based authentication is unsuccessful, or to unlock a desktop lock screen. Enabled_no_directory_login_fallback enables certificate-based authentication, but does not allow users to log in using their AD domain password. Users will be disconnected to re-authenticate using certificates.
    public struct CertificateBasedAuthProperties: Swift.Equatable {
        /// The ARN of the AWS Certificate Manager Private CA resource.
        public var certificateAuthorityArn: Swift.String?
        /// The status of the certificate-based authentication properties.
        public var status: AppStreamClientTypes.CertificateBasedAuthStatus?

        public init(
            certificateAuthorityArn: Swift.String? = nil,
            status: AppStreamClientTypes.CertificateBasedAuthStatus? = nil
        )
        {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.status = status
        }
    }

}

extension AppStreamClientTypes {
    public enum CertificateBasedAuthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case enabledNoDirectoryLoginFallback
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateBasedAuthStatus] {
            return [
                .disabled,
                .enabled,
                .enabledNoDirectoryLoginFallback,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .enabledNoDirectoryLoginFallback: return "ENABLED_NO_DIRECTORY_LOGIN_FALLBACK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateBasedAuthStatus(rawValue: rawValue) ?? CertificateBasedAuthStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.ComputeCapacity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredInstances = "DesiredInstances"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredInstances = self.desiredInstances {
            try encodeContainer.encode(desiredInstances, forKey: .desiredInstances)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredInstancesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desiredInstances)
        desiredInstances = desiredInstancesDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the capacity for a fleet.
    public struct ComputeCapacity: Swift.Equatable {
        /// The desired number of streaming instances.
        /// This member is required.
        public var desiredInstances: Swift.Int?

        public init(
            desiredInstances: Swift.Int? = nil
        )
        {
            self.desiredInstances = desiredInstances
        }
    }

}

extension AppStreamClientTypes.ComputeCapacityStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case available = "Available"
        case desired = "Desired"
        case inUse = "InUse"
        case running = "Running"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let available = self.available {
            try encodeContainer.encode(available, forKey: .available)
        }
        if let desired = self.desired {
            try encodeContainer.encode(desired, forKey: .desired)
        }
        if let inUse = self.inUse {
            try encodeContainer.encode(inUse, forKey: .inUse)
        }
        if let running = self.running {
            try encodeContainer.encode(running, forKey: .running)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desired)
        desired = desiredDecoded
        let runningDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .running)
        running = runningDecoded
        let inUseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inUse)
        inUse = inUseDecoded
        let availableDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .available)
        available = availableDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the capacity status for a fleet.
    public struct ComputeCapacityStatus: Swift.Equatable {
        /// The number of currently available instances that can be used to stream sessions.
        public var available: Swift.Int?
        /// The desired number of streaming instances.
        /// This member is required.
        public var desired: Swift.Int?
        /// The number of instances in use for streaming.
        public var inUse: Swift.Int?
        /// The total number of simultaneous streaming instances that are running.
        public var running: Swift.Int?

        public init(
            available: Swift.Int? = nil,
            desired: Swift.Int? = nil,
            inUse: Swift.Int? = nil,
            running: Swift.Int? = nil
        )
        {
            self.available = available
            self.desired = desired
            self.inUse = inUse
            self.running = running
        }
    }

}

extension ConcurrentModificationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An API error occurred. Wait a few minutes and try again.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CopyImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationImageDescription = "DestinationImageDescription"
        case destinationImageName = "DestinationImageName"
        case destinationRegion = "DestinationRegion"
        case sourceImageName = "SourceImageName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationImageDescription = self.destinationImageDescription {
            try encodeContainer.encode(destinationImageDescription, forKey: .destinationImageDescription)
        }
        if let destinationImageName = self.destinationImageName {
            try encodeContainer.encode(destinationImageName, forKey: .destinationImageName)
        }
        if let destinationRegion = self.destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
        if let sourceImageName = self.sourceImageName {
            try encodeContainer.encode(sourceImageName, forKey: .sourceImageName)
        }
    }
}

extension CopyImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CopyImageInput: Swift.Equatable {
    /// The description that the image will have when it is copied to the destination.
    public var destinationImageDescription: Swift.String?
    /// The name that the image will have when it is copied to the destination.
    /// This member is required.
    public var destinationImageName: Swift.String?
    /// The destination region to which the image will be copied. This parameter is required, even if you are copying an image within the same region.
    /// This member is required.
    public var destinationRegion: Swift.String?
    /// The name of the image to copy.
    /// This member is required.
    public var sourceImageName: Swift.String?

    public init(
        destinationImageDescription: Swift.String? = nil,
        destinationImageName: Swift.String? = nil,
        destinationRegion: Swift.String? = nil,
        sourceImageName: Swift.String? = nil
    )
    {
        self.destinationImageDescription = destinationImageDescription
        self.destinationImageName = destinationImageName
        self.destinationRegion = destinationRegion
        self.sourceImageName = sourceImageName
    }
}

struct CopyImageInputBody: Swift.Equatable {
    let sourceImageName: Swift.String?
    let destinationImageName: Swift.String?
    let destinationRegion: Swift.String?
    let destinationImageDescription: Swift.String?
}

extension CopyImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationImageDescription = "DestinationImageDescription"
        case destinationImageName = "DestinationImageName"
        case destinationRegion = "DestinationRegion"
        case sourceImageName = "SourceImageName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceImageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceImageName)
        sourceImageName = sourceImageNameDecoded
        let destinationImageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationImageName)
        destinationImageName = destinationImageNameDecoded
        let destinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let destinationImageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationImageDescription)
        destinationImageDescription = destinationImageDescriptionDecoded
    }
}

extension CopyImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CopyImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinationImageName = output.destinationImageName
        } else {
            self.destinationImageName = nil
        }
    }
}

public struct CopyImageOutput: Swift.Equatable {
    /// The name of the destination image.
    public var destinationImageName: Swift.String?

    public init(
        destinationImageName: Swift.String? = nil
    )
    {
        self.destinationImageName = destinationImageName
    }
}

struct CopyImageOutputBody: Swift.Equatable {
    let destinationImageName: Swift.String?
}

extension CopyImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationImageName = "DestinationImageName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationImageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationImageName)
        destinationImageName = destinationImageNameDecoded
    }
}

enum CopyImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IncompatibleImageException": return try await IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotAvailableException": return try await ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAppBlockBuilderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case description = "Description"
        case displayName = "DisplayName"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case instanceType = "InstanceType"
        case name = "Name"
        case platform = "Platform"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpoint0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpoint0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let enableDefaultInternetAccess = self.enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension CreateAppBlockBuilderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAppBlockBuilderInput: Swift.Equatable {
    /// The list of interface VPC endpoint (interface endpoint) objects. Administrators can connect to the app block builder only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The description of the app block builder.
    public var description: Swift.String?
    /// The display name of the app block builder.
    public var displayName: Swift.String?
    /// Enables or disables default internet access for the app block builder.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the app block builder. To assume a role, the app block builder calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The instance type to use when launching the app block builder. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.standard.xlarge
    ///
    /// * stream.standard.2xlarge
    /// This member is required.
    public var instanceType: Swift.String?
    /// The unique name for the app block builder.
    /// This member is required.
    public var name: Swift.String?
    /// The platform of the app block builder. WINDOWS_SERVER_2019 is the only valid value.
    /// This member is required.
    public var platform: AppStreamClientTypes.AppBlockBuilderPlatformType?
    /// The tags to associate with the app block builder. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. If you do not specify a value, the value is set to an empty string. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ For more information, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var tags: [Swift.String:Swift.String]?
    /// The VPC configuration for the app block builder. App block builders require that you specify at least two subnets in different availability zones.
    /// This member is required.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init(
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        iamRoleArn: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        name: Swift.String? = nil,
        platform: AppStreamClientTypes.AppBlockBuilderPlatformType? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.description = description
        self.displayName = displayName
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.iamRoleArn = iamRoleArn
        self.instanceType = instanceType
        self.name = name
        self.platform = platform
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateAppBlockBuilderInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let displayName: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let platform: AppStreamClientTypes.AppBlockBuilderPlatformType?
    let instanceType: Swift.String?
    let vpcConfig: AppStreamClientTypes.VpcConfig?
    let enableDefaultInternetAccess: Swift.Bool?
    let iamRoleArn: Swift.String?
    let accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
}

extension CreateAppBlockBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case description = "Description"
        case displayName = "DisplayName"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case instanceType = "InstanceType"
        case name = "Name"
        case platform = "Platform"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let platformDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppBlockBuilderPlatformType.self, forKey: .platform)
        platform = platformDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
    }
}

extension CreateAppBlockBuilderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppBlockBuilderOutputBody = try responseDecoder.decode(responseBody: data)
            self.appBlockBuilder = output.appBlockBuilder
        } else {
            self.appBlockBuilder = nil
        }
    }
}

public struct CreateAppBlockBuilderOutput: Swift.Equatable {
    /// Describes an app block builder.
    public var appBlockBuilder: AppStreamClientTypes.AppBlockBuilder?

    public init(
        appBlockBuilder: AppStreamClientTypes.AppBlockBuilder? = nil
    )
    {
        self.appBlockBuilder = appBlockBuilder
    }
}

struct CreateAppBlockBuilderOutputBody: Swift.Equatable {
    let appBlockBuilder: AppStreamClientTypes.AppBlockBuilder?
}

extension CreateAppBlockBuilderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockBuilder = "AppBlockBuilder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlockBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppBlockBuilder.self, forKey: .appBlockBuilder)
        appBlockBuilder = appBlockBuilderDecoded
    }
}

enum CreateAppBlockBuilderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRoleException": return try await InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestLimitExceededException": return try await RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotAvailableException": return try await ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAppBlockBuilderStreamingURLInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockBuilderName = "AppBlockBuilderName"
        case validity = "Validity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBlockBuilderName = self.appBlockBuilderName {
            try encodeContainer.encode(appBlockBuilderName, forKey: .appBlockBuilderName)
        }
        if let validity = self.validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }
}

extension CreateAppBlockBuilderStreamingURLInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAppBlockBuilderStreamingURLInput: Swift.Equatable {
    /// The name of the app block builder.
    /// This member is required.
    public var appBlockBuilderName: Swift.String?
    /// The time that the streaming URL will be valid, in seconds. Specify a value between 1 and 604800 seconds. The default is 3600 seconds.
    public var validity: Swift.Int?

    public init(
        appBlockBuilderName: Swift.String? = nil,
        validity: Swift.Int? = nil
    )
    {
        self.appBlockBuilderName = appBlockBuilderName
        self.validity = validity
    }
}

struct CreateAppBlockBuilderStreamingURLInputBody: Swift.Equatable {
    let appBlockBuilderName: Swift.String?
    let validity: Swift.Int?
}

extension CreateAppBlockBuilderStreamingURLInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockBuilderName = "AppBlockBuilderName"
        case validity = "Validity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlockBuilderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBlockBuilderName)
        appBlockBuilderName = appBlockBuilderNameDecoded
        let validityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validity)
        validity = validityDecoded
    }
}

extension CreateAppBlockBuilderStreamingURLOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppBlockBuilderStreamingURLOutputBody = try responseDecoder.decode(responseBody: data)
            self.expires = output.expires
            self.streamingURL = output.streamingURL
        } else {
            self.expires = nil
            self.streamingURL = nil
        }
    }
}

public struct CreateAppBlockBuilderStreamingURLOutput: Swift.Equatable {
    /// The elapsed time, in seconds after the Unix epoch, when this URL expires.
    public var expires: ClientRuntime.Date?
    /// The URL to start the streaming session.
    public var streamingURL: Swift.String?

    public init(
        expires: ClientRuntime.Date? = nil,
        streamingURL: Swift.String? = nil
    )
    {
        self.expires = expires
        self.streamingURL = streamingURL
    }
}

struct CreateAppBlockBuilderStreamingURLOutputBody: Swift.Equatable {
    let streamingURL: Swift.String?
    let expires: ClientRuntime.Date?
}

extension CreateAppBlockBuilderStreamingURLOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expires = "Expires"
        case streamingURL = "StreamingURL"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingURL)
        streamingURL = streamingURLDecoded
        let expiresDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expires)
        expires = expiresDecoded
    }
}

enum CreateAppBlockBuilderStreamingURLOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAppBlockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayName = "DisplayName"
        case name = "Name"
        case packagingType = "PackagingType"
        case postSetupScriptDetails = "PostSetupScriptDetails"
        case setupScriptDetails = "SetupScriptDetails"
        case sourceS3Location = "SourceS3Location"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packagingType = self.packagingType {
            try encodeContainer.encode(packagingType.rawValue, forKey: .packagingType)
        }
        if let postSetupScriptDetails = self.postSetupScriptDetails {
            try encodeContainer.encode(postSetupScriptDetails, forKey: .postSetupScriptDetails)
        }
        if let setupScriptDetails = self.setupScriptDetails {
            try encodeContainer.encode(setupScriptDetails, forKey: .setupScriptDetails)
        }
        if let sourceS3Location = self.sourceS3Location {
            try encodeContainer.encode(sourceS3Location, forKey: .sourceS3Location)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAppBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAppBlockInput: Swift.Equatable {
    /// The description of the app block.
    public var description: Swift.String?
    /// The display name of the app block. This is not displayed to the user.
    public var displayName: Swift.String?
    /// The name of the app block.
    /// This member is required.
    public var name: Swift.String?
    /// The packaging type of the app block.
    public var packagingType: AppStreamClientTypes.PackagingType?
    /// The post setup script details of the app block. This can only be provided for the APPSTREAM2 PackagingType.
    public var postSetupScriptDetails: AppStreamClientTypes.ScriptDetails?
    /// The setup script details of the app block. This must be provided for the CUSTOM PackagingType.
    public var setupScriptDetails: AppStreamClientTypes.ScriptDetails?
    /// The source S3 location of the app block.
    /// This member is required.
    public var sourceS3Location: AppStreamClientTypes.S3Location?
    /// The tags assigned to the app block.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        name: Swift.String? = nil,
        packagingType: AppStreamClientTypes.PackagingType? = nil,
        postSetupScriptDetails: AppStreamClientTypes.ScriptDetails? = nil,
        setupScriptDetails: AppStreamClientTypes.ScriptDetails? = nil,
        sourceS3Location: AppStreamClientTypes.S3Location? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.name = name
        self.packagingType = packagingType
        self.postSetupScriptDetails = postSetupScriptDetails
        self.setupScriptDetails = setupScriptDetails
        self.sourceS3Location = sourceS3Location
        self.tags = tags
    }
}

struct CreateAppBlockInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let displayName: Swift.String?
    let sourceS3Location: AppStreamClientTypes.S3Location?
    let setupScriptDetails: AppStreamClientTypes.ScriptDetails?
    let tags: [Swift.String:Swift.String]?
    let postSetupScriptDetails: AppStreamClientTypes.ScriptDetails?
    let packagingType: AppStreamClientTypes.PackagingType?
}

extension CreateAppBlockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayName = "DisplayName"
        case name = "Name"
        case packagingType = "PackagingType"
        case postSetupScriptDetails = "PostSetupScriptDetails"
        case setupScriptDetails = "SetupScriptDetails"
        case sourceS3Location = "SourceS3Location"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let sourceS3LocationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.S3Location.self, forKey: .sourceS3Location)
        sourceS3Location = sourceS3LocationDecoded
        let setupScriptDetailsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ScriptDetails.self, forKey: .setupScriptDetails)
        setupScriptDetails = setupScriptDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let postSetupScriptDetailsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ScriptDetails.self, forKey: .postSetupScriptDetails)
        postSetupScriptDetails = postSetupScriptDetailsDecoded
        let packagingTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PackagingType.self, forKey: .packagingType)
        packagingType = packagingTypeDecoded
    }
}

extension CreateAppBlockOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppBlockOutputBody = try responseDecoder.decode(responseBody: data)
            self.appBlock = output.appBlock
        } else {
            self.appBlock = nil
        }
    }
}

public struct CreateAppBlockOutput: Swift.Equatable {
    /// The app block.
    public var appBlock: AppStreamClientTypes.AppBlock?

    public init(
        appBlock: AppStreamClientTypes.AppBlock? = nil
    )
    {
        self.appBlock = appBlock
    }
}

struct CreateAppBlockOutputBody: Swift.Equatable {
    let appBlock: AppStreamClientTypes.AppBlock?
}

extension CreateAppBlockOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlock = "AppBlock"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlockDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppBlock.self, forKey: .appBlock)
        appBlock = appBlockDecoded
    }
}

enum CreateAppBlockOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case description = "Description"
        case displayName = "DisplayName"
        case iconS3Location = "IconS3Location"
        case instanceFamilies = "InstanceFamilies"
        case launchParameters = "LaunchParameters"
        case launchPath = "LaunchPath"
        case name = "Name"
        case platforms = "Platforms"
        case tags = "Tags"
        case workingDirectory = "WorkingDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBlockArn = self.appBlockArn {
            try encodeContainer.encode(appBlockArn, forKey: .appBlockArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let iconS3Location = self.iconS3Location {
            try encodeContainer.encode(iconS3Location, forKey: .iconS3Location)
        }
        if let instanceFamilies = instanceFamilies {
            var instanceFamiliesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceFamilies)
            for string0 in instanceFamilies {
                try instanceFamiliesContainer.encode(string0)
            }
        }
        if let launchParameters = self.launchParameters {
            try encodeContainer.encode(launchParameters, forKey: .launchParameters)
        }
        if let launchPath = self.launchPath {
            try encodeContainer.encode(launchPath, forKey: .launchPath)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platforms = platforms {
            var platformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platforms)
            for platformtype0 in platforms {
                try platformsContainer.encode(platformtype0.rawValue)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workingDirectory = self.workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// The app block ARN to which the application should be associated
    /// This member is required.
    public var appBlockArn: Swift.String?
    /// The description of the application.
    public var description: Swift.String?
    /// The display name of the application. This name is visible to users in the application catalog.
    public var displayName: Swift.String?
    /// The location in S3 of the application icon.
    /// This member is required.
    public var iconS3Location: AppStreamClientTypes.S3Location?
    /// The instance families the application supports. Valid values are GENERAL_PURPOSE and GRAPHICS_G4.
    /// This member is required.
    public var instanceFamilies: [Swift.String]?
    /// The launch parameters of the application.
    public var launchParameters: Swift.String?
    /// The launch path of the application.
    /// This member is required.
    public var launchPath: Swift.String?
    /// The name of the application. This name is visible to users when display name is not specified.
    /// This member is required.
    public var name: Swift.String?
    /// The platforms the application supports. WINDOWS_SERVER_2019 and AMAZON_LINUX2 are supported for Elastic fleets.
    /// This member is required.
    public var platforms: [AppStreamClientTypes.PlatformType]?
    /// The tags assigned to the application.
    public var tags: [Swift.String:Swift.String]?
    /// The working directory of the application.
    public var workingDirectory: Swift.String?

    public init(
        appBlockArn: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        iconS3Location: AppStreamClientTypes.S3Location? = nil,
        instanceFamilies: [Swift.String]? = nil,
        launchParameters: Swift.String? = nil,
        launchPath: Swift.String? = nil,
        name: Swift.String? = nil,
        platforms: [AppStreamClientTypes.PlatformType]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.appBlockArn = appBlockArn
        self.description = description
        self.displayName = displayName
        self.iconS3Location = iconS3Location
        self.instanceFamilies = instanceFamilies
        self.launchParameters = launchParameters
        self.launchPath = launchPath
        self.name = name
        self.platforms = platforms
        self.tags = tags
        self.workingDirectory = workingDirectory
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
    let iconS3Location: AppStreamClientTypes.S3Location?
    let launchPath: Swift.String?
    let workingDirectory: Swift.String?
    let launchParameters: Swift.String?
    let platforms: [AppStreamClientTypes.PlatformType]?
    let instanceFamilies: [Swift.String]?
    let appBlockArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case description = "Description"
        case displayName = "DisplayName"
        case iconS3Location = "IconS3Location"
        case instanceFamilies = "InstanceFamilies"
        case launchParameters = "LaunchParameters"
        case launchPath = "LaunchPath"
        case name = "Name"
        case platforms = "Platforms"
        case tags = "Tags"
        case workingDirectory = "WorkingDirectory"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let iconS3LocationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.S3Location.self, forKey: .iconS3Location)
        iconS3Location = iconS3LocationDecoded
        let launchPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchPath)
        launchPath = launchPathDecoded
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let launchParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchParameters)
        launchParameters = launchParametersDecoded
        let platformsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.PlatformType?].self, forKey: .platforms)
        var platformsDecoded0:[AppStreamClientTypes.PlatformType]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [AppStreamClientTypes.PlatformType]()
            for enum0 in platformsContainer {
                if let enum0 = enum0 {
                    platformsDecoded0?.append(enum0)
                }
            }
        }
        platforms = platformsDecoded0
        let instanceFamiliesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceFamilies)
        var instanceFamiliesDecoded0:[Swift.String]? = nil
        if let instanceFamiliesContainer = instanceFamiliesContainer {
            instanceFamiliesDecoded0 = [Swift.String]()
            for string0 in instanceFamiliesContainer {
                if let string0 = string0 {
                    instanceFamiliesDecoded0?.append(string0)
                }
            }
        }
        instanceFamilies = instanceFamiliesDecoded0
        let appBlockArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBlockArn)
        appBlockArn = appBlockArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct CreateApplicationOutput: Swift.Equatable {
    /// Describes an application in the application catalog.
    public var application: AppStreamClientTypes.Application?

    public init(
        application: AppStreamClientTypes.Application? = nil
    )
    {
        self.application = application
    }
}

struct CreateApplicationOutputBody: Swift.Equatable {
    let application: AppStreamClientTypes.Application?
}

extension CreateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application = "Application"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
    }
}

enum CreateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDirectoryConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBasedAuthProperties = "CertificateBasedAuthProperties"
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateBasedAuthProperties = self.certificateBasedAuthProperties {
            try encodeContainer.encode(certificateBasedAuthProperties, forKey: .certificateBasedAuthProperties)
        }
        if let directoryName = self.directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames {
            var organizationalUnitDistinguishedNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitDistinguishedNames)
            for organizationalunitdistinguishedname0 in organizationalUnitDistinguishedNames {
                try organizationalUnitDistinguishedNamesContainer.encode(organizationalunitdistinguishedname0)
            }
        }
        if let serviceAccountCredentials = self.serviceAccountCredentials {
            try encodeContainer.encode(serviceAccountCredentials, forKey: .serviceAccountCredentials)
        }
    }
}

extension CreateDirectoryConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDirectoryConfigInput: Swift.Equatable {
    /// The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory domain-joined streaming instances. Fallback is turned on by default when certificate-based authentication is Enabled . Fallback allows users to log in using their AD domain password if certificate-based authentication is unsuccessful, or to unlock a desktop lock screen. Enabled_no_directory_login_fallback enables certificate-based authentication, but does not allow users to log in using their AD domain password. Users will be disconnected to re-authenticate using certificates.
    public var certificateBasedAuthProperties: AppStreamClientTypes.CertificateBasedAuthProperties?
    /// The fully qualified name of the directory (for example, corp.example.com).
    /// This member is required.
    public var directoryName: Swift.String?
    /// The distinguished names of the organizational units for computer accounts.
    /// This member is required.
    public var organizationalUnitDistinguishedNames: [Swift.String]?
    /// The credentials for the service account used by the fleet or image builder to connect to the directory.
    public var serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?

    public init(
        certificateBasedAuthProperties: AppStreamClientTypes.CertificateBasedAuthProperties? = nil,
        directoryName: Swift.String? = nil,
        organizationalUnitDistinguishedNames: [Swift.String]? = nil,
        serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials? = nil
    )
    {
        self.certificateBasedAuthProperties = certificateBasedAuthProperties
        self.directoryName = directoryName
        self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
        self.serviceAccountCredentials = serviceAccountCredentials
    }
}

struct CreateDirectoryConfigInputBody: Swift.Equatable {
    let directoryName: Swift.String?
    let organizationalUnitDistinguishedNames: [Swift.String]?
    let serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?
    let certificateBasedAuthProperties: AppStreamClientTypes.CertificateBasedAuthProperties?
}

extension CreateDirectoryConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBasedAuthProperties = "CertificateBasedAuthProperties"
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitDistinguishedNames)
        var organizationalUnitDistinguishedNamesDecoded0:[Swift.String]? = nil
        if let organizationalUnitDistinguishedNamesContainer = organizationalUnitDistinguishedNamesContainer {
            organizationalUnitDistinguishedNamesDecoded0 = [Swift.String]()
            for string0 in organizationalUnitDistinguishedNamesContainer {
                if let string0 = string0 {
                    organizationalUnitDistinguishedNamesDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNamesDecoded0
        let serviceAccountCredentialsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ServiceAccountCredentials.self, forKey: .serviceAccountCredentials)
        serviceAccountCredentials = serviceAccountCredentialsDecoded
        let certificateBasedAuthPropertiesDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.CertificateBasedAuthProperties.self, forKey: .certificateBasedAuthProperties)
        certificateBasedAuthProperties = certificateBasedAuthPropertiesDecoded
    }
}

extension CreateDirectoryConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDirectoryConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.directoryConfig = output.directoryConfig
        } else {
            self.directoryConfig = nil
        }
    }
}

public struct CreateDirectoryConfigOutput: Swift.Equatable {
    /// Information about the directory configuration.
    public var directoryConfig: AppStreamClientTypes.DirectoryConfig?

    public init(
        directoryConfig: AppStreamClientTypes.DirectoryConfig? = nil
    )
    {
        self.directoryConfig = directoryConfig
    }
}

struct CreateDirectoryConfigOutputBody: Swift.Equatable {
    let directoryConfig: AppStreamClientTypes.DirectoryConfig?
}

extension CreateDirectoryConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryConfig = "DirectoryConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DirectoryConfig.self, forKey: .directoryConfig)
        directoryConfig = directoryConfigDecoded
    }
}

enum CreateDirectoryConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRoleException": return try await InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEntitlementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appVisibility = "AppVisibility"
        case attributes = "Attributes"
        case description = "Description"
        case name = "Name"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appVisibility = self.appVisibility {
            try encodeContainer.encode(appVisibility.rawValue, forKey: .appVisibility)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for entitlementattribute0 in attributes {
                try attributesContainer.encode(entitlementattribute0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

extension CreateEntitlementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEntitlementInput: Swift.Equatable {
    /// Specifies whether all or selected apps are entitled.
    /// This member is required.
    public var appVisibility: AppStreamClientTypes.AppVisibility?
    /// The attributes of the entitlement.
    /// This member is required.
    public var attributes: [AppStreamClientTypes.EntitlementAttribute]?
    /// The description of the entitlement.
    public var description: Swift.String?
    /// The name of the entitlement.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the stack with which the entitlement is associated.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        appVisibility: AppStreamClientTypes.AppVisibility? = nil,
        attributes: [AppStreamClientTypes.EntitlementAttribute]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.appVisibility = appVisibility
        self.attributes = attributes
        self.description = description
        self.name = name
        self.stackName = stackName
    }
}

struct CreateEntitlementInputBody: Swift.Equatable {
    let name: Swift.String?
    let stackName: Swift.String?
    let description: Swift.String?
    let appVisibility: AppStreamClientTypes.AppVisibility?
    let attributes: [AppStreamClientTypes.EntitlementAttribute]?
}

extension CreateEntitlementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appVisibility = "AppVisibility"
        case attributes = "Attributes"
        case description = "Description"
        case name = "Name"
        case stackName = "StackName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let appVisibilityDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppVisibility.self, forKey: .appVisibility)
        appVisibility = appVisibilityDecoded
        let attributesContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.EntitlementAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[AppStreamClientTypes.EntitlementAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [AppStreamClientTypes.EntitlementAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CreateEntitlementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEntitlementOutputBody = try responseDecoder.decode(responseBody: data)
            self.entitlement = output.entitlement
        } else {
            self.entitlement = nil
        }
    }
}

public struct CreateEntitlementOutput: Swift.Equatable {
    /// The entitlement.
    public var entitlement: AppStreamClientTypes.Entitlement?

    public init(
        entitlement: AppStreamClientTypes.Entitlement? = nil
    )
    {
        self.entitlement = entitlement
    }
}

struct CreateEntitlementOutputBody: Swift.Equatable {
    let entitlement: AppStreamClientTypes.Entitlement?
}

extension CreateEntitlementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlement = "Entitlement"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Entitlement.self, forKey: .entitlement)
        entitlement = entitlementDecoded
    }
}

enum CreateEntitlementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntitlementAlreadyExistsException": return try await EntitlementAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeCapacity = "ComputeCapacity"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case fleetType = "FleetType"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxConcurrentSessions = "MaxConcurrentSessions"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case platform = "Platform"
        case sessionScriptS3Location = "SessionScriptS3Location"
        case streamView = "StreamView"
        case tags = "Tags"
        case usbDeviceFilterStrings = "UsbDeviceFilterStrings"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeCapacity = self.computeCapacity {
            try encodeContainer.encode(computeCapacity, forKey: .computeCapacity)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disconnectTimeoutInSeconds = self.disconnectTimeoutInSeconds {
            try encodeContainer.encode(disconnectTimeoutInSeconds, forKey: .disconnectTimeoutInSeconds)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = self.domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = self.enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let fleetType = self.fleetType {
            try encodeContainer.encode(fleetType.rawValue, forKey: .fleetType)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idleDisconnectTimeoutInSeconds = self.idleDisconnectTimeoutInSeconds {
            try encodeContainer.encode(idleDisconnectTimeoutInSeconds, forKey: .idleDisconnectTimeoutInSeconds)
        }
        if let imageArn = self.imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = self.imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let maxConcurrentSessions = self.maxConcurrentSessions {
            try encodeContainer.encode(maxConcurrentSessions, forKey: .maxConcurrentSessions)
        }
        if let maxUserDurationInSeconds = self.maxUserDurationInSeconds {
            try encodeContainer.encode(maxUserDurationInSeconds, forKey: .maxUserDurationInSeconds)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let sessionScriptS3Location = self.sessionScriptS3Location {
            try encodeContainer.encode(sessionScriptS3Location, forKey: .sessionScriptS3Location)
        }
        if let streamView = self.streamView {
            try encodeContainer.encode(streamView.rawValue, forKey: .streamView)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let usbDeviceFilterStrings = usbDeviceFilterStrings {
            var usbDeviceFilterStringsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usbDeviceFilterStrings)
            for usbdevicefilterstring0 in usbDeviceFilterStrings {
                try usbDeviceFilterStringsContainer.encode(usbdevicefilterstring0)
            }
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension CreateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFleetInput: Swift.Equatable {
    /// The desired capacity for the fleet. This is not allowed for Elastic fleets. For Elastic fleets, specify MaxConcurrentSessions instead.
    public var computeCapacity: AppStreamClientTypes.ComputeCapacity?
    /// The description to display.
    public var description: Swift.String?
    /// The amount of time that a streaming session remains active after users disconnect. If users try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance. Specify a value between 60 and 360000.
    public var disconnectTimeoutInSeconds: Swift.Int?
    /// The fleet name to display.
    public var displayName: Swift.String?
    /// The name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain. This is not allowed for Elastic fleets.
    public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    /// Enables or disables default internet access for the fleet.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The fleet type. ALWAYS_ON Provides users with instant-on access to their apps. You are charged for all running instances in your fleet, even if no users are streaming apps. ON_DEMAND Provide users with access to applications after they connect, which takes one to two minutes. You are charged for instance streaming when users are connected and a small hourly fee for instances that are not streaming apps.
    public var fleetType: AppStreamClientTypes.FleetType?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the fleet. To assume a role, a fleet instance calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the DisconnectTimeoutInSeconds time interval begins. Users are notified before they are disconnected due to inactivity. If they try to reconnect to the streaming session before the time interval specified in DisconnectTimeoutInSeconds elapses, they are connected to their previous session. Users are considered idle when they stop providing keyboard or mouse input during their streaming session. File uploads and downloads, audio in, audio out, and pixels changing do not qualify as user activity. If users continue to be idle after the time interval in IdleDisconnectTimeoutInSeconds elapses, they are disconnected. To prevent users from being disconnected due to inactivity, specify a value of 0. Otherwise, specify a value between 60 and 3600. The default value is 0. If you enable this feature, we recommend that you specify a value that corresponds exactly to a whole number of minutes (for example, 60, 120, and 180). If you don't do this, the value is rounded to the nearest minute. For example, if you specify a value of 70, users are disconnected after 1 minute of inactivity. If you specify a value that is at the midpoint between two different minutes, the value is rounded up. For example, if you specify a value of 90, users are disconnected after 2 minutes of inactivity.
    public var idleDisconnectTimeoutInSeconds: Swift.Int?
    /// The ARN of the public, private, or shared image to use.
    public var imageArn: Swift.String?
    /// The name of the image used to create the fleet.
    public var imageName: Swift.String?
    /// The instance type to use when launching fleet instances. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.standard.xlarge
    ///
    /// * stream.standard.2xlarge
    ///
    /// * stream.compute.large
    ///
    /// * stream.compute.xlarge
    ///
    /// * stream.compute.2xlarge
    ///
    /// * stream.compute.4xlarge
    ///
    /// * stream.compute.8xlarge
    ///
    /// * stream.memory.large
    ///
    /// * stream.memory.xlarge
    ///
    /// * stream.memory.2xlarge
    ///
    /// * stream.memory.4xlarge
    ///
    /// * stream.memory.8xlarge
    ///
    /// * stream.memory.z1d.large
    ///
    /// * stream.memory.z1d.xlarge
    ///
    /// * stream.memory.z1d.2xlarge
    ///
    /// * stream.memory.z1d.3xlarge
    ///
    /// * stream.memory.z1d.6xlarge
    ///
    /// * stream.memory.z1d.12xlarge
    ///
    /// * stream.graphics-design.large
    ///
    /// * stream.graphics-design.xlarge
    ///
    /// * stream.graphics-design.2xlarge
    ///
    /// * stream.graphics-design.4xlarge
    ///
    /// * stream.graphics-desktop.2xlarge
    ///
    /// * stream.graphics.g4dn.xlarge
    ///
    /// * stream.graphics.g4dn.2xlarge
    ///
    /// * stream.graphics.g4dn.4xlarge
    ///
    /// * stream.graphics.g4dn.8xlarge
    ///
    /// * stream.graphics.g4dn.12xlarge
    ///
    /// * stream.graphics.g4dn.16xlarge
    ///
    /// * stream.graphics-pro.4xlarge
    ///
    /// * stream.graphics-pro.8xlarge
    ///
    /// * stream.graphics-pro.16xlarge
    ///
    ///
    /// The following instance types are available for Elastic fleets:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.standard.xlarge
    ///
    /// * stream.standard.2xlarge
    /// This member is required.
    public var instanceType: Swift.String?
    /// The maximum concurrent sessions of the Elastic fleet. This is required for Elastic fleets, and not allowed for other fleet types.
    public var maxConcurrentSessions: Swift.Int?
    /// The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance. Specify a value between 600 and 360000.
    public var maxUserDurationInSeconds: Swift.Int?
    /// A unique name for the fleet.
    /// This member is required.
    public var name: Swift.String?
    /// The fleet platform. WINDOWS_SERVER_2019 and AMAZON_LINUX2 are supported for Elastic fleets.
    public var platform: AppStreamClientTypes.PlatformType?
    /// The S3 location of the session scripts configuration zip file. This only applies to Elastic fleets.
    public var sessionScriptS3Location: AppStreamClientTypes.S3Location?
    /// The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When APP is specified, only the windows of applications opened by users display. When DESKTOP is specified, the standard desktop that is provided by the operating system displays. The default value is APP.
    public var streamView: AppStreamClientTypes.StreamView?
    /// The tags to associate with the fleet. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. If you do not specify a value, the value is set to an empty string. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ For more information, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var tags: [Swift.String:Swift.String]?
    /// The USB device filter strings that specify which USB devices a user can redirect to the fleet streaming session, when using the Windows native client. This is allowed but not required for Elastic fleets.
    public var usbDeviceFilterStrings: [Swift.String]?
    /// The VPC configuration for the fleet. This is required for Elastic fleets, but not required for other fleet types. Elastic fleets require that you specify at least two subnets in different availability zones.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init(
        computeCapacity: AppStreamClientTypes.ComputeCapacity? = nil,
        description: Swift.String? = nil,
        disconnectTimeoutInSeconds: Swift.Int? = nil,
        displayName: Swift.String? = nil,
        domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        fleetType: AppStreamClientTypes.FleetType? = nil,
        iamRoleArn: Swift.String? = nil,
        idleDisconnectTimeoutInSeconds: Swift.Int? = nil,
        imageArn: Swift.String? = nil,
        imageName: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        maxConcurrentSessions: Swift.Int? = nil,
        maxUserDurationInSeconds: Swift.Int? = nil,
        name: Swift.String? = nil,
        platform: AppStreamClientTypes.PlatformType? = nil,
        sessionScriptS3Location: AppStreamClientTypes.S3Location? = nil,
        streamView: AppStreamClientTypes.StreamView? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        usbDeviceFilterStrings: [Swift.String]? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.computeCapacity = computeCapacity
        self.description = description
        self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.fleetType = fleetType
        self.iamRoleArn = iamRoleArn
        self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.maxConcurrentSessions = maxConcurrentSessions
        self.maxUserDurationInSeconds = maxUserDurationInSeconds
        self.name = name
        self.platform = platform
        self.sessionScriptS3Location = sessionScriptS3Location
        self.streamView = streamView
        self.tags = tags
        self.usbDeviceFilterStrings = usbDeviceFilterStrings
        self.vpcConfig = vpcConfig
    }
}

struct CreateFleetInputBody: Swift.Equatable {
    let name: Swift.String?
    let imageName: Swift.String?
    let imageArn: Swift.String?
    let instanceType: Swift.String?
    let fleetType: AppStreamClientTypes.FleetType?
    let computeCapacity: AppStreamClientTypes.ComputeCapacity?
    let vpcConfig: AppStreamClientTypes.VpcConfig?
    let maxUserDurationInSeconds: Swift.Int?
    let disconnectTimeoutInSeconds: Swift.Int?
    let description: Swift.String?
    let displayName: Swift.String?
    let enableDefaultInternetAccess: Swift.Bool?
    let domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    let tags: [Swift.String:Swift.String]?
    let idleDisconnectTimeoutInSeconds: Swift.Int?
    let iamRoleArn: Swift.String?
    let streamView: AppStreamClientTypes.StreamView?
    let platform: AppStreamClientTypes.PlatformType?
    let maxConcurrentSessions: Swift.Int?
    let usbDeviceFilterStrings: [Swift.String]?
    let sessionScriptS3Location: AppStreamClientTypes.S3Location?
}

extension CreateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeCapacity = "ComputeCapacity"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case fleetType = "FleetType"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxConcurrentSessions = "MaxConcurrentSessions"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case platform = "Platform"
        case sessionScriptS3Location = "SessionScriptS3Location"
        case streamView = "StreamView"
        case tags = "Tags"
        case usbDeviceFilterStrings = "UsbDeviceFilterStrings"
        case vpcConfig = "VpcConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let fleetTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.FleetType.self, forKey: .fleetType)
        fleetType = fleetTypeDecoded
        let computeCapacityDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ComputeCapacity.self, forKey: .computeCapacity)
        computeCapacity = computeCapacityDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let maxUserDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxUserDurationInSeconds)
        maxUserDurationInSeconds = maxUserDurationInSecondsDecoded
        let disconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInSeconds)
        disconnectTimeoutInSeconds = disconnectTimeoutInSecondsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let idleDisconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInSeconds)
        idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSecondsDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let streamViewDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StreamView.self, forKey: .streamView)
        streamView = streamViewDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let maxConcurrentSessionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConcurrentSessions)
        maxConcurrentSessions = maxConcurrentSessionsDecoded
        let usbDeviceFilterStringsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usbDeviceFilterStrings)
        var usbDeviceFilterStringsDecoded0:[Swift.String]? = nil
        if let usbDeviceFilterStringsContainer = usbDeviceFilterStringsContainer {
            usbDeviceFilterStringsDecoded0 = [Swift.String]()
            for string0 in usbDeviceFilterStringsContainer {
                if let string0 = string0 {
                    usbDeviceFilterStringsDecoded0?.append(string0)
                }
            }
        }
        usbDeviceFilterStrings = usbDeviceFilterStringsDecoded0
        let sessionScriptS3LocationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.S3Location.self, forKey: .sessionScriptS3Location)
        sessionScriptS3Location = sessionScriptS3LocationDecoded
    }
}

extension CreateFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.fleet = output.fleet
        } else {
            self.fleet = nil
        }
    }
}

public struct CreateFleetOutput: Swift.Equatable {
    /// Information about the fleet.
    public var fleet: AppStreamClientTypes.Fleet?

    public init(
        fleet: AppStreamClientTypes.Fleet? = nil
    )
    {
        self.fleet = fleet
    }
}

struct CreateFleetOutputBody: Swift.Equatable {
    let fleet: AppStreamClientTypes.Fleet?
}

extension CreateFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet = "Fleet"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Fleet.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

enum CreateFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncompatibleImageException": return try await IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRoleException": return try await InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestLimitExceededException": return try await RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotAvailableException": return try await ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateImageBuilderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case description = "Description"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case name = "Name"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpoint0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpoint0)
            }
        }
        if let appstreamAgentVersion = self.appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = self.domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = self.enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let imageArn = self.imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = self.imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension CreateImageBuilderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateImageBuilderInput: Swift.Equatable {
    /// The list of interface VPC endpoint (interface endpoint) objects. Administrators can connect to the image builder only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The version of the AppStream 2.0 agent to use for this image builder. To use the latest version of the AppStream 2.0 agent, specify [LATEST].
    public var appstreamAgentVersion: Swift.String?
    /// The description to display.
    public var description: Swift.String?
    /// The image builder name to display.
    public var displayName: Swift.String?
    /// The name of the directory and organizational unit (OU) to use to join the image builder to a Microsoft Active Directory domain.
    public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    /// Enables or disables default internet access for the image builder.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the image builder. To assume a role, the image builder calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The ARN of the public, private, or shared image to use.
    public var imageArn: Swift.String?
    /// The name of the image used to create the image builder.
    public var imageName: Swift.String?
    /// The instance type to use when launching the image builder. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.compute.large
    ///
    /// * stream.compute.xlarge
    ///
    /// * stream.compute.2xlarge
    ///
    /// * stream.compute.4xlarge
    ///
    /// * stream.compute.8xlarge
    ///
    /// * stream.memory.large
    ///
    /// * stream.memory.xlarge
    ///
    /// * stream.memory.2xlarge
    ///
    /// * stream.memory.4xlarge
    ///
    /// * stream.memory.8xlarge
    ///
    /// * stream.memory.z1d.large
    ///
    /// * stream.memory.z1d.xlarge
    ///
    /// * stream.memory.z1d.2xlarge
    ///
    /// * stream.memory.z1d.3xlarge
    ///
    /// * stream.memory.z1d.6xlarge
    ///
    /// * stream.memory.z1d.12xlarge
    ///
    /// * stream.graphics-design.large
    ///
    /// * stream.graphics-design.xlarge
    ///
    /// * stream.graphics-design.2xlarge
    ///
    /// * stream.graphics-design.4xlarge
    ///
    /// * stream.graphics-desktop.2xlarge
    ///
    /// * stream.graphics.g4dn.xlarge
    ///
    /// * stream.graphics.g4dn.2xlarge
    ///
    /// * stream.graphics.g4dn.4xlarge
    ///
    /// * stream.graphics.g4dn.8xlarge
    ///
    /// * stream.graphics.g4dn.12xlarge
    ///
    /// * stream.graphics.g4dn.16xlarge
    ///
    /// * stream.graphics-pro.4xlarge
    ///
    /// * stream.graphics-pro.8xlarge
    ///
    /// * stream.graphics-pro.16xlarge
    /// This member is required.
    public var instanceType: Swift.String?
    /// A unique name for the image builder.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to associate with the image builder. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ If you do not specify a value, the value is set to an empty string. For more information about tags, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var tags: [Swift.String:Swift.String]?
    /// The VPC configuration for the image builder. You can specify only one subnet.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init(
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        appstreamAgentVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        iamRoleArn: Swift.String? = nil,
        imageArn: Swift.String? = nil,
        imageName: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.appstreamAgentVersion = appstreamAgentVersion
        self.description = description
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.iamRoleArn = iamRoleArn
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.name = name
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateImageBuilderInputBody: Swift.Equatable {
    let name: Swift.String?
    let imageName: Swift.String?
    let imageArn: Swift.String?
    let instanceType: Swift.String?
    let description: Swift.String?
    let displayName: Swift.String?
    let vpcConfig: AppStreamClientTypes.VpcConfig?
    let iamRoleArn: Swift.String?
    let enableDefaultInternetAccess: Swift.Bool?
    let domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    let appstreamAgentVersion: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
}

extension CreateImageBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case description = "Description"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case name = "Name"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
    }
}

extension CreateImageBuilderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateImageBuilderOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct CreateImageBuilderOutput: Swift.Equatable {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init(
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct CreateImageBuilderOutputBody: Swift.Equatable {
    let imageBuilder: AppStreamClientTypes.ImageBuilder?
}

extension CreateImageBuilderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

enum CreateImageBuilderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncompatibleImageException": return try await IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRoleException": return try await InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestLimitExceededException": return try await RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotAvailableException": return try await ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateImageBuilderStreamingURLInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case validity = "Validity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let validity = self.validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }
}

extension CreateImageBuilderStreamingURLInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateImageBuilderStreamingURLInput: Swift.Equatable {
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?
    /// The time that the streaming URL will be valid, in seconds. Specify a value between 1 and 604800 seconds. The default is 3600 seconds.
    public var validity: Swift.Int?

    public init(
        name: Swift.String? = nil,
        validity: Swift.Int? = nil
    )
    {
        self.name = name
        self.validity = validity
    }
}

struct CreateImageBuilderStreamingURLInputBody: Swift.Equatable {
    let name: Swift.String?
    let validity: Swift.Int?
}

extension CreateImageBuilderStreamingURLInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case validity = "Validity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let validityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validity)
        validity = validityDecoded
    }
}

extension CreateImageBuilderStreamingURLOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateImageBuilderStreamingURLOutputBody = try responseDecoder.decode(responseBody: data)
            self.expires = output.expires
            self.streamingURL = output.streamingURL
        } else {
            self.expires = nil
            self.streamingURL = nil
        }
    }
}

public struct CreateImageBuilderStreamingURLOutput: Swift.Equatable {
    /// The elapsed time, in seconds after the Unix epoch, when this URL expires.
    public var expires: ClientRuntime.Date?
    /// The URL to start the AppStream 2.0 streaming session.
    public var streamingURL: Swift.String?

    public init(
        expires: ClientRuntime.Date? = nil,
        streamingURL: Swift.String? = nil
    )
    {
        self.expires = expires
        self.streamingURL = streamingURL
    }
}

struct CreateImageBuilderStreamingURLOutputBody: Swift.Equatable {
    let streamingURL: Swift.String?
    let expires: ClientRuntime.Date?
}

extension CreateImageBuilderStreamingURLOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expires = "Expires"
        case streamingURL = "StreamingURL"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingURL)
        streamingURL = streamingURLDecoded
        let expiresDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expires)
        expires = expiresDecoded
    }
}

enum CreateImageBuilderStreamingURLOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case streamingExperienceSettings = "StreamingExperienceSettings"
        case tags = "Tags"
        case userSettings = "UserSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpoint0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpoint0)
            }
        }
        if let applicationSettings = self.applicationSettings {
            try encodeContainer.encode(applicationSettings, forKey: .applicationSettings)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let embedHostDomains = embedHostDomains {
            var embedHostDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .embedHostDomains)
            for embedhostdomain0 in embedHostDomains {
                try embedHostDomainsContainer.encode(embedhostdomain0)
            }
        }
        if let feedbackURL = self.feedbackURL {
            try encodeContainer.encode(feedbackURL, forKey: .feedbackURL)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let redirectURL = self.redirectURL {
            try encodeContainer.encode(redirectURL, forKey: .redirectURL)
        }
        if let storageConnectors = storageConnectors {
            var storageConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storageConnectors)
            for storageconnector0 in storageConnectors {
                try storageConnectorsContainer.encode(storageconnector0)
            }
        }
        if let streamingExperienceSettings = self.streamingExperienceSettings {
            try encodeContainer.encode(streamingExperienceSettings, forKey: .streamingExperienceSettings)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userSettings = userSettings {
            var userSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userSettings)
            for usersetting0 in userSettings {
                try userSettingsContainer.encode(usersetting0)
            }
        }
    }
}

extension CreateStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateStackInput: Swift.Equatable {
    /// The list of interface VPC endpoint (interface endpoint) objects. Users of the stack can connect to AppStream 2.0 only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The persistent application settings for users of a stack. When these settings are enabled, changes that users make to applications and Windows settings are automatically saved after each session and applied to the next session.
    public var applicationSettings: AppStreamClientTypes.ApplicationSettings?
    /// The description to display.
    public var description: Swift.String?
    /// The stack name to display.
    public var displayName: Swift.String?
    /// The domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions.
    public var embedHostDomains: [Swift.String]?
    /// The URL that users are redirected to after they click the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.
    public var feedbackURL: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var name: Swift.String?
    /// The URL that users are redirected to after their streaming session ends.
    public var redirectURL: Swift.String?
    /// The storage connectors to enable.
    public var storageConnectors: [AppStreamClientTypes.StorageConnector]?
    /// The streaming protocol you want your stack to prefer. This can be UDP or TCP. Currently, UDP is only supported in the Windows native client.
    public var streamingExperienceSettings: AppStreamClientTypes.StreamingExperienceSettings?
    /// The tags to associate with the stack. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. If you do not specify a value, the value is set to an empty string. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ For more information about tags, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var tags: [Swift.String:Swift.String]?
    /// The actions that are enabled or disabled for users during their streaming sessions. By default, these actions are enabled.
    public var userSettings: [AppStreamClientTypes.UserSetting]?

    public init(
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        applicationSettings: AppStreamClientTypes.ApplicationSettings? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        embedHostDomains: [Swift.String]? = nil,
        feedbackURL: Swift.String? = nil,
        name: Swift.String? = nil,
        redirectURL: Swift.String? = nil,
        storageConnectors: [AppStreamClientTypes.StorageConnector]? = nil,
        streamingExperienceSettings: AppStreamClientTypes.StreamingExperienceSettings? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userSettings: [AppStreamClientTypes.UserSetting]? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.applicationSettings = applicationSettings
        self.description = description
        self.displayName = displayName
        self.embedHostDomains = embedHostDomains
        self.feedbackURL = feedbackURL
        self.name = name
        self.redirectURL = redirectURL
        self.storageConnectors = storageConnectors
        self.streamingExperienceSettings = streamingExperienceSettings
        self.tags = tags
        self.userSettings = userSettings
    }
}

struct CreateStackInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let displayName: Swift.String?
    let storageConnectors: [AppStreamClientTypes.StorageConnector]?
    let redirectURL: Swift.String?
    let feedbackURL: Swift.String?
    let userSettings: [AppStreamClientTypes.UserSetting]?
    let applicationSettings: AppStreamClientTypes.ApplicationSettings?
    let tags: [Swift.String:Swift.String]?
    let accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    let embedHostDomains: [Swift.String]?
    let streamingExperienceSettings: AppStreamClientTypes.StreamingExperienceSettings?
}

extension CreateStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case streamingExperienceSettings = "StreamingExperienceSettings"
        case tags = "Tags"
        case userSettings = "UserSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let storageConnectorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.StorageConnector?].self, forKey: .storageConnectors)
        var storageConnectorsDecoded0:[AppStreamClientTypes.StorageConnector]? = nil
        if let storageConnectorsContainer = storageConnectorsContainer {
            storageConnectorsDecoded0 = [AppStreamClientTypes.StorageConnector]()
            for structure0 in storageConnectorsContainer {
                if let structure0 = structure0 {
                    storageConnectorsDecoded0?.append(structure0)
                }
            }
        }
        storageConnectors = storageConnectorsDecoded0
        let redirectURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectURL)
        redirectURL = redirectURLDecoded
        let feedbackURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feedbackURL)
        feedbackURL = feedbackURLDecoded
        let userSettingsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserSetting?].self, forKey: .userSettings)
        var userSettingsDecoded0:[AppStreamClientTypes.UserSetting]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [AppStreamClientTypes.UserSetting]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let applicationSettingsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ApplicationSettings.self, forKey: .applicationSettings)
        applicationSettings = applicationSettingsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
        let embedHostDomainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .embedHostDomains)
        var embedHostDomainsDecoded0:[Swift.String]? = nil
        if let embedHostDomainsContainer = embedHostDomainsContainer {
            embedHostDomainsDecoded0 = [Swift.String]()
            for string0 in embedHostDomainsContainer {
                if let string0 = string0 {
                    embedHostDomainsDecoded0?.append(string0)
                }
            }
        }
        embedHostDomains = embedHostDomainsDecoded0
        let streamingExperienceSettingsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StreamingExperienceSettings.self, forKey: .streamingExperienceSettings)
        streamingExperienceSettings = streamingExperienceSettingsDecoded
    }
}

extension CreateStackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStackOutputBody = try responseDecoder.decode(responseBody: data)
            self.stack = output.stack
        } else {
            self.stack = nil
        }
    }
}

public struct CreateStackOutput: Swift.Equatable {
    /// Information about the stack.
    public var stack: AppStreamClientTypes.Stack?

    public init(
        stack: AppStreamClientTypes.Stack? = nil
    )
    {
        self.stack = stack
    }
}

struct CreateStackOutputBody: Swift.Equatable {
    let stack: AppStreamClientTypes.Stack?
}

extension CreateStackOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stack = "Stack"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Stack.self, forKey: .stack)
        stack = stackDecoded
    }
}

enum CreateStackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRoleException": return try await InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStreamingURLInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case fleetName = "FleetName"
        case sessionContext = "SessionContext"
        case stackName = "StackName"
        case userId = "UserId"
        case validity = "Validity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let fleetName = self.fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let sessionContext = self.sessionContext {
            try encodeContainer.encode(sessionContext, forKey: .sessionContext)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let validity = self.validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }
}

extension CreateStreamingURLInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateStreamingURLInput: Swift.Equatable {
    /// The name of the application to launch after the session starts. This is the name that you specified as Name in the Image Assistant. If your fleet is enabled for the Desktop stream view, you can also choose to launch directly to the operating system desktop. To do so, specify Desktop.
    public var applicationId: Swift.String?
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The session context. For more information, see [Session Context](https://docs.aws.amazon.com/appstream2/latest/developerguide/managing-stacks-fleets.html#managing-stacks-fleets-parameters) in the Amazon AppStream 2.0 Administration Guide.
    public var sessionContext: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?
    /// The identifier of the user.
    /// This member is required.
    public var userId: Swift.String?
    /// The time that the streaming URL will be valid, in seconds. Specify a value between 1 and 604800 seconds. The default is 60 seconds.
    public var validity: Swift.Int?

    public init(
        applicationId: Swift.String? = nil,
        fleetName: Swift.String? = nil,
        sessionContext: Swift.String? = nil,
        stackName: Swift.String? = nil,
        userId: Swift.String? = nil,
        validity: Swift.Int? = nil
    )
    {
        self.applicationId = applicationId
        self.fleetName = fleetName
        self.sessionContext = sessionContext
        self.stackName = stackName
        self.userId = userId
        self.validity = validity
    }
}

struct CreateStreamingURLInputBody: Swift.Equatable {
    let stackName: Swift.String?
    let fleetName: Swift.String?
    let userId: Swift.String?
    let applicationId: Swift.String?
    let validity: Swift.Int?
    let sessionContext: Swift.String?
}

extension CreateStreamingURLInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case fleetName = "FleetName"
        case sessionContext = "SessionContext"
        case stackName = "StackName"
        case userId = "UserId"
        case validity = "Validity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let validityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validity)
        validity = validityDecoded
        let sessionContextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionContext)
        sessionContext = sessionContextDecoded
    }
}

extension CreateStreamingURLOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStreamingURLOutputBody = try responseDecoder.decode(responseBody: data)
            self.expires = output.expires
            self.streamingURL = output.streamingURL
        } else {
            self.expires = nil
            self.streamingURL = nil
        }
    }
}

public struct CreateStreamingURLOutput: Swift.Equatable {
    /// The elapsed time, in seconds after the Unix epoch, when this URL expires.
    public var expires: ClientRuntime.Date?
    /// The URL to start the AppStream 2.0 streaming session.
    public var streamingURL: Swift.String?

    public init(
        expires: ClientRuntime.Date? = nil,
        streamingURL: Swift.String? = nil
    )
    {
        self.expires = expires
        self.streamingURL = streamingURL
    }
}

struct CreateStreamingURLOutputBody: Swift.Equatable {
    let streamingURL: Swift.String?
    let expires: ClientRuntime.Date?
}

extension CreateStreamingURLOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expires = "Expires"
        case streamingURL = "StreamingURL"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingURL)
        streamingURL = streamingURLDecoded
        let expiresDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expires)
        expires = expiresDecoded
    }
}

enum CreateStreamingURLOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotAvailableException": return try await ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUpdatedImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun
        case existingImageName
        case newImageDescription
        case newImageDisplayName
        case newImageName
        case newImageTags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let existingImageName = self.existingImageName {
            try encodeContainer.encode(existingImageName, forKey: .existingImageName)
        }
        if let newImageDescription = self.newImageDescription {
            try encodeContainer.encode(newImageDescription, forKey: .newImageDescription)
        }
        if let newImageDisplayName = self.newImageDisplayName {
            try encodeContainer.encode(newImageDisplayName, forKey: .newImageDisplayName)
        }
        if let newImageName = self.newImageName {
            try encodeContainer.encode(newImageName, forKey: .newImageName)
        }
        if let newImageTags = newImageTags {
            var newImageTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .newImageTags)
            for (dictKey0, tags0) in newImageTags {
                try newImageTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateUpdatedImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUpdatedImageInput: Swift.Equatable {
    /// Indicates whether to display the status of image update availability before AppStream 2.0 initiates the process of creating a new updated image. If this value is set to true, AppStream 2.0 displays whether image updates are available. If this value is set to false, AppStream 2.0 initiates the process of creating a new updated image without displaying whether image updates are available.
    public var dryRun: Swift.Bool?
    /// The name of the image to update.
    /// This member is required.
    public var existingImageName: Swift.String?
    /// The description to display for the new image.
    public var newImageDescription: Swift.String?
    /// The name to display for the new image.
    public var newImageDisplayName: Swift.String?
    /// The name of the new image. The name must be unique within the AWS account and Region.
    /// This member is required.
    public var newImageName: Swift.String?
    /// The tags to associate with the new image. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ If you do not specify a value, the value is set to an empty string. For more information about tags, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var newImageTags: [Swift.String:Swift.String]?

    public init(
        dryRun: Swift.Bool? = nil,
        existingImageName: Swift.String? = nil,
        newImageDescription: Swift.String? = nil,
        newImageDisplayName: Swift.String? = nil,
        newImageName: Swift.String? = nil,
        newImageTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dryRun = dryRun
        self.existingImageName = existingImageName
        self.newImageDescription = newImageDescription
        self.newImageDisplayName = newImageDisplayName
        self.newImageName = newImageName
        self.newImageTags = newImageTags
    }
}

struct CreateUpdatedImageInputBody: Swift.Equatable {
    let existingImageName: Swift.String?
    let newImageName: Swift.String?
    let newImageDescription: Swift.String?
    let newImageDisplayName: Swift.String?
    let newImageTags: [Swift.String:Swift.String]?
    let dryRun: Swift.Bool?
}

extension CreateUpdatedImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun
        case existingImageName
        case newImageDescription
        case newImageDisplayName
        case newImageName
        case newImageTags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let existingImageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .existingImageName)
        existingImageName = existingImageNameDecoded
        let newImageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newImageName)
        newImageName = newImageNameDecoded
        let newImageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newImageDescription)
        newImageDescription = newImageDescriptionDecoded
        let newImageDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newImageDisplayName)
        newImageDisplayName = newImageDisplayNameDecoded
        let newImageTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .newImageTags)
        var newImageTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let newImageTagsContainer = newImageTagsContainer {
            newImageTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in newImageTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    newImageTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        newImageTags = newImageTagsDecoded0
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension CreateUpdatedImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUpdatedImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.canUpdateImage = output.canUpdateImage
            self.image = output.image
        } else {
            self.canUpdateImage = false
            self.image = nil
        }
    }
}

public struct CreateUpdatedImageOutput: Swift.Equatable {
    /// Indicates whether a new image can be created.
    public var canUpdateImage: Swift.Bool
    /// Describes an image.
    public var image: AppStreamClientTypes.Image?

    public init(
        canUpdateImage: Swift.Bool = false,
        image: AppStreamClientTypes.Image? = nil
    )
    {
        self.canUpdateImage = canUpdateImage
        self.image = image
    }
}

struct CreateUpdatedImageOutputBody: Swift.Equatable {
    let image: AppStreamClientTypes.Image?
    let canUpdateImage: Swift.Bool
}

extension CreateUpdatedImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canUpdateImage
        case image
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Image.self, forKey: .image)
        image = imageDecoded
        let canUpdateImageDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canUpdateImage) ?? false
        canUpdateImage = canUpdateImageDecoded
    }
}

enum CreateUpdatedImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncompatibleImageException": return try await IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUsageReportSubscriptionInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension CreateUsageReportSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUsageReportSubscriptionInput: Swift.Equatable {

    public init() { }
}

struct CreateUsageReportSubscriptionInputBody: Swift.Equatable {
}

extension CreateUsageReportSubscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CreateUsageReportSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUsageReportSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.s3BucketName = output.s3BucketName
            self.schedule = output.schedule
        } else {
            self.s3BucketName = nil
            self.schedule = nil
        }
    }
}

public struct CreateUsageReportSubscriptionOutput: Swift.Equatable {
    /// The Amazon S3 bucket where generated reports are stored. If you enabled on-instance session scripts and Amazon S3 logging for your session script configuration, AppStream 2.0 created an S3 bucket to store the script output. The bucket is unique to your account and Region. When you enable usage reporting in this case, AppStream 2.0 uses the same bucket to store your usage reports. If you haven't already enabled on-instance session scripts, when you enable usage reports, AppStream 2.0 creates a new S3 bucket.
    public var s3BucketName: Swift.String?
    /// The schedule for generating usage reports.
    public var schedule: AppStreamClientTypes.UsageReportSchedule?

    public init(
        s3BucketName: Swift.String? = nil,
        schedule: AppStreamClientTypes.UsageReportSchedule? = nil
    )
    {
        self.s3BucketName = s3BucketName
        self.schedule = schedule
    }
}

struct CreateUsageReportSubscriptionOutputBody: Swift.Equatable {
    let s3BucketName: Swift.String?
    let schedule: AppStreamClientTypes.UsageReportSchedule?
}

extension CreateUsageReportSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName = "S3BucketName"
        case schedule = "Schedule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.UsageReportSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
    }
}

enum CreateUsageReportSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRoleException": return try await InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(authenticationType: \(Swift.String(describing: authenticationType)), messageAction: \(Swift.String(describing: messageAction)), firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", userName: \"CONTENT_REDACTED\")"}
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case firstName = "FirstName"
        case lastName = "LastName"
        case messageAction = "MessageAction"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let messageAction = self.messageAction {
            try encodeContainer.encode(messageAction.rawValue, forKey: .messageAction)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The first name, or given name, of the user.
    public var firstName: Swift.String?
    /// The last name, or surname, of the user.
    public var lastName: Swift.String?
    /// The action to take for the welcome email that is sent to a user after the user is created in the user pool. If you specify SUPPRESS, no email is sent. If you specify RESEND, do not specify the first name or last name of the user. If the value is null, the email is sent. The temporary password in the welcome email is valid for only 7 days. If users donâ€™t set their passwords within 7 days, you must send them a new welcome email.
    public var messageAction: AppStreamClientTypes.MessageAction?
    /// The email address of the user. Users' email addresses are case-sensitive. During login, if they specify an email address that doesn't use the same capitalization as the email address specified when their user pool account was created, a "user does not exist" error message displays.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        messageAction: AppStreamClientTypes.MessageAction? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.firstName = firstName
        self.lastName = lastName
        self.messageAction = messageAction
        self.userName = userName
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let messageAction: AppStreamClientTypes.MessageAction?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let authenticationType: AppStreamClientTypes.AuthenticationType?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case firstName = "FirstName"
        case lastName = "LastName"
        case messageAction = "MessageAction"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let messageActionDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.MessageAction.self, forKey: .messageAction)
        messageAction = messageActionDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension CreateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateUserOutput: Swift.Equatable {

    public init() { }
}

enum CreateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppBlockBuilderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteAppBlockBuilderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAppBlockBuilderInput: Swift.Equatable {
    /// The name of the app block builder.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteAppBlockBuilderInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteAppBlockBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteAppBlockBuilderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppBlockBuilderOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppBlockBuilderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppBlockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteAppBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAppBlockInput: Swift.Equatable {
    /// The name of the app block.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteAppBlockInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteAppBlockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteAppBlockOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppBlockOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppBlockOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The name of the application.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDirectoryConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = self.directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
    }
}

extension DeleteDirectoryConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDirectoryConfigInput: Swift.Equatable {
    /// The name of the directory configuration.
    /// This member is required.
    public var directoryName: Swift.String?

    public init(
        directoryName: Swift.String? = nil
    )
    {
        self.directoryName = directoryName
    }
}

struct DeleteDirectoryConfigInputBody: Swift.Equatable {
    let directoryName: Swift.String?
}

extension DeleteDirectoryConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
    }
}

extension DeleteDirectoryConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDirectoryConfigOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDirectoryConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEntitlementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

extension DeleteEntitlementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEntitlementInput: Swift.Equatable {
    /// The name of the entitlement.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the stack with which the entitlement is associated.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        name: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.name = name
        self.stackName = stackName
    }
}

struct DeleteEntitlementInputBody: Swift.Equatable {
    let name: Swift.String?
    let stackName: Swift.String?
}

extension DeleteEntitlementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case stackName = "StackName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
    }
}

extension DeleteEntitlementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEntitlementOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEntitlementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntitlementNotFoundException": return try await EntitlementNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteFleetInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFleetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteImageBuilderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteImageBuilderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteImageBuilderInput: Swift.Equatable {
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteImageBuilderInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteImageBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteImageBuilderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteImageBuilderOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct DeleteImageBuilderOutput: Swift.Equatable {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init(
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct DeleteImageBuilderOutputBody: Swift.Equatable {
    let imageBuilder: AppStreamClientTypes.ImageBuilder?
}

extension DeleteImageBuilderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

enum DeleteImageBuilderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteImageInput: Swift.Equatable {
    /// The name of the image.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteImageInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.image = output.image
        } else {
            self.image = nil
        }
    }
}

public struct DeleteImageOutput: Swift.Equatable {
    /// Information about the image.
    public var image: AppStreamClientTypes.Image?

    public init(
        image: AppStreamClientTypes.Image? = nil
    )
    {
        self.image = image
    }
}

struct DeleteImageOutputBody: Swift.Equatable {
    let image: AppStreamClientTypes.Image?
}

extension DeleteImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case image = "Image"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Image.self, forKey: .image)
        image = imageDecoded
    }
}

enum DeleteImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteImagePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sharedAccountId = self.sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }
}

extension DeleteImagePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteImagePermissionsInput: Swift.Equatable {
    /// The name of the private image.
    /// This member is required.
    public var name: Swift.String?
    /// The 12-digit identifier of the AWS account for which to delete image permissions.
    /// This member is required.
    public var sharedAccountId: Swift.String?

    public init(
        name: Swift.String? = nil,
        sharedAccountId: Swift.String? = nil
    )
    {
        self.name = name
        self.sharedAccountId = sharedAccountId
    }
}

struct DeleteImagePermissionsInputBody: Swift.Equatable {
    let name: Swift.String?
    let sharedAccountId: Swift.String?
}

extension DeleteImagePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
    }
}

extension DeleteImagePermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteImagePermissionsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteImagePermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotAvailableException": return try await ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteStackInput: Swift.Equatable {
    /// The name of the stack.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteStackInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteStackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStackOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUsageReportSubscriptionInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteUsageReportSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUsageReportSubscriptionInput: Swift.Equatable {

    public init() { }
}

struct DeleteUsageReportSubscriptionInputBody: Swift.Equatable {
}

extension DeleteUsageReportSubscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUsageReportSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUsageReportSubscriptionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUsageReportSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserInput(authenticationType: \(Swift.String(describing: authenticationType)), userName: \"CONTENT_REDACTED\")"}
}

extension DeleteUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The email address of the user. Users' email addresses are case-sensitive.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.userName = userName
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let authenticationType: AppStreamClientTypes.AuthenticationType?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension DeleteUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppBlockBuilderAppBlockAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case appBlockBuilderName = "AppBlockBuilderName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBlockArn = self.appBlockArn {
            try encodeContainer.encode(appBlockArn, forKey: .appBlockArn)
        }
        if let appBlockBuilderName = self.appBlockBuilderName {
            try encodeContainer.encode(appBlockBuilderName, forKey: .appBlockBuilderName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAppBlockBuilderAppBlockAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAppBlockBuilderAppBlockAssociationsInput: Swift.Equatable {
    /// The ARN of the app block.
    public var appBlockArn: Swift.String?
    /// The name of the app block builder.
    public var appBlockBuilderName: Swift.String?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        appBlockArn: Swift.String? = nil,
        appBlockBuilderName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBlockArn = appBlockArn
        self.appBlockBuilderName = appBlockBuilderName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAppBlockBuilderAppBlockAssociationsInputBody: Swift.Equatable {
    let appBlockArn: Swift.String?
    let appBlockBuilderName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeAppBlockBuilderAppBlockAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case appBlockBuilderName = "AppBlockBuilderName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlockArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBlockArn)
        appBlockArn = appBlockArnDecoded
        let appBlockBuilderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBlockBuilderName)
        appBlockBuilderName = appBlockBuilderNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAppBlockBuilderAppBlockAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppBlockBuilderAppBlockAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appBlockBuilderAppBlockAssociations = output.appBlockBuilderAppBlockAssociations
            self.nextToken = output.nextToken
        } else {
            self.appBlockBuilderAppBlockAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAppBlockBuilderAppBlockAssociationsOutput: Swift.Equatable {
    /// This list of app block builders associated with app blocks.
    public var appBlockBuilderAppBlockAssociations: [AppStreamClientTypes.AppBlockBuilderAppBlockAssociation]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        appBlockBuilderAppBlockAssociations: [AppStreamClientTypes.AppBlockBuilderAppBlockAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBlockBuilderAppBlockAssociations = appBlockBuilderAppBlockAssociations
        self.nextToken = nextToken
    }
}

struct DescribeAppBlockBuilderAppBlockAssociationsOutputBody: Swift.Equatable {
    let appBlockBuilderAppBlockAssociations: [AppStreamClientTypes.AppBlockBuilderAppBlockAssociation]?
    let nextToken: Swift.String?
}

extension DescribeAppBlockBuilderAppBlockAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockBuilderAppBlockAssociations = "AppBlockBuilderAppBlockAssociations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlockBuilderAppBlockAssociationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AppBlockBuilderAppBlockAssociation?].self, forKey: .appBlockBuilderAppBlockAssociations)
        var appBlockBuilderAppBlockAssociationsDecoded0:[AppStreamClientTypes.AppBlockBuilderAppBlockAssociation]? = nil
        if let appBlockBuilderAppBlockAssociationsContainer = appBlockBuilderAppBlockAssociationsContainer {
            appBlockBuilderAppBlockAssociationsDecoded0 = [AppStreamClientTypes.AppBlockBuilderAppBlockAssociation]()
            for structure0 in appBlockBuilderAppBlockAssociationsContainer {
                if let structure0 = structure0 {
                    appBlockBuilderAppBlockAssociationsDecoded0?.append(structure0)
                }
            }
        }
        appBlockBuilderAppBlockAssociations = appBlockBuilderAppBlockAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAppBlockBuilderAppBlockAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppBlockBuildersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for string0 in names {
                try namesContainer.encode(string0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAppBlockBuildersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAppBlockBuildersInput: Swift.Equatable {
    /// The maximum size of each page of results. The maximum value is 25.
    public var maxResults: Swift.Int?
    /// The names of the app block builders.
    public var names: [Swift.String]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
    }
}

struct DescribeAppBlockBuildersInputBody: Swift.Equatable {
    let names: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeAppBlockBuildersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAppBlockBuildersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppBlockBuildersOutputBody = try responseDecoder.decode(responseBody: data)
            self.appBlockBuilders = output.appBlockBuilders
            self.nextToken = output.nextToken
        } else {
            self.appBlockBuilders = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAppBlockBuildersOutput: Swift.Equatable {
    /// The list that describes one or more app block builders.
    public var appBlockBuilders: [AppStreamClientTypes.AppBlockBuilder]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        appBlockBuilders: [AppStreamClientTypes.AppBlockBuilder]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBlockBuilders = appBlockBuilders
        self.nextToken = nextToken
    }
}

struct DescribeAppBlockBuildersOutputBody: Swift.Equatable {
    let appBlockBuilders: [AppStreamClientTypes.AppBlockBuilder]?
    let nextToken: Swift.String?
}

extension DescribeAppBlockBuildersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockBuilders = "AppBlockBuilders"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlockBuildersContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AppBlockBuilder?].self, forKey: .appBlockBuilders)
        var appBlockBuildersDecoded0:[AppStreamClientTypes.AppBlockBuilder]? = nil
        if let appBlockBuildersContainer = appBlockBuildersContainer {
            appBlockBuildersDecoded0 = [AppStreamClientTypes.AppBlockBuilder]()
            for structure0 in appBlockBuildersContainer {
                if let structure0 = structure0 {
                    appBlockBuildersDecoded0?.append(structure0)
                }
            }
        }
        appBlockBuilders = appBlockBuildersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAppBlockBuildersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppBlocksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for arn0 in arns {
                try arnsContainer.encode(arn0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAppBlocksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAppBlocksInput: Swift.Equatable {
    /// The ARNs of the app blocks.
    public var arns: [Swift.String]?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        arns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arns = arns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAppBlocksInputBody: Swift.Equatable {
    let arns: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeAppBlocksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAppBlocksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppBlocksOutputBody = try responseDecoder.decode(responseBody: data)
            self.appBlocks = output.appBlocks
            self.nextToken = output.nextToken
        } else {
            self.appBlocks = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAppBlocksOutput: Swift.Equatable {
    /// The app blocks in the list.
    public var appBlocks: [AppStreamClientTypes.AppBlock]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        appBlocks: [AppStreamClientTypes.AppBlock]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBlocks = appBlocks
        self.nextToken = nextToken
    }
}

struct DescribeAppBlocksOutputBody: Swift.Equatable {
    let appBlocks: [AppStreamClientTypes.AppBlock]?
    let nextToken: Swift.String?
}

extension DescribeAppBlocksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlocks = "AppBlocks"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlocksContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AppBlock?].self, forKey: .appBlocks)
        var appBlocksDecoded0:[AppStreamClientTypes.AppBlock]? = nil
        if let appBlocksContainer = appBlocksContainer {
            appBlocksDecoded0 = [AppStreamClientTypes.AppBlock]()
            for structure0 in appBlocksContainer {
                if let structure0 = structure0 {
                    appBlocksDecoded0?.append(structure0)
                }
            }
        }
        appBlocks = appBlocksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAppBlocksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeApplicationFleetAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case fleetName = "FleetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let fleetName = self.fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeApplicationFleetAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationFleetAssociationsInput: Swift.Equatable {
    /// The ARN of the application.
    public var applicationArn: Swift.String?
    /// The name of the fleet.
    public var fleetName: Swift.String?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        fleetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.fleetName = fleetName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeApplicationFleetAssociationsInputBody: Swift.Equatable {
    let fleetName: Swift.String?
    let applicationArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeApplicationFleetAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case fleetName = "FleetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeApplicationFleetAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeApplicationFleetAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationFleetAssociations = output.applicationFleetAssociations
            self.nextToken = output.nextToken
        } else {
            self.applicationFleetAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeApplicationFleetAssociationsOutput: Swift.Equatable {
    /// The application fleet associations in the list.
    public var applicationFleetAssociations: [AppStreamClientTypes.ApplicationFleetAssociation]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        applicationFleetAssociations: [AppStreamClientTypes.ApplicationFleetAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationFleetAssociations = applicationFleetAssociations
        self.nextToken = nextToken
    }
}

struct DescribeApplicationFleetAssociationsOutputBody: Swift.Equatable {
    let applicationFleetAssociations: [AppStreamClientTypes.ApplicationFleetAssociation]?
    let nextToken: Swift.String?
}

extension DescribeApplicationFleetAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationFleetAssociations = "ApplicationFleetAssociations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationFleetAssociationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.ApplicationFleetAssociation?].self, forKey: .applicationFleetAssociations)
        var applicationFleetAssociationsDecoded0:[AppStreamClientTypes.ApplicationFleetAssociation]? = nil
        if let applicationFleetAssociationsContainer = applicationFleetAssociationsContainer {
            applicationFleetAssociationsDecoded0 = [AppStreamClientTypes.ApplicationFleetAssociation]()
            for structure0 in applicationFleetAssociationsContainer {
                if let structure0 = structure0 {
                    applicationFleetAssociationsDecoded0?.append(structure0)
                }
            }
        }
        applicationFleetAssociations = applicationFleetAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeApplicationFleetAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for arn0 in arns {
                try arnsContainer.encode(arn0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationsInput: Swift.Equatable {
    /// The ARNs for the applications.
    public var arns: [Swift.String]?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        arns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arns = arns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeApplicationsInputBody: Swift.Equatable {
    let arns: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeApplicationsOutput: Swift.Equatable {
    /// The applications in the list.
    public var applications: [AppStreamClientTypes.Application]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        applications: [AppStreamClientTypes.Application]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct DescribeApplicationsOutputBody: Swift.Equatable {
    let applications: [AppStreamClientTypes.Application]?
    let nextToken: Swift.String?
}

extension DescribeApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Application?].self, forKey: .applications)
        var applicationsDecoded0:[AppStreamClientTypes.Application]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [AppStreamClientTypes.Application]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDirectoryConfigsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryNames = "DirectoryNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryNames = directoryNames {
            var directoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .directoryNames)
            for directoryname0 in directoryNames {
                try directoryNamesContainer.encode(directoryname0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeDirectoryConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDirectoryConfigsInput: Swift.Equatable {
    /// The directory names.
    public var directoryNames: [Swift.String]?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        directoryNames: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryNames = directoryNames
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeDirectoryConfigsInputBody: Swift.Equatable {
    let directoryNames: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeDirectoryConfigsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryNames = "DirectoryNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .directoryNames)
        var directoryNamesDecoded0:[Swift.String]? = nil
        if let directoryNamesContainer = directoryNamesContainer {
            directoryNamesDecoded0 = [Swift.String]()
            for string0 in directoryNamesContainer {
                if let string0 = string0 {
                    directoryNamesDecoded0?.append(string0)
                }
            }
        }
        directoryNames = directoryNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDirectoryConfigsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDirectoryConfigsOutputBody = try responseDecoder.decode(responseBody: data)
            self.directoryConfigs = output.directoryConfigs
            self.nextToken = output.nextToken
        } else {
            self.directoryConfigs = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDirectoryConfigsOutput: Swift.Equatable {
    /// Information about the directory configurations. Note that although the response syntax in this topic includes the account password, this password is not returned in the actual response.
    public var directoryConfigs: [AppStreamClientTypes.DirectoryConfig]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        directoryConfigs: [AppStreamClientTypes.DirectoryConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryConfigs = directoryConfigs
        self.nextToken = nextToken
    }
}

struct DescribeDirectoryConfigsOutputBody: Swift.Equatable {
    let directoryConfigs: [AppStreamClientTypes.DirectoryConfig]?
    let nextToken: Swift.String?
}

extension DescribeDirectoryConfigsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryConfigs = "DirectoryConfigs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryConfigsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.DirectoryConfig?].self, forKey: .directoryConfigs)
        var directoryConfigsDecoded0:[AppStreamClientTypes.DirectoryConfig]? = nil
        if let directoryConfigsContainer = directoryConfigsContainer {
            directoryConfigsDecoded0 = [AppStreamClientTypes.DirectoryConfig]()
            for structure0 in directoryConfigsContainer {
                if let structure0 = structure0 {
                    directoryConfigsDecoded0?.append(structure0)
                }
            }
        }
        directoryConfigs = directoryConfigsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeDirectoryConfigsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEntitlementsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

extension DescribeEntitlementsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEntitlementsInput: Swift.Equatable {
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The name of the entitlement.
    public var name: Swift.String?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The name of the stack with which the entitlement is associated.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.stackName = stackName
    }
}

struct DescribeEntitlementsInputBody: Swift.Equatable {
    let name: Swift.String?
    let stackName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeEntitlementsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case stackName = "StackName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeEntitlementsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEntitlementsOutputBody = try responseDecoder.decode(responseBody: data)
            self.entitlements = output.entitlements
            self.nextToken = output.nextToken
        } else {
            self.entitlements = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEntitlementsOutput: Swift.Equatable {
    /// The entitlements.
    public var entitlements: [AppStreamClientTypes.Entitlement]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        entitlements: [AppStreamClientTypes.Entitlement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entitlements = entitlements
        self.nextToken = nextToken
    }
}

struct DescribeEntitlementsOutputBody: Swift.Equatable {
    let entitlements: [AppStreamClientTypes.Entitlement]?
    let nextToken: Swift.String?
}

extension DescribeEntitlementsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlements = "Entitlements"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[AppStreamClientTypes.Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [AppStreamClientTypes.Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeEntitlementsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntitlementNotFoundException": return try await EntitlementNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFleetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for string0 in names {
                try namesContainer.encode(string0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeFleetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFleetsInput: Swift.Equatable {
    /// The names of the fleets to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct DescribeFleetsInputBody: Swift.Equatable {
    let names: [Swift.String]?
    let nextToken: Swift.String?
}

extension DescribeFleetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFleetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.fleets = output.fleets
            self.nextToken = output.nextToken
        } else {
            self.fleets = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFleetsOutput: Swift.Equatable {
    /// Information about the fleets.
    public var fleets: [AppStreamClientTypes.Fleet]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        fleets: [AppStreamClientTypes.Fleet]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleets = fleets
        self.nextToken = nextToken
    }
}

struct DescribeFleetsOutputBody: Swift.Equatable {
    let fleets: [AppStreamClientTypes.Fleet]?
    let nextToken: Swift.String?
}

extension DescribeFleetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleets = "Fleets"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Fleet?].self, forKey: .fleets)
        var fleetsDecoded0:[AppStreamClientTypes.Fleet]? = nil
        if let fleetsContainer = fleetsContainer {
            fleetsDecoded0 = [AppStreamClientTypes.Fleet]()
            for structure0 in fleetsContainer {
                if let structure0 = structure0 {
                    fleetsDecoded0?.append(structure0)
                }
            }
        }
        fleets = fleetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeFleetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeImageBuildersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for string0 in names {
                try namesContainer.encode(string0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeImageBuildersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeImageBuildersInput: Swift.Equatable {
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The names of the image builders to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
    }
}

struct DescribeImageBuildersInputBody: Swift.Equatable {
    let names: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeImageBuildersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImageBuildersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeImageBuildersOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageBuilders = output.imageBuilders
            self.nextToken = output.nextToken
        } else {
            self.imageBuilders = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImageBuildersOutput: Swift.Equatable {
    /// Information about the image builders.
    public var imageBuilders: [AppStreamClientTypes.ImageBuilder]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        imageBuilders: [AppStreamClientTypes.ImageBuilder]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageBuilders = imageBuilders
        self.nextToken = nextToken
    }
}

struct DescribeImageBuildersOutputBody: Swift.Equatable {
    let imageBuilders: [AppStreamClientTypes.ImageBuilder]?
    let nextToken: Swift.String?
}

extension DescribeImageBuildersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuilders = "ImageBuilders"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuildersContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.ImageBuilder?].self, forKey: .imageBuilders)
        var imageBuildersDecoded0:[AppStreamClientTypes.ImageBuilder]? = nil
        if let imageBuildersContainer = imageBuildersContainer {
            imageBuildersDecoded0 = [AppStreamClientTypes.ImageBuilder]()
            for structure0 in imageBuildersContainer {
                if let structure0 = structure0 {
                    imageBuildersDecoded0?.append(structure0)
                }
            }
        }
        imageBuilders = imageBuildersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeImageBuildersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeImagePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case sharedAwsAccountIds = "SharedAwsAccountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sharedAwsAccountIds = sharedAwsAccountIds {
            var sharedAwsAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedAwsAccountIds)
            for awsaccountid0 in sharedAwsAccountIds {
                try sharedAwsAccountIdsContainer.encode(awsaccountid0)
            }
        }
    }
}

extension DescribeImagePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeImagePermissionsInput: Swift.Equatable {
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The name of the private image for which to describe permissions. The image must be one that you own.
    /// This member is required.
    public var name: Swift.String?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The 12-digit identifier of one or more AWS accounts with which the image is shared.
    public var sharedAwsAccountIds: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sharedAwsAccountIds: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.sharedAwsAccountIds = sharedAwsAccountIds
    }
}

struct DescribeImagePermissionsInputBody: Swift.Equatable {
    let name: Swift.String?
    let maxResults: Swift.Int?
    let sharedAwsAccountIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension DescribeImagePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case sharedAwsAccountIds = "SharedAwsAccountIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sharedAwsAccountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sharedAwsAccountIds)
        var sharedAwsAccountIdsDecoded0:[Swift.String]? = nil
        if let sharedAwsAccountIdsContainer = sharedAwsAccountIdsContainer {
            sharedAwsAccountIdsDecoded0 = [Swift.String]()
            for string0 in sharedAwsAccountIdsContainer {
                if let string0 = string0 {
                    sharedAwsAccountIdsDecoded0?.append(string0)
                }
            }
        }
        sharedAwsAccountIds = sharedAwsAccountIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImagePermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeImagePermissionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
            self.nextToken = output.nextToken
            self.sharedImagePermissionsList = output.sharedImagePermissionsList
        } else {
            self.name = nil
            self.nextToken = nil
            self.sharedImagePermissionsList = nil
        }
    }
}

public struct DescribeImagePermissionsOutput: Swift.Equatable {
    /// The name of the private image.
    public var name: Swift.String?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The permissions for a private image that you own.
    public var sharedImagePermissionsList: [AppStreamClientTypes.SharedImagePermissions]?

    public init(
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sharedImagePermissionsList: [AppStreamClientTypes.SharedImagePermissions]? = nil
    )
    {
        self.name = name
        self.nextToken = nextToken
        self.sharedImagePermissionsList = sharedImagePermissionsList
    }
}

struct DescribeImagePermissionsOutputBody: Swift.Equatable {
    let name: Swift.String?
    let sharedImagePermissionsList: [AppStreamClientTypes.SharedImagePermissions]?
    let nextToken: Swift.String?
}

extension DescribeImagePermissionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case nextToken = "NextToken"
        case sharedImagePermissionsList = "SharedImagePermissionsList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sharedImagePermissionsListContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.SharedImagePermissions?].self, forKey: .sharedImagePermissionsList)
        var sharedImagePermissionsListDecoded0:[AppStreamClientTypes.SharedImagePermissions]? = nil
        if let sharedImagePermissionsListContainer = sharedImagePermissionsListContainer {
            sharedImagePermissionsListDecoded0 = [AppStreamClientTypes.SharedImagePermissions]()
            for structure0 in sharedImagePermissionsListContainer {
                if let structure0 = structure0 {
                    sharedImagePermissionsListDecoded0?.append(structure0)
                }
            }
        }
        sharedImagePermissionsList = sharedImagePermissionsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeImagePermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeImagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for arn0 in arns {
                try arnsContainer.encode(arn0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for string0 in names {
                try namesContainer.encode(string0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension DescribeImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeImagesInput: Swift.Equatable {
    /// The ARNs of the public, private, and shared images to describe.
    public var arns: [Swift.String]?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The names of the public or private images to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The type of image (public, private, or shared) to describe.
    public var type: AppStreamClientTypes.VisibilityType?

    public init(
        arns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        type: AppStreamClientTypes.VisibilityType? = nil
    )
    {
        self.arns = arns
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
        self.type = type
    }
}

struct DescribeImagesInputBody: Swift.Equatable {
    let names: [Swift.String]?
    let arns: [Swift.String]?
    let type: AppStreamClientTypes.VisibilityType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VisibilityType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeImagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeImagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.images = output.images
            self.nextToken = output.nextToken
        } else {
            self.images = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImagesOutput: Swift.Equatable {
    /// Information about the images.
    public var images: [AppStreamClientTypes.Image]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        images: [AppStreamClientTypes.Image]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.images = images
        self.nextToken = nextToken
    }
}

struct DescribeImagesOutputBody: Swift.Equatable {
    let images: [AppStreamClientTypes.Image]?
    let nextToken: Swift.String?
}

extension DescribeImagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case images = "Images"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagesContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Image?].self, forKey: .images)
        var imagesDecoded0:[AppStreamClientTypes.Image]? = nil
        if let imagesContainer = imagesContainer {
            imagesDecoded0 = [AppStreamClientTypes.Image]()
            for structure0 in imagesContainer {
                if let structure0 = structure0 {
                    imagesDecoded0?.append(structure0)
                }
            }
        }
        images = imagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeImagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case fleetName = "FleetName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let fleetName = self.fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DescribeSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSessionsInput: Swift.Equatable {
    /// The authentication method. Specify API for a user authenticated using a streaming URL or SAML for a SAML federated user. The default is to authenticate users using a streaming URL.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The name of the fleet. This value is case-sensitive.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The size of each page of results. The default value is 20 and the maximum value is 50.
    public var limit: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The name of the stack. This value is case-sensitive.
    /// This member is required.
    public var stackName: Swift.String?
    /// The user identifier (ID). If you specify a user ID, you must also specify the authentication type.
    public var userId: Swift.String?

    public init(
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        fleetName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.fleetName = fleetName
        self.limit = limit
        self.nextToken = nextToken
        self.stackName = stackName
        self.userId = userId
    }
}

struct DescribeSessionsInputBody: Swift.Equatable {
    let stackName: Swift.String?
    let fleetName: Swift.String?
    let userId: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
    let authenticationType: AppStreamClientTypes.AuthenticationType?
}

extension DescribeSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case fleetName = "FleetName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension DescribeSessionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSessionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

public struct DescribeSessionsOutput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the streaming sessions.
    public var sessions: [AppStreamClientTypes.Session]?

    public init(
        nextToken: Swift.String? = nil,
        sessions: [AppStreamClientTypes.Session]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct DescribeSessionsOutputBody: Swift.Equatable {
    let sessions: [AppStreamClientTypes.Session]?
    let nextToken: Swift.String?
}

extension DescribeSessionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sessions = "Sessions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Session?].self, forKey: .sessions)
        var sessionsDecoded0:[AppStreamClientTypes.Session]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [AppStreamClientTypes.Session]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeSessionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeStacksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for string0 in names {
                try namesContainer.encode(string0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeStacksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeStacksInput: Swift.Equatable {
    /// The names of the stacks to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct DescribeStacksInputBody: Swift.Equatable {
    let names: [Swift.String]?
    let nextToken: Swift.String?
}

extension DescribeStacksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeStacksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeStacksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.stacks = output.stacks
        } else {
            self.nextToken = nil
            self.stacks = nil
        }
    }
}

public struct DescribeStacksOutput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the stacks.
    public var stacks: [AppStreamClientTypes.Stack]?

    public init(
        nextToken: Swift.String? = nil,
        stacks: [AppStreamClientTypes.Stack]? = nil
    )
    {
        self.nextToken = nextToken
        self.stacks = stacks
    }
}

struct DescribeStacksOutputBody: Swift.Equatable {
    let stacks: [AppStreamClientTypes.Stack]?
    let nextToken: Swift.String?
}

extension DescribeStacksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case stacks = "Stacks"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stacksContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Stack?].self, forKey: .stacks)
        var stacksDecoded0:[AppStreamClientTypes.Stack]? = nil
        if let stacksContainer = stacksContainer {
            stacksDecoded0 = [AppStreamClientTypes.Stack]()
            for structure0 in stacksContainer {
                if let structure0 = structure0 {
                    stacksDecoded0?.append(structure0)
                }
            }
        }
        stacks = stacksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeStacksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeUsageReportSubscriptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeUsageReportSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUsageReportSubscriptionsInput: Swift.Equatable {
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeUsageReportSubscriptionsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeUsageReportSubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUsageReportSubscriptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeUsageReportSubscriptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.usageReportSubscriptions = output.usageReportSubscriptions
        } else {
            self.nextToken = nil
            self.usageReportSubscriptions = nil
        }
    }
}

public struct DescribeUsageReportSubscriptionsOutput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the usage report subscription.
    public var usageReportSubscriptions: [AppStreamClientTypes.UsageReportSubscription]?

    public init(
        nextToken: Swift.String? = nil,
        usageReportSubscriptions: [AppStreamClientTypes.UsageReportSubscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.usageReportSubscriptions = usageReportSubscriptions
    }
}

struct DescribeUsageReportSubscriptionsOutputBody: Swift.Equatable {
    let usageReportSubscriptions: [AppStreamClientTypes.UsageReportSubscription]?
    let nextToken: Swift.String?
}

extension DescribeUsageReportSubscriptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case usageReportSubscriptions = "UsageReportSubscriptions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageReportSubscriptionsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UsageReportSubscription?].self, forKey: .usageReportSubscriptions)
        var usageReportSubscriptionsDecoded0:[AppStreamClientTypes.UsageReportSubscription]? = nil
        if let usageReportSubscriptionsContainer = usageReportSubscriptionsContainer {
            usageReportSubscriptionsDecoded0 = [AppStreamClientTypes.UsageReportSubscription]()
            for structure0 in usageReportSubscriptionsContainer {
                if let structure0 = structure0 {
                    usageReportSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        usageReportSubscriptions = usageReportSubscriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeUsageReportSubscriptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeUserStackAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserStackAssociationsInput(authenticationType: \(Swift.String(describing: authenticationType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), stackName: \(Swift.String(describing: stackName)), userName: \"CONTENT_REDACTED\")"}
}

extension DescribeUserStackAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DescribeUserStackAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUserStackAssociationsInput: Swift.Equatable {
    /// The authentication type for the user who is associated with the stack. You must specify USERPOOL.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The name of the stack that is associated with the user.
    public var stackName: Swift.String?
    /// The email address of the user who is associated with the stack. Users' email addresses are case-sensitive.
    public var userName: Swift.String?

    public init(
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stackName = stackName
        self.userName = userName
    }
}

struct DescribeUserStackAssociationsInputBody: Swift.Equatable {
    let stackName: Swift.String?
    let userName: Swift.String?
    let authenticationType: AppStreamClientTypes.AuthenticationType?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeUserStackAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUserStackAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeUserStackAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userStackAssociations = output.userStackAssociations
        } else {
            self.nextToken = nil
            self.userStackAssociations = nil
        }
    }
}

public struct DescribeUserStackAssociationsOutput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The UserStackAssociation objects.
    public var userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?

    public init(
        nextToken: Swift.String? = nil,
        userStackAssociations: [AppStreamClientTypes.UserStackAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.userStackAssociations = userStackAssociations
    }
}

struct DescribeUserStackAssociationsOutputBody: Swift.Equatable {
    let userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?
    let nextToken: Swift.String?
}

extension DescribeUserStackAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case userStackAssociations = "UserStackAssociations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserStackAssociation?].self, forKey: .userStackAssociations)
        var userStackAssociationsDecoded0:[AppStreamClientTypes.UserStackAssociation]? = nil
        if let userStackAssociationsContainer = userStackAssociationsContainer {
            userStackAssociationsDecoded0 = [AppStreamClientTypes.UserStackAssociation]()
            for structure0 in userStackAssociationsContainer {
                if let structure0 = structure0 {
                    userStackAssociationsDecoded0?.append(structure0)
                }
            }
        }
        userStackAssociations = userStackAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeUserStackAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUsersInput: Swift.Equatable {
    /// The authentication type for the users in the user pool to describe. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeUsersInputBody: Swift.Equatable {
    let authenticationType: AppStreamClientTypes.AuthenticationType?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct DescribeUsersOutput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about users in the user pool.
    public var users: [AppStreamClientTypes.User]?

    public init(
        nextToken: Swift.String? = nil,
        users: [AppStreamClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct DescribeUsersOutputBody: Swift.Equatable {
    let users: [AppStreamClientTypes.User]?
    let nextToken: Swift.String?
}

extension DescribeUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[AppStreamClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [AppStreamClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppStreamClientTypes.DirectoryConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBasedAuthProperties = "CertificateBasedAuthProperties"
        case createdTime = "CreatedTime"
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateBasedAuthProperties = self.certificateBasedAuthProperties {
            try encodeContainer.encode(certificateBasedAuthProperties, forKey: .certificateBasedAuthProperties)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let directoryName = self.directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames {
            var organizationalUnitDistinguishedNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitDistinguishedNames)
            for organizationalunitdistinguishedname0 in organizationalUnitDistinguishedNames {
                try organizationalUnitDistinguishedNamesContainer.encode(organizationalunitdistinguishedname0)
            }
        }
        if let serviceAccountCredentials = self.serviceAccountCredentials {
            try encodeContainer.encode(serviceAccountCredentials, forKey: .serviceAccountCredentials)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitDistinguishedNames)
        var organizationalUnitDistinguishedNamesDecoded0:[Swift.String]? = nil
        if let organizationalUnitDistinguishedNamesContainer = organizationalUnitDistinguishedNamesContainer {
            organizationalUnitDistinguishedNamesDecoded0 = [Swift.String]()
            for string0 in organizationalUnitDistinguishedNamesContainer {
                if let string0 = string0 {
                    organizationalUnitDistinguishedNamesDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNamesDecoded0
        let serviceAccountCredentialsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ServiceAccountCredentials.self, forKey: .serviceAccountCredentials)
        serviceAccountCredentials = serviceAccountCredentialsDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let certificateBasedAuthPropertiesDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.CertificateBasedAuthProperties.self, forKey: .certificateBasedAuthProperties)
        certificateBasedAuthProperties = certificateBasedAuthPropertiesDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the configuration information required to join fleets and image builders to Microsoft Active Directory domains.
    public struct DirectoryConfig: Swift.Equatable {
        /// The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory domain-joined streaming instances. Fallback is turned on by default when certificate-based authentication is Enabled . Fallback allows users to log in using their AD domain password if certificate-based authentication is unsuccessful, or to unlock a desktop lock screen. Enabled_no_directory_login_fallback enables certificate-based authentication, but does not allow users to log in using their AD domain password. Users will be disconnected to re-authenticate using certificates.
        public var certificateBasedAuthProperties: AppStreamClientTypes.CertificateBasedAuthProperties?
        /// The time the directory configuration was created.
        public var createdTime: ClientRuntime.Date?
        /// The fully qualified name of the directory (for example, corp.example.com).
        /// This member is required.
        public var directoryName: Swift.String?
        /// The distinguished names of the organizational units for computer accounts.
        public var organizationalUnitDistinguishedNames: [Swift.String]?
        /// The credentials for the service account used by the fleet or image builder to connect to the directory.
        public var serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?

        public init(
            certificateBasedAuthProperties: AppStreamClientTypes.CertificateBasedAuthProperties? = nil,
            createdTime: ClientRuntime.Date? = nil,
            directoryName: Swift.String? = nil,
            organizationalUnitDistinguishedNames: [Swift.String]? = nil,
            serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials? = nil
        )
        {
            self.certificateBasedAuthProperties = certificateBasedAuthProperties
            self.createdTime = createdTime
            self.directoryName = directoryName
            self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
            self.serviceAccountCredentials = serviceAccountCredentials
        }
    }

}

extension DisableUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableUserInput(authenticationType: \(Swift.String(describing: authenticationType)), userName: \"CONTENT_REDACTED\")"}
}

extension DisableUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DisableUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisableUserInput: Swift.Equatable {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The email address of the user. Users' email addresses are case-sensitive.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.userName = userName
    }
}

struct DisableUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let authenticationType: AppStreamClientTypes.AuthenticationType?
}

extension DisableUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension DisableUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisableUserOutput: Swift.Equatable {

    public init() { }
}

enum DisableUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateAppBlockBuilderAppBlockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case appBlockBuilderName = "AppBlockBuilderName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBlockArn = self.appBlockArn {
            try encodeContainer.encode(appBlockArn, forKey: .appBlockArn)
        }
        if let appBlockBuilderName = self.appBlockBuilderName {
            try encodeContainer.encode(appBlockBuilderName, forKey: .appBlockBuilderName)
        }
    }
}

extension DisassociateAppBlockBuilderAppBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateAppBlockBuilderAppBlockInput: Swift.Equatable {
    /// The ARN of the app block.
    /// This member is required.
    public var appBlockArn: Swift.String?
    /// The name of the app block builder.
    /// This member is required.
    public var appBlockBuilderName: Swift.String?

    public init(
        appBlockArn: Swift.String? = nil,
        appBlockBuilderName: Swift.String? = nil
    )
    {
        self.appBlockArn = appBlockArn
        self.appBlockBuilderName = appBlockBuilderName
    }
}

struct DisassociateAppBlockBuilderAppBlockInputBody: Swift.Equatable {
    let appBlockArn: Swift.String?
    let appBlockBuilderName: Swift.String?
}

extension DisassociateAppBlockBuilderAppBlockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case appBlockBuilderName = "AppBlockBuilderName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlockArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBlockArn)
        appBlockArn = appBlockArnDecoded
        let appBlockBuilderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBlockBuilderName)
        appBlockBuilderName = appBlockBuilderNameDecoded
    }
}

extension DisassociateAppBlockBuilderAppBlockOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateAppBlockBuilderAppBlockOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateAppBlockBuilderAppBlockOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateApplicationFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case fleetName = "FleetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let fleetName = self.fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
    }
}

extension DisassociateApplicationFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateApplicationFleetInput: Swift.Equatable {
    /// The ARN of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        fleetName: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.fleetName = fleetName
    }
}

struct DisassociateApplicationFleetInputBody: Swift.Equatable {
    let fleetName: Swift.String?
    let applicationArn: Swift.String?
}

extension DisassociateApplicationFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case fleetName = "FleetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension DisassociateApplicationFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateApplicationFleetOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateApplicationFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateApplicationFromEntitlementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIdentifier = "ApplicationIdentifier"
        case entitlementName = "EntitlementName"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationIdentifier = self.applicationIdentifier {
            try encodeContainer.encode(applicationIdentifier, forKey: .applicationIdentifier)
        }
        if let entitlementName = self.entitlementName {
            try encodeContainer.encode(entitlementName, forKey: .entitlementName)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

extension DisassociateApplicationFromEntitlementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateApplicationFromEntitlementInput: Swift.Equatable {
    /// The identifier of the application to remove from the entitlement.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The name of the entitlement.
    /// This member is required.
    public var entitlementName: Swift.String?
    /// The name of the stack with which the entitlement is associated.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        applicationIdentifier: Swift.String? = nil,
        entitlementName: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.entitlementName = entitlementName
        self.stackName = stackName
    }
}

struct DisassociateApplicationFromEntitlementInputBody: Swift.Equatable {
    let stackName: Swift.String?
    let entitlementName: Swift.String?
    let applicationIdentifier: Swift.String?
}

extension DisassociateApplicationFromEntitlementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIdentifier = "ApplicationIdentifier"
        case entitlementName = "EntitlementName"
        case stackName = "StackName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let entitlementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementName)
        entitlementName = entitlementNameDecoded
        let applicationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationIdentifier)
        applicationIdentifier = applicationIdentifierDecoded
    }
}

extension DisassociateApplicationFromEntitlementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateApplicationFromEntitlementOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateApplicationFromEntitlementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntitlementNotFoundException": return try await EntitlementNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetName = self.fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

extension DisassociateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        fleetName: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.fleetName = fleetName
        self.stackName = stackName
    }
}

struct DisassociateFleetInputBody: Swift.Equatable {
    let fleetName: Swift.String?
    let stackName: Swift.String?
}

extension DisassociateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
    }
}

extension DisassociateFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateFleetOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppStreamClientTypes.DomainJoinInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedName = "OrganizationalUnitDistinguishedName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = self.directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedName = self.organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the configuration information required to join fleets and image builders to Microsoft Active Directory domains.
    public struct DomainJoinInfo: Swift.Equatable {
        /// The fully qualified name of the directory (for example, corp.example.com).
        public var directoryName: Swift.String?
        /// The distinguished name of the organizational unit for computer accounts.
        public var organizationalUnitDistinguishedName: Swift.String?

        public init(
            directoryName: Swift.String? = nil,
            organizationalUnitDistinguishedName: Swift.String? = nil
        )
        {
            self.directoryName = directoryName
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        }
    }

}

extension EnableUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableUserInput(authenticationType: \(Swift.String(describing: authenticationType)), userName: \"CONTENT_REDACTED\")"}
}

extension EnableUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension EnableUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EnableUserInput: Swift.Equatable {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The email address of the user. Users' email addresses are case-sensitive. During login, if they specify an email address that doesn't use the same capitalization as the email address specified when their user pool account was created, a "user does not exist" error message displays.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.userName = userName
    }
}

struct EnableUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let authenticationType: AppStreamClientTypes.AuthenticationType?
}

extension EnableUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension EnableUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct EnableUserOutput: Swift.Equatable {

    public init() { }
}

enum EnableUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppStreamClientTypes.EntitledApplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIdentifier = "ApplicationIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationIdentifier = self.applicationIdentifier {
            try encodeContainer.encode(applicationIdentifier, forKey: .applicationIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationIdentifier)
        applicationIdentifier = applicationIdentifierDecoded
    }
}

extension AppStreamClientTypes {
    /// The application associated to an entitlement. Access is controlled based on user attributes.
    public struct EntitledApplication: Swift.Equatable {
        /// The identifier of the application.
        /// This member is required.
        public var applicationIdentifier: Swift.String?

        public init(
            applicationIdentifier: Swift.String? = nil
        )
        {
            self.applicationIdentifier = applicationIdentifier
        }
    }

}

extension AppStreamClientTypes.Entitlement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appVisibility = "AppVisibility"
        case attributes = "Attributes"
        case createdTime = "CreatedTime"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appVisibility = self.appVisibility {
            try encodeContainer.encode(appVisibility.rawValue, forKey: .appVisibility)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for entitlementattribute0 in attributes {
                try attributesContainer.encode(entitlementattribute0)
            }
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let appVisibilityDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppVisibility.self, forKey: .appVisibility)
        appVisibility = appVisibilityDecoded
        let attributesContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.EntitlementAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[AppStreamClientTypes.EntitlementAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [AppStreamClientTypes.EntitlementAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension AppStreamClientTypes {
    /// Specifies an entitlement. Entitlements control access to specific applications within a stack, based on user attributes. Entitlements apply to SAML 2.0 federated user identities. Amazon AppStream 2.0 user pool and streaming URL users are entitled to all applications in a stack. Entitlements don't apply to the desktop stream view application, or to applications managed by a dynamic app provider using the Dynamic Application Framework.
    public struct Entitlement: Swift.Equatable {
        /// Specifies whether all or selected apps are entitled.
        /// This member is required.
        public var appVisibility: AppStreamClientTypes.AppVisibility?
        /// The attributes of the entitlement.
        /// This member is required.
        public var attributes: [AppStreamClientTypes.EntitlementAttribute]?
        /// The time when the entitlement was created.
        public var createdTime: ClientRuntime.Date?
        /// The description of the entitlement.
        public var description: Swift.String?
        /// The time when the entitlement was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the entitlement.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the stack with which the entitlement is associated.
        /// This member is required.
        public var stackName: Swift.String?

        public init(
            appVisibility: AppStreamClientTypes.AppVisibility? = nil,
            attributes: [AppStreamClientTypes.EntitlementAttribute]? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            stackName: Swift.String? = nil
        )
        {
            self.appVisibility = appVisibility
            self.attributes = attributes
            self.createdTime = createdTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.stackName = stackName
        }
    }

}

extension EntitlementAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EntitlementAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The entitlement already exists.
public struct EntitlementAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntitlementAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EntitlementAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntitlementAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes.EntitlementAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AppStreamClientTypes {
    /// An attribute associated with an entitlement. Application entitlements work by matching a supported SAML 2.0 attribute name to a value when a user identity federates to an Amazon AppStream 2.0 SAML application.
    public struct EntitlementAttribute: Swift.Equatable {
        /// A supported AWS IAM SAML PrincipalTag attribute that is matched to the associated value when a user identity federates into an Amazon AppStream 2.0 SAML application. The following are valid values:
        ///
        /// * roles
        ///
        /// * department
        ///
        /// * organization
        ///
        /// * groups
        ///
        /// * title
        ///
        /// * costCenter
        ///
        /// * userType
        /// This member is required.
        public var name: Swift.String?
        /// A value that is matched to a supported SAML attribute name when a user identity federates into an Amazon AppStream 2.0 SAML application.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension EntitlementNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EntitlementNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The entitlement can't be found.
public struct EntitlementNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntitlementNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EntitlementNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntitlementNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AppStreamClientTypes {
    /// The error details.
    public struct ErrorDetails: Swift.Equatable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension ExpireSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension ExpireSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ExpireSessionInput: Swift.Equatable {
    /// The identifier of the streaming session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct ExpireSessionInputBody: Swift.Equatable {
    let sessionId: Swift.String?
}

extension ExpireSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension ExpireSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ExpireSessionOutput: Swift.Equatable {

    public init() { }
}

enum ExpireSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppStreamClientTypes.Fleet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case computeCapacityStatus = "ComputeCapacityStatus"
        case createdTime = "CreatedTime"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case fleetErrors = "FleetErrors"
        case fleetType = "FleetType"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxConcurrentSessions = "MaxConcurrentSessions"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case platform = "Platform"
        case sessionScriptS3Location = "SessionScriptS3Location"
        case state = "State"
        case streamView = "StreamView"
        case usbDeviceFilterStrings = "UsbDeviceFilterStrings"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let computeCapacityStatus = self.computeCapacityStatus {
            try encodeContainer.encode(computeCapacityStatus, forKey: .computeCapacityStatus)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disconnectTimeoutInSeconds = self.disconnectTimeoutInSeconds {
            try encodeContainer.encode(disconnectTimeoutInSeconds, forKey: .disconnectTimeoutInSeconds)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = self.domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = self.enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let fleetErrors = fleetErrors {
            var fleetErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fleetErrors)
            for fleeterror0 in fleetErrors {
                try fleetErrorsContainer.encode(fleeterror0)
            }
        }
        if let fleetType = self.fleetType {
            try encodeContainer.encode(fleetType.rawValue, forKey: .fleetType)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idleDisconnectTimeoutInSeconds = self.idleDisconnectTimeoutInSeconds {
            try encodeContainer.encode(idleDisconnectTimeoutInSeconds, forKey: .idleDisconnectTimeoutInSeconds)
        }
        if let imageArn = self.imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = self.imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let maxConcurrentSessions = self.maxConcurrentSessions {
            try encodeContainer.encode(maxConcurrentSessions, forKey: .maxConcurrentSessions)
        }
        if let maxUserDurationInSeconds = self.maxUserDurationInSeconds {
            try encodeContainer.encode(maxUserDurationInSeconds, forKey: .maxUserDurationInSeconds)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let sessionScriptS3Location = self.sessionScriptS3Location {
            try encodeContainer.encode(sessionScriptS3Location, forKey: .sessionScriptS3Location)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let streamView = self.streamView {
            try encodeContainer.encode(streamView.rawValue, forKey: .streamView)
        }
        if let usbDeviceFilterStrings = usbDeviceFilterStrings {
            var usbDeviceFilterStringsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usbDeviceFilterStrings)
            for usbdevicefilterstring0 in usbDeviceFilterStrings {
                try usbDeviceFilterStringsContainer.encode(usbdevicefilterstring0)
            }
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let fleetTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.FleetType.self, forKey: .fleetType)
        fleetType = fleetTypeDecoded
        let computeCapacityStatusDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ComputeCapacityStatus.self, forKey: .computeCapacityStatus)
        computeCapacityStatus = computeCapacityStatusDecoded
        let maxUserDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxUserDurationInSeconds)
        maxUserDurationInSeconds = maxUserDurationInSecondsDecoded
        let disconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInSeconds)
        disconnectTimeoutInSeconds = disconnectTimeoutInSecondsDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.FleetState.self, forKey: .state)
        state = stateDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let fleetErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.FleetError?].self, forKey: .fleetErrors)
        var fleetErrorsDecoded0:[AppStreamClientTypes.FleetError]? = nil
        if let fleetErrorsContainer = fleetErrorsContainer {
            fleetErrorsDecoded0 = [AppStreamClientTypes.FleetError]()
            for structure0 in fleetErrorsContainer {
                if let structure0 = structure0 {
                    fleetErrorsDecoded0?.append(structure0)
                }
            }
        }
        fleetErrors = fleetErrorsDecoded0
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let idleDisconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInSeconds)
        idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSecondsDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let streamViewDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StreamView.self, forKey: .streamView)
        streamView = streamViewDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let maxConcurrentSessionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConcurrentSessions)
        maxConcurrentSessions = maxConcurrentSessionsDecoded
        let usbDeviceFilterStringsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usbDeviceFilterStrings)
        var usbDeviceFilterStringsDecoded0:[Swift.String]? = nil
        if let usbDeviceFilterStringsContainer = usbDeviceFilterStringsContainer {
            usbDeviceFilterStringsDecoded0 = [Swift.String]()
            for string0 in usbDeviceFilterStringsContainer {
                if let string0 = string0 {
                    usbDeviceFilterStringsDecoded0?.append(string0)
                }
            }
        }
        usbDeviceFilterStrings = usbDeviceFilterStringsDecoded0
        let sessionScriptS3LocationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.S3Location.self, forKey: .sessionScriptS3Location)
        sessionScriptS3Location = sessionScriptS3LocationDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes a fleet.
    public struct Fleet: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the fleet.
        /// This member is required.
        public var arn: Swift.String?
        /// The capacity status for the fleet.
        /// This member is required.
        public var computeCapacityStatus: AppStreamClientTypes.ComputeCapacityStatus?
        /// The time the fleet was created.
        public var createdTime: ClientRuntime.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The amount of time that a streaming session remains active after users disconnect. If they try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance. Specify a value between 60 and 360000.
        public var disconnectTimeoutInSeconds: Swift.Int?
        /// The fleet name to display.
        public var displayName: Swift.String?
        /// The name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain.
        public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
        /// Indicates whether default internet access is enabled for the fleet.
        public var enableDefaultInternetAccess: Swift.Bool?
        /// The fleet errors.
        public var fleetErrors: [AppStreamClientTypes.FleetError]?
        /// The fleet type. ALWAYS_ON Provides users with instant-on access to their apps. You are charged for all running instances in your fleet, even if no users are streaming apps. ON_DEMAND Provide users with access to applications after they connect, which takes one to two minutes. You are charged for instance streaming when users are connected and a small hourly fee for instances that are not streaming apps.
        public var fleetType: AppStreamClientTypes.FleetType?
        /// The ARN of the IAM role that is applied to the fleet. To assume a role, the fleet instance calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
        public var iamRoleArn: Swift.String?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the DisconnectTimeoutInSeconds time interval begins. Users are notified before they are disconnected due to inactivity. If users try to reconnect to the streaming session before the time interval specified in DisconnectTimeoutInSeconds elapses, they are connected to their previous session. Users are considered idle when they stop providing keyboard or mouse input during their streaming session. File uploads and downloads, audio in, audio out, and pixels changing do not qualify as user activity. If users continue to be idle after the time interval in IdleDisconnectTimeoutInSeconds elapses, they are disconnected. To prevent users from being disconnected due to inactivity, specify a value of 0. Otherwise, specify a value between 60 and 3600. The default value is 0. If you enable this feature, we recommend that you specify a value that corresponds exactly to a whole number of minutes (for example, 60, 120, and 180). If you don't do this, the value is rounded to the nearest minute. For example, if you specify a value of 70, users are disconnected after 1 minute of inactivity. If you specify a value that is at the midpoint between two different minutes, the value is rounded up. For example, if you specify a value of 90, users are disconnected after 2 minutes of inactivity.
        public var idleDisconnectTimeoutInSeconds: Swift.Int?
        /// The ARN for the public, private, or shared image.
        public var imageArn: Swift.String?
        /// The name of the image used to create the fleet.
        public var imageName: Swift.String?
        /// The instance type to use when launching fleet instances. The following instance types are available:
        ///
        /// * stream.standard.small
        ///
        /// * stream.standard.medium
        ///
        /// * stream.standard.large
        ///
        /// * stream.compute.large
        ///
        /// * stream.compute.xlarge
        ///
        /// * stream.compute.2xlarge
        ///
        /// * stream.compute.4xlarge
        ///
        /// * stream.compute.8xlarge
        ///
        /// * stream.memory.large
        ///
        /// * stream.memory.xlarge
        ///
        /// * stream.memory.2xlarge
        ///
        /// * stream.memory.4xlarge
        ///
        /// * stream.memory.8xlarge
        ///
        /// * stream.memory.z1d.large
        ///
        /// * stream.memory.z1d.xlarge
        ///
        /// * stream.memory.z1d.2xlarge
        ///
        /// * stream.memory.z1d.3xlarge
        ///
        /// * stream.memory.z1d.6xlarge
        ///
        /// * stream.memory.z1d.12xlarge
        ///
        /// * stream.graphics-design.large
        ///
        /// * stream.graphics-design.xlarge
        ///
        /// * stream.graphics-design.2xlarge
        ///
        /// * stream.graphics-design.4xlarge
        ///
        /// * stream.graphics-desktop.2xlarge
        ///
        /// * stream.graphics.g4dn.xlarge
        ///
        /// * stream.graphics.g4dn.2xlarge
        ///
        /// * stream.graphics.g4dn.4xlarge
        ///
        /// * stream.graphics.g4dn.8xlarge
        ///
        /// * stream.graphics.g4dn.12xlarge
        ///
        /// * stream.graphics.g4dn.16xlarge
        ///
        /// * stream.graphics-pro.4xlarge
        ///
        /// * stream.graphics-pro.8xlarge
        ///
        /// * stream.graphics-pro.16xlarge
        /// This member is required.
        public var instanceType: Swift.String?
        /// The maximum number of concurrent sessions for the fleet.
        public var maxConcurrentSessions: Swift.Int?
        /// The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance. Specify a value between 600 and 360000.
        public var maxUserDurationInSeconds: Swift.Int?
        /// The name of the fleet.
        /// This member is required.
        public var name: Swift.String?
        /// The platform of the fleet.
        public var platform: AppStreamClientTypes.PlatformType?
        /// The S3 location of the session scripts configuration zip file. This only applies to Elastic fleets.
        public var sessionScriptS3Location: AppStreamClientTypes.S3Location?
        /// The current state for the fleet.
        /// This member is required.
        public var state: AppStreamClientTypes.FleetState?
        /// The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When APP is specified, only the windows of applications opened by users display. When DESKTOP is specified, the standard desktop that is provided by the operating system displays. The default value is APP.
        public var streamView: AppStreamClientTypes.StreamView?
        /// The USB device filter strings associated with the fleet.
        public var usbDeviceFilterStrings: [Swift.String]?
        /// The VPC configuration for the fleet.
        public var vpcConfig: AppStreamClientTypes.VpcConfig?

        public init(
            arn: Swift.String? = nil,
            computeCapacityStatus: AppStreamClientTypes.ComputeCapacityStatus? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            disconnectTimeoutInSeconds: Swift.Int? = nil,
            displayName: Swift.String? = nil,
            domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
            enableDefaultInternetAccess: Swift.Bool? = nil,
            fleetErrors: [AppStreamClientTypes.FleetError]? = nil,
            fleetType: AppStreamClientTypes.FleetType? = nil,
            iamRoleArn: Swift.String? = nil,
            idleDisconnectTimeoutInSeconds: Swift.Int? = nil,
            imageArn: Swift.String? = nil,
            imageName: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            maxConcurrentSessions: Swift.Int? = nil,
            maxUserDurationInSeconds: Swift.Int? = nil,
            name: Swift.String? = nil,
            platform: AppStreamClientTypes.PlatformType? = nil,
            sessionScriptS3Location: AppStreamClientTypes.S3Location? = nil,
            state: AppStreamClientTypes.FleetState? = nil,
            streamView: AppStreamClientTypes.StreamView? = nil,
            usbDeviceFilterStrings: [Swift.String]? = nil,
            vpcConfig: AppStreamClientTypes.VpcConfig? = nil
        )
        {
            self.arn = arn
            self.computeCapacityStatus = computeCapacityStatus
            self.createdTime = createdTime
            self.description = description
            self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
            self.displayName = displayName
            self.domainJoinInfo = domainJoinInfo
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.fleetErrors = fleetErrors
            self.fleetType = fleetType
            self.iamRoleArn = iamRoleArn
            self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
            self.imageArn = imageArn
            self.imageName = imageName
            self.instanceType = instanceType
            self.maxConcurrentSessions = maxConcurrentSessions
            self.maxUserDurationInSeconds = maxUserDurationInSeconds
            self.name = name
            self.platform = platform
            self.sessionScriptS3Location = sessionScriptS3Location
            self.state = state
            self.streamView = streamView
            self.usbDeviceFilterStrings = usbDeviceFilterStrings
            self.vpcConfig = vpcConfig
        }
    }

}

extension AppStreamClientTypes {
    /// The fleet attribute.
    public enum FleetAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case domainJoinInfo
        case iamRoleArn
        case sessionScriptS3Location
        case usbDeviceFilterStrings
        case vpcConfiguration
        case vpcConfigurationSecurityGroupIds
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetAttribute] {
            return [
                .domainJoinInfo,
                .iamRoleArn,
                .sessionScriptS3Location,
                .usbDeviceFilterStrings,
                .vpcConfiguration,
                .vpcConfigurationSecurityGroupIds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .domainJoinInfo: return "DOMAIN_JOIN_INFO"
            case .iamRoleArn: return "IAM_ROLE_ARN"
            case .sessionScriptS3Location: return "SESSION_SCRIPT_S3_LOCATION"
            case .usbDeviceFilterStrings: return "USB_DEVICE_FILTER_STRINGS"
            case .vpcConfiguration: return "VPC_CONFIGURATION"
            case .vpcConfigurationSecurityGroupIds: return "VPC_CONFIGURATION_SECURITY_GROUP_IDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetAttribute(rawValue: rawValue) ?? FleetAttribute.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.FleetError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.FleetErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes a fleet error.
    public struct FleetError: Swift.Equatable {
        /// The error code.
        public var errorCode: AppStreamClientTypes.FleetErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?

        public init(
            errorCode: AppStreamClientTypes.FleetErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension AppStreamClientTypes {
    public enum FleetErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case domainJoinErrorAccessDenied
        case domainJoinErrorDsMachineAccountQuotaExceeded
        case domainJoinErrorFileNotFound
        case domainJoinErrorInvalidParameter
        case domainJoinErrorLogonFailure
        case domainJoinErrorMoreData
        case domainJoinErrorNotSupported
        case domainJoinErrorNoSuchDomain
        case domainJoinInternalServiceError
        case domainJoinNerrInvalidWorkgroupName
        case domainJoinNerrPasswordExpired
        case domainJoinNerrWorkstationNotStarted
        case fleetInstanceProvisioningFailure
        case fleetStopped
        case iamServiceRoleIsMissing
        case iamServiceRoleMissingDescribeSecurityGroupsAction
        case iamServiceRoleMissingDescribeSubnetAction
        case iamServiceRoleMissingEniCreateAction
        case iamServiceRoleMissingEniDeleteAction
        case iamServiceRoleMissingEniDescribeAction
        case igwNotAttached
        case imageNotFound
        case internalServiceError
        case invalidSubnetConfiguration
        case machineRoleIsMissing
        case networkInterfaceLimitExceeded
        case securityGroupsNotFound
        case stsDisabledInRegion
        case subnetHasInsufficientIpAddresses
        case subnetNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetErrorCode] {
            return [
                .domainJoinErrorAccessDenied,
                .domainJoinErrorDsMachineAccountQuotaExceeded,
                .domainJoinErrorFileNotFound,
                .domainJoinErrorInvalidParameter,
                .domainJoinErrorLogonFailure,
                .domainJoinErrorMoreData,
                .domainJoinErrorNotSupported,
                .domainJoinErrorNoSuchDomain,
                .domainJoinInternalServiceError,
                .domainJoinNerrInvalidWorkgroupName,
                .domainJoinNerrPasswordExpired,
                .domainJoinNerrWorkstationNotStarted,
                .fleetInstanceProvisioningFailure,
                .fleetStopped,
                .iamServiceRoleIsMissing,
                .iamServiceRoleMissingDescribeSecurityGroupsAction,
                .iamServiceRoleMissingDescribeSubnetAction,
                .iamServiceRoleMissingEniCreateAction,
                .iamServiceRoleMissingEniDeleteAction,
                .iamServiceRoleMissingEniDescribeAction,
                .igwNotAttached,
                .imageNotFound,
                .internalServiceError,
                .invalidSubnetConfiguration,
                .machineRoleIsMissing,
                .networkInterfaceLimitExceeded,
                .securityGroupsNotFound,
                .stsDisabledInRegion,
                .subnetHasInsufficientIpAddresses,
                .subnetNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .domainJoinErrorAccessDenied: return "DOMAIN_JOIN_ERROR_ACCESS_DENIED"
            case .domainJoinErrorDsMachineAccountQuotaExceeded: return "DOMAIN_JOIN_ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED"
            case .domainJoinErrorFileNotFound: return "DOMAIN_JOIN_ERROR_FILE_NOT_FOUND"
            case .domainJoinErrorInvalidParameter: return "DOMAIN_JOIN_ERROR_INVALID_PARAMETER"
            case .domainJoinErrorLogonFailure: return "DOMAIN_JOIN_ERROR_LOGON_FAILURE"
            case .domainJoinErrorMoreData: return "DOMAIN_JOIN_ERROR_MORE_DATA"
            case .domainJoinErrorNotSupported: return "DOMAIN_JOIN_ERROR_NOT_SUPPORTED"
            case .domainJoinErrorNoSuchDomain: return "DOMAIN_JOIN_ERROR_NO_SUCH_DOMAIN"
            case .domainJoinInternalServiceError: return "DOMAIN_JOIN_INTERNAL_SERVICE_ERROR"
            case .domainJoinNerrInvalidWorkgroupName: return "DOMAIN_JOIN_NERR_INVALID_WORKGROUP_NAME"
            case .domainJoinNerrPasswordExpired: return "DOMAIN_JOIN_NERR_PASSWORD_EXPIRED"
            case .domainJoinNerrWorkstationNotStarted: return "DOMAIN_JOIN_NERR_WORKSTATION_NOT_STARTED"
            case .fleetInstanceProvisioningFailure: return "FLEET_INSTANCE_PROVISIONING_FAILURE"
            case .fleetStopped: return "FLEET_STOPPED"
            case .iamServiceRoleIsMissing: return "IAM_SERVICE_ROLE_IS_MISSING"
            case .iamServiceRoleMissingDescribeSecurityGroupsAction: return "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SECURITY_GROUPS_ACTION"
            case .iamServiceRoleMissingDescribeSubnetAction: return "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SUBNET_ACTION"
            case .iamServiceRoleMissingEniCreateAction: return "IAM_SERVICE_ROLE_MISSING_ENI_CREATE_ACTION"
            case .iamServiceRoleMissingEniDeleteAction: return "IAM_SERVICE_ROLE_MISSING_ENI_DELETE_ACTION"
            case .iamServiceRoleMissingEniDescribeAction: return "IAM_SERVICE_ROLE_MISSING_ENI_DESCRIBE_ACTION"
            case .igwNotAttached: return "IGW_NOT_ATTACHED"
            case .imageNotFound: return "IMAGE_NOT_FOUND"
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .invalidSubnetConfiguration: return "INVALID_SUBNET_CONFIGURATION"
            case .machineRoleIsMissing: return "MACHINE_ROLE_IS_MISSING"
            case .networkInterfaceLimitExceeded: return "NETWORK_INTERFACE_LIMIT_EXCEEDED"
            case .securityGroupsNotFound: return "SECURITY_GROUPS_NOT_FOUND"
            case .stsDisabledInRegion: return "STS_DISABLED_IN_REGION"
            case .subnetHasInsufficientIpAddresses: return "SUBNET_HAS_INSUFFICIENT_IP_ADDRESSES"
            case .subnetNotFound: return "SUBNET_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetErrorCode(rawValue: rawValue) ?? FleetErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum FleetState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case running
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetState] {
            return [
                .running,
                .starting,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetState(rawValue: rawValue) ?? FleetState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum FleetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alwaysOn
        case elastic
        case onDemand
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetType] {
            return [
                .alwaysOn,
                .elastic,
                .onDemand,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alwaysOn: return "ALWAYS_ON"
            case .elastic: return "ELASTIC"
            case .onDemand: return "ON_DEMAND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetType(rawValue: rawValue) ?? FleetType.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.Image: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case arn = "Arn"
        case baseImageArn = "BaseImageArn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case imageBuilderName = "ImageBuilderName"
        case imageBuilderSupported = "ImageBuilderSupported"
        case imageErrors = "ImageErrors"
        case imagePermissions = "ImagePermissions"
        case name = "Name"
        case platform = "Platform"
        case publicBaseImageReleasedDate = "PublicBaseImageReleasedDate"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for application0 in applications {
                try applicationsContainer.encode(application0)
            }
        }
        if let appstreamAgentVersion = self.appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let baseImageArn = self.baseImageArn {
            try encodeContainer.encode(baseImageArn, forKey: .baseImageArn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let imageBuilderName = self.imageBuilderName {
            try encodeContainer.encode(imageBuilderName, forKey: .imageBuilderName)
        }
        if imageBuilderSupported != false {
            try encodeContainer.encode(imageBuilderSupported, forKey: .imageBuilderSupported)
        }
        if let imageErrors = imageErrors {
            var imageErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageErrors)
            for resourceerror0 in imageErrors {
                try imageErrorsContainer.encode(resourceerror0)
            }
        }
        if let imagePermissions = self.imagePermissions {
            try encodeContainer.encode(imagePermissions, forKey: .imagePermissions)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let publicBaseImageReleasedDate = self.publicBaseImageReleasedDate {
            try encodeContainer.encodeTimestamp(publicBaseImageReleasedDate, format: .epochSeconds, forKey: .publicBaseImageReleasedDate)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = self.stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let baseImageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseImageArn)
        baseImageArn = baseImageArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageState.self, forKey: .state)
        state = stateDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VisibilityType.self, forKey: .visibility)
        visibility = visibilityDecoded
        let imageBuilderSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .imageBuilderSupported) ?? false
        imageBuilderSupported = imageBuilderSupportedDecoded
        let imageBuilderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuilderName)
        imageBuilderName = imageBuilderNameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageStateChangeReason.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
        let applicationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Application?].self, forKey: .applications)
        var applicationsDecoded0:[AppStreamClientTypes.Application]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [AppStreamClientTypes.Application]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let publicBaseImageReleasedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .publicBaseImageReleasedDate)
        publicBaseImageReleasedDate = publicBaseImageReleasedDateDecoded
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
        let imagePermissionsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImagePermissions.self, forKey: .imagePermissions)
        imagePermissions = imagePermissionsDecoded
        let imageErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.ResourceError?].self, forKey: .imageErrors)
        var imageErrorsDecoded0:[AppStreamClientTypes.ResourceError]? = nil
        if let imageErrorsContainer = imageErrorsContainer {
            imageErrorsDecoded0 = [AppStreamClientTypes.ResourceError]()
            for structure0 in imageErrorsContainer {
                if let structure0 = structure0 {
                    imageErrorsDecoded0?.append(structure0)
                }
            }
        }
        imageErrors = imageErrorsDecoded0
    }
}

extension AppStreamClientTypes {
    /// Describes an image.
    public struct Image: Swift.Equatable {
        /// The applications associated with the image.
        public var applications: [AppStreamClientTypes.Application]?
        /// The version of the AppStream 2.0 agent to use for instances that are launched from this image.
        public var appstreamAgentVersion: Swift.String?
        /// The ARN of the image.
        public var arn: Swift.String?
        /// The ARN of the image from which this image was created.
        public var baseImageArn: Swift.String?
        /// The time the image was created.
        public var createdTime: ClientRuntime.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The image name to display.
        public var displayName: Swift.String?
        /// The name of the image builder that was used to create the private image. If the image is shared, this value is null.
        public var imageBuilderName: Swift.String?
        /// Indicates whether an image builder can be launched from this image.
        public var imageBuilderSupported: Swift.Bool
        /// Describes the errors that are returned when a new image can't be created.
        public var imageErrors: [AppStreamClientTypes.ResourceError]?
        /// The permissions to provide to the destination AWS account for the specified image.
        public var imagePermissions: AppStreamClientTypes.ImagePermissions?
        /// The name of the image.
        /// This member is required.
        public var name: Swift.String?
        /// The operating system platform of the image.
        public var platform: AppStreamClientTypes.PlatformType?
        /// The release date of the public base image. For private images, this date is the release date of the base image from which the image was created.
        public var publicBaseImageReleasedDate: ClientRuntime.Date?
        /// The image starts in the PENDING state. If image creation succeeds, the state is AVAILABLE. If image creation fails, the state is FAILED.
        public var state: AppStreamClientTypes.ImageState?
        /// The reason why the last state change occurred.
        public var stateChangeReason: AppStreamClientTypes.ImageStateChangeReason?
        /// Indicates whether the image is public or private.
        public var visibility: AppStreamClientTypes.VisibilityType?

        public init(
            applications: [AppStreamClientTypes.Application]? = nil,
            appstreamAgentVersion: Swift.String? = nil,
            arn: Swift.String? = nil,
            baseImageArn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            imageBuilderName: Swift.String? = nil,
            imageBuilderSupported: Swift.Bool = false,
            imageErrors: [AppStreamClientTypes.ResourceError]? = nil,
            imagePermissions: AppStreamClientTypes.ImagePermissions? = nil,
            name: Swift.String? = nil,
            platform: AppStreamClientTypes.PlatformType? = nil,
            publicBaseImageReleasedDate: ClientRuntime.Date? = nil,
            state: AppStreamClientTypes.ImageState? = nil,
            stateChangeReason: AppStreamClientTypes.ImageStateChangeReason? = nil,
            visibility: AppStreamClientTypes.VisibilityType? = nil
        )
        {
            self.applications = applications
            self.appstreamAgentVersion = appstreamAgentVersion
            self.arn = arn
            self.baseImageArn = baseImageArn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.imageBuilderName = imageBuilderName
            self.imageBuilderSupported = imageBuilderSupported
            self.imageErrors = imageErrors
            self.imagePermissions = imagePermissions
            self.name = name
            self.platform = platform
            self.publicBaseImageReleasedDate = publicBaseImageReleasedDate
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.visibility = visibility
        }
    }

}

extension AppStreamClientTypes.ImageBuilder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case imageArn = "ImageArn"
        case imageBuilderErrors = "ImageBuilderErrors"
        case instanceType = "InstanceType"
        case name = "Name"
        case networkAccessConfiguration = "NetworkAccessConfiguration"
        case platform = "Platform"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpoint0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpoint0)
            }
        }
        if let appstreamAgentVersion = self.appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = self.domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = self.enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let imageArn = self.imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageBuilderErrors = imageBuilderErrors {
            var imageBuilderErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageBuilderErrors)
            for resourceerror0 in imageBuilderErrors {
                try imageBuilderErrorsContainer.encode(resourceerror0)
            }
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkAccessConfiguration = self.networkAccessConfiguration {
            try encodeContainer.encode(networkAccessConfiguration, forKey: .networkAccessConfiguration)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = self.stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilderState.self, forKey: .state)
        state = stateDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilderStateChangeReason.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let networkAccessConfigurationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.NetworkAccessConfiguration.self, forKey: .networkAccessConfiguration)
        networkAccessConfiguration = networkAccessConfigurationDecoded
        let imageBuilderErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.ResourceError?].self, forKey: .imageBuilderErrors)
        var imageBuilderErrorsDecoded0:[AppStreamClientTypes.ResourceError]? = nil
        if let imageBuilderErrorsContainer = imageBuilderErrorsContainer {
            imageBuilderErrorsDecoded0 = [AppStreamClientTypes.ResourceError]()
            for structure0 in imageBuilderErrorsContainer {
                if let structure0 = structure0 {
                    imageBuilderErrorsDecoded0?.append(structure0)
                }
            }
        }
        imageBuilderErrors = imageBuilderErrorsDecoded0
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
    }
}

extension AppStreamClientTypes {
    /// Describes a virtual machine that is used to create an image.
    public struct ImageBuilder: Swift.Equatable {
        /// The list of virtual private cloud (VPC) interface endpoint objects. Administrators can connect to the image builder only through the specified endpoints.
        public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
        /// The version of the AppStream 2.0 agent that is currently being used by the image builder.
        public var appstreamAgentVersion: Swift.String?
        /// The ARN for the image builder.
        public var arn: Swift.String?
        /// The time stamp when the image builder was created.
        public var createdTime: ClientRuntime.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The image builder name to display.
        public var displayName: Swift.String?
        /// The name of the directory and organizational unit (OU) to use to join the image builder to a Microsoft Active Directory domain.
        public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
        /// Enables or disables default internet access for the image builder.
        public var enableDefaultInternetAccess: Swift.Bool?
        /// The ARN of the IAM role that is applied to the image builder. To assume a role, the image builder calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
        public var iamRoleArn: Swift.String?
        /// The ARN of the image from which this builder was created.
        public var imageArn: Swift.String?
        /// The image builder errors.
        public var imageBuilderErrors: [AppStreamClientTypes.ResourceError]?
        /// The instance type for the image builder. The following instance types are available:
        ///
        /// * stream.standard.small
        ///
        /// * stream.standard.medium
        ///
        /// * stream.standard.large
        ///
        /// * stream.compute.large
        ///
        /// * stream.compute.xlarge
        ///
        /// * stream.compute.2xlarge
        ///
        /// * stream.compute.4xlarge
        ///
        /// * stream.compute.8xlarge
        ///
        /// * stream.memory.large
        ///
        /// * stream.memory.xlarge
        ///
        /// * stream.memory.2xlarge
        ///
        /// * stream.memory.4xlarge
        ///
        /// * stream.memory.8xlarge
        ///
        /// * stream.memory.z1d.large
        ///
        /// * stream.memory.z1d.xlarge
        ///
        /// * stream.memory.z1d.2xlarge
        ///
        /// * stream.memory.z1d.3xlarge
        ///
        /// * stream.memory.z1d.6xlarge
        ///
        /// * stream.memory.z1d.12xlarge
        ///
        /// * stream.graphics-design.large
        ///
        /// * stream.graphics-design.xlarge
        ///
        /// * stream.graphics-design.2xlarge
        ///
        /// * stream.graphics-design.4xlarge
        ///
        /// * stream.graphics-desktop.2xlarge
        ///
        /// * stream.graphics.g4dn.xlarge
        ///
        /// * stream.graphics.g4dn.2xlarge
        ///
        /// * stream.graphics.g4dn.4xlarge
        ///
        /// * stream.graphics.g4dn.8xlarge
        ///
        /// * stream.graphics.g4dn.12xlarge
        ///
        /// * stream.graphics.g4dn.16xlarge
        ///
        /// * stream.graphics-pro.4xlarge
        ///
        /// * stream.graphics-pro.8xlarge
        ///
        /// * stream.graphics-pro.16xlarge
        public var instanceType: Swift.String?
        /// The name of the image builder.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the network details of the fleet or image builder instance.
        public var networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration?
        /// The operating system platform of the image builder.
        public var platform: AppStreamClientTypes.PlatformType?
        /// The state of the image builder.
        public var state: AppStreamClientTypes.ImageBuilderState?
        /// The reason why the last state change occurred.
        public var stateChangeReason: AppStreamClientTypes.ImageBuilderStateChangeReason?
        /// The VPC configuration of the image builder.
        public var vpcConfig: AppStreamClientTypes.VpcConfig?

        public init(
            accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
            appstreamAgentVersion: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
            enableDefaultInternetAccess: Swift.Bool? = nil,
            iamRoleArn: Swift.String? = nil,
            imageArn: Swift.String? = nil,
            imageBuilderErrors: [AppStreamClientTypes.ResourceError]? = nil,
            instanceType: Swift.String? = nil,
            name: Swift.String? = nil,
            networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration? = nil,
            platform: AppStreamClientTypes.PlatformType? = nil,
            state: AppStreamClientTypes.ImageBuilderState? = nil,
            stateChangeReason: AppStreamClientTypes.ImageBuilderStateChangeReason? = nil,
            vpcConfig: AppStreamClientTypes.VpcConfig? = nil
        )
        {
            self.accessEndpoints = accessEndpoints
            self.appstreamAgentVersion = appstreamAgentVersion
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.domainJoinInfo = domainJoinInfo
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.iamRoleArn = iamRoleArn
            self.imageArn = imageArn
            self.imageBuilderErrors = imageBuilderErrors
            self.instanceType = instanceType
            self.name = name
            self.networkAccessConfiguration = networkAccessConfiguration
            self.platform = platform
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.vpcConfig = vpcConfig
        }
    }

}

extension AppStreamClientTypes {
    public enum ImageBuilderState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case failed
        case pending
        case pendingQualification
        case rebooting
        case running
        case snapshotting
        case stopped
        case stopping
        case updating
        case updatingAgent
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageBuilderState] {
            return [
                .deleting,
                .failed,
                .pending,
                .pendingQualification,
                .rebooting,
                .running,
                .snapshotting,
                .stopped,
                .stopping,
                .updating,
                .updatingAgent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .pendingQualification: return "PENDING_QUALIFICATION"
            case .rebooting: return "REBOOTING"
            case .running: return "RUNNING"
            case .snapshotting: return "SNAPSHOTTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case .updatingAgent: return "UPDATING_AGENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageBuilderState(rawValue: rawValue) ?? ImageBuilderState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.ImageBuilderStateChangeReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilderStateChangeReasonCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the reason why the last image builder state change occurred.
    public struct ImageBuilderStateChangeReason: Swift.Equatable {
        /// The state change reason code.
        public var code: AppStreamClientTypes.ImageBuilderStateChangeReasonCode?
        /// The state change reason message.
        public var message: Swift.String?

        public init(
            code: AppStreamClientTypes.ImageBuilderStateChangeReasonCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension AppStreamClientTypes {
    public enum ImageBuilderStateChangeReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case imageUnavailable
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageBuilderStateChangeReasonCode] {
            return [
                .imageUnavailable,
                .internalError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .imageUnavailable: return "IMAGE_UNAVAILABLE"
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageBuilderStateChangeReasonCode(rawValue: rawValue) ?? ImageBuilderStateChangeReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.ImagePermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowFleet
        case allowImageBuilder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowFleet = self.allowFleet {
            try encodeContainer.encode(allowFleet, forKey: .allowFleet)
        }
        if let allowImageBuilder = self.allowImageBuilder {
            try encodeContainer.encode(allowImageBuilder, forKey: .allowImageBuilder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowFleetDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowFleet)
        allowFleet = allowFleetDecoded
        let allowImageBuilderDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowImageBuilder)
        allowImageBuilder = allowImageBuilderDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the permissions for an image.
    public struct ImagePermissions: Swift.Equatable {
        /// Indicates whether the image can be used for a fleet.
        public var allowFleet: Swift.Bool?
        /// Indicates whether the image can be used for an image builder.
        public var allowImageBuilder: Swift.Bool?

        public init(
            allowFleet: Swift.Bool? = nil,
            allowImageBuilder: Swift.Bool? = nil
        )
        {
            self.allowFleet = allowFleet
            self.allowImageBuilder = allowImageBuilder
        }
    }

}

extension AppStreamClientTypes {
    public enum ImageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case copying
        case creating
        case deleting
        case failed
        case importing
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageState] {
            return [
                .available,
                .copying,
                .creating,
                .deleting,
                .failed,
                .importing,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .copying: return "COPYING"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .importing: return "IMPORTING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageState(rawValue: rawValue) ?? ImageState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.ImageStateChangeReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageStateChangeReasonCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the reason why the last image state change occurred.
    public struct ImageStateChangeReason: Swift.Equatable {
        /// The state change reason code.
        public var code: AppStreamClientTypes.ImageStateChangeReasonCode?
        /// The state change reason message.
        public var message: Swift.String?

        public init(
            code: AppStreamClientTypes.ImageStateChangeReasonCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension AppStreamClientTypes {
    public enum ImageStateChangeReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case imageBuilderNotAvailable
        case imageCopyFailure
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageStateChangeReasonCode] {
            return [
                .imageBuilderNotAvailable,
                .imageCopyFailure,
                .internalError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .imageBuilderNotAvailable: return "IMAGE_BUILDER_NOT_AVAILABLE"
            case .imageCopyFailure: return "IMAGE_COPY_FAILURE"
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageStateChangeReasonCode(rawValue: rawValue) ?? ImageStateChangeReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension IncompatibleImageException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IncompatibleImageExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The image can't be updated because it's not compatible for updates.
public struct IncompatibleImageException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IncompatibleImageException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IncompatibleImageExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IncompatibleImageExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAccountStatusException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidAccountStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource cannot be created because your AWS account is suspended. For assistance, contact AWS Support.
public struct InvalidAccountStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAccountStatusException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidAccountStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAccountStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates an incorrect combination of parameters, or a missing parameter.
public struct InvalidParameterCombinationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterCombinationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRoleException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRoleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified role is invalid.
public struct InvalidRoleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRoleException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRoleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRoleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes.LastReportGenerationExecutionError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.UsageReportExecutionErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the error that is returned when a usage report can't be generated.
    public struct LastReportGenerationExecutionError: Swift.Equatable {
        /// The error code for the error that is returned when a usage report can't be generated.
        public var errorCode: AppStreamClientTypes.UsageReportExecutionErrorCode?
        /// The error message for the error that is returned when a usage report can't be generated.
        public var errorMessage: Swift.String?

        public init(
            errorCode: AppStreamClientTypes.UsageReportExecutionErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested limit exceeds the permitted limit for an account.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAssociatedFleetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

extension ListAssociatedFleetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAssociatedFleetsInput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.stackName = stackName
    }
}

struct ListAssociatedFleetsInputBody: Swift.Equatable {
    let stackName: Swift.String?
    let nextToken: Swift.String?
}

extension ListAssociatedFleetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case stackName = "StackName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedFleetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssociatedFleetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.names = output.names
            self.nextToken = output.nextToken
        } else {
            self.names = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedFleetsOutput: Swift.Equatable {
    /// The name of the fleet.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct ListAssociatedFleetsOutputBody: Swift.Equatable {
    let names: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAssociatedFleetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssociatedFleetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAssociatedStacksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetName = self.fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAssociatedStacksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAssociatedStacksInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        fleetName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetName = fleetName
        self.nextToken = nextToken
    }
}

struct ListAssociatedStacksInputBody: Swift.Equatable {
    let fleetName: Swift.String?
    let nextToken: Swift.String?
}

extension ListAssociatedStacksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedStacksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssociatedStacksOutputBody = try responseDecoder.decode(responseBody: data)
            self.names = output.names
            self.nextToken = output.nextToken
        } else {
            self.names = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedStacksOutput: Swift.Equatable {
    /// The name of the stack.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct ListAssociatedStacksOutputBody: Swift.Equatable {
    let names: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAssociatedStacksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssociatedStacksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEntitledApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlementName = "EntitlementName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entitlementName = self.entitlementName {
            try encodeContainer.encode(entitlementName, forKey: .entitlementName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

extension ListEntitledApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEntitledApplicationsInput: Swift.Equatable {
    /// The name of the entitlement.
    /// This member is required.
    public var entitlementName: Swift.String?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The name of the stack with which the entitlement is associated.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        entitlementName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.entitlementName = entitlementName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stackName = stackName
    }
}

struct ListEntitledApplicationsInputBody: Swift.Equatable {
    let stackName: Swift.String?
    let entitlementName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEntitledApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlementName = "EntitlementName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackName = "StackName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let entitlementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementName)
        entitlementName = entitlementNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEntitledApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEntitledApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.entitledApplications = output.entitledApplications
            self.nextToken = output.nextToken
        } else {
            self.entitledApplications = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntitledApplicationsOutput: Swift.Equatable {
    /// The entitled applications.
    public var entitledApplications: [AppStreamClientTypes.EntitledApplication]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        entitledApplications: [AppStreamClientTypes.EntitledApplication]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entitledApplications = entitledApplications
        self.nextToken = nextToken
    }
}

struct ListEntitledApplicationsOutputBody: Swift.Equatable {
    let entitledApplications: [AppStreamClientTypes.EntitledApplication]?
    let nextToken: Swift.String?
}

extension ListEntitledApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitledApplications = "EntitledApplications"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitledApplicationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.EntitledApplication?].self, forKey: .entitledApplications)
        var entitledApplicationsDecoded0:[AppStreamClientTypes.EntitledApplication]? = nil
        if let entitledApplicationsContainer = entitledApplicationsContainer {
            entitledApplicationsDecoded0 = [AppStreamClientTypes.EntitledApplication]()
            for structure0 in entitledApplicationsContainer {
                if let structure0 = structure0 {
                    entitledApplicationsDecoded0?.append(structure0)
                }
            }
        }
        entitledApplications = entitledApplicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEntitledApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntitlementNotFoundException": return try await EntitlementNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The information about the tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppStreamClientTypes {
    public enum MessageAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case resend
        case suppress
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageAction] {
            return [
                .resend,
                .suppress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resend: return "RESEND"
            case .suppress: return "SUPPRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageAction(rawValue: rawValue) ?? MessageAction.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.NetworkAccessConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eniId = "EniId"
        case eniPrivateIpAddress = "EniPrivateIpAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eniId = self.eniId {
            try encodeContainer.encode(eniId, forKey: .eniId)
        }
        if let eniPrivateIpAddress = self.eniPrivateIpAddress {
            try encodeContainer.encode(eniPrivateIpAddress, forKey: .eniPrivateIpAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eniPrivateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniPrivateIpAddress)
        eniPrivateIpAddress = eniPrivateIpAddressDecoded
        let eniIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniId)
        eniId = eniIdDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the network details of the fleet or image builder instance.
    public struct NetworkAccessConfiguration: Swift.Equatable {
        /// The resource identifier of the elastic network interface that is attached to instances in your VPC. All network interfaces have the eni-xxxxxxxx resource identifier.
        public var eniId: Swift.String?
        /// The private IP address of the elastic network interface that is attached to instances in your VPC.
        public var eniPrivateIpAddress: Swift.String?

        public init(
            eniId: Swift.String? = nil,
            eniPrivateIpAddress: Swift.String? = nil
        )
        {
            self.eniId = eniId
            self.eniPrivateIpAddress = eniPrivateIpAddress
        }
    }

}

extension OperationNotPermittedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The attempted operation is not permitted.
public struct OperationNotPermittedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotPermittedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OperationNotPermittedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes {
    public enum PackagingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appstream2
        case custom
        case sdkUnknown(Swift.String)

        public static var allCases: [PackagingType] {
            return [
                .appstream2,
                .custom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appstream2: return "APPSTREAM2"
            case .custom: return "CUSTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackagingType(rawValue: rawValue) ?? PackagingType.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum PlatformType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonLinux2
        case windows
        case windowsServer2016
        case windowsServer2019
        case sdkUnknown(Swift.String)

        public static var allCases: [PlatformType] {
            return [
                .amazonLinux2,
                .windows,
                .windowsServer2016,
                .windowsServer2019,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonLinux2: return "AMAZON_LINUX2"
            case .windows: return "WINDOWS"
            case .windowsServer2016: return "WINDOWS_SERVER_2016"
            case .windowsServer2019: return "WINDOWS_SERVER_2019"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlatformType(rawValue: rawValue) ?? PlatformType.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum PreferredProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [PreferredProtocol] {
            return [
                .tcp,
                .udp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PreferredProtocol(rawValue: rawValue) ?? PreferredProtocol.sdkUnknown(rawValue)
        }
    }
}

extension RequestLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// AppStream 2.0 canâ€™t process the request right now because the Describe calls from your AWS account are being throttled by Amazon EC2. Try again later.
public struct RequestLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RequestLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes.ResourceError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case errorTimestamp = "ErrorTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorTimestamp = self.errorTimestamp {
            try encodeContainer.encodeTimestamp(errorTimestamp, format: .epochSeconds, forKey: .errorTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.FleetErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .errorTimestamp)
        errorTimestamp = errorTimestampDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes a resource error.
    public struct ResourceError: Swift.Equatable {
        /// The error code.
        public var errorCode: AppStreamClientTypes.FleetErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The time the error occurred.
        public var errorTimestamp: ClientRuntime.Date?

        public init(
            errorCode: AppStreamClientTypes.FleetErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            errorTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.errorTimestamp = errorTimestamp
        }
    }

}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource is in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotAvailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotAvailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource exists and is not in use, but isn't available.
public struct ResourceNotAvailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotAvailableException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotAvailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotAvailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the S3 location.
    public struct S3Location: Swift.Equatable {
        /// The S3 bucket of the S3 object.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The S3 key of the S3 object. This is required when used for the following:
        ///
        /// * IconS3Location (Actions: CreateApplication and UpdateApplication)
        ///
        /// * SessionScriptS3Location (Actions: CreateFleet and UpdateFleet)
        ///
        /// * ScriptDetails (Actions: CreateAppBlock)
        ///
        /// * SourceS3Location when creating an app block with CUSTOM PackagingType (Actions: CreateAppBlock)
        ///
        /// * SourceS3Location when creating an app block with APPSTREAM2 PackagingType, and using an existing application package (VHD file). In this case, S3Key refers to the VHD file. If a new application package is required, then S3Key is not required. (Actions: CreateAppBlock)
        public var s3Key: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension AppStreamClientTypes.ScriptDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executableParameters = "ExecutableParameters"
        case executablePath = "ExecutablePath"
        case scriptS3Location = "ScriptS3Location"
        case timeoutInSeconds = "TimeoutInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executableParameters = self.executableParameters {
            try encodeContainer.encode(executableParameters, forKey: .executableParameters)
        }
        if let executablePath = self.executablePath {
            try encodeContainer.encode(executablePath, forKey: .executablePath)
        }
        if let scriptS3Location = self.scriptS3Location {
            try encodeContainer.encode(scriptS3Location, forKey: .scriptS3Location)
        }
        if let timeoutInSeconds = self.timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scriptS3LocationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.S3Location.self, forKey: .scriptS3Location)
        scriptS3Location = scriptS3LocationDecoded
        let executablePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executablePath)
        executablePath = executablePathDecoded
        let executableParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executableParameters)
        executableParameters = executableParametersDecoded
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the details of the script.
    public struct ScriptDetails: Swift.Equatable {
        /// The runtime parameters passed to the run path for the script.
        public var executableParameters: Swift.String?
        /// The run path for the script.
        /// This member is required.
        public var executablePath: Swift.String?
        /// The S3 object location for the script.
        /// This member is required.
        public var scriptS3Location: AppStreamClientTypes.S3Location?
        /// The run timeout, in seconds, for the script.
        /// This member is required.
        public var timeoutInSeconds: Swift.Int?

        public init(
            executableParameters: Swift.String? = nil,
            executablePath: Swift.String? = nil,
            scriptS3Location: AppStreamClientTypes.S3Location? = nil,
            timeoutInSeconds: Swift.Int? = nil
        )
        {
            self.executableParameters = executableParameters
            self.executablePath = executablePath
            self.scriptS3Location = scriptS3Location
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension AppStreamClientTypes.ServiceAccountCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountName = "AccountName"
        case accountPassword = "AccountPassword"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountName = self.accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let accountPassword = self.accountPassword {
            try encodeContainer.encode(accountPassword, forKey: .accountPassword)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let accountPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountPassword)
        accountPassword = accountPasswordDecoded
    }
}

extension AppStreamClientTypes.ServiceAccountCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceAccountCredentials(accountName: \"CONTENT_REDACTED\", accountPassword: \"CONTENT_REDACTED\")"}
}

extension AppStreamClientTypes {
    /// Describes the credentials for the service account used by the fleet or image builder to connect to the directory.
    public struct ServiceAccountCredentials: Swift.Equatable {
        /// The user name of the account. This account must have the following privileges: create computer objects, join computers to the domain, and change/reset the password on descendant computer objects for the organizational units specified.
        /// This member is required.
        public var accountName: Swift.String?
        /// The password for the account.
        /// This member is required.
        public var accountPassword: Swift.String?

        public init(
            accountName: Swift.String? = nil,
            accountPassword: Swift.String? = nil
        )
        {
            self.accountName = accountName
            self.accountPassword = accountPassword
        }
    }

}

extension AppStreamClientTypes.Session: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case connectionState = "ConnectionState"
        case fleetName = "FleetName"
        case id = "Id"
        case maxExpirationTime = "MaxExpirationTime"
        case networkAccessConfiguration = "NetworkAccessConfiguration"
        case stackName = "StackName"
        case startTime = "StartTime"
        case state = "State"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let connectionState = self.connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let fleetName = self.fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxExpirationTime = self.maxExpirationTime {
            try encodeContainer.encodeTimestamp(maxExpirationTime, format: .epochSeconds, forKey: .maxExpirationTime)
        }
        if let networkAccessConfiguration = self.networkAccessConfiguration {
            try encodeContainer.encode(networkAccessConfiguration, forKey: .networkAccessConfiguration)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.SessionState.self, forKey: .state)
        state = stateDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.SessionConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let maxExpirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .maxExpirationTime)
        maxExpirationTime = maxExpirationTimeDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let networkAccessConfigurationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.NetworkAccessConfiguration.self, forKey: .networkAccessConfiguration)
        networkAccessConfiguration = networkAccessConfigurationDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes a streaming session.
    public struct Session: Swift.Equatable {
        /// The authentication method. The user is authenticated using a streaming URL (API) or SAML 2.0 federation (SAML).
        public var authenticationType: AppStreamClientTypes.AuthenticationType?
        /// Specifies whether a user is connected to the streaming session.
        public var connectionState: AppStreamClientTypes.SessionConnectionState?
        /// The name of the fleet for the streaming session.
        /// This member is required.
        public var fleetName: Swift.String?
        /// The identifier of the streaming session.
        /// This member is required.
        public var id: Swift.String?
        /// The time when the streaming session is set to expire. This time is based on the MaxUserDurationinSeconds value, which determines the maximum length of time that a streaming session can run. A streaming session might end earlier than the time specified in SessionMaxExpirationTime, when the DisconnectTimeOutInSeconds elapses or the user chooses to end his or her session. If the DisconnectTimeOutInSeconds elapses, or the user chooses to end his or her session, the streaming instance is terminated and the streaming session ends.
        public var maxExpirationTime: ClientRuntime.Date?
        /// The network details for the streaming session.
        public var networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration?
        /// The name of the stack for the streaming session.
        /// This member is required.
        public var stackName: Swift.String?
        /// The time when a streaming instance is dedicated for the user.
        public var startTime: ClientRuntime.Date?
        /// The current state of the streaming session.
        /// This member is required.
        public var state: AppStreamClientTypes.SessionState?
        /// The identifier of the user for whom the session was created.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
            connectionState: AppStreamClientTypes.SessionConnectionState? = nil,
            fleetName: Swift.String? = nil,
            id: Swift.String? = nil,
            maxExpirationTime: ClientRuntime.Date? = nil,
            networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration? = nil,
            stackName: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: AppStreamClientTypes.SessionState? = nil,
            userId: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.connectionState = connectionState
            self.fleetName = fleetName
            self.id = id
            self.maxExpirationTime = maxExpirationTime
            self.networkAccessConfiguration = networkAccessConfiguration
            self.stackName = stackName
            self.startTime = startTime
            self.state = state
            self.userId = userId
        }
    }

}

extension AppStreamClientTypes {
    public enum SessionConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case notConnected
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionConnectionState] {
            return [
                .connected,
                .notConnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .notConnected: return "NOT_CONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionConnectionState(rawValue: rawValue) ?? SessionConnectionState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    /// Possible values for the state of a streaming session.
    public enum SessionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case expired
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionState] {
            return [
                .active,
                .expired,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .expired: return "EXPIRED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionState(rawValue: rawValue) ?? SessionState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.SharedImagePermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePermissions
        case sharedAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imagePermissions = self.imagePermissions {
            try encodeContainer.encode(imagePermissions, forKey: .imagePermissions)
        }
        if let sharedAccountId = self.sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
        let imagePermissionsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImagePermissions.self, forKey: .imagePermissions)
        imagePermissions = imagePermissionsDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the permissions that are available to the specified AWS account for a shared image.
    public struct SharedImagePermissions: Swift.Equatable {
        /// Describes the permissions for a shared image.
        /// This member is required.
        public var imagePermissions: AppStreamClientTypes.ImagePermissions?
        /// The 12-digit identifier of the AWS account with which the image is shared.
        /// This member is required.
        public var sharedAccountId: Swift.String?

        public init(
            imagePermissions: AppStreamClientTypes.ImagePermissions? = nil,
            sharedAccountId: Swift.String? = nil
        )
        {
            self.imagePermissions = imagePermissions
            self.sharedAccountId = sharedAccountId
        }
    }

}

extension AppStreamClientTypes.Stack: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case stackErrors = "StackErrors"
        case storageConnectors = "StorageConnectors"
        case streamingExperienceSettings = "StreamingExperienceSettings"
        case userSettings = "UserSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpoint0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpoint0)
            }
        }
        if let applicationSettings = self.applicationSettings {
            try encodeContainer.encode(applicationSettings, forKey: .applicationSettings)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let embedHostDomains = embedHostDomains {
            var embedHostDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .embedHostDomains)
            for embedhostdomain0 in embedHostDomains {
                try embedHostDomainsContainer.encode(embedhostdomain0)
            }
        }
        if let feedbackURL = self.feedbackURL {
            try encodeContainer.encode(feedbackURL, forKey: .feedbackURL)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let redirectURL = self.redirectURL {
            try encodeContainer.encode(redirectURL, forKey: .redirectURL)
        }
        if let stackErrors = stackErrors {
            var stackErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackErrors)
            for stackerror0 in stackErrors {
                try stackErrorsContainer.encode(stackerror0)
            }
        }
        if let storageConnectors = storageConnectors {
            var storageConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storageConnectors)
            for storageconnector0 in storageConnectors {
                try storageConnectorsContainer.encode(storageconnector0)
            }
        }
        if let streamingExperienceSettings = self.streamingExperienceSettings {
            try encodeContainer.encode(streamingExperienceSettings, forKey: .streamingExperienceSettings)
        }
        if let userSettings = userSettings {
            var userSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userSettings)
            for usersetting0 in userSettings {
                try userSettingsContainer.encode(usersetting0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let storageConnectorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.StorageConnector?].self, forKey: .storageConnectors)
        var storageConnectorsDecoded0:[AppStreamClientTypes.StorageConnector]? = nil
        if let storageConnectorsContainer = storageConnectorsContainer {
            storageConnectorsDecoded0 = [AppStreamClientTypes.StorageConnector]()
            for structure0 in storageConnectorsContainer {
                if let structure0 = structure0 {
                    storageConnectorsDecoded0?.append(structure0)
                }
            }
        }
        storageConnectors = storageConnectorsDecoded0
        let redirectURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectURL)
        redirectURL = redirectURLDecoded
        let feedbackURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feedbackURL)
        feedbackURL = feedbackURLDecoded
        let stackErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.StackError?].self, forKey: .stackErrors)
        var stackErrorsDecoded0:[AppStreamClientTypes.StackError]? = nil
        if let stackErrorsContainer = stackErrorsContainer {
            stackErrorsDecoded0 = [AppStreamClientTypes.StackError]()
            for structure0 in stackErrorsContainer {
                if let structure0 = structure0 {
                    stackErrorsDecoded0?.append(structure0)
                }
            }
        }
        stackErrors = stackErrorsDecoded0
        let userSettingsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserSetting?].self, forKey: .userSettings)
        var userSettingsDecoded0:[AppStreamClientTypes.UserSetting]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [AppStreamClientTypes.UserSetting]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let applicationSettingsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ApplicationSettingsResponse.self, forKey: .applicationSettings)
        applicationSettings = applicationSettingsDecoded
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
        let embedHostDomainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .embedHostDomains)
        var embedHostDomainsDecoded0:[Swift.String]? = nil
        if let embedHostDomainsContainer = embedHostDomainsContainer {
            embedHostDomainsDecoded0 = [Swift.String]()
            for string0 in embedHostDomainsContainer {
                if let string0 = string0 {
                    embedHostDomainsDecoded0?.append(string0)
                }
            }
        }
        embedHostDomains = embedHostDomainsDecoded0
        let streamingExperienceSettingsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StreamingExperienceSettings.self, forKey: .streamingExperienceSettings)
        streamingExperienceSettings = streamingExperienceSettingsDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes a stack.
    public struct Stack: Swift.Equatable {
        /// The list of virtual private cloud (VPC) interface endpoint objects. Users of the stack can connect to AppStream 2.0 only through the specified endpoints.
        public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
        /// The persistent application settings for users of the stack.
        public var applicationSettings: AppStreamClientTypes.ApplicationSettingsResponse?
        /// The ARN of the stack.
        public var arn: Swift.String?
        /// The time the stack was created.
        public var createdTime: ClientRuntime.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The stack name to display.
        public var displayName: Swift.String?
        /// The domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions.
        public var embedHostDomains: [Swift.String]?
        /// The URL that users are redirected to after they click the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.
        public var feedbackURL: Swift.String?
        /// The name of the stack.
        /// This member is required.
        public var name: Swift.String?
        /// The URL that users are redirected to after their streaming session ends.
        public var redirectURL: Swift.String?
        /// The errors for the stack.
        public var stackErrors: [AppStreamClientTypes.StackError]?
        /// The storage connectors to enable.
        public var storageConnectors: [AppStreamClientTypes.StorageConnector]?
        /// The streaming protocol you want your stack to prefer. This can be UDP or TCP. Currently, UDP is only supported in the Windows native client.
        public var streamingExperienceSettings: AppStreamClientTypes.StreamingExperienceSettings?
        /// The actions that are enabled or disabled for users during their streaming sessions. By default these actions are enabled.
        public var userSettings: [AppStreamClientTypes.UserSetting]?

        public init(
            accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
            applicationSettings: AppStreamClientTypes.ApplicationSettingsResponse? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            embedHostDomains: [Swift.String]? = nil,
            feedbackURL: Swift.String? = nil,
            name: Swift.String? = nil,
            redirectURL: Swift.String? = nil,
            stackErrors: [AppStreamClientTypes.StackError]? = nil,
            storageConnectors: [AppStreamClientTypes.StorageConnector]? = nil,
            streamingExperienceSettings: AppStreamClientTypes.StreamingExperienceSettings? = nil,
            userSettings: [AppStreamClientTypes.UserSetting]? = nil
        )
        {
            self.accessEndpoints = accessEndpoints
            self.applicationSettings = applicationSettings
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.embedHostDomains = embedHostDomains
            self.feedbackURL = feedbackURL
            self.name = name
            self.redirectURL = redirectURL
            self.stackErrors = stackErrors
            self.storageConnectors = storageConnectors
            self.streamingExperienceSettings = streamingExperienceSettings
            self.userSettings = userSettings
        }
    }

}

extension AppStreamClientTypes {
    public enum StackAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessEndpoints
        case embedHostDomains
        case feedbackUrl
        case iamRoleArn
        case redirectUrl
        case storageConnectors
        case storageConnectorGoogleDrive
        case storageConnectorHomefolders
        case storageConnectorOneDrive
        case streamingExperienceSettings
        case themeName
        case userSettings
        case sdkUnknown(Swift.String)

        public static var allCases: [StackAttribute] {
            return [
                .accessEndpoints,
                .embedHostDomains,
                .feedbackUrl,
                .iamRoleArn,
                .redirectUrl,
                .storageConnectors,
                .storageConnectorGoogleDrive,
                .storageConnectorHomefolders,
                .storageConnectorOneDrive,
                .streamingExperienceSettings,
                .themeName,
                .userSettings,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessEndpoints: return "ACCESS_ENDPOINTS"
            case .embedHostDomains: return "EMBED_HOST_DOMAINS"
            case .feedbackUrl: return "FEEDBACK_URL"
            case .iamRoleArn: return "IAM_ROLE_ARN"
            case .redirectUrl: return "REDIRECT_URL"
            case .storageConnectors: return "STORAGE_CONNECTORS"
            case .storageConnectorGoogleDrive: return "STORAGE_CONNECTOR_GOOGLE_DRIVE"
            case .storageConnectorHomefolders: return "STORAGE_CONNECTOR_HOMEFOLDERS"
            case .storageConnectorOneDrive: return "STORAGE_CONNECTOR_ONE_DRIVE"
            case .streamingExperienceSettings: return "STREAMING_EXPERIENCE_SETTINGS"
            case .themeName: return "THEME_NAME"
            case .userSettings: return "USER_SETTINGS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StackAttribute(rawValue: rawValue) ?? StackAttribute.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.StackError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StackErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes a stack error.
    public struct StackError: Swift.Equatable {
        /// The error code.
        public var errorCode: AppStreamClientTypes.StackErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?

        public init(
            errorCode: AppStreamClientTypes.StackErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension AppStreamClientTypes {
    public enum StackErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalServiceError
        case storageConnectorError
        case sdkUnknown(Swift.String)

        public static var allCases: [StackErrorCode] {
            return [
                .internalServiceError,
                .storageConnectorError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .storageConnectorError: return "STORAGE_CONNECTOR_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StackErrorCode(rawValue: rawValue) ?? StackErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension StartAppBlockBuilderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StartAppBlockBuilderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartAppBlockBuilderInput: Swift.Equatable {
    /// The name of the app block builder.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StartAppBlockBuilderInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension StartAppBlockBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StartAppBlockBuilderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartAppBlockBuilderOutputBody = try responseDecoder.decode(responseBody: data)
            self.appBlockBuilder = output.appBlockBuilder
        } else {
            self.appBlockBuilder = nil
        }
    }
}

public struct StartAppBlockBuilderOutput: Swift.Equatable {
    /// Describes an app block builder.
    public var appBlockBuilder: AppStreamClientTypes.AppBlockBuilder?

    public init(
        appBlockBuilder: AppStreamClientTypes.AppBlockBuilder? = nil
    )
    {
        self.appBlockBuilder = appBlockBuilder
    }
}

struct StartAppBlockBuilderOutputBody: Swift.Equatable {
    let appBlockBuilder: AppStreamClientTypes.AppBlockBuilder?
}

extension StartAppBlockBuilderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockBuilder = "AppBlockBuilder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlockBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppBlockBuilder.self, forKey: .appBlockBuilder)
        appBlockBuilder = appBlockBuilderDecoded
    }
}

enum StartAppBlockBuilderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestLimitExceededException": return try await RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotAvailableException": return try await ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StartFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StartFleetInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension StartFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StartFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartFleetOutput: Swift.Equatable {

    public init() { }
}

enum StartFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRoleException": return try await InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestLimitExceededException": return try await RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotAvailableException": return try await ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartImageBuilderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appstreamAgentVersion = self.appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StartImageBuilderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartImageBuilderInput: Swift.Equatable {
    /// The version of the AppStream 2.0 agent to use for this image builder. To use the latest version of the AppStream 2.0 agent, specify [LATEST].
    public var appstreamAgentVersion: Swift.String?
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?

    public init(
        appstreamAgentVersion: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appstreamAgentVersion = appstreamAgentVersion
        self.name = name
    }
}

struct StartImageBuilderInputBody: Swift.Equatable {
    let name: Swift.String?
    let appstreamAgentVersion: Swift.String?
}

extension StartImageBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
    }
}

extension StartImageBuilderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartImageBuilderOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct StartImageBuilderOutput: Swift.Equatable {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init(
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct StartImageBuilderOutputBody: Swift.Equatable {
    let imageBuilder: AppStreamClientTypes.ImageBuilder?
}

extension StartImageBuilderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

enum StartImageBuilderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncompatibleImageException": return try await IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotAvailableException": return try await ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopAppBlockBuilderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StopAppBlockBuilderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopAppBlockBuilderInput: Swift.Equatable {
    /// The name of the app block builder.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StopAppBlockBuilderInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension StopAppBlockBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StopAppBlockBuilderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopAppBlockBuilderOutputBody = try responseDecoder.decode(responseBody: data)
            self.appBlockBuilder = output.appBlockBuilder
        } else {
            self.appBlockBuilder = nil
        }
    }
}

public struct StopAppBlockBuilderOutput: Swift.Equatable {
    /// Describes an app block builder.
    public var appBlockBuilder: AppStreamClientTypes.AppBlockBuilder?

    public init(
        appBlockBuilder: AppStreamClientTypes.AppBlockBuilder? = nil
    )
    {
        self.appBlockBuilder = appBlockBuilder
    }
}

struct StopAppBlockBuilderOutputBody: Swift.Equatable {
    let appBlockBuilder: AppStreamClientTypes.AppBlockBuilder?
}

extension StopAppBlockBuilderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockBuilder = "AppBlockBuilder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlockBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppBlockBuilder.self, forKey: .appBlockBuilder)
        appBlockBuilder = appBlockBuilderDecoded
    }
}

enum StopAppBlockBuilderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StopFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StopFleetInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension StopFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StopFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopFleetOutput: Swift.Equatable {

    public init() { }
}

enum StopFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopImageBuilderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StopImageBuilderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopImageBuilderInput: Swift.Equatable {
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StopImageBuilderInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension StopImageBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StopImageBuilderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopImageBuilderOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct StopImageBuilderOutput: Swift.Equatable {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init(
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct StopImageBuilderOutputBody: Swift.Equatable {
    let imageBuilder: AppStreamClientTypes.ImageBuilder?
}

extension StopImageBuilderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

enum StopImageBuilderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppStreamClientTypes.StorageConnector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorType = "ConnectorType"
        case domains = "Domains"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorType = self.connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for domain0 in domains {
                try domainsContainer.encode(domain0)
            }
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StorageConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let domainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domains)
        var domainsDecoded0:[Swift.String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [Swift.String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
    }
}

extension AppStreamClientTypes {
    /// Describes a connector that enables persistent storage for users.
    public struct StorageConnector: Swift.Equatable {
        /// The type of storage connector.
        /// This member is required.
        public var connectorType: AppStreamClientTypes.StorageConnectorType?
        /// The names of the domains for the account.
        public var domains: [Swift.String]?
        /// The ARN of the storage connector.
        public var resourceIdentifier: Swift.String?

        public init(
            connectorType: AppStreamClientTypes.StorageConnectorType? = nil,
            domains: [Swift.String]? = nil,
            resourceIdentifier: Swift.String? = nil
        )
        {
            self.connectorType = connectorType
            self.domains = domains
            self.resourceIdentifier = resourceIdentifier
        }
    }

}

extension AppStreamClientTypes {
    /// The type of storage connector.
    public enum StorageConnectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case googleDrive
        case homefolders
        case oneDrive
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageConnectorType] {
            return [
                .googleDrive,
                .homefolders,
                .oneDrive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .googleDrive: return "GOOGLE_DRIVE"
            case .homefolders: return "HOMEFOLDERS"
            case .oneDrive: return "ONE_DRIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageConnectorType(rawValue: rawValue) ?? StorageConnectorType.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum StreamView: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case app
        case desktop
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamView] {
            return [
                .app,
                .desktop,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .app: return "APP"
            case .desktop: return "DESKTOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamView(rawValue: rawValue) ?? StreamView.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.StreamingExperienceSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preferredProtocol = "PreferredProtocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let preferredProtocol = self.preferredProtocol {
            try encodeContainer.encode(preferredProtocol.rawValue, forKey: .preferredProtocol)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preferredProtocolDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PreferredProtocol.self, forKey: .preferredProtocol)
        preferredProtocol = preferredProtocolDecoded
    }
}

extension AppStreamClientTypes {
    /// The streaming protocol you want your stack to prefer. This can be UDP or TCP. Currently, UDP is only supported in the Windows native client.
    public struct StreamingExperienceSettings: Swift.Equatable {
        /// The preferred protocol that you want to use while streaming your application.
        public var preferredProtocol: AppStreamClientTypes.PreferredProtocol?

        public init(
            preferredProtocol: AppStreamClientTypes.PreferredProtocol? = nil
        )
        {
            self.preferredProtocol = preferredProtocol
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to associate. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. If you do not specify a value, the value is set to an empty string. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys for the tags to disassociate.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAppBlockBuilderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case attributesToDelete = "AttributesToDelete"
        case description = "Description"
        case displayName = "DisplayName"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case instanceType = "InstanceType"
        case name = "Name"
        case platform = "Platform"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpoint0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpoint0)
            }
        }
        if let attributesToDelete = attributesToDelete {
            var attributesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributesToDelete)
            for appblockbuilderattribute0 in attributesToDelete {
                try attributesToDeleteContainer.encode(appblockbuilderattribute0.rawValue)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let enableDefaultInternetAccess = self.enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension UpdateAppBlockBuilderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAppBlockBuilderInput: Swift.Equatable {
    /// The list of interface VPC endpoint (interface endpoint) objects. Administrators can connect to the app block builder only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The attributes to delete from the app block builder.
    public var attributesToDelete: [AppStreamClientTypes.AppBlockBuilderAttribute]?
    /// The description of the app block builder.
    public var description: Swift.String?
    /// The display name of the app block builder.
    public var displayName: Swift.String?
    /// Enables or disables default internet access for the app block builder.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the app block builder. To assume a role, the app block builder calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The instance type to use when launching the app block builder. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.standard.xlarge
    ///
    /// * stream.standard.2xlarge
    public var instanceType: Swift.String?
    /// The unique name for the app block builder.
    /// This member is required.
    public var name: Swift.String?
    /// The platform of the app block builder. WINDOWS_SERVER_2019 is the only valid value.
    public var platform: AppStreamClientTypes.PlatformType?
    /// The VPC configuration for the app block builder. App block builders require that you specify at least two subnets in different availability zones.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init(
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        attributesToDelete: [AppStreamClientTypes.AppBlockBuilderAttribute]? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        iamRoleArn: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        name: Swift.String? = nil,
        platform: AppStreamClientTypes.PlatformType? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.attributesToDelete = attributesToDelete
        self.description = description
        self.displayName = displayName
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.iamRoleArn = iamRoleArn
        self.instanceType = instanceType
        self.name = name
        self.platform = platform
        self.vpcConfig = vpcConfig
    }
}

struct UpdateAppBlockBuilderInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let displayName: Swift.String?
    let platform: AppStreamClientTypes.PlatformType?
    let instanceType: Swift.String?
    let vpcConfig: AppStreamClientTypes.VpcConfig?
    let enableDefaultInternetAccess: Swift.Bool?
    let iamRoleArn: Swift.String?
    let accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    let attributesToDelete: [AppStreamClientTypes.AppBlockBuilderAttribute]?
}

extension UpdateAppBlockBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case attributesToDelete = "AttributesToDelete"
        case description = "Description"
        case displayName = "DisplayName"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case instanceType = "InstanceType"
        case name = "Name"
        case platform = "Platform"
        case vpcConfig = "VpcConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
        let attributesToDeleteContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AppBlockBuilderAttribute?].self, forKey: .attributesToDelete)
        var attributesToDeleteDecoded0:[AppStreamClientTypes.AppBlockBuilderAttribute]? = nil
        if let attributesToDeleteContainer = attributesToDeleteContainer {
            attributesToDeleteDecoded0 = [AppStreamClientTypes.AppBlockBuilderAttribute]()
            for enum0 in attributesToDeleteContainer {
                if let enum0 = enum0 {
                    attributesToDeleteDecoded0?.append(enum0)
                }
            }
        }
        attributesToDelete = attributesToDeleteDecoded0
    }
}

extension UpdateAppBlockBuilderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAppBlockBuilderOutputBody = try responseDecoder.decode(responseBody: data)
            self.appBlockBuilder = output.appBlockBuilder
        } else {
            self.appBlockBuilder = nil
        }
    }
}

public struct UpdateAppBlockBuilderOutput: Swift.Equatable {
    /// Describes an app block builder.
    public var appBlockBuilder: AppStreamClientTypes.AppBlockBuilder?

    public init(
        appBlockBuilder: AppStreamClientTypes.AppBlockBuilder? = nil
    )
    {
        self.appBlockBuilder = appBlockBuilder
    }
}

struct UpdateAppBlockBuilderOutputBody: Swift.Equatable {
    let appBlockBuilder: AppStreamClientTypes.AppBlockBuilder?
}

extension UpdateAppBlockBuilderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockBuilder = "AppBlockBuilder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlockBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppBlockBuilder.self, forKey: .appBlockBuilder)
        appBlockBuilder = appBlockBuilderDecoded
    }
}

enum UpdateAppBlockBuilderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRoleException": return try await InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestLimitExceededException": return try await RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotAvailableException": return try await ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case attributesToDelete = "AttributesToDelete"
        case description = "Description"
        case displayName = "DisplayName"
        case iconS3Location = "IconS3Location"
        case launchParameters = "LaunchParameters"
        case launchPath = "LaunchPath"
        case name = "Name"
        case workingDirectory = "WorkingDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBlockArn = self.appBlockArn {
            try encodeContainer.encode(appBlockArn, forKey: .appBlockArn)
        }
        if let attributesToDelete = attributesToDelete {
            var attributesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributesToDelete)
            for applicationattribute0 in attributesToDelete {
                try attributesToDeleteContainer.encode(applicationattribute0.rawValue)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let iconS3Location = self.iconS3Location {
            try encodeContainer.encode(iconS3Location, forKey: .iconS3Location)
        }
        if let launchParameters = self.launchParameters {
            try encodeContainer.encode(launchParameters, forKey: .launchParameters)
        }
        if let launchPath = self.launchPath {
            try encodeContainer.encode(launchPath, forKey: .launchPath)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let workingDirectory = self.workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// The ARN of the app block.
    public var appBlockArn: Swift.String?
    /// The attributes to delete for an application.
    public var attributesToDelete: [AppStreamClientTypes.ApplicationAttribute]?
    /// The description of the application.
    public var description: Swift.String?
    /// The display name of the application. This name is visible to users in the application catalog.
    public var displayName: Swift.String?
    /// The icon S3 location of the application.
    public var iconS3Location: AppStreamClientTypes.S3Location?
    /// The launch parameters of the application.
    public var launchParameters: Swift.String?
    /// The launch path of the application.
    public var launchPath: Swift.String?
    /// The name of the application. This name is visible to users when display name is not specified.
    /// This member is required.
    public var name: Swift.String?
    /// The working directory of the application.
    public var workingDirectory: Swift.String?

    public init(
        appBlockArn: Swift.String? = nil,
        attributesToDelete: [AppStreamClientTypes.ApplicationAttribute]? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        iconS3Location: AppStreamClientTypes.S3Location? = nil,
        launchParameters: Swift.String? = nil,
        launchPath: Swift.String? = nil,
        name: Swift.String? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.appBlockArn = appBlockArn
        self.attributesToDelete = attributesToDelete
        self.description = description
        self.displayName = displayName
        self.iconS3Location = iconS3Location
        self.launchParameters = launchParameters
        self.launchPath = launchPath
        self.name = name
        self.workingDirectory = workingDirectory
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
    let iconS3Location: AppStreamClientTypes.S3Location?
    let launchPath: Swift.String?
    let workingDirectory: Swift.String?
    let launchParameters: Swift.String?
    let appBlockArn: Swift.String?
    let attributesToDelete: [AppStreamClientTypes.ApplicationAttribute]?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case attributesToDelete = "AttributesToDelete"
        case description = "Description"
        case displayName = "DisplayName"
        case iconS3Location = "IconS3Location"
        case launchParameters = "LaunchParameters"
        case launchPath = "LaunchPath"
        case name = "Name"
        case workingDirectory = "WorkingDirectory"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let iconS3LocationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.S3Location.self, forKey: .iconS3Location)
        iconS3Location = iconS3LocationDecoded
        let launchPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchPath)
        launchPath = launchPathDecoded
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let launchParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchParameters)
        launchParameters = launchParametersDecoded
        let appBlockArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBlockArn)
        appBlockArn = appBlockArnDecoded
        let attributesToDeleteContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.ApplicationAttribute?].self, forKey: .attributesToDelete)
        var attributesToDeleteDecoded0:[AppStreamClientTypes.ApplicationAttribute]? = nil
        if let attributesToDeleteContainer = attributesToDeleteContainer {
            attributesToDeleteDecoded0 = [AppStreamClientTypes.ApplicationAttribute]()
            for enum0 in attributesToDeleteContainer {
                if let enum0 = enum0 {
                    attributesToDeleteDecoded0?.append(enum0)
                }
            }
        }
        attributesToDelete = attributesToDeleteDecoded0
    }
}

extension UpdateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct UpdateApplicationOutput: Swift.Equatable {
    /// Describes an application in the application catalog.
    public var application: AppStreamClientTypes.Application?

    public init(
        application: AppStreamClientTypes.Application? = nil
    )
    {
        self.application = application
    }
}

struct UpdateApplicationOutputBody: Swift.Equatable {
    let application: AppStreamClientTypes.Application?
}

extension UpdateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application = "Application"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
    }
}

enum UpdateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDirectoryConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBasedAuthProperties = "CertificateBasedAuthProperties"
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateBasedAuthProperties = self.certificateBasedAuthProperties {
            try encodeContainer.encode(certificateBasedAuthProperties, forKey: .certificateBasedAuthProperties)
        }
        if let directoryName = self.directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames {
            var organizationalUnitDistinguishedNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitDistinguishedNames)
            for organizationalunitdistinguishedname0 in organizationalUnitDistinguishedNames {
                try organizationalUnitDistinguishedNamesContainer.encode(organizationalunitdistinguishedname0)
            }
        }
        if let serviceAccountCredentials = self.serviceAccountCredentials {
            try encodeContainer.encode(serviceAccountCredentials, forKey: .serviceAccountCredentials)
        }
    }
}

extension UpdateDirectoryConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDirectoryConfigInput: Swift.Equatable {
    /// The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory domain-joined streaming instances. Fallback is turned on by default when certificate-based authentication is Enabled . Fallback allows users to log in using their AD domain password if certificate-based authentication is unsuccessful, or to unlock a desktop lock screen. Enabled_no_directory_login_fallback enables certificate-based authentication, but does not allow users to log in using their AD domain password. Users will be disconnected to re-authenticate using certificates.
    public var certificateBasedAuthProperties: AppStreamClientTypes.CertificateBasedAuthProperties?
    /// The name of the Directory Config object.
    /// This member is required.
    public var directoryName: Swift.String?
    /// The distinguished names of the organizational units for computer accounts.
    public var organizationalUnitDistinguishedNames: [Swift.String]?
    /// The credentials for the service account used by the fleet or image builder to connect to the directory.
    public var serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?

    public init(
        certificateBasedAuthProperties: AppStreamClientTypes.CertificateBasedAuthProperties? = nil,
        directoryName: Swift.String? = nil,
        organizationalUnitDistinguishedNames: [Swift.String]? = nil,
        serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials? = nil
    )
    {
        self.certificateBasedAuthProperties = certificateBasedAuthProperties
        self.directoryName = directoryName
        self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
        self.serviceAccountCredentials = serviceAccountCredentials
    }
}

struct UpdateDirectoryConfigInputBody: Swift.Equatable {
    let directoryName: Swift.String?
    let organizationalUnitDistinguishedNames: [Swift.String]?
    let serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?
    let certificateBasedAuthProperties: AppStreamClientTypes.CertificateBasedAuthProperties?
}

extension UpdateDirectoryConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBasedAuthProperties = "CertificateBasedAuthProperties"
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitDistinguishedNames)
        var organizationalUnitDistinguishedNamesDecoded0:[Swift.String]? = nil
        if let organizationalUnitDistinguishedNamesContainer = organizationalUnitDistinguishedNamesContainer {
            organizationalUnitDistinguishedNamesDecoded0 = [Swift.String]()
            for string0 in organizationalUnitDistinguishedNamesContainer {
                if let string0 = string0 {
                    organizationalUnitDistinguishedNamesDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNamesDecoded0
        let serviceAccountCredentialsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ServiceAccountCredentials.self, forKey: .serviceAccountCredentials)
        serviceAccountCredentials = serviceAccountCredentialsDecoded
        let certificateBasedAuthPropertiesDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.CertificateBasedAuthProperties.self, forKey: .certificateBasedAuthProperties)
        certificateBasedAuthProperties = certificateBasedAuthPropertiesDecoded
    }
}

extension UpdateDirectoryConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDirectoryConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.directoryConfig = output.directoryConfig
        } else {
            self.directoryConfig = nil
        }
    }
}

public struct UpdateDirectoryConfigOutput: Swift.Equatable {
    /// Information about the Directory Config object.
    public var directoryConfig: AppStreamClientTypes.DirectoryConfig?

    public init(
        directoryConfig: AppStreamClientTypes.DirectoryConfig? = nil
    )
    {
        self.directoryConfig = directoryConfig
    }
}

struct UpdateDirectoryConfigOutputBody: Swift.Equatable {
    let directoryConfig: AppStreamClientTypes.DirectoryConfig?
}

extension UpdateDirectoryConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryConfig = "DirectoryConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DirectoryConfig.self, forKey: .directoryConfig)
        directoryConfig = directoryConfigDecoded
    }
}

enum UpdateDirectoryConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRoleException": return try await InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEntitlementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appVisibility = "AppVisibility"
        case attributes = "Attributes"
        case description = "Description"
        case name = "Name"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appVisibility = self.appVisibility {
            try encodeContainer.encode(appVisibility.rawValue, forKey: .appVisibility)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for entitlementattribute0 in attributes {
                try attributesContainer.encode(entitlementattribute0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

extension UpdateEntitlementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEntitlementInput: Swift.Equatable {
    /// Specifies whether all or only selected apps are entitled.
    public var appVisibility: AppStreamClientTypes.AppVisibility?
    /// The attributes of the entitlement.
    public var attributes: [AppStreamClientTypes.EntitlementAttribute]?
    /// The description of the entitlement.
    public var description: Swift.String?
    /// The name of the entitlement.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the stack with which the entitlement is associated.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        appVisibility: AppStreamClientTypes.AppVisibility? = nil,
        attributes: [AppStreamClientTypes.EntitlementAttribute]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.appVisibility = appVisibility
        self.attributes = attributes
        self.description = description
        self.name = name
        self.stackName = stackName
    }
}

struct UpdateEntitlementInputBody: Swift.Equatable {
    let name: Swift.String?
    let stackName: Swift.String?
    let description: Swift.String?
    let appVisibility: AppStreamClientTypes.AppVisibility?
    let attributes: [AppStreamClientTypes.EntitlementAttribute]?
}

extension UpdateEntitlementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appVisibility = "AppVisibility"
        case attributes = "Attributes"
        case description = "Description"
        case name = "Name"
        case stackName = "StackName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let appVisibilityDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppVisibility.self, forKey: .appVisibility)
        appVisibility = appVisibilityDecoded
        let attributesContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.EntitlementAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[AppStreamClientTypes.EntitlementAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [AppStreamClientTypes.EntitlementAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension UpdateEntitlementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEntitlementOutputBody = try responseDecoder.decode(responseBody: data)
            self.entitlement = output.entitlement
        } else {
            self.entitlement = nil
        }
    }
}

public struct UpdateEntitlementOutput: Swift.Equatable {
    /// The entitlement.
    public var entitlement: AppStreamClientTypes.Entitlement?

    public init(
        entitlement: AppStreamClientTypes.Entitlement? = nil
    )
    {
        self.entitlement = entitlement
    }
}

struct UpdateEntitlementOutputBody: Swift.Equatable {
    let entitlement: AppStreamClientTypes.Entitlement?
}

extension UpdateEntitlementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlement = "Entitlement"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Entitlement.self, forKey: .entitlement)
        entitlement = entitlementDecoded
    }
}

enum UpdateEntitlementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntitlementNotFoundException": return try await EntitlementNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributesToDelete = "AttributesToDelete"
        case computeCapacity = "ComputeCapacity"
        case deleteVpcConfig = "DeleteVpcConfig"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxConcurrentSessions = "MaxConcurrentSessions"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case platform = "Platform"
        case sessionScriptS3Location = "SessionScriptS3Location"
        case streamView = "StreamView"
        case usbDeviceFilterStrings = "UsbDeviceFilterStrings"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributesToDelete = attributesToDelete {
            var attributesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributesToDelete)
            for fleetattribute0 in attributesToDelete {
                try attributesToDeleteContainer.encode(fleetattribute0.rawValue)
            }
        }
        if let computeCapacity = self.computeCapacity {
            try encodeContainer.encode(computeCapacity, forKey: .computeCapacity)
        }
        if let deleteVpcConfig = self.deleteVpcConfig {
            try encodeContainer.encode(deleteVpcConfig, forKey: .deleteVpcConfig)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disconnectTimeoutInSeconds = self.disconnectTimeoutInSeconds {
            try encodeContainer.encode(disconnectTimeoutInSeconds, forKey: .disconnectTimeoutInSeconds)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = self.domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = self.enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idleDisconnectTimeoutInSeconds = self.idleDisconnectTimeoutInSeconds {
            try encodeContainer.encode(idleDisconnectTimeoutInSeconds, forKey: .idleDisconnectTimeoutInSeconds)
        }
        if let imageArn = self.imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = self.imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let maxConcurrentSessions = self.maxConcurrentSessions {
            try encodeContainer.encode(maxConcurrentSessions, forKey: .maxConcurrentSessions)
        }
        if let maxUserDurationInSeconds = self.maxUserDurationInSeconds {
            try encodeContainer.encode(maxUserDurationInSeconds, forKey: .maxUserDurationInSeconds)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let sessionScriptS3Location = self.sessionScriptS3Location {
            try encodeContainer.encode(sessionScriptS3Location, forKey: .sessionScriptS3Location)
        }
        if let streamView = self.streamView {
            try encodeContainer.encode(streamView.rawValue, forKey: .streamView)
        }
        if let usbDeviceFilterStrings = usbDeviceFilterStrings {
            var usbDeviceFilterStringsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usbDeviceFilterStrings)
            for usbdevicefilterstring0 in usbDeviceFilterStrings {
                try usbDeviceFilterStringsContainer.encode(usbdevicefilterstring0)
            }
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension UpdateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateFleetInput: Swift.Equatable {
    /// The fleet attributes to delete.
    public var attributesToDelete: [AppStreamClientTypes.FleetAttribute]?
    /// The desired capacity for the fleet. This is not allowed for Elastic fleets.
    public var computeCapacity: AppStreamClientTypes.ComputeCapacity?
    /// Deletes the VPC association for the specified fleet.
    @available(*, deprecated)
    public var deleteVpcConfig: Swift.Bool?
    /// The description to display.
    public var description: Swift.String?
    /// The amount of time that a streaming session remains active after users disconnect. If users try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance. Specify a value between 60 and 360000.
    public var disconnectTimeoutInSeconds: Swift.Int?
    /// The fleet name to display.
    public var displayName: Swift.String?
    /// The name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain.
    public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    /// Enables or disables default internet access for the fleet.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the fleet. To assume a role, a fleet instance calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the DisconnectTimeoutInSeconds time interval begins. Users are notified before they are disconnected due to inactivity. If users try to reconnect to the streaming session before the time interval specified in DisconnectTimeoutInSeconds elapses, they are connected to their previous session. Users are considered idle when they stop providing keyboard or mouse input during their streaming session. File uploads and downloads, audio in, audio out, and pixels changing do not qualify as user activity. If users continue to be idle after the time interval in IdleDisconnectTimeoutInSeconds elapses, they are disconnected. To prevent users from being disconnected due to inactivity, specify a value of 0. Otherwise, specify a value between 60 and 3600. The default value is 0. If you enable this feature, we recommend that you specify a value that corresponds exactly to a whole number of minutes (for example, 60, 120, and 180). If you don't do this, the value is rounded to the nearest minute. For example, if you specify a value of 70, users are disconnected after 1 minute of inactivity. If you specify a value that is at the midpoint between two different minutes, the value is rounded up. For example, if you specify a value of 90, users are disconnected after 2 minutes of inactivity.
    public var idleDisconnectTimeoutInSeconds: Swift.Int?
    /// The ARN of the public, private, or shared image to use.
    public var imageArn: Swift.String?
    /// The name of the image used to create the fleet.
    public var imageName: Swift.String?
    /// The instance type to use when launching fleet instances. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.standard.xlarge
    ///
    /// * stream.standard.2xlarge
    ///
    /// * stream.compute.large
    ///
    /// * stream.compute.xlarge
    ///
    /// * stream.compute.2xlarge
    ///
    /// * stream.compute.4xlarge
    ///
    /// * stream.compute.8xlarge
    ///
    /// * stream.memory.large
    ///
    /// * stream.memory.xlarge
    ///
    /// * stream.memory.2xlarge
    ///
    /// * stream.memory.4xlarge
    ///
    /// * stream.memory.8xlarge
    ///
    /// * stream.memory.z1d.large
    ///
    /// * stream.memory.z1d.xlarge
    ///
    /// * stream.memory.z1d.2xlarge
    ///
    /// * stream.memory.z1d.3xlarge
    ///
    /// * stream.memory.z1d.6xlarge
    ///
    /// * stream.memory.z1d.12xlarge
    ///
    /// * stream.graphics-design.large
    ///
    /// * stream.graphics-design.xlarge
    ///
    /// * stream.graphics-design.2xlarge
    ///
    /// * stream.graphics-design.4xlarge
    ///
    /// * stream.graphics-desktop.2xlarge
    ///
    /// * stream.graphics.g4dn.xlarge
    ///
    /// * stream.graphics.g4dn.2xlarge
    ///
    /// * stream.graphics.g4dn.4xlarge
    ///
    /// * stream.graphics.g4dn.8xlarge
    ///
    /// * stream.graphics.g4dn.12xlarge
    ///
    /// * stream.graphics.g4dn.16xlarge
    ///
    /// * stream.graphics-pro.4xlarge
    ///
    /// * stream.graphics-pro.8xlarge
    ///
    /// * stream.graphics-pro.16xlarge
    ///
    ///
    /// The following instance types are available for Elastic fleets:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.standard.xlarge
    ///
    /// * stream.standard.2xlarge
    public var instanceType: Swift.String?
    /// The maximum number of concurrent sessions for a fleet.
    public var maxConcurrentSessions: Swift.Int?
    /// The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance. Specify a value between 600 and 432000.
    public var maxUserDurationInSeconds: Swift.Int?
    /// A unique name for the fleet.
    public var name: Swift.String?
    /// The platform of the fleet. WINDOWS_SERVER_2019 and AMAZON_LINUX2 are supported for Elastic fleets.
    public var platform: AppStreamClientTypes.PlatformType?
    /// The S3 location of the session scripts configuration zip file. This only applies to Elastic fleets.
    public var sessionScriptS3Location: AppStreamClientTypes.S3Location?
    /// The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When APP is specified, only the windows of applications opened by users display. When DESKTOP is specified, the standard desktop that is provided by the operating system displays. The default value is APP.
    public var streamView: AppStreamClientTypes.StreamView?
    /// The USB device filter strings that specify which USB devices a user can redirect to the fleet streaming session, when using the Windows native client. This is allowed but not required for Elastic fleets.
    public var usbDeviceFilterStrings: [Swift.String]?
    /// The VPC configuration for the fleet. This is required for Elastic fleets, but not required for other fleet types. Elastic fleets require that you specify at least two subnets in different availability zones.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init(
        attributesToDelete: [AppStreamClientTypes.FleetAttribute]? = nil,
        computeCapacity: AppStreamClientTypes.ComputeCapacity? = nil,
        deleteVpcConfig: Swift.Bool? = nil,
        description: Swift.String? = nil,
        disconnectTimeoutInSeconds: Swift.Int? = nil,
        displayName: Swift.String? = nil,
        domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        iamRoleArn: Swift.String? = nil,
        idleDisconnectTimeoutInSeconds: Swift.Int? = nil,
        imageArn: Swift.String? = nil,
        imageName: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        maxConcurrentSessions: Swift.Int? = nil,
        maxUserDurationInSeconds: Swift.Int? = nil,
        name: Swift.String? = nil,
        platform: AppStreamClientTypes.PlatformType? = nil,
        sessionScriptS3Location: AppStreamClientTypes.S3Location? = nil,
        streamView: AppStreamClientTypes.StreamView? = nil,
        usbDeviceFilterStrings: [Swift.String]? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.attributesToDelete = attributesToDelete
        self.computeCapacity = computeCapacity
        self.deleteVpcConfig = deleteVpcConfig
        self.description = description
        self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.iamRoleArn = iamRoleArn
        self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.maxConcurrentSessions = maxConcurrentSessions
        self.maxUserDurationInSeconds = maxUserDurationInSeconds
        self.name = name
        self.platform = platform
        self.sessionScriptS3Location = sessionScriptS3Location
        self.streamView = streamView
        self.usbDeviceFilterStrings = usbDeviceFilterStrings
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFleetInputBody: Swift.Equatable {
    let imageName: Swift.String?
    let imageArn: Swift.String?
    let name: Swift.String?
    let instanceType: Swift.String?
    let computeCapacity: AppStreamClientTypes.ComputeCapacity?
    let vpcConfig: AppStreamClientTypes.VpcConfig?
    let maxUserDurationInSeconds: Swift.Int?
    let disconnectTimeoutInSeconds: Swift.Int?
    let deleteVpcConfig: Swift.Bool?
    let description: Swift.String?
    let displayName: Swift.String?
    let enableDefaultInternetAccess: Swift.Bool?
    let domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    let idleDisconnectTimeoutInSeconds: Swift.Int?
    let attributesToDelete: [AppStreamClientTypes.FleetAttribute]?
    let iamRoleArn: Swift.String?
    let streamView: AppStreamClientTypes.StreamView?
    let platform: AppStreamClientTypes.PlatformType?
    let maxConcurrentSessions: Swift.Int?
    let usbDeviceFilterStrings: [Swift.String]?
    let sessionScriptS3Location: AppStreamClientTypes.S3Location?
}

extension UpdateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributesToDelete = "AttributesToDelete"
        case computeCapacity = "ComputeCapacity"
        case deleteVpcConfig = "DeleteVpcConfig"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxConcurrentSessions = "MaxConcurrentSessions"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case platform = "Platform"
        case sessionScriptS3Location = "SessionScriptS3Location"
        case streamView = "StreamView"
        case usbDeviceFilterStrings = "UsbDeviceFilterStrings"
        case vpcConfig = "VpcConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let computeCapacityDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ComputeCapacity.self, forKey: .computeCapacity)
        computeCapacity = computeCapacityDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let maxUserDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxUserDurationInSeconds)
        maxUserDurationInSeconds = maxUserDurationInSecondsDecoded
        let disconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInSeconds)
        disconnectTimeoutInSeconds = disconnectTimeoutInSecondsDecoded
        let deleteVpcConfigDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteVpcConfig)
        deleteVpcConfig = deleteVpcConfigDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let idleDisconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInSeconds)
        idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSecondsDecoded
        let attributesToDeleteContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.FleetAttribute?].self, forKey: .attributesToDelete)
        var attributesToDeleteDecoded0:[AppStreamClientTypes.FleetAttribute]? = nil
        if let attributesToDeleteContainer = attributesToDeleteContainer {
            attributesToDeleteDecoded0 = [AppStreamClientTypes.FleetAttribute]()
            for enum0 in attributesToDeleteContainer {
                if let enum0 = enum0 {
                    attributesToDeleteDecoded0?.append(enum0)
                }
            }
        }
        attributesToDelete = attributesToDeleteDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let streamViewDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StreamView.self, forKey: .streamView)
        streamView = streamViewDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let maxConcurrentSessionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConcurrentSessions)
        maxConcurrentSessions = maxConcurrentSessionsDecoded
        let usbDeviceFilterStringsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usbDeviceFilterStrings)
        var usbDeviceFilterStringsDecoded0:[Swift.String]? = nil
        if let usbDeviceFilterStringsContainer = usbDeviceFilterStringsContainer {
            usbDeviceFilterStringsDecoded0 = [Swift.String]()
            for string0 in usbDeviceFilterStringsContainer {
                if let string0 = string0 {
                    usbDeviceFilterStringsDecoded0?.append(string0)
                }
            }
        }
        usbDeviceFilterStrings = usbDeviceFilterStringsDecoded0
        let sessionScriptS3LocationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.S3Location.self, forKey: .sessionScriptS3Location)
        sessionScriptS3Location = sessionScriptS3LocationDecoded
    }
}

extension UpdateFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.fleet = output.fleet
        } else {
            self.fleet = nil
        }
    }
}

public struct UpdateFleetOutput: Swift.Equatable {
    /// Information about the fleet.
    public var fleet: AppStreamClientTypes.Fleet?

    public init(
        fleet: AppStreamClientTypes.Fleet? = nil
    )
    {
        self.fleet = fleet
    }
}

struct UpdateFleetOutputBody: Swift.Equatable {
    let fleet: AppStreamClientTypes.Fleet?
}

extension UpdateFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet = "Fleet"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Fleet.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

enum UpdateFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncompatibleImageException": return try await IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRoleException": return try await InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestLimitExceededException": return try await RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotAvailableException": return try await ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateImagePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePermissions = "ImagePermissions"
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imagePermissions = self.imagePermissions {
            try encodeContainer.encode(imagePermissions, forKey: .imagePermissions)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sharedAccountId = self.sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }
}

extension UpdateImagePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateImagePermissionsInput: Swift.Equatable {
    /// The permissions for the image.
    /// This member is required.
    public var imagePermissions: AppStreamClientTypes.ImagePermissions?
    /// The name of the private image.
    /// This member is required.
    public var name: Swift.String?
    /// The 12-digit identifier of the AWS account for which you want add or update image permissions.
    /// This member is required.
    public var sharedAccountId: Swift.String?

    public init(
        imagePermissions: AppStreamClientTypes.ImagePermissions? = nil,
        name: Swift.String? = nil,
        sharedAccountId: Swift.String? = nil
    )
    {
        self.imagePermissions = imagePermissions
        self.name = name
        self.sharedAccountId = sharedAccountId
    }
}

struct UpdateImagePermissionsInputBody: Swift.Equatable {
    let name: Swift.String?
    let sharedAccountId: Swift.String?
    let imagePermissions: AppStreamClientTypes.ImagePermissions?
}

extension UpdateImagePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePermissions = "ImagePermissions"
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
        let imagePermissionsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImagePermissions.self, forKey: .imagePermissions)
        imagePermissions = imagePermissionsDecoded
    }
}

extension UpdateImagePermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateImagePermissionsOutput: Swift.Equatable {

    public init() { }
}

enum UpdateImagePermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotAvailableException": return try await ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case attributesToDelete = "AttributesToDelete"
        case deleteStorageConnectors = "DeleteStorageConnectors"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case streamingExperienceSettings = "StreamingExperienceSettings"
        case userSettings = "UserSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpoint0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpoint0)
            }
        }
        if let applicationSettings = self.applicationSettings {
            try encodeContainer.encode(applicationSettings, forKey: .applicationSettings)
        }
        if let attributesToDelete = attributesToDelete {
            var attributesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributesToDelete)
            for stackattribute0 in attributesToDelete {
                try attributesToDeleteContainer.encode(stackattribute0.rawValue)
            }
        }
        if let deleteStorageConnectors = self.deleteStorageConnectors {
            try encodeContainer.encode(deleteStorageConnectors, forKey: .deleteStorageConnectors)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let embedHostDomains = embedHostDomains {
            var embedHostDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .embedHostDomains)
            for embedhostdomain0 in embedHostDomains {
                try embedHostDomainsContainer.encode(embedhostdomain0)
            }
        }
        if let feedbackURL = self.feedbackURL {
            try encodeContainer.encode(feedbackURL, forKey: .feedbackURL)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let redirectURL = self.redirectURL {
            try encodeContainer.encode(redirectURL, forKey: .redirectURL)
        }
        if let storageConnectors = storageConnectors {
            var storageConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storageConnectors)
            for storageconnector0 in storageConnectors {
                try storageConnectorsContainer.encode(storageconnector0)
            }
        }
        if let streamingExperienceSettings = self.streamingExperienceSettings {
            try encodeContainer.encode(streamingExperienceSettings, forKey: .streamingExperienceSettings)
        }
        if let userSettings = userSettings {
            var userSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userSettings)
            for usersetting0 in userSettings {
                try userSettingsContainer.encode(usersetting0)
            }
        }
    }
}

extension UpdateStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateStackInput: Swift.Equatable {
    /// The list of interface VPC endpoint (interface endpoint) objects. Users of the stack can connect to AppStream 2.0 only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The persistent application settings for users of a stack. When these settings are enabled, changes that users make to applications and Windows settings are automatically saved after each session and applied to the next session.
    public var applicationSettings: AppStreamClientTypes.ApplicationSettings?
    /// The stack attributes to delete.
    public var attributesToDelete: [AppStreamClientTypes.StackAttribute]?
    /// Deletes the storage connectors currently enabled for the stack.
    @available(*, deprecated)
    public var deleteStorageConnectors: Swift.Bool?
    /// The description to display.
    public var description: Swift.String?
    /// The stack name to display.
    public var displayName: Swift.String?
    /// The domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions.
    public var embedHostDomains: [Swift.String]?
    /// The URL that users are redirected to after they choose the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.
    public var feedbackURL: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var name: Swift.String?
    /// The URL that users are redirected to after their streaming session ends.
    public var redirectURL: Swift.String?
    /// The storage connectors to enable.
    public var storageConnectors: [AppStreamClientTypes.StorageConnector]?
    /// The streaming protocol you want your stack to prefer. This can be UDP or TCP. Currently, UDP is only supported in the Windows native client.
    public var streamingExperienceSettings: AppStreamClientTypes.StreamingExperienceSettings?
    /// The actions that are enabled or disabled for users during their streaming sessions. By default, these actions are enabled.
    public var userSettings: [AppStreamClientTypes.UserSetting]?

    public init(
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        applicationSettings: AppStreamClientTypes.ApplicationSettings? = nil,
        attributesToDelete: [AppStreamClientTypes.StackAttribute]? = nil,
        deleteStorageConnectors: Swift.Bool? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        embedHostDomains: [Swift.String]? = nil,
        feedbackURL: Swift.String? = nil,
        name: Swift.String? = nil,
        redirectURL: Swift.String? = nil,
        storageConnectors: [AppStreamClientTypes.StorageConnector]? = nil,
        streamingExperienceSettings: AppStreamClientTypes.StreamingExperienceSettings? = nil,
        userSettings: [AppStreamClientTypes.UserSetting]? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.applicationSettings = applicationSettings
        self.attributesToDelete = attributesToDelete
        self.deleteStorageConnectors = deleteStorageConnectors
        self.description = description
        self.displayName = displayName
        self.embedHostDomains = embedHostDomains
        self.feedbackURL = feedbackURL
        self.name = name
        self.redirectURL = redirectURL
        self.storageConnectors = storageConnectors
        self.streamingExperienceSettings = streamingExperienceSettings
        self.userSettings = userSettings
    }
}

struct UpdateStackInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let name: Swift.String?
    let storageConnectors: [AppStreamClientTypes.StorageConnector]?
    let deleteStorageConnectors: Swift.Bool?
    let redirectURL: Swift.String?
    let feedbackURL: Swift.String?
    let attributesToDelete: [AppStreamClientTypes.StackAttribute]?
    let userSettings: [AppStreamClientTypes.UserSetting]?
    let applicationSettings: AppStreamClientTypes.ApplicationSettings?
    let accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    let embedHostDomains: [Swift.String]?
    let streamingExperienceSettings: AppStreamClientTypes.StreamingExperienceSettings?
}

extension UpdateStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case attributesToDelete = "AttributesToDelete"
        case deleteStorageConnectors = "DeleteStorageConnectors"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case streamingExperienceSettings = "StreamingExperienceSettings"
        case userSettings = "UserSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let storageConnectorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.StorageConnector?].self, forKey: .storageConnectors)
        var storageConnectorsDecoded0:[AppStreamClientTypes.StorageConnector]? = nil
        if let storageConnectorsContainer = storageConnectorsContainer {
            storageConnectorsDecoded0 = [AppStreamClientTypes.StorageConnector]()
            for structure0 in storageConnectorsContainer {
                if let structure0 = structure0 {
                    storageConnectorsDecoded0?.append(structure0)
                }
            }
        }
        storageConnectors = storageConnectorsDecoded0
        let deleteStorageConnectorsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteStorageConnectors)
        deleteStorageConnectors = deleteStorageConnectorsDecoded
        let redirectURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectURL)
        redirectURL = redirectURLDecoded
        let feedbackURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feedbackURL)
        feedbackURL = feedbackURLDecoded
        let attributesToDeleteContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.StackAttribute?].self, forKey: .attributesToDelete)
        var attributesToDeleteDecoded0:[AppStreamClientTypes.StackAttribute]? = nil
        if let attributesToDeleteContainer = attributesToDeleteContainer {
            attributesToDeleteDecoded0 = [AppStreamClientTypes.StackAttribute]()
            for enum0 in attributesToDeleteContainer {
                if let enum0 = enum0 {
                    attributesToDeleteDecoded0?.append(enum0)
                }
            }
        }
        attributesToDelete = attributesToDeleteDecoded0
        let userSettingsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserSetting?].self, forKey: .userSettings)
        var userSettingsDecoded0:[AppStreamClientTypes.UserSetting]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [AppStreamClientTypes.UserSetting]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let applicationSettingsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ApplicationSettings.self, forKey: .applicationSettings)
        applicationSettings = applicationSettingsDecoded
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
        let embedHostDomainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .embedHostDomains)
        var embedHostDomainsDecoded0:[Swift.String]? = nil
        if let embedHostDomainsContainer = embedHostDomainsContainer {
            embedHostDomainsDecoded0 = [Swift.String]()
            for string0 in embedHostDomainsContainer {
                if let string0 = string0 {
                    embedHostDomainsDecoded0?.append(string0)
                }
            }
        }
        embedHostDomains = embedHostDomainsDecoded0
        let streamingExperienceSettingsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StreamingExperienceSettings.self, forKey: .streamingExperienceSettings)
        streamingExperienceSettings = streamingExperienceSettingsDecoded
    }
}

extension UpdateStackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateStackOutputBody = try responseDecoder.decode(responseBody: data)
            self.stack = output.stack
        } else {
            self.stack = nil
        }
    }
}

public struct UpdateStackOutput: Swift.Equatable {
    /// Information about the stack.
    public var stack: AppStreamClientTypes.Stack?

    public init(
        stack: AppStreamClientTypes.Stack? = nil
    )
    {
        self.stack = stack
    }
}

struct UpdateStackOutputBody: Swift.Equatable {
    let stack: AppStreamClientTypes.Stack?
}

extension UpdateStackOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stack = "Stack"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Stack.self, forKey: .stack)
        stack = stackDecoded
    }
}

enum UpdateStackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncompatibleImageException": return try await IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAccountStatusException": return try await InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRoleException": return try await InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppStreamClientTypes {
    public enum UsageReportExecutionErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case internalServiceError
        case resourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageReportExecutionErrorCode] {
            return [
                .accessDenied,
                .internalServiceError,
                .resourceNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageReportExecutionErrorCode(rawValue: rawValue) ?? UsageReportExecutionErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum UsageReportSchedule: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageReportSchedule] {
            return [
                .daily,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageReportSchedule(rawValue: rawValue) ?? UsageReportSchedule.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.UsageReportSubscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastGeneratedReportDate = "LastGeneratedReportDate"
        case s3BucketName = "S3BucketName"
        case schedule = "Schedule"
        case subscriptionErrors = "SubscriptionErrors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastGeneratedReportDate = self.lastGeneratedReportDate {
            try encodeContainer.encodeTimestamp(lastGeneratedReportDate, format: .epochSeconds, forKey: .lastGeneratedReportDate)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule.rawValue, forKey: .schedule)
        }
        if let subscriptionErrors = subscriptionErrors {
            var subscriptionErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptionErrors)
            for lastreportgenerationexecutionerror0 in subscriptionErrors {
                try subscriptionErrorsContainer.encode(lastreportgenerationexecutionerror0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.UsageReportSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let lastGeneratedReportDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastGeneratedReportDate)
        lastGeneratedReportDate = lastGeneratedReportDateDecoded
        let subscriptionErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.LastReportGenerationExecutionError?].self, forKey: .subscriptionErrors)
        var subscriptionErrorsDecoded0:[AppStreamClientTypes.LastReportGenerationExecutionError]? = nil
        if let subscriptionErrorsContainer = subscriptionErrorsContainer {
            subscriptionErrorsDecoded0 = [AppStreamClientTypes.LastReportGenerationExecutionError]()
            for structure0 in subscriptionErrorsContainer {
                if let structure0 = structure0 {
                    subscriptionErrorsDecoded0?.append(structure0)
                }
            }
        }
        subscriptionErrors = subscriptionErrorsDecoded0
    }
}

extension AppStreamClientTypes {
    /// Describes information about the usage report subscription.
    public struct UsageReportSubscription: Swift.Equatable {
        /// The time when the last usage report was generated.
        public var lastGeneratedReportDate: ClientRuntime.Date?
        /// The Amazon S3 bucket where generated reports are stored. If you enabled on-instance session scripts and Amazon S3 logging for your session script configuration, AppStream 2.0 created an S3 bucket to store the script output. The bucket is unique to your account and Region. When you enable usage reporting in this case, AppStream 2.0 uses the same bucket to store your usage reports. If you haven't already enabled on-instance session scripts, when you enable usage reports, AppStream 2.0 creates a new S3 bucket.
        public var s3BucketName: Swift.String?
        /// The schedule for generating usage reports.
        public var schedule: AppStreamClientTypes.UsageReportSchedule?
        /// The errors that were returned if usage reports couldn't be generated.
        public var subscriptionErrors: [AppStreamClientTypes.LastReportGenerationExecutionError]?

        public init(
            lastGeneratedReportDate: ClientRuntime.Date? = nil,
            s3BucketName: Swift.String? = nil,
            schedule: AppStreamClientTypes.UsageReportSchedule? = nil,
            subscriptionErrors: [AppStreamClientTypes.LastReportGenerationExecutionError]? = nil
        )
        {
            self.lastGeneratedReportDate = lastGeneratedReportDate
            self.s3BucketName = s3BucketName
            self.schedule = schedule
            self.subscriptionErrors = subscriptionErrors
        }
    }

}

extension AppStreamClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case authenticationType = "AuthenticationType"
        case createdTime = "CreatedTime"
        case enabled = "Enabled"
        case firstName = "FirstName"
        case lastName = "LastName"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension AppStreamClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(arn: \(Swift.String(describing: arn)), authenticationType: \(Swift.String(describing: authenticationType)), createdTime: \(Swift.String(describing: createdTime)), enabled: \(Swift.String(describing: enabled)), status: \(Swift.String(describing: status)), firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", userName: \"CONTENT_REDACTED\")"}
}

extension AppStreamClientTypes {
    /// Describes a user in the user pool.
    public struct User: Swift.Equatable {
        /// The ARN of the user.
        public var arn: Swift.String?
        /// The authentication type for the user.
        /// This member is required.
        public var authenticationType: AppStreamClientTypes.AuthenticationType?
        /// The date and time the user was created in the user pool.
        public var createdTime: ClientRuntime.Date?
        /// Specifies whether the user in the user pool is enabled.
        public var enabled: Swift.Bool
        /// The first name, or given name, of the user.
        public var firstName: Swift.String?
        /// The last name, or surname, of the user.
        public var lastName: Swift.String?
        /// The status of the user in the user pool. The status can be one of the following:
        ///
        /// * UNCONFIRMED â€“ The user is created but not confirmed.
        ///
        /// * CONFIRMED â€“ The user is confirmed.
        ///
        /// * ARCHIVED â€“ The user is no longer active.
        ///
        /// * COMPROMISED â€“ The user is disabled because of a potential security threat.
        ///
        /// * UNKNOWN â€“ The user status is not known.
        public var status: Swift.String?
        /// The email address of the user. Users' email addresses are case-sensitive.
        public var userName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
            createdTime: ClientRuntime.Date? = nil,
            enabled: Swift.Bool = false,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            status: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.authenticationType = authenticationType
            self.createdTime = createdTime
            self.enabled = enabled
            self.firstName = firstName
            self.lastName = lastName
            self.status = status
            self.userName = userName
        }
    }

}

extension AppStreamClientTypes.UserSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case permission = "Permission"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let permission = self.permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Permission.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes an action and whether the action is enabled or disabled for users during their streaming sessions.
    public struct UserSetting: Swift.Equatable {
        /// The action that is enabled or disabled.
        /// This member is required.
        public var action: AppStreamClientTypes.Action?
        /// Indicates whether the action is enabled or disabled.
        /// This member is required.
        public var permission: AppStreamClientTypes.Permission?

        public init(
            action: AppStreamClientTypes.Action? = nil,
            permission: AppStreamClientTypes.Permission? = nil
        )
        {
            self.action = action
            self.permission = permission
        }
    }

}

extension AppStreamClientTypes.UserStackAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case sendEmailNotification = "SendEmailNotification"
        case stackName = "StackName"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if sendEmailNotification != false {
            try encodeContainer.encode(sendEmailNotification, forKey: .sendEmailNotification)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let sendEmailNotificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sendEmailNotification) ?? false
        sendEmailNotification = sendEmailNotificationDecoded
    }
}

extension AppStreamClientTypes.UserStackAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserStackAssociation(authenticationType: \(Swift.String(describing: authenticationType)), sendEmailNotification: \(Swift.String(describing: sendEmailNotification)), stackName: \(Swift.String(describing: stackName)), userName: \"CONTENT_REDACTED\")"}
}

extension AppStreamClientTypes {
    /// Describes a user in the user pool and the associated stack.
    public struct UserStackAssociation: Swift.Equatable {
        /// The authentication type for the user.
        /// This member is required.
        public var authenticationType: AppStreamClientTypes.AuthenticationType?
        /// Specifies whether a welcome email is sent to a user after the user is created in the user pool.
        public var sendEmailNotification: Swift.Bool
        /// The name of the stack that is associated with the user.
        /// This member is required.
        public var stackName: Swift.String?
        /// The email address of the user who is associated with the stack. Users' email addresses are case-sensitive.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
            sendEmailNotification: Swift.Bool = false,
            stackName: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.sendEmailNotification = sendEmailNotification
            self.stackName = stackName
            self.userName = userName
        }
    }

}

extension AppStreamClientTypes.UserStackAssociationError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case userStackAssociation = "UserStackAssociation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let userStackAssociation = self.userStackAssociation {
            try encodeContainer.encode(userStackAssociation, forKey: .userStackAssociation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.UserStackAssociation.self, forKey: .userStackAssociation)
        userStackAssociation = userStackAssociationDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.UserStackAssociationErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the error that is returned when a user canâ€™t be associated with or disassociated from a stack.
    public struct UserStackAssociationError: Swift.Equatable {
        /// The error code for the error that is returned when a user canâ€™t be associated with or disassociated from a stack.
        public var errorCode: AppStreamClientTypes.UserStackAssociationErrorCode?
        /// The error message for the error that is returned when a user canâ€™t be associated with or disassociated from a stack.
        public var errorMessage: Swift.String?
        /// Information about the user and associated stack.
        public var userStackAssociation: AppStreamClientTypes.UserStackAssociation?

        public init(
            errorCode: AppStreamClientTypes.UserStackAssociationErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            userStackAssociation: AppStreamClientTypes.UserStackAssociation? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.userStackAssociation = userStackAssociation
        }
    }

}

extension AppStreamClientTypes {
    public enum UserStackAssociationErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case directoryNotFound
        case internalError
        case stackNotFound
        case userNameNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [UserStackAssociationErrorCode] {
            return [
                .directoryNotFound,
                .internalError,
                .stackNotFound,
                .userNameNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .directoryNotFound: return "DIRECTORY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .stackNotFound: return "STACK_NOT_FOUND"
            case .userNameNotFound: return "USER_NAME_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserStackAssociationErrorCode(rawValue: rawValue) ?? UserStackAssociationErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum VisibilityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [VisibilityType] {
            return [
                .private,
                .public,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VisibilityType(rawValue: rawValue) ?? VisibilityType.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.VpcConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(string0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension AppStreamClientTypes {
    /// Describes VPC configuration information for fleets and image builders.
    public struct VpcConfig: Swift.Equatable {
        /// The identifiers of the security groups for the fleet or image builder.
        public var securityGroupIds: [Swift.String]?
        /// The identifiers of the subnets to which a network interface is attached from the fleet instance or image builder instance. Fleet instances use one or more subnets. Image builder instances use one subnet.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}
