//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

extension AppStreamClientTypes {

    public enum AccessEndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case streaming
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessEndpointType] {
            return [
                .streaming
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .streaming: return "STREAMING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes an interface VPC endpoint (interface endpoint) that lets you create a private connection between the virtual private cloud (VPC) that you specify and AppStream 2.0. When you specify an interface endpoint for a stack, users of the stack can connect to AppStream 2.0 only through that endpoint. When you specify an interface endpoint for an image builder, administrators can connect to the image builder only through that endpoint.
    public struct AccessEndpoint {
        /// The type of interface endpoint.
        /// This member is required.
        public var endpointType: AppStreamClientTypes.AccessEndpointType?
        /// The identifier (ID) of the VPC in which the interface endpoint is used.
        public var vpceId: Swift.String?

        public init(
            endpointType: AppStreamClientTypes.AccessEndpointType? = nil,
            vpceId: Swift.String? = nil
        )
        {
            self.endpointType = endpointType
            self.vpceId = vpceId
        }
    }

}

extension AppStreamClientTypes {

    public enum Action: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case clipboardCopyFromLocalDevice
        case clipboardCopyToLocalDevice
        case domainPasswordSignin
        case domainSmartCardSignin
        case fileDownload
        case fileUpload
        case printingToLocalDevice
        case sdkUnknown(Swift.String)

        public static var allCases: [Action] {
            return [
                .clipboardCopyFromLocalDevice,
                .clipboardCopyToLocalDevice,
                .domainPasswordSignin,
                .domainSmartCardSignin,
                .fileDownload,
                .fileUpload,
                .printingToLocalDevice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .clipboardCopyFromLocalDevice: return "CLIPBOARD_COPY_FROM_LOCAL_DEVICE"
            case .clipboardCopyToLocalDevice: return "CLIPBOARD_COPY_TO_LOCAL_DEVICE"
            case .domainPasswordSignin: return "DOMAIN_PASSWORD_SIGNIN"
            case .domainSmartCardSignin: return "DOMAIN_SMART_CARD_SIGNIN"
            case .fileDownload: return "FILE_DOWNLOAD"
            case .fileUpload: return "FILE_UPLOAD"
            case .printingToLocalDevice: return "PRINTING_TO_LOCAL_DEVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// The error details.
    public struct ErrorDetails {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension AppStreamClientTypes {

    public enum PackagingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case appstream2
        case custom
        case sdkUnknown(Swift.String)

        public static var allCases: [PackagingType] {
            return [
                .appstream2,
                .custom
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .appstream2: return "APPSTREAM2"
            case .custom: return "CUSTOM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes the S3 location.
    public struct S3Location {
        /// The S3 bucket of the S3 object.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The S3 key of the S3 object. This is required when used for the following:
        ///
        /// * IconS3Location (Actions: CreateApplication and UpdateApplication)
        ///
        /// * SessionScriptS3Location (Actions: CreateFleet and UpdateFleet)
        ///
        /// * ScriptDetails (Actions: CreateAppBlock)
        ///
        /// * SourceS3Location when creating an app block with CUSTOM PackagingType (Actions: CreateAppBlock)
        ///
        /// * SourceS3Location when creating an app block with APPSTREAM2 PackagingType, and using an existing application package (VHD file). In this case, S3Key refers to the VHD file. If a new application package is required, then S3Key is not required. (Actions: CreateAppBlock)
        public var s3Key: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension AppStreamClientTypes {
    /// Describes the details of the script.
    public struct ScriptDetails {
        /// The runtime parameters passed to the run path for the script.
        public var executableParameters: Swift.String?
        /// The run path for the script.
        /// This member is required.
        public var executablePath: Swift.String?
        /// The S3 object location for the script.
        /// This member is required.
        public var scriptS3Location: AppStreamClientTypes.S3Location?
        /// The run timeout, in seconds, for the script.
        /// This member is required.
        public var timeoutInSeconds: Swift.Int?

        public init(
            executableParameters: Swift.String? = nil,
            executablePath: Swift.String? = nil,
            scriptS3Location: AppStreamClientTypes.S3Location? = nil,
            timeoutInSeconds: Swift.Int? = nil
        )
        {
            self.executableParameters = executableParameters
            self.executablePath = executablePath
            self.scriptS3Location = scriptS3Location
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension AppStreamClientTypes {

    public enum AppBlockState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AppBlockState] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes an app block. App blocks are an Amazon AppStream 2.0 resource that stores the details about the virtual hard disk in an S3 bucket. It also stores the setup script with details about how to mount the virtual hard disk. The virtual hard disk includes the application binaries and other files necessary to launch your applications. Multiple applications can be assigned to a single app block. This is only supported for Elastic fleets.
    public struct AppBlock {
        /// The errors of the app block.
        public var appBlockErrors: [AppStreamClientTypes.ErrorDetails]?
        /// The ARN of the app block.
        /// This member is required.
        public var arn: Swift.String?
        /// The created time of the app block.
        public var createdTime: Foundation.Date?
        /// The description of the app block.
        public var description: Swift.String?
        /// The display name of the app block.
        public var displayName: Swift.String?
        /// The name of the app block.
        /// This member is required.
        public var name: Swift.String?
        /// The packaging type of the app block.
        public var packagingType: AppStreamClientTypes.PackagingType?
        /// The post setup script details of the app block. This only applies to app blocks with PackagingType APPSTREAM2.
        public var postSetupScriptDetails: AppStreamClientTypes.ScriptDetails?
        /// The setup script details of the app block. This only applies to app blocks with PackagingType CUSTOM.
        public var setupScriptDetails: AppStreamClientTypes.ScriptDetails?
        /// The source S3 location of the app block.
        public var sourceS3Location: AppStreamClientTypes.S3Location?
        /// The state of the app block. An app block with AppStream 2.0 packaging will be in the INACTIVE state if no application package (VHD) is assigned to it. After an application package (VHD) is created by an app block builder for an app block, it becomes ACTIVE. Custom app blocks are always in the ACTIVE state and no action is required to use them.
        public var state: AppStreamClientTypes.AppBlockState?

        public init(
            appBlockErrors: [AppStreamClientTypes.ErrorDetails]? = nil,
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            name: Swift.String? = nil,
            packagingType: AppStreamClientTypes.PackagingType? = nil,
            postSetupScriptDetails: AppStreamClientTypes.ScriptDetails? = nil,
            setupScriptDetails: AppStreamClientTypes.ScriptDetails? = nil,
            sourceS3Location: AppStreamClientTypes.S3Location? = nil,
            state: AppStreamClientTypes.AppBlockState? = nil
        )
        {
            self.appBlockErrors = appBlockErrors
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.name = name
            self.packagingType = packagingType
            self.postSetupScriptDetails = postSetupScriptDetails
            self.setupScriptDetails = setupScriptDetails
            self.sourceS3Location = sourceS3Location
            self.state = state
        }
    }

}

extension AppStreamClientTypes {

    public enum FleetErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case domainJoinErrorAccessDenied
        case domainJoinErrorDsMachineAccountQuotaExceeded
        case domainJoinErrorFileNotFound
        case domainJoinErrorInvalidParameter
        case domainJoinErrorLogonFailure
        case domainJoinErrorMoreData
        case domainJoinErrorNotSupported
        case domainJoinErrorNoSuchDomain
        case domainJoinInternalServiceError
        case domainJoinNerrInvalidWorkgroupName
        case domainJoinNerrPasswordExpired
        case domainJoinNerrWorkstationNotStarted
        case fleetInstanceProvisioningFailure
        case fleetStopped
        case iamServiceRoleIsMissing
        case iamServiceRoleMissingDescribeSecurityGroupsAction
        case iamServiceRoleMissingDescribeSubnetAction
        case iamServiceRoleMissingEniCreateAction
        case iamServiceRoleMissingEniDeleteAction
        case iamServiceRoleMissingEniDescribeAction
        case igwNotAttached
        case imageNotFound
        case internalServiceError
        case invalidSubnetConfiguration
        case machineRoleIsMissing
        case networkInterfaceLimitExceeded
        case securityGroupsNotFound
        case stsDisabledInRegion
        case subnetHasInsufficientIpAddresses
        case subnetNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetErrorCode] {
            return [
                .domainJoinErrorAccessDenied,
                .domainJoinErrorDsMachineAccountQuotaExceeded,
                .domainJoinErrorFileNotFound,
                .domainJoinErrorInvalidParameter,
                .domainJoinErrorLogonFailure,
                .domainJoinErrorMoreData,
                .domainJoinErrorNotSupported,
                .domainJoinErrorNoSuchDomain,
                .domainJoinInternalServiceError,
                .domainJoinNerrInvalidWorkgroupName,
                .domainJoinNerrPasswordExpired,
                .domainJoinNerrWorkstationNotStarted,
                .fleetInstanceProvisioningFailure,
                .fleetStopped,
                .iamServiceRoleIsMissing,
                .iamServiceRoleMissingDescribeSecurityGroupsAction,
                .iamServiceRoleMissingDescribeSubnetAction,
                .iamServiceRoleMissingEniCreateAction,
                .iamServiceRoleMissingEniDeleteAction,
                .iamServiceRoleMissingEniDescribeAction,
                .igwNotAttached,
                .imageNotFound,
                .internalServiceError,
                .invalidSubnetConfiguration,
                .machineRoleIsMissing,
                .networkInterfaceLimitExceeded,
                .securityGroupsNotFound,
                .stsDisabledInRegion,
                .subnetHasInsufficientIpAddresses,
                .subnetNotFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .domainJoinErrorAccessDenied: return "DOMAIN_JOIN_ERROR_ACCESS_DENIED"
            case .domainJoinErrorDsMachineAccountQuotaExceeded: return "DOMAIN_JOIN_ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED"
            case .domainJoinErrorFileNotFound: return "DOMAIN_JOIN_ERROR_FILE_NOT_FOUND"
            case .domainJoinErrorInvalidParameter: return "DOMAIN_JOIN_ERROR_INVALID_PARAMETER"
            case .domainJoinErrorLogonFailure: return "DOMAIN_JOIN_ERROR_LOGON_FAILURE"
            case .domainJoinErrorMoreData: return "DOMAIN_JOIN_ERROR_MORE_DATA"
            case .domainJoinErrorNotSupported: return "DOMAIN_JOIN_ERROR_NOT_SUPPORTED"
            case .domainJoinErrorNoSuchDomain: return "DOMAIN_JOIN_ERROR_NO_SUCH_DOMAIN"
            case .domainJoinInternalServiceError: return "DOMAIN_JOIN_INTERNAL_SERVICE_ERROR"
            case .domainJoinNerrInvalidWorkgroupName: return "DOMAIN_JOIN_NERR_INVALID_WORKGROUP_NAME"
            case .domainJoinNerrPasswordExpired: return "DOMAIN_JOIN_NERR_PASSWORD_EXPIRED"
            case .domainJoinNerrWorkstationNotStarted: return "DOMAIN_JOIN_NERR_WORKSTATION_NOT_STARTED"
            case .fleetInstanceProvisioningFailure: return "FLEET_INSTANCE_PROVISIONING_FAILURE"
            case .fleetStopped: return "FLEET_STOPPED"
            case .iamServiceRoleIsMissing: return "IAM_SERVICE_ROLE_IS_MISSING"
            case .iamServiceRoleMissingDescribeSecurityGroupsAction: return "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SECURITY_GROUPS_ACTION"
            case .iamServiceRoleMissingDescribeSubnetAction: return "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SUBNET_ACTION"
            case .iamServiceRoleMissingEniCreateAction: return "IAM_SERVICE_ROLE_MISSING_ENI_CREATE_ACTION"
            case .iamServiceRoleMissingEniDeleteAction: return "IAM_SERVICE_ROLE_MISSING_ENI_DELETE_ACTION"
            case .iamServiceRoleMissingEniDescribeAction: return "IAM_SERVICE_ROLE_MISSING_ENI_DESCRIBE_ACTION"
            case .igwNotAttached: return "IGW_NOT_ATTACHED"
            case .imageNotFound: return "IMAGE_NOT_FOUND"
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .invalidSubnetConfiguration: return "INVALID_SUBNET_CONFIGURATION"
            case .machineRoleIsMissing: return "MACHINE_ROLE_IS_MISSING"
            case .networkInterfaceLimitExceeded: return "NETWORK_INTERFACE_LIMIT_EXCEEDED"
            case .securityGroupsNotFound: return "SECURITY_GROUPS_NOT_FOUND"
            case .stsDisabledInRegion: return "STS_DISABLED_IN_REGION"
            case .subnetHasInsufficientIpAddresses: return "SUBNET_HAS_INSUFFICIENT_IP_ADDRESSES"
            case .subnetNotFound: return "SUBNET_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes a resource error.
    public struct ResourceError {
        /// The error code.
        public var errorCode: AppStreamClientTypes.FleetErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The time the error occurred.
        public var errorTimestamp: Foundation.Date?

        public init(
            errorCode: AppStreamClientTypes.FleetErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            errorTimestamp: Foundation.Date? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.errorTimestamp = errorTimestamp
        }
    }

}

extension AppStreamClientTypes {

    public enum AppBlockBuilderPlatformType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case windowsServer2019
        case sdkUnknown(Swift.String)

        public static var allCases: [AppBlockBuilderPlatformType] {
            return [
                .windowsServer2019
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .windowsServer2019: return "WINDOWS_SERVER_2019"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {

    public enum AppBlockBuilderState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case running
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [AppBlockBuilderState] {
            return [
                .running,
                .starting,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {

    public enum AppBlockBuilderStateChangeReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [AppBlockBuilderStateChangeReasonCode] {
            return [
                .internalError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes the reason why the last app block builder state change occurred.
    public struct AppBlockBuilderStateChangeReason {
        /// The state change reason code.
        public var code: AppStreamClientTypes.AppBlockBuilderStateChangeReasonCode?
        /// The state change reason message.
        public var message: Swift.String?

        public init(
            code: AppStreamClientTypes.AppBlockBuilderStateChangeReasonCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension AppStreamClientTypes {
    /// Describes VPC configuration information for fleets and image builders.
    public struct VpcConfig {
        /// The identifiers of the security groups for the fleet or image builder.
        public var securityGroupIds: [Swift.String]?
        /// The identifiers of the subnets to which a network interface is attached from the fleet instance or image builder instance. Fleet instances use one or more subnets. Image builder instances use one subnet.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension AppStreamClientTypes {
    /// Describes an app block builder.
    public struct AppBlockBuilder {
        /// The list of interface VPC endpoint (interface endpoint) objects. Administrators can connect to the app block builder only through the specified endpoints.
        public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
        /// The app block builder errors.
        public var appBlockBuilderErrors: [AppStreamClientTypes.ResourceError]?
        /// The ARN of the app block builder.
        /// This member is required.
        public var arn: Swift.String?
        /// The creation time of the app block builder.
        public var createdTime: Foundation.Date?
        /// The description of the app block builder.
        public var description: Swift.String?
        /// The display name of the app block builder.
        public var displayName: Swift.String?
        /// Indicates whether default internet access is enabled for the app block builder.
        public var enableDefaultInternetAccess: Swift.Bool?
        /// The ARN of the IAM role that is applied to the app block builder.
        public var iamRoleArn: Swift.String?
        /// The instance type of the app block builder.
        /// This member is required.
        public var instanceType: Swift.String?
        /// The name of the app block builder.
        /// This member is required.
        public var name: Swift.String?
        /// The platform of the app block builder. WINDOWS_SERVER_2019 is the only valid value.
        /// This member is required.
        public var platform: AppStreamClientTypes.AppBlockBuilderPlatformType?
        /// The state of the app block builder.
        /// This member is required.
        public var state: AppStreamClientTypes.AppBlockBuilderState?
        /// The state change reason.
        public var stateChangeReason: AppStreamClientTypes.AppBlockBuilderStateChangeReason?
        /// The VPC configuration for the app block builder.
        /// This member is required.
        public var vpcConfig: AppStreamClientTypes.VpcConfig?

        public init(
            accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
            appBlockBuilderErrors: [AppStreamClientTypes.ResourceError]? = nil,
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            enableDefaultInternetAccess: Swift.Bool? = nil,
            iamRoleArn: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            name: Swift.String? = nil,
            platform: AppStreamClientTypes.AppBlockBuilderPlatformType? = nil,
            state: AppStreamClientTypes.AppBlockBuilderState? = nil,
            stateChangeReason: AppStreamClientTypes.AppBlockBuilderStateChangeReason? = nil,
            vpcConfig: AppStreamClientTypes.VpcConfig? = nil
        )
        {
            self.accessEndpoints = accessEndpoints
            self.appBlockBuilderErrors = appBlockBuilderErrors
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.iamRoleArn = iamRoleArn
            self.instanceType = instanceType
            self.name = name
            self.platform = platform
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.vpcConfig = vpcConfig
        }
    }

}

extension AppStreamClientTypes {
    /// Describes an association between an app block builder and app block.
    public struct AppBlockBuilderAppBlockAssociation {
        /// The ARN of the app block.
        /// This member is required.
        public var appBlockArn: Swift.String?
        /// The name of the app block builder.
        /// This member is required.
        public var appBlockBuilderName: Swift.String?

        public init(
            appBlockArn: Swift.String? = nil,
            appBlockBuilderName: Swift.String? = nil
        )
        {
            self.appBlockArn = appBlockArn
            self.appBlockBuilderName = appBlockBuilderName
        }
    }

}

extension AppStreamClientTypes {

    public enum AppBlockBuilderAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessEndpoints
        case iamRoleArn
        case vpcConfigurationSecurityGroupIds
        case sdkUnknown(Swift.String)

        public static var allCases: [AppBlockBuilderAttribute] {
            return [
                .accessEndpoints,
                .iamRoleArn,
                .vpcConfigurationSecurityGroupIds
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessEndpoints: return "ACCESS_ENDPOINTS"
            case .iamRoleArn: return "IAM_ROLE_ARN"
            case .vpcConfigurationSecurityGroupIds: return "VPC_CONFIGURATION_SECURITY_GROUP_IDS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {

    public enum PlatformType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonLinux2
        case rhel8
        case windows
        case windowsServer2016
        case windowsServer2019
        case windowsServer2022
        case sdkUnknown(Swift.String)

        public static var allCases: [PlatformType] {
            return [
                .amazonLinux2,
                .rhel8,
                .windows,
                .windowsServer2016,
                .windowsServer2019,
                .windowsServer2022
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonLinux2: return "AMAZON_LINUX2"
            case .rhel8: return "RHEL8"
            case .windows: return "WINDOWS"
            case .windowsServer2016: return "WINDOWS_SERVER_2016"
            case .windowsServer2019: return "WINDOWS_SERVER_2019"
            case .windowsServer2022: return "WINDOWS_SERVER_2022"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes an application in the application catalog.
    public struct Application {
        /// The app block ARN of the application.
        public var appBlockArn: Swift.String?
        /// The ARN of the application.
        public var arn: Swift.String?
        /// The time at which the application was created within the app block.
        public var createdTime: Foundation.Date?
        /// The description of the application.
        public var description: Swift.String?
        /// The application name to display.
        public var displayName: Swift.String?
        /// If there is a problem, the application can be disabled after image creation.
        public var enabled: Swift.Bool?
        /// The S3 location of the application icon.
        public var iconS3Location: AppStreamClientTypes.S3Location?
        /// The URL for the application icon. This URL might be time-limited.
        public var iconURL: Swift.String?
        /// The instance families for the application.
        public var instanceFamilies: [Swift.String]?
        /// The arguments that are passed to the application at launch.
        public var launchParameters: Swift.String?
        /// The path to the application executable in the instance.
        public var launchPath: Swift.String?
        /// Additional attributes that describe the application.
        public var metadata: [Swift.String: Swift.String]?
        /// The name of the application.
        public var name: Swift.String?
        /// The platforms on which the application can run.
        public var platforms: [AppStreamClientTypes.PlatformType]?
        /// The working directory for the application.
        public var workingDirectory: Swift.String?

        public init(
            appBlockArn: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            iconS3Location: AppStreamClientTypes.S3Location? = nil,
            iconURL: Swift.String? = nil,
            instanceFamilies: [Swift.String]? = nil,
            launchParameters: Swift.String? = nil,
            launchPath: Swift.String? = nil,
            metadata: [Swift.String: Swift.String]? = nil,
            name: Swift.String? = nil,
            platforms: [AppStreamClientTypes.PlatformType]? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.appBlockArn = appBlockArn
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.enabled = enabled
            self.iconS3Location = iconS3Location
            self.iconURL = iconURL
            self.instanceFamilies = instanceFamilies
            self.launchParameters = launchParameters
            self.launchPath = launchPath
            self.metadata = metadata
            self.name = name
            self.platforms = platforms
            self.workingDirectory = workingDirectory
        }
    }

}

extension AppStreamClientTypes {

    public enum ApplicationAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case launchParameters
        case workingDirectory
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationAttribute] {
            return [
                .launchParameters,
                .workingDirectory
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .launchParameters: return "LAUNCH_PARAMETERS"
            case .workingDirectory: return "WORKING_DIRECTORY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes the application fleet association.
    public struct ApplicationFleetAssociation {
        /// The ARN of the application associated with the fleet.
        /// This member is required.
        public var applicationArn: Swift.String?
        /// The name of the fleet associated with the application.
        /// This member is required.
        public var fleetName: Swift.String?

        public init(
            applicationArn: Swift.String? = nil,
            fleetName: Swift.String? = nil
        )
        {
            self.applicationArn = applicationArn
            self.fleetName = fleetName
        }
    }

}

extension AppStreamClientTypes {
    /// The persistent application settings for users of a stack.
    public struct ApplicationSettings {
        /// Enables or disables persistent application settings for users during their streaming sessions.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The path prefix for the S3 bucket where users’ persistent application settings are stored. You can allow the same persistent application settings to be used across multiple stacks by specifying the same settings group for each stack.
        public var settingsGroup: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            settingsGroup: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.settingsGroup = settingsGroup
        }
    }

}

extension AppStreamClientTypes {
    /// Describes the persistent application settings for users of a stack.
    public struct ApplicationSettingsResponse {
        /// Specifies whether persistent application settings are enabled for users during their streaming sessions.
        public var enabled: Swift.Bool?
        /// The S3 bucket where users’ persistent application settings are stored. When persistent application settings are enabled for the first time for an account in an AWS Region, an S3 bucket is created. The bucket is unique to the AWS account and the Region.
        public var s3BucketName: Swift.String?
        /// The path prefix for the S3 bucket where users’ persistent application settings are stored.
        public var settingsGroup: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            s3BucketName: Swift.String? = nil,
            settingsGroup: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.s3BucketName = s3BucketName
            self.settingsGroup = settingsGroup
        }
    }

}

extension AppStreamClientTypes {

    public enum AppVisibility: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case associated
        case sdkUnknown(Swift.String)

        public static var allCases: [AppVisibility] {
            return [
                .all,
                .associated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .associated: return "ASSOCIATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// An API error occurred. Wait a few minutes and try again.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates an incorrect combination of parameters, or a missing parameter.
public struct InvalidParameterCombinationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterCombinationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested limit exceeds the permitted limit for an account.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The attempted operation is not permitted.
public struct OperationNotPermittedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotPermittedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateAppBlockBuilderAppBlockInput {
    /// The ARN of the app block.
    /// This member is required.
    public var appBlockArn: Swift.String?
    /// The name of the app block builder.
    /// This member is required.
    public var appBlockBuilderName: Swift.String?

    public init(
        appBlockArn: Swift.String? = nil,
        appBlockBuilderName: Swift.String? = nil
    )
    {
        self.appBlockArn = appBlockArn
        self.appBlockBuilderName = appBlockBuilderName
    }
}

public struct AssociateAppBlockBuilderAppBlockOutput {
    /// The list of app block builders associated with app blocks.
    public var appBlockBuilderAppBlockAssociation: AppStreamClientTypes.AppBlockBuilderAppBlockAssociation?

    public init(
        appBlockBuilderAppBlockAssociation: AppStreamClientTypes.AppBlockBuilderAppBlockAssociation? = nil
    )
    {
        self.appBlockBuilderAppBlockAssociation = appBlockBuilderAppBlockAssociation
    }
}

public struct AssociateApplicationFleetInput {
    /// The ARN of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        fleetName: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.fleetName = fleetName
    }
}

public struct AssociateApplicationFleetOutput {
    /// If fleet name is specified, this returns the list of applications that are associated to it. If application ARN is specified, this returns the list of fleets to which it is associated.
    public var applicationFleetAssociation: AppStreamClientTypes.ApplicationFleetAssociation?

    public init(
        applicationFleetAssociation: AppStreamClientTypes.ApplicationFleetAssociation? = nil
    )
    {
        self.applicationFleetAssociation = applicationFleetAssociation
    }
}

/// The entitlement can't be found.
public struct EntitlementNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntitlementNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateApplicationToEntitlementInput {
    /// The identifier of the application.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The name of the entitlement.
    /// This member is required.
    public var entitlementName: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        applicationIdentifier: Swift.String? = nil,
        entitlementName: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.entitlementName = entitlementName
        self.stackName = stackName
    }
}

public struct AssociateApplicationToEntitlementOutput {

    public init() { }
}

/// The image can't be updated because it's not compatible for updates.
public struct IncompatibleImageException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IncompatibleImageException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource cannot be created because your AWS account is suspended. For assistance, contact AWS Support.
public struct InvalidAccountStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAccountStatusException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateFleetInput {
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        fleetName: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.fleetName = fleetName
        self.stackName = stackName
    }
}

public struct AssociateFleetOutput {

    public init() { }
}

extension AppStreamClientTypes {

    public enum AuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case api
        case awsAd
        case saml
        case userpool
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .api,
                .awsAd,
                .saml,
                .userpool
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .api: return "API"
            case .awsAd: return "AWS_AD"
            case .saml: return "SAML"
            case .userpool: return "USERPOOL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes a user in the user pool and the associated stack.
    public struct UserStackAssociation {
        /// The authentication type for the user.
        /// This member is required.
        public var authenticationType: AppStreamClientTypes.AuthenticationType?
        /// Specifies whether a welcome email is sent to a user after the user is created in the user pool.
        public var sendEmailNotification: Swift.Bool?
        /// The name of the stack that is associated with the user.
        /// This member is required.
        public var stackName: Swift.String?
        /// The email address of the user who is associated with the stack. Users' email addresses are case-sensitive.
        /// This member is required.
        public var userName: Swift.String?

        public init(
            authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
            sendEmailNotification: Swift.Bool? = nil,
            stackName: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.sendEmailNotification = sendEmailNotification
            self.stackName = stackName
            self.userName = userName
        }
    }

}

extension AppStreamClientTypes.UserStackAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserStackAssociation(authenticationType: \(Swift.String(describing: authenticationType)), sendEmailNotification: \(Swift.String(describing: sendEmailNotification)), stackName: \(Swift.String(describing: stackName)), userName: \"CONTENT_REDACTED\")"}
}

public struct BatchAssociateUserStackInput {
    /// The list of UserStackAssociation objects.
    /// This member is required.
    public var userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?

    public init(
        userStackAssociations: [AppStreamClientTypes.UserStackAssociation]? = nil
    )
    {
        self.userStackAssociations = userStackAssociations
    }
}

extension AppStreamClientTypes {

    public enum UserStackAssociationErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case directoryNotFound
        case internalError
        case stackNotFound
        case userNameNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [UserStackAssociationErrorCode] {
            return [
                .directoryNotFound,
                .internalError,
                .stackNotFound,
                .userNameNotFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .directoryNotFound: return "DIRECTORY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .stackNotFound: return "STACK_NOT_FOUND"
            case .userNameNotFound: return "USER_NAME_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes the error that is returned when a user can’t be associated with or disassociated from a stack.
    public struct UserStackAssociationError {
        /// The error code for the error that is returned when a user can’t be associated with or disassociated from a stack.
        public var errorCode: AppStreamClientTypes.UserStackAssociationErrorCode?
        /// The error message for the error that is returned when a user can’t be associated with or disassociated from a stack.
        public var errorMessage: Swift.String?
        /// Information about the user and associated stack.
        public var userStackAssociation: AppStreamClientTypes.UserStackAssociation?

        public init(
            errorCode: AppStreamClientTypes.UserStackAssociationErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            userStackAssociation: AppStreamClientTypes.UserStackAssociation? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.userStackAssociation = userStackAssociation
        }
    }

}

public struct BatchAssociateUserStackOutput {
    /// The list of UserStackAssociationError objects.
    public var errors: [AppStreamClientTypes.UserStackAssociationError]?

    public init(
        errors: [AppStreamClientTypes.UserStackAssociationError]? = nil
    )
    {
        self.errors = errors
    }
}

public struct BatchDisassociateUserStackInput {
    /// The list of UserStackAssociation objects.
    /// This member is required.
    public var userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?

    public init(
        userStackAssociations: [AppStreamClientTypes.UserStackAssociation]? = nil
    )
    {
        self.userStackAssociations = userStackAssociations
    }
}

public struct BatchDisassociateUserStackOutput {
    /// The list of UserStackAssociationError objects.
    public var errors: [AppStreamClientTypes.UserStackAssociationError]?

    public init(
        errors: [AppStreamClientTypes.UserStackAssociationError]? = nil
    )
    {
        self.errors = errors
    }
}

extension AppStreamClientTypes {

    public enum CertificateBasedAuthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case enabledNoDirectoryLoginFallback
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateBasedAuthStatus] {
            return [
                .disabled,
                .enabled,
                .enabledNoDirectoryLoginFallback
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .enabledNoDirectoryLoginFallback: return "ENABLED_NO_DIRECTORY_LOGIN_FALLBACK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory domain-joined streaming instances. Fallback is turned on by default when certificate-based authentication is Enabled . Fallback allows users to log in using their AD domain password if certificate-based authentication is unsuccessful, or to unlock a desktop lock screen. Enabled_no_directory_login_fallback enables certificate-based authentication, but does not allow users to log in using their AD domain password. Users will be disconnected to re-authenticate using certificates.
    public struct CertificateBasedAuthProperties {
        /// The ARN of the AWS Certificate Manager Private CA resource.
        public var certificateAuthorityArn: Swift.String?
        /// The status of the certificate-based authentication properties.
        public var status: AppStreamClientTypes.CertificateBasedAuthStatus?

        public init(
            certificateAuthorityArn: Swift.String? = nil,
            status: AppStreamClientTypes.CertificateBasedAuthStatus? = nil
        )
        {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.status = status
        }
    }

}

extension AppStreamClientTypes {
    /// Describes the capacity for a fleet.
    public struct ComputeCapacity {
        /// The desired number of streaming instances.
        public var desiredInstances: Swift.Int?
        /// The desired number of user sessions for a multi-session fleet. This is not allowed for single-session fleets. When you create a fleet, you must set either the DesiredSessions or DesiredInstances attribute, based on the type of fleet you create. You can’t define both attributes or leave both attributes blank.
        public var desiredSessions: Swift.Int?

        public init(
            desiredInstances: Swift.Int? = nil,
            desiredSessions: Swift.Int? = nil
        )
        {
            self.desiredInstances = desiredInstances
            self.desiredSessions = desiredSessions
        }
    }

}

extension AppStreamClientTypes {
    /// Describes the capacity status for a fleet.
    public struct ComputeCapacityStatus {
        /// The number of user sessions currently being used for streaming sessions. This only applies to multi-session fleets.
        public var activeUserSessions: Swift.Int?
        /// The total number of session slots that are available for streaming or are currently streaming. ActualUserSessionCapacity = AvailableUserSessionCapacity + ActiveUserSessions This only applies to multi-session fleets.
        public var actualUserSessions: Swift.Int?
        /// The number of currently available instances that can be used to stream sessions.
        public var available: Swift.Int?
        /// The number of idle session slots currently available for user sessions. AvailableUserSessionCapacity = ActualUserSessionCapacity - ActiveUserSessions This only applies to multi-session fleets.
        public var availableUserSessions: Swift.Int?
        /// The desired number of streaming instances.
        /// This member is required.
        public var desired: Swift.Int?
        /// The total number of sessions slots that are either running or pending. This represents the total number of concurrent streaming sessions your fleet can support in a steady state. DesiredUserSessionCapacity = ActualUserSessionCapacity + PendingUserSessionCapacity This only applies to multi-session fleets.
        public var desiredUserSessions: Swift.Int?
        /// The number of instances in use for streaming.
        public var inUse: Swift.Int?
        /// The total number of simultaneous streaming instances that are running.
        public var running: Swift.Int?

        public init(
            activeUserSessions: Swift.Int? = nil,
            actualUserSessions: Swift.Int? = nil,
            available: Swift.Int? = nil,
            availableUserSessions: Swift.Int? = nil,
            desired: Swift.Int? = nil,
            desiredUserSessions: Swift.Int? = nil,
            inUse: Swift.Int? = nil,
            running: Swift.Int? = nil
        )
        {
            self.activeUserSessions = activeUserSessions
            self.actualUserSessions = actualUserSessions
            self.available = available
            self.availableUserSessions = availableUserSessions
            self.desired = desired
            self.desiredUserSessions = desiredUserSessions
            self.inUse = inUse
            self.running = running
        }
    }

}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource exists and is not in use, but isn't available.
public struct ResourceNotAvailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotAvailableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CopyImageInput {
    /// The description that the image will have when it is copied to the destination.
    public var destinationImageDescription: Swift.String?
    /// The name that the image will have when it is copied to the destination.
    /// This member is required.
    public var destinationImageName: Swift.String?
    /// The destination region to which the image will be copied. This parameter is required, even if you are copying an image within the same region.
    /// This member is required.
    public var destinationRegion: Swift.String?
    /// The name of the image to copy.
    /// This member is required.
    public var sourceImageName: Swift.String?

    public init(
        destinationImageDescription: Swift.String? = nil,
        destinationImageName: Swift.String? = nil,
        destinationRegion: Swift.String? = nil,
        sourceImageName: Swift.String? = nil
    )
    {
        self.destinationImageDescription = destinationImageDescription
        self.destinationImageName = destinationImageName
        self.destinationRegion = destinationRegion
        self.sourceImageName = sourceImageName
    }
}

public struct CopyImageOutput {
    /// The name of the destination image.
    public var destinationImageName: Swift.String?

    public init(
        destinationImageName: Swift.String? = nil
    )
    {
        self.destinationImageName = destinationImageName
    }
}

public struct CreateAppBlockInput {
    /// The description of the app block.
    public var description: Swift.String?
    /// The display name of the app block. This is not displayed to the user.
    public var displayName: Swift.String?
    /// The name of the app block.
    /// This member is required.
    public var name: Swift.String?
    /// The packaging type of the app block.
    public var packagingType: AppStreamClientTypes.PackagingType?
    /// The post setup script details of the app block. This can only be provided for the APPSTREAM2 PackagingType.
    public var postSetupScriptDetails: AppStreamClientTypes.ScriptDetails?
    /// The setup script details of the app block. This must be provided for the CUSTOM PackagingType.
    public var setupScriptDetails: AppStreamClientTypes.ScriptDetails?
    /// The source S3 location of the app block.
    /// This member is required.
    public var sourceS3Location: AppStreamClientTypes.S3Location?
    /// The tags assigned to the app block.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        name: Swift.String? = nil,
        packagingType: AppStreamClientTypes.PackagingType? = nil,
        postSetupScriptDetails: AppStreamClientTypes.ScriptDetails? = nil,
        setupScriptDetails: AppStreamClientTypes.ScriptDetails? = nil,
        sourceS3Location: AppStreamClientTypes.S3Location? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.name = name
        self.packagingType = packagingType
        self.postSetupScriptDetails = postSetupScriptDetails
        self.setupScriptDetails = setupScriptDetails
        self.sourceS3Location = sourceS3Location
        self.tags = tags
    }
}

public struct CreateAppBlockOutput {
    /// The app block.
    public var appBlock: AppStreamClientTypes.AppBlock?

    public init(
        appBlock: AppStreamClientTypes.AppBlock? = nil
    )
    {
        self.appBlock = appBlock
    }
}

/// The specified role is invalid.
public struct InvalidRoleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRoleException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// AppStream 2.0 can’t process the request right now because the Describe calls from your AWS account are being throttled by Amazon EC2. Try again later.
public struct RequestLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateAppBlockBuilderInput {
    /// The list of interface VPC endpoint (interface endpoint) objects. Administrators can connect to the app block builder only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The description of the app block builder.
    public var description: Swift.String?
    /// The display name of the app block builder.
    public var displayName: Swift.String?
    /// Enables or disables default internet access for the app block builder.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the app block builder. To assume a role, the app block builder calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The instance type to use when launching the app block builder. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.standard.xlarge
    ///
    /// * stream.standard.2xlarge
    /// This member is required.
    public var instanceType: Swift.String?
    /// The unique name for the app block builder.
    /// This member is required.
    public var name: Swift.String?
    /// The platform of the app block builder. WINDOWS_SERVER_2019 is the only valid value.
    /// This member is required.
    public var platform: AppStreamClientTypes.AppBlockBuilderPlatformType?
    /// The tags to associate with the app block builder. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. If you do not specify a value, the value is set to an empty string. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ For more information, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var tags: [Swift.String: Swift.String]?
    /// The VPC configuration for the app block builder. App block builders require that you specify at least two subnets in different availability zones.
    /// This member is required.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init(
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        iamRoleArn: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        name: Swift.String? = nil,
        platform: AppStreamClientTypes.AppBlockBuilderPlatformType? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.description = description
        self.displayName = displayName
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.iamRoleArn = iamRoleArn
        self.instanceType = instanceType
        self.name = name
        self.platform = platform
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

public struct CreateAppBlockBuilderOutput {
    /// Describes an app block builder.
    public var appBlockBuilder: AppStreamClientTypes.AppBlockBuilder?

    public init(
        appBlockBuilder: AppStreamClientTypes.AppBlockBuilder? = nil
    )
    {
        self.appBlockBuilder = appBlockBuilder
    }
}

public struct CreateAppBlockBuilderStreamingURLInput {
    /// The name of the app block builder.
    /// This member is required.
    public var appBlockBuilderName: Swift.String?
    /// The time that the streaming URL will be valid, in seconds. Specify a value between 1 and 604800 seconds. The default is 3600 seconds.
    public var validity: Swift.Int?

    public init(
        appBlockBuilderName: Swift.String? = nil,
        validity: Swift.Int? = nil
    )
    {
        self.appBlockBuilderName = appBlockBuilderName
        self.validity = validity
    }
}

public struct CreateAppBlockBuilderStreamingURLOutput {
    /// The elapsed time, in seconds after the Unix epoch, when this URL expires.
    public var expires: Foundation.Date?
    /// The URL to start the streaming session.
    public var streamingURL: Swift.String?

    public init(
        expires: Foundation.Date? = nil,
        streamingURL: Swift.String? = nil
    )
    {
        self.expires = expires
        self.streamingURL = streamingURL
    }
}

public struct CreateApplicationInput {
    /// The app block ARN to which the application should be associated
    /// This member is required.
    public var appBlockArn: Swift.String?
    /// The description of the application.
    public var description: Swift.String?
    /// The display name of the application. This name is visible to users in the application catalog.
    public var displayName: Swift.String?
    /// The location in S3 of the application icon.
    /// This member is required.
    public var iconS3Location: AppStreamClientTypes.S3Location?
    /// The instance families the application supports. Valid values are GENERAL_PURPOSE and GRAPHICS_G4.
    /// This member is required.
    public var instanceFamilies: [Swift.String]?
    /// The launch parameters of the application.
    public var launchParameters: Swift.String?
    /// The launch path of the application.
    /// This member is required.
    public var launchPath: Swift.String?
    /// The name of the application. This name is visible to users when display name is not specified.
    /// This member is required.
    public var name: Swift.String?
    /// The platforms the application supports. WINDOWS_SERVER_2019 and AMAZON_LINUX2 are supported for Elastic fleets.
    /// This member is required.
    public var platforms: [AppStreamClientTypes.PlatformType]?
    /// The tags assigned to the application.
    public var tags: [Swift.String: Swift.String]?
    /// The working directory of the application.
    public var workingDirectory: Swift.String?

    public init(
        appBlockArn: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        iconS3Location: AppStreamClientTypes.S3Location? = nil,
        instanceFamilies: [Swift.String]? = nil,
        launchParameters: Swift.String? = nil,
        launchPath: Swift.String? = nil,
        name: Swift.String? = nil,
        platforms: [AppStreamClientTypes.PlatformType]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.appBlockArn = appBlockArn
        self.description = description
        self.displayName = displayName
        self.iconS3Location = iconS3Location
        self.instanceFamilies = instanceFamilies
        self.launchParameters = launchParameters
        self.launchPath = launchPath
        self.name = name
        self.platforms = platforms
        self.tags = tags
        self.workingDirectory = workingDirectory
    }
}

public struct CreateApplicationOutput {
    /// Describes an application in the application catalog.
    public var application: AppStreamClientTypes.Application?

    public init(
        application: AppStreamClientTypes.Application? = nil
    )
    {
        self.application = application
    }
}

extension AppStreamClientTypes {
    /// Describes the credentials for the service account used by the fleet or image builder to connect to the directory.
    public struct ServiceAccountCredentials {
        /// The user name of the account. This account must have the following privileges: create computer objects, join computers to the domain, and change/reset the password on descendant computer objects for the organizational units specified.
        /// This member is required.
        public var accountName: Swift.String?
        /// The password for the account.
        /// This member is required.
        public var accountPassword: Swift.String?

        public init(
            accountName: Swift.String? = nil,
            accountPassword: Swift.String? = nil
        )
        {
            self.accountName = accountName
            self.accountPassword = accountPassword
        }
    }

}

extension AppStreamClientTypes.ServiceAccountCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceAccountCredentials(accountName: \"CONTENT_REDACTED\", accountPassword: \"CONTENT_REDACTED\")"}
}

public struct CreateDirectoryConfigInput {
    /// The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory domain-joined streaming instances. Fallback is turned on by default when certificate-based authentication is Enabled . Fallback allows users to log in using their AD domain password if certificate-based authentication is unsuccessful, or to unlock a desktop lock screen. Enabled_no_directory_login_fallback enables certificate-based authentication, but does not allow users to log in using their AD domain password. Users will be disconnected to re-authenticate using certificates.
    public var certificateBasedAuthProperties: AppStreamClientTypes.CertificateBasedAuthProperties?
    /// The fully qualified name of the directory (for example, corp.example.com).
    /// This member is required.
    public var directoryName: Swift.String?
    /// The distinguished names of the organizational units for computer accounts.
    /// This member is required.
    public var organizationalUnitDistinguishedNames: [Swift.String]?
    /// The credentials for the service account used by the fleet or image builder to connect to the directory.
    public var serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?

    public init(
        certificateBasedAuthProperties: AppStreamClientTypes.CertificateBasedAuthProperties? = nil,
        directoryName: Swift.String? = nil,
        organizationalUnitDistinguishedNames: [Swift.String]? = nil,
        serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials? = nil
    )
    {
        self.certificateBasedAuthProperties = certificateBasedAuthProperties
        self.directoryName = directoryName
        self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
        self.serviceAccountCredentials = serviceAccountCredentials
    }
}

extension AppStreamClientTypes {
    /// Describes the configuration information required to join fleets and image builders to Microsoft Active Directory domains.
    public struct DirectoryConfig {
        /// The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory domain-joined streaming instances. Fallback is turned on by default when certificate-based authentication is Enabled . Fallback allows users to log in using their AD domain password if certificate-based authentication is unsuccessful, or to unlock a desktop lock screen. Enabled_no_directory_login_fallback enables certificate-based authentication, but does not allow users to log in using their AD domain password. Users will be disconnected to re-authenticate using certificates.
        public var certificateBasedAuthProperties: AppStreamClientTypes.CertificateBasedAuthProperties?
        /// The time the directory configuration was created.
        public var createdTime: Foundation.Date?
        /// The fully qualified name of the directory (for example, corp.example.com).
        /// This member is required.
        public var directoryName: Swift.String?
        /// The distinguished names of the organizational units for computer accounts.
        public var organizationalUnitDistinguishedNames: [Swift.String]?
        /// The credentials for the service account used by the fleet or image builder to connect to the directory.
        public var serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?

        public init(
            certificateBasedAuthProperties: AppStreamClientTypes.CertificateBasedAuthProperties? = nil,
            createdTime: Foundation.Date? = nil,
            directoryName: Swift.String? = nil,
            organizationalUnitDistinguishedNames: [Swift.String]? = nil,
            serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials? = nil
        )
        {
            self.certificateBasedAuthProperties = certificateBasedAuthProperties
            self.createdTime = createdTime
            self.directoryName = directoryName
            self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
            self.serviceAccountCredentials = serviceAccountCredentials
        }
    }

}

public struct CreateDirectoryConfigOutput {
    /// Information about the directory configuration.
    public var directoryConfig: AppStreamClientTypes.DirectoryConfig?

    public init(
        directoryConfig: AppStreamClientTypes.DirectoryConfig? = nil
    )
    {
        self.directoryConfig = directoryConfig
    }
}

/// The entitlement already exists.
public struct EntitlementAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntitlementAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AppStreamClientTypes {
    /// An attribute associated with an entitlement. Application entitlements work by matching a supported SAML 2.0 attribute name to a value when a user identity federates to an Amazon AppStream 2.0 SAML application.
    public struct EntitlementAttribute {
        /// A supported AWS IAM SAML PrincipalTag attribute that is matched to the associated value when a user identity federates into an Amazon AppStream 2.0 SAML application. The following are valid values:
        ///
        /// * roles
        ///
        /// * department
        ///
        /// * organization
        ///
        /// * groups
        ///
        /// * title
        ///
        /// * costCenter
        ///
        /// * userType
        /// This member is required.
        public var name: Swift.String?
        /// A value that is matched to a supported SAML attribute name when a user identity federates into an Amazon AppStream 2.0 SAML application.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

public struct CreateEntitlementInput {
    /// Specifies whether all or selected apps are entitled.
    /// This member is required.
    public var appVisibility: AppStreamClientTypes.AppVisibility?
    /// The attributes of the entitlement.
    /// This member is required.
    public var attributes: [AppStreamClientTypes.EntitlementAttribute]?
    /// The description of the entitlement.
    public var description: Swift.String?
    /// The name of the entitlement.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the stack with which the entitlement is associated.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        appVisibility: AppStreamClientTypes.AppVisibility? = nil,
        attributes: [AppStreamClientTypes.EntitlementAttribute]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.appVisibility = appVisibility
        self.attributes = attributes
        self.description = description
        self.name = name
        self.stackName = stackName
    }
}

extension AppStreamClientTypes {
    /// Specifies an entitlement. Entitlements control access to specific applications within a stack, based on user attributes. Entitlements apply to SAML 2.0 federated user identities. Amazon AppStream 2.0 user pool and streaming URL users are entitled to all applications in a stack. Entitlements don't apply to the desktop stream view application, or to applications managed by a dynamic app provider using the Dynamic Application Framework.
    public struct Entitlement {
        /// Specifies whether all or selected apps are entitled.
        /// This member is required.
        public var appVisibility: AppStreamClientTypes.AppVisibility?
        /// The attributes of the entitlement.
        /// This member is required.
        public var attributes: [AppStreamClientTypes.EntitlementAttribute]?
        /// The time when the entitlement was created.
        public var createdTime: Foundation.Date?
        /// The description of the entitlement.
        public var description: Swift.String?
        /// The time when the entitlement was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the entitlement.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the stack with which the entitlement is associated.
        /// This member is required.
        public var stackName: Swift.String?

        public init(
            appVisibility: AppStreamClientTypes.AppVisibility? = nil,
            attributes: [AppStreamClientTypes.EntitlementAttribute]? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            stackName: Swift.String? = nil
        )
        {
            self.appVisibility = appVisibility
            self.attributes = attributes
            self.createdTime = createdTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.stackName = stackName
        }
    }

}

public struct CreateEntitlementOutput {
    /// The entitlement.
    public var entitlement: AppStreamClientTypes.Entitlement?

    public init(
        entitlement: AppStreamClientTypes.Entitlement? = nil
    )
    {
        self.entitlement = entitlement
    }
}

extension AppStreamClientTypes {
    /// Describes the configuration information required to join fleets and image builders to Microsoft Active Directory domains.
    public struct DomainJoinInfo {
        /// The fully qualified name of the directory (for example, corp.example.com).
        public var directoryName: Swift.String?
        /// The distinguished name of the organizational unit for computer accounts.
        public var organizationalUnitDistinguishedName: Swift.String?

        public init(
            directoryName: Swift.String? = nil,
            organizationalUnitDistinguishedName: Swift.String? = nil
        )
        {
            self.directoryName = directoryName
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        }
    }

}

extension AppStreamClientTypes {

    public enum FleetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alwaysOn
        case elastic
        case onDemand
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetType] {
            return [
                .alwaysOn,
                .elastic,
                .onDemand
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alwaysOn: return "ALWAYS_ON"
            case .elastic: return "ELASTIC"
            case .onDemand: return "ON_DEMAND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {

    public enum StreamView: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case app
        case desktop
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamView] {
            return [
                .app,
                .desktop
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .app: return "APP"
            case .desktop: return "DESKTOP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateFleetInput {
    /// The desired capacity for the fleet. This is not allowed for Elastic fleets. For Elastic fleets, specify MaxConcurrentSessions instead.
    public var computeCapacity: AppStreamClientTypes.ComputeCapacity?
    /// The description to display.
    public var description: Swift.String?
    /// The amount of time that a streaming session remains active after users disconnect. If users try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance. Specify a value between 60 and 36000.
    public var disconnectTimeoutInSeconds: Swift.Int?
    /// The fleet name to display.
    public var displayName: Swift.String?
    /// The name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain. This is not allowed for Elastic fleets.
    public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    /// Enables or disables default internet access for the fleet.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The fleet type. ALWAYS_ON Provides users with instant-on access to their apps. You are charged for all running instances in your fleet, even if no users are streaming apps. ON_DEMAND Provide users with access to applications after they connect, which takes one to two minutes. You are charged for instance streaming when users are connected and a small hourly fee for instances that are not streaming apps.
    public var fleetType: AppStreamClientTypes.FleetType?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the fleet. To assume a role, a fleet instance calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the DisconnectTimeoutInSeconds time interval begins. Users are notified before they are disconnected due to inactivity. If they try to reconnect to the streaming session before the time interval specified in DisconnectTimeoutInSeconds elapses, they are connected to their previous session. Users are considered idle when they stop providing keyboard or mouse input during their streaming session. File uploads and downloads, audio in, audio out, and pixels changing do not qualify as user activity. If users continue to be idle after the time interval in IdleDisconnectTimeoutInSeconds elapses, they are disconnected. To prevent users from being disconnected due to inactivity, specify a value of 0. Otherwise, specify a value between 60 and 36000. The default value is 0. If you enable this feature, we recommend that you specify a value that corresponds exactly to a whole number of minutes (for example, 60, 120, and 180). If you don't do this, the value is rounded to the nearest minute. For example, if you specify a value of 70, users are disconnected after 1 minute of inactivity. If you specify a value that is at the midpoint between two different minutes, the value is rounded up. For example, if you specify a value of 90, users are disconnected after 2 minutes of inactivity.
    public var idleDisconnectTimeoutInSeconds: Swift.Int?
    /// The ARN of the public, private, or shared image to use.
    public var imageArn: Swift.String?
    /// The name of the image used to create the fleet.
    public var imageName: Swift.String?
    /// The instance type to use when launching fleet instances. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.standard.xlarge
    ///
    /// * stream.standard.2xlarge
    ///
    /// * stream.compute.large
    ///
    /// * stream.compute.xlarge
    ///
    /// * stream.compute.2xlarge
    ///
    /// * stream.compute.4xlarge
    ///
    /// * stream.compute.8xlarge
    ///
    /// * stream.memory.large
    ///
    /// * stream.memory.xlarge
    ///
    /// * stream.memory.2xlarge
    ///
    /// * stream.memory.4xlarge
    ///
    /// * stream.memory.8xlarge
    ///
    /// * stream.memory.z1d.large
    ///
    /// * stream.memory.z1d.xlarge
    ///
    /// * stream.memory.z1d.2xlarge
    ///
    /// * stream.memory.z1d.3xlarge
    ///
    /// * stream.memory.z1d.6xlarge
    ///
    /// * stream.memory.z1d.12xlarge
    ///
    /// * stream.graphics-design.large
    ///
    /// * stream.graphics-design.xlarge
    ///
    /// * stream.graphics-design.2xlarge
    ///
    /// * stream.graphics-design.4xlarge
    ///
    /// * stream.graphics-desktop.2xlarge
    ///
    /// * stream.graphics.g4dn.xlarge
    ///
    /// * stream.graphics.g4dn.2xlarge
    ///
    /// * stream.graphics.g4dn.4xlarge
    ///
    /// * stream.graphics.g4dn.8xlarge
    ///
    /// * stream.graphics.g4dn.12xlarge
    ///
    /// * stream.graphics.g4dn.16xlarge
    ///
    /// * stream.graphics.g5.xlarge
    ///
    /// * stream.graphics.g5.2xlarge
    ///
    /// * stream.graphics.g5.4xlarge
    ///
    /// * stream.graphics.g5.8xlarge
    ///
    /// * stream.graphics.g5.12xlarge
    ///
    /// * stream.graphics.g5.16xlarge
    ///
    /// * stream.graphics.g5.24xlarge
    ///
    /// * stream.graphics-pro.4xlarge
    ///
    /// * stream.graphics-pro.8xlarge
    ///
    /// * stream.graphics-pro.16xlarge
    ///
    ///
    /// The following instance types are available for Elastic fleets:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.standard.xlarge
    ///
    /// * stream.standard.2xlarge
    /// This member is required.
    public var instanceType: Swift.String?
    /// The maximum concurrent sessions of the Elastic fleet. This is required for Elastic fleets, and not allowed for other fleet types.
    public var maxConcurrentSessions: Swift.Int?
    /// The maximum number of user sessions on an instance. This only applies to multi-session fleets.
    public var maxSessionsPerInstance: Swift.Int?
    /// The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance. Specify a value between 600 and 432000.
    public var maxUserDurationInSeconds: Swift.Int?
    /// A unique name for the fleet.
    /// This member is required.
    public var name: Swift.String?
    /// The fleet platform. WINDOWS_SERVER_2019 and AMAZON_LINUX2 are supported for Elastic fleets.
    public var platform: AppStreamClientTypes.PlatformType?
    /// The S3 location of the session scripts configuration zip file. This only applies to Elastic fleets.
    public var sessionScriptS3Location: AppStreamClientTypes.S3Location?
    /// The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When APP is specified, only the windows of applications opened by users display. When DESKTOP is specified, the standard desktop that is provided by the operating system displays. The default value is APP.
    public var streamView: AppStreamClientTypes.StreamView?
    /// The tags to associate with the fleet. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. If you do not specify a value, the value is set to an empty string. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ For more information, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var tags: [Swift.String: Swift.String]?
    /// The USB device filter strings that specify which USB devices a user can redirect to the fleet streaming session, when using the Windows native client. This is allowed but not required for Elastic fleets.
    public var usbDeviceFilterStrings: [Swift.String]?
    /// The VPC configuration for the fleet. This is required for Elastic fleets, but not required for other fleet types. Elastic fleets require that you specify at least two subnets in different availability zones.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init(
        computeCapacity: AppStreamClientTypes.ComputeCapacity? = nil,
        description: Swift.String? = nil,
        disconnectTimeoutInSeconds: Swift.Int? = nil,
        displayName: Swift.String? = nil,
        domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        fleetType: AppStreamClientTypes.FleetType? = nil,
        iamRoleArn: Swift.String? = nil,
        idleDisconnectTimeoutInSeconds: Swift.Int? = nil,
        imageArn: Swift.String? = nil,
        imageName: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        maxConcurrentSessions: Swift.Int? = nil,
        maxSessionsPerInstance: Swift.Int? = nil,
        maxUserDurationInSeconds: Swift.Int? = nil,
        name: Swift.String? = nil,
        platform: AppStreamClientTypes.PlatformType? = nil,
        sessionScriptS3Location: AppStreamClientTypes.S3Location? = nil,
        streamView: AppStreamClientTypes.StreamView? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        usbDeviceFilterStrings: [Swift.String]? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.computeCapacity = computeCapacity
        self.description = description
        self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.fleetType = fleetType
        self.iamRoleArn = iamRoleArn
        self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.maxConcurrentSessions = maxConcurrentSessions
        self.maxSessionsPerInstance = maxSessionsPerInstance
        self.maxUserDurationInSeconds = maxUserDurationInSeconds
        self.name = name
        self.platform = platform
        self.sessionScriptS3Location = sessionScriptS3Location
        self.streamView = streamView
        self.tags = tags
        self.usbDeviceFilterStrings = usbDeviceFilterStrings
        self.vpcConfig = vpcConfig
    }
}

extension AppStreamClientTypes {
    /// Describes a fleet error.
    public struct FleetError {
        /// The error code.
        public var errorCode: AppStreamClientTypes.FleetErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?

        public init(
            errorCode: AppStreamClientTypes.FleetErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension AppStreamClientTypes {

    public enum FleetState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case running
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetState] {
            return [
                .running,
                .starting,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes a fleet.
    public struct Fleet {
        /// The Amazon Resource Name (ARN) for the fleet.
        /// This member is required.
        public var arn: Swift.String?
        /// The capacity status for the fleet.
        /// This member is required.
        public var computeCapacityStatus: AppStreamClientTypes.ComputeCapacityStatus?
        /// The time the fleet was created.
        public var createdTime: Foundation.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The amount of time that a streaming session remains active after users disconnect. If they try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance. Specify a value between 60 and 36000.
        public var disconnectTimeoutInSeconds: Swift.Int?
        /// The fleet name to display.
        public var displayName: Swift.String?
        /// The name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain.
        public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
        /// Indicates whether default internet access is enabled for the fleet.
        public var enableDefaultInternetAccess: Swift.Bool?
        /// The fleet errors.
        public var fleetErrors: [AppStreamClientTypes.FleetError]?
        /// The fleet type. ALWAYS_ON Provides users with instant-on access to their apps. You are charged for all running instances in your fleet, even if no users are streaming apps. ON_DEMAND Provide users with access to applications after they connect, which takes one to two minutes. You are charged for instance streaming when users are connected and a small hourly fee for instances that are not streaming apps.
        public var fleetType: AppStreamClientTypes.FleetType?
        /// The ARN of the IAM role that is applied to the fleet. To assume a role, the fleet instance calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
        public var iamRoleArn: Swift.String?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the DisconnectTimeoutInSeconds time interval begins. Users are notified before they are disconnected due to inactivity. If users try to reconnect to the streaming session before the time interval specified in DisconnectTimeoutInSeconds elapses, they are connected to their previous session. Users are considered idle when they stop providing keyboard or mouse input during their streaming session. File uploads and downloads, audio in, audio out, and pixels changing do not qualify as user activity. If users continue to be idle after the time interval in IdleDisconnectTimeoutInSeconds elapses, they are disconnected. To prevent users from being disconnected due to inactivity, specify a value of 0. Otherwise, specify a value between 60 and 36000. The default value is 0. If you enable this feature, we recommend that you specify a value that corresponds exactly to a whole number of minutes (for example, 60, 120, and 180). If you don't do this, the value is rounded to the nearest minute. For example, if you specify a value of 70, users are disconnected after 1 minute of inactivity. If you specify a value that is at the midpoint between two different minutes, the value is rounded up. For example, if you specify a value of 90, users are disconnected after 2 minutes of inactivity.
        public var idleDisconnectTimeoutInSeconds: Swift.Int?
        /// The ARN for the public, private, or shared image.
        public var imageArn: Swift.String?
        /// The name of the image used to create the fleet.
        public var imageName: Swift.String?
        /// The instance type to use when launching fleet instances. The following instance types are available:
        ///
        /// * stream.standard.small
        ///
        /// * stream.standard.medium
        ///
        /// * stream.standard.large
        ///
        /// * stream.compute.large
        ///
        /// * stream.compute.xlarge
        ///
        /// * stream.compute.2xlarge
        ///
        /// * stream.compute.4xlarge
        ///
        /// * stream.compute.8xlarge
        ///
        /// * stream.memory.large
        ///
        /// * stream.memory.xlarge
        ///
        /// * stream.memory.2xlarge
        ///
        /// * stream.memory.4xlarge
        ///
        /// * stream.memory.8xlarge
        ///
        /// * stream.memory.z1d.large
        ///
        /// * stream.memory.z1d.xlarge
        ///
        /// * stream.memory.z1d.2xlarge
        ///
        /// * stream.memory.z1d.3xlarge
        ///
        /// * stream.memory.z1d.6xlarge
        ///
        /// * stream.memory.z1d.12xlarge
        ///
        /// * stream.graphics-design.large
        ///
        /// * stream.graphics-design.xlarge
        ///
        /// * stream.graphics-design.2xlarge
        ///
        /// * stream.graphics-design.4xlarge
        ///
        /// * stream.graphics-desktop.2xlarge
        ///
        /// * stream.graphics.g4dn.xlarge
        ///
        /// * stream.graphics.g4dn.2xlarge
        ///
        /// * stream.graphics.g4dn.4xlarge
        ///
        /// * stream.graphics.g4dn.8xlarge
        ///
        /// * stream.graphics.g4dn.12xlarge
        ///
        /// * stream.graphics.g4dn.16xlarge
        ///
        /// * stream.graphics-pro.4xlarge
        ///
        /// * stream.graphics-pro.8xlarge
        ///
        /// * stream.graphics-pro.16xlarge
        /// This member is required.
        public var instanceType: Swift.String?
        /// The maximum number of concurrent sessions for the fleet.
        public var maxConcurrentSessions: Swift.Int?
        /// The maximum number of user sessions on an instance. This only applies to multi-session fleets.
        public var maxSessionsPerInstance: Swift.Int?
        /// The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance. Specify a value between 600 and 360000.
        public var maxUserDurationInSeconds: Swift.Int?
        /// The name of the fleet.
        /// This member is required.
        public var name: Swift.String?
        /// The platform of the fleet.
        public var platform: AppStreamClientTypes.PlatformType?
        /// The S3 location of the session scripts configuration zip file. This only applies to Elastic fleets.
        public var sessionScriptS3Location: AppStreamClientTypes.S3Location?
        /// The current state for the fleet.
        /// This member is required.
        public var state: AppStreamClientTypes.FleetState?
        /// The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When APP is specified, only the windows of applications opened by users display. When DESKTOP is specified, the standard desktop that is provided by the operating system displays. The default value is APP.
        public var streamView: AppStreamClientTypes.StreamView?
        /// The USB device filter strings associated with the fleet.
        public var usbDeviceFilterStrings: [Swift.String]?
        /// The VPC configuration for the fleet.
        public var vpcConfig: AppStreamClientTypes.VpcConfig?

        public init(
            arn: Swift.String? = nil,
            computeCapacityStatus: AppStreamClientTypes.ComputeCapacityStatus? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            disconnectTimeoutInSeconds: Swift.Int? = nil,
            displayName: Swift.String? = nil,
            domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
            enableDefaultInternetAccess: Swift.Bool? = nil,
            fleetErrors: [AppStreamClientTypes.FleetError]? = nil,
            fleetType: AppStreamClientTypes.FleetType? = nil,
            iamRoleArn: Swift.String? = nil,
            idleDisconnectTimeoutInSeconds: Swift.Int? = nil,
            imageArn: Swift.String? = nil,
            imageName: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            maxConcurrentSessions: Swift.Int? = nil,
            maxSessionsPerInstance: Swift.Int? = nil,
            maxUserDurationInSeconds: Swift.Int? = nil,
            name: Swift.String? = nil,
            platform: AppStreamClientTypes.PlatformType? = nil,
            sessionScriptS3Location: AppStreamClientTypes.S3Location? = nil,
            state: AppStreamClientTypes.FleetState? = nil,
            streamView: AppStreamClientTypes.StreamView? = nil,
            usbDeviceFilterStrings: [Swift.String]? = nil,
            vpcConfig: AppStreamClientTypes.VpcConfig? = nil
        )
        {
            self.arn = arn
            self.computeCapacityStatus = computeCapacityStatus
            self.createdTime = createdTime
            self.description = description
            self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
            self.displayName = displayName
            self.domainJoinInfo = domainJoinInfo
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.fleetErrors = fleetErrors
            self.fleetType = fleetType
            self.iamRoleArn = iamRoleArn
            self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
            self.imageArn = imageArn
            self.imageName = imageName
            self.instanceType = instanceType
            self.maxConcurrentSessions = maxConcurrentSessions
            self.maxSessionsPerInstance = maxSessionsPerInstance
            self.maxUserDurationInSeconds = maxUserDurationInSeconds
            self.name = name
            self.platform = platform
            self.sessionScriptS3Location = sessionScriptS3Location
            self.state = state
            self.streamView = streamView
            self.usbDeviceFilterStrings = usbDeviceFilterStrings
            self.vpcConfig = vpcConfig
        }
    }

}

public struct CreateFleetOutput {
    /// Information about the fleet.
    public var fleet: AppStreamClientTypes.Fleet?

    public init(
        fleet: AppStreamClientTypes.Fleet? = nil
    )
    {
        self.fleet = fleet
    }
}

public struct CreateImageBuilderInput {
    /// The list of interface VPC endpoint (interface endpoint) objects. Administrators can connect to the image builder only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The version of the AppStream 2.0 agent to use for this image builder. To use the latest version of the AppStream 2.0 agent, specify [LATEST].
    public var appstreamAgentVersion: Swift.String?
    /// The description to display.
    public var description: Swift.String?
    /// The image builder name to display.
    public var displayName: Swift.String?
    /// The name of the directory and organizational unit (OU) to use to join the image builder to a Microsoft Active Directory domain.
    public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    /// Enables or disables default internet access for the image builder.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the image builder. To assume a role, the image builder calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The ARN of the public, private, or shared image to use.
    public var imageArn: Swift.String?
    /// The name of the image used to create the image builder.
    public var imageName: Swift.String?
    /// The instance type to use when launching the image builder. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.compute.large
    ///
    /// * stream.compute.xlarge
    ///
    /// * stream.compute.2xlarge
    ///
    /// * stream.compute.4xlarge
    ///
    /// * stream.compute.8xlarge
    ///
    /// * stream.memory.large
    ///
    /// * stream.memory.xlarge
    ///
    /// * stream.memory.2xlarge
    ///
    /// * stream.memory.4xlarge
    ///
    /// * stream.memory.8xlarge
    ///
    /// * stream.memory.z1d.large
    ///
    /// * stream.memory.z1d.xlarge
    ///
    /// * stream.memory.z1d.2xlarge
    ///
    /// * stream.memory.z1d.3xlarge
    ///
    /// * stream.memory.z1d.6xlarge
    ///
    /// * stream.memory.z1d.12xlarge
    ///
    /// * stream.graphics-design.large
    ///
    /// * stream.graphics-design.xlarge
    ///
    /// * stream.graphics-design.2xlarge
    ///
    /// * stream.graphics-design.4xlarge
    ///
    /// * stream.graphics-desktop.2xlarge
    ///
    /// * stream.graphics.g4dn.xlarge
    ///
    /// * stream.graphics.g4dn.2xlarge
    ///
    /// * stream.graphics.g4dn.4xlarge
    ///
    /// * stream.graphics.g4dn.8xlarge
    ///
    /// * stream.graphics.g4dn.12xlarge
    ///
    /// * stream.graphics.g4dn.16xlarge
    ///
    /// * stream.graphics-pro.4xlarge
    ///
    /// * stream.graphics-pro.8xlarge
    ///
    /// * stream.graphics-pro.16xlarge
    /// This member is required.
    public var instanceType: Swift.String?
    /// A unique name for the image builder.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to associate with the image builder. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ If you do not specify a value, the value is set to an empty string. For more information about tags, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var tags: [Swift.String: Swift.String]?
    /// The VPC configuration for the image builder. You can specify only one subnet.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init(
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        appstreamAgentVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        iamRoleArn: Swift.String? = nil,
        imageArn: Swift.String? = nil,
        imageName: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.appstreamAgentVersion = appstreamAgentVersion
        self.description = description
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.iamRoleArn = iamRoleArn
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.name = name
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

extension AppStreamClientTypes {

    public enum LatestAppstreamAgentVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [LatestAppstreamAgentVersion] {
            return [
                .false,
                .true
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes the network details of the fleet or image builder instance.
    public struct NetworkAccessConfiguration {
        /// The resource identifier of the elastic network interface that is attached to instances in your VPC. All network interfaces have the eni-xxxxxxxx resource identifier.
        public var eniId: Swift.String?
        /// The private IP address of the elastic network interface that is attached to instances in your VPC.
        public var eniPrivateIpAddress: Swift.String?

        public init(
            eniId: Swift.String? = nil,
            eniPrivateIpAddress: Swift.String? = nil
        )
        {
            self.eniId = eniId
            self.eniPrivateIpAddress = eniPrivateIpAddress
        }
    }

}

extension AppStreamClientTypes {

    public enum ImageBuilderState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleting
        case failed
        case pending
        case pendingQualification
        case rebooting
        case running
        case snapshotting
        case stopped
        case stopping
        case updating
        case updatingAgent
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageBuilderState] {
            return [
                .deleting,
                .failed,
                .pending,
                .pendingQualification,
                .rebooting,
                .running,
                .snapshotting,
                .stopped,
                .stopping,
                .updating,
                .updatingAgent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .pendingQualification: return "PENDING_QUALIFICATION"
            case .rebooting: return "REBOOTING"
            case .running: return "RUNNING"
            case .snapshotting: return "SNAPSHOTTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case .updatingAgent: return "UPDATING_AGENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {

    public enum ImageBuilderStateChangeReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case imageUnavailable
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageBuilderStateChangeReasonCode] {
            return [
                .imageUnavailable,
                .internalError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .imageUnavailable: return "IMAGE_UNAVAILABLE"
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes the reason why the last image builder state change occurred.
    public struct ImageBuilderStateChangeReason {
        /// The state change reason code.
        public var code: AppStreamClientTypes.ImageBuilderStateChangeReasonCode?
        /// The state change reason message.
        public var message: Swift.String?

        public init(
            code: AppStreamClientTypes.ImageBuilderStateChangeReasonCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension AppStreamClientTypes {
    /// Describes a virtual machine that is used to create an image.
    public struct ImageBuilder {
        /// The list of virtual private cloud (VPC) interface endpoint objects. Administrators can connect to the image builder only through the specified endpoints.
        public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
        /// The version of the AppStream 2.0 agent that is currently being used by the image builder.
        public var appstreamAgentVersion: Swift.String?
        /// The ARN for the image builder.
        public var arn: Swift.String?
        /// The time stamp when the image builder was created.
        public var createdTime: Foundation.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The image builder name to display.
        public var displayName: Swift.String?
        /// The name of the directory and organizational unit (OU) to use to join the image builder to a Microsoft Active Directory domain.
        public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
        /// Enables or disables default internet access for the image builder.
        public var enableDefaultInternetAccess: Swift.Bool?
        /// The ARN of the IAM role that is applied to the image builder. To assume a role, the image builder calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
        public var iamRoleArn: Swift.String?
        /// The ARN of the image from which this builder was created.
        public var imageArn: Swift.String?
        /// The image builder errors.
        public var imageBuilderErrors: [AppStreamClientTypes.ResourceError]?
        /// The instance type for the image builder. The following instance types are available:
        ///
        /// * stream.standard.small
        ///
        /// * stream.standard.medium
        ///
        /// * stream.standard.large
        ///
        /// * stream.compute.large
        ///
        /// * stream.compute.xlarge
        ///
        /// * stream.compute.2xlarge
        ///
        /// * stream.compute.4xlarge
        ///
        /// * stream.compute.8xlarge
        ///
        /// * stream.memory.large
        ///
        /// * stream.memory.xlarge
        ///
        /// * stream.memory.2xlarge
        ///
        /// * stream.memory.4xlarge
        ///
        /// * stream.memory.8xlarge
        ///
        /// * stream.memory.z1d.large
        ///
        /// * stream.memory.z1d.xlarge
        ///
        /// * stream.memory.z1d.2xlarge
        ///
        /// * stream.memory.z1d.3xlarge
        ///
        /// * stream.memory.z1d.6xlarge
        ///
        /// * stream.memory.z1d.12xlarge
        ///
        /// * stream.graphics-design.large
        ///
        /// * stream.graphics-design.xlarge
        ///
        /// * stream.graphics-design.2xlarge
        ///
        /// * stream.graphics-design.4xlarge
        ///
        /// * stream.graphics-desktop.2xlarge
        ///
        /// * stream.graphics.g4dn.xlarge
        ///
        /// * stream.graphics.g4dn.2xlarge
        ///
        /// * stream.graphics.g4dn.4xlarge
        ///
        /// * stream.graphics.g4dn.8xlarge
        ///
        /// * stream.graphics.g4dn.12xlarge
        ///
        /// * stream.graphics.g4dn.16xlarge
        ///
        /// * stream.graphics-pro.4xlarge
        ///
        /// * stream.graphics-pro.8xlarge
        ///
        /// * stream.graphics-pro.16xlarge
        public var instanceType: Swift.String?
        /// Indicates whether the image builder is using the latest AppStream 2.0 agent version or not.
        public var latestAppstreamAgentVersion: AppStreamClientTypes.LatestAppstreamAgentVersion?
        /// The name of the image builder.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the network details of the fleet or image builder instance.
        public var networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration?
        /// The operating system platform of the image builder.
        public var platform: AppStreamClientTypes.PlatformType?
        /// The state of the image builder.
        public var state: AppStreamClientTypes.ImageBuilderState?
        /// The reason why the last state change occurred.
        public var stateChangeReason: AppStreamClientTypes.ImageBuilderStateChangeReason?
        /// The VPC configuration of the image builder.
        public var vpcConfig: AppStreamClientTypes.VpcConfig?

        public init(
            accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
            appstreamAgentVersion: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
            enableDefaultInternetAccess: Swift.Bool? = nil,
            iamRoleArn: Swift.String? = nil,
            imageArn: Swift.String? = nil,
            imageBuilderErrors: [AppStreamClientTypes.ResourceError]? = nil,
            instanceType: Swift.String? = nil,
            latestAppstreamAgentVersion: AppStreamClientTypes.LatestAppstreamAgentVersion? = nil,
            name: Swift.String? = nil,
            networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration? = nil,
            platform: AppStreamClientTypes.PlatformType? = nil,
            state: AppStreamClientTypes.ImageBuilderState? = nil,
            stateChangeReason: AppStreamClientTypes.ImageBuilderStateChangeReason? = nil,
            vpcConfig: AppStreamClientTypes.VpcConfig? = nil
        )
        {
            self.accessEndpoints = accessEndpoints
            self.appstreamAgentVersion = appstreamAgentVersion
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.domainJoinInfo = domainJoinInfo
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.iamRoleArn = iamRoleArn
            self.imageArn = imageArn
            self.imageBuilderErrors = imageBuilderErrors
            self.instanceType = instanceType
            self.latestAppstreamAgentVersion = latestAppstreamAgentVersion
            self.name = name
            self.networkAccessConfiguration = networkAccessConfiguration
            self.platform = platform
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.vpcConfig = vpcConfig
        }
    }

}

public struct CreateImageBuilderOutput {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init(
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

public struct CreateImageBuilderStreamingURLInput {
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?
    /// The time that the streaming URL will be valid, in seconds. Specify a value between 1 and 604800 seconds. The default is 3600 seconds.
    public var validity: Swift.Int?

    public init(
        name: Swift.String? = nil,
        validity: Swift.Int? = nil
    )
    {
        self.name = name
        self.validity = validity
    }
}

public struct CreateImageBuilderStreamingURLOutput {
    /// The elapsed time, in seconds after the Unix epoch, when this URL expires.
    public var expires: Foundation.Date?
    /// The URL to start the AppStream 2.0 streaming session.
    public var streamingURL: Swift.String?

    public init(
        expires: Foundation.Date? = nil,
        streamingURL: Swift.String? = nil
    )
    {
        self.expires = expires
        self.streamingURL = streamingURL
    }
}

extension AppStreamClientTypes {

    /// The type of storage connector.
    public enum StorageConnectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case googleDrive
        case homefolders
        case oneDrive
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageConnectorType] {
            return [
                .googleDrive,
                .homefolders,
                .oneDrive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .googleDrive: return "GOOGLE_DRIVE"
            case .homefolders: return "HOMEFOLDERS"
            case .oneDrive: return "ONE_DRIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes a connector that enables persistent storage for users.
    public struct StorageConnector {
        /// The type of storage connector.
        /// This member is required.
        public var connectorType: AppStreamClientTypes.StorageConnectorType?
        /// The names of the domains for the account.
        public var domains: [Swift.String]?
        /// The ARN of the storage connector.
        public var resourceIdentifier: Swift.String?

        public init(
            connectorType: AppStreamClientTypes.StorageConnectorType? = nil,
            domains: [Swift.String]? = nil,
            resourceIdentifier: Swift.String? = nil
        )
        {
            self.connectorType = connectorType
            self.domains = domains
            self.resourceIdentifier = resourceIdentifier
        }
    }

}

extension AppStreamClientTypes {

    public enum PreferredProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [PreferredProtocol] {
            return [
                .tcp,
                .udp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// The streaming protocol you want your stack to prefer. This can be UDP or TCP. Currently, UDP is only supported in the Windows native client.
    public struct StreamingExperienceSettings {
        /// The preferred protocol that you want to use while streaming your application.
        public var preferredProtocol: AppStreamClientTypes.PreferredProtocol?

        public init(
            preferredProtocol: AppStreamClientTypes.PreferredProtocol? = nil
        )
        {
            self.preferredProtocol = preferredProtocol
        }
    }

}

extension AppStreamClientTypes {

    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes an action and whether the action is enabled or disabled for users during their streaming sessions.
    public struct UserSetting {
        /// The action that is enabled or disabled.
        /// This member is required.
        public var action: AppStreamClientTypes.Action?
        /// Specifies the number of characters that can be copied by end users from the local device to the remote session, and to the local device from the remote session. This can be specified only for the CLIPBOARD_COPY_FROM_LOCAL_DEVICE and CLIPBOARD_COPY_TO_LOCAL_DEVICE actions. This defaults to 20,971,520 (20 MB) when unspecified and the permission is ENABLED. This can't be specified when the permission is DISABLED. The value can be between 1 and 20,971,520 (20 MB).
        public var maximumLength: Swift.Int?
        /// Indicates whether the action is enabled or disabled.
        /// This member is required.
        public var permission: AppStreamClientTypes.Permission?

        public init(
            action: AppStreamClientTypes.Action? = nil,
            maximumLength: Swift.Int? = nil,
            permission: AppStreamClientTypes.Permission? = nil
        )
        {
            self.action = action
            self.maximumLength = maximumLength
            self.permission = permission
        }
    }

}

public struct CreateStackInput {
    /// The list of interface VPC endpoint (interface endpoint) objects. Users of the stack can connect to AppStream 2.0 only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The persistent application settings for users of a stack. When these settings are enabled, changes that users make to applications and Windows settings are automatically saved after each session and applied to the next session.
    public var applicationSettings: AppStreamClientTypes.ApplicationSettings?
    /// The description to display.
    public var description: Swift.String?
    /// The stack name to display.
    public var displayName: Swift.String?
    /// The domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions.
    public var embedHostDomains: [Swift.String]?
    /// The URL that users are redirected to after they click the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.
    public var feedbackURL: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var name: Swift.String?
    /// The URL that users are redirected to after their streaming session ends.
    public var redirectURL: Swift.String?
    /// The storage connectors to enable.
    public var storageConnectors: [AppStreamClientTypes.StorageConnector]?
    /// The streaming protocol you want your stack to prefer. This can be UDP or TCP. Currently, UDP is only supported in the Windows native client.
    public var streamingExperienceSettings: AppStreamClientTypes.StreamingExperienceSettings?
    /// The tags to associate with the stack. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. If you do not specify a value, the value is set to an empty string. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ For more information about tags, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var tags: [Swift.String: Swift.String]?
    /// The actions that are enabled or disabled for users during their streaming sessions. By default, these actions are enabled.
    public var userSettings: [AppStreamClientTypes.UserSetting]?

    public init(
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        applicationSettings: AppStreamClientTypes.ApplicationSettings? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        embedHostDomains: [Swift.String]? = nil,
        feedbackURL: Swift.String? = nil,
        name: Swift.String? = nil,
        redirectURL: Swift.String? = nil,
        storageConnectors: [AppStreamClientTypes.StorageConnector]? = nil,
        streamingExperienceSettings: AppStreamClientTypes.StreamingExperienceSettings? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        userSettings: [AppStreamClientTypes.UserSetting]? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.applicationSettings = applicationSettings
        self.description = description
        self.displayName = displayName
        self.embedHostDomains = embedHostDomains
        self.feedbackURL = feedbackURL
        self.name = name
        self.redirectURL = redirectURL
        self.storageConnectors = storageConnectors
        self.streamingExperienceSettings = streamingExperienceSettings
        self.tags = tags
        self.userSettings = userSettings
    }
}

extension AppStreamClientTypes {

    public enum StackErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalServiceError
        case storageConnectorError
        case sdkUnknown(Swift.String)

        public static var allCases: [StackErrorCode] {
            return [
                .internalServiceError,
                .storageConnectorError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .storageConnectorError: return "STORAGE_CONNECTOR_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes a stack error.
    public struct StackError {
        /// The error code.
        public var errorCode: AppStreamClientTypes.StackErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?

        public init(
            errorCode: AppStreamClientTypes.StackErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension AppStreamClientTypes {
    /// Describes a stack.
    public struct Stack {
        /// The list of virtual private cloud (VPC) interface endpoint objects. Users of the stack can connect to AppStream 2.0 only through the specified endpoints.
        public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
        /// The persistent application settings for users of the stack.
        public var applicationSettings: AppStreamClientTypes.ApplicationSettingsResponse?
        /// The ARN of the stack.
        public var arn: Swift.String?
        /// The time the stack was created.
        public var createdTime: Foundation.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The stack name to display.
        public var displayName: Swift.String?
        /// The domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions.
        public var embedHostDomains: [Swift.String]?
        /// The URL that users are redirected to after they click the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.
        public var feedbackURL: Swift.String?
        /// The name of the stack.
        /// This member is required.
        public var name: Swift.String?
        /// The URL that users are redirected to after their streaming session ends.
        public var redirectURL: Swift.String?
        /// The errors for the stack.
        public var stackErrors: [AppStreamClientTypes.StackError]?
        /// The storage connectors to enable.
        public var storageConnectors: [AppStreamClientTypes.StorageConnector]?
        /// The streaming protocol you want your stack to prefer. This can be UDP or TCP. Currently, UDP is only supported in the Windows native client.
        public var streamingExperienceSettings: AppStreamClientTypes.StreamingExperienceSettings?
        /// The actions that are enabled or disabled for users during their streaming sessions. By default these actions are enabled.
        public var userSettings: [AppStreamClientTypes.UserSetting]?

        public init(
            accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
            applicationSettings: AppStreamClientTypes.ApplicationSettingsResponse? = nil,
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            embedHostDomains: [Swift.String]? = nil,
            feedbackURL: Swift.String? = nil,
            name: Swift.String? = nil,
            redirectURL: Swift.String? = nil,
            stackErrors: [AppStreamClientTypes.StackError]? = nil,
            storageConnectors: [AppStreamClientTypes.StorageConnector]? = nil,
            streamingExperienceSettings: AppStreamClientTypes.StreamingExperienceSettings? = nil,
            userSettings: [AppStreamClientTypes.UserSetting]? = nil
        )
        {
            self.accessEndpoints = accessEndpoints
            self.applicationSettings = applicationSettings
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.embedHostDomains = embedHostDomains
            self.feedbackURL = feedbackURL
            self.name = name
            self.redirectURL = redirectURL
            self.stackErrors = stackErrors
            self.storageConnectors = storageConnectors
            self.streamingExperienceSettings = streamingExperienceSettings
            self.userSettings = userSettings
        }
    }

}

public struct CreateStackOutput {
    /// Information about the stack.
    public var stack: AppStreamClientTypes.Stack?

    public init(
        stack: AppStreamClientTypes.Stack? = nil
    )
    {
        self.stack = stack
    }
}

public struct CreateStreamingURLInput {
    /// The name of the application to launch after the session starts. This is the name that you specified as Name in the Image Assistant. If your fleet is enabled for the Desktop stream view, you can also choose to launch directly to the operating system desktop. To do so, specify Desktop.
    public var applicationId: Swift.String?
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The session context. For more information, see [Session Context](https://docs.aws.amazon.com/appstream2/latest/developerguide/managing-stacks-fleets.html#managing-stacks-fleets-parameters) in the Amazon AppStream 2.0 Administration Guide.
    public var sessionContext: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?
    /// The identifier of the user.
    /// This member is required.
    public var userId: Swift.String?
    /// The time that the streaming URL will be valid, in seconds. Specify a value between 1 and 604800 seconds. The default is 60 seconds.
    public var validity: Swift.Int?

    public init(
        applicationId: Swift.String? = nil,
        fleetName: Swift.String? = nil,
        sessionContext: Swift.String? = nil,
        stackName: Swift.String? = nil,
        userId: Swift.String? = nil,
        validity: Swift.Int? = nil
    )
    {
        self.applicationId = applicationId
        self.fleetName = fleetName
        self.sessionContext = sessionContext
        self.stackName = stackName
        self.userId = userId
        self.validity = validity
    }
}

public struct CreateStreamingURLOutput {
    /// The elapsed time, in seconds after the Unix epoch, when this URL expires.
    public var expires: Foundation.Date?
    /// The URL to start the AppStream 2.0 streaming session.
    public var streamingURL: Swift.String?

    public init(
        expires: Foundation.Date? = nil,
        streamingURL: Swift.String? = nil
    )
    {
        self.expires = expires
        self.streamingURL = streamingURL
    }
}

extension AppStreamClientTypes {
    /// The website links that display in the catalog page footer.
    public struct ThemeFooterLink {
        /// The name of the websites that display in the catalog page footer.
        public var displayName: Swift.String?
        /// The URL of the websites that display in the catalog page footer.
        public var footerLinkURL: Swift.String?

        public init(
            displayName: Swift.String? = nil,
            footerLinkURL: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.footerLinkURL = footerLinkURL
        }
    }

}

extension AppStreamClientTypes {

    public enum ThemeStyling: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blue
        case lightBlue
        case pink
        case red
        case sdkUnknown(Swift.String)

        public static var allCases: [ThemeStyling] {
            return [
                .blue,
                .lightBlue,
                .pink,
                .red
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blue: return "BLUE"
            case .lightBlue: return "LIGHT_BLUE"
            case .pink: return "PINK"
            case .red: return "RED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateThemeForStackInput {
    /// The S3 location of the favicon. The favicon enables users to recognize their application streaming site in a browser full of tabs or bookmarks. It is displayed at the top of the browser tab for the application streaming site during users' streaming sessions.
    /// This member is required.
    public var faviconS3Location: AppStreamClientTypes.S3Location?
    /// The links that are displayed in the footer of the streaming application catalog page. These links are helpful resources for users, such as the organization's IT support and product marketing sites.
    public var footerLinks: [AppStreamClientTypes.ThemeFooterLink]?
    /// The organization logo that appears on the streaming application catalog page.
    /// This member is required.
    public var organizationLogoS3Location: AppStreamClientTypes.S3Location?
    /// The name of the stack for the theme.
    /// This member is required.
    public var stackName: Swift.String?
    /// The color theme that is applied to website links, text, and buttons. These colors are also applied as accents in the background for the streaming application catalog page.
    /// This member is required.
    public var themeStyling: AppStreamClientTypes.ThemeStyling?
    /// The title that is displayed at the top of the browser tab during users' application streaming sessions.
    /// This member is required.
    public var titleText: Swift.String?

    public init(
        faviconS3Location: AppStreamClientTypes.S3Location? = nil,
        footerLinks: [AppStreamClientTypes.ThemeFooterLink]? = nil,
        organizationLogoS3Location: AppStreamClientTypes.S3Location? = nil,
        stackName: Swift.String? = nil,
        themeStyling: AppStreamClientTypes.ThemeStyling? = nil,
        titleText: Swift.String? = nil
    )
    {
        self.faviconS3Location = faviconS3Location
        self.footerLinks = footerLinks
        self.organizationLogoS3Location = organizationLogoS3Location
        self.stackName = stackName
        self.themeStyling = themeStyling
        self.titleText = titleText
    }
}

extension AppStreamClientTypes {

    public enum ThemeState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ThemeState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// The custom branding theme, which might include a custom logo, website links, and other branding to display to users.
    public struct Theme {
        /// The time the theme was created.
        public var createdTime: Foundation.Date?
        /// The stack that has the custom branding theme.
        public var stackName: Swift.String?
        /// The state of the theme.
        public var state: AppStreamClientTypes.ThemeState?
        /// The URL of the icon that displays at the top of a user's browser tab during streaming sessions.
        public var themeFaviconURL: Swift.String?
        /// The website links that display in the catalog page footer.
        public var themeFooterLinks: [AppStreamClientTypes.ThemeFooterLink]?
        /// The URL of the logo that displays in the catalog page header.
        public var themeOrganizationLogoURL: Swift.String?
        /// The color that is used for the website links, text, buttons, and catalog page background.
        public var themeStyling: AppStreamClientTypes.ThemeStyling?
        /// The browser tab page title.
        public var themeTitleText: Swift.String?

        public init(
            createdTime: Foundation.Date? = nil,
            stackName: Swift.String? = nil,
            state: AppStreamClientTypes.ThemeState? = nil,
            themeFaviconURL: Swift.String? = nil,
            themeFooterLinks: [AppStreamClientTypes.ThemeFooterLink]? = nil,
            themeOrganizationLogoURL: Swift.String? = nil,
            themeStyling: AppStreamClientTypes.ThemeStyling? = nil,
            themeTitleText: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.stackName = stackName
            self.state = state
            self.themeFaviconURL = themeFaviconURL
            self.themeFooterLinks = themeFooterLinks
            self.themeOrganizationLogoURL = themeOrganizationLogoURL
            self.themeStyling = themeStyling
            self.themeTitleText = themeTitleText
        }
    }

}

public struct CreateThemeForStackOutput {
    /// The theme object that contains the metadata of the custom branding.
    public var theme: AppStreamClientTypes.Theme?

    public init(
        theme: AppStreamClientTypes.Theme? = nil
    )
    {
        self.theme = theme
    }
}

public struct CreateUpdatedImageInput {
    /// Indicates whether to display the status of image update availability before AppStream 2.0 initiates the process of creating a new updated image. If this value is set to true, AppStream 2.0 displays whether image updates are available. If this value is set to false, AppStream 2.0 initiates the process of creating a new updated image without displaying whether image updates are available.
    public var dryRun: Swift.Bool?
    /// The name of the image to update.
    /// This member is required.
    public var existingImageName: Swift.String?
    /// The description to display for the new image.
    public var newImageDescription: Swift.String?
    /// The name to display for the new image.
    public var newImageDisplayName: Swift.String?
    /// The name of the new image. The name must be unique within the AWS account and Region.
    /// This member is required.
    public var newImageName: Swift.String?
    /// The tags to associate with the new image. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ If you do not specify a value, the value is set to an empty string. For more information about tags, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var newImageTags: [Swift.String: Swift.String]?

    public init(
        dryRun: Swift.Bool? = nil,
        existingImageName: Swift.String? = nil,
        newImageDescription: Swift.String? = nil,
        newImageDisplayName: Swift.String? = nil,
        newImageName: Swift.String? = nil,
        newImageTags: [Swift.String: Swift.String]? = nil
    )
    {
        self.dryRun = dryRun
        self.existingImageName = existingImageName
        self.newImageDescription = newImageDescription
        self.newImageDisplayName = newImageDisplayName
        self.newImageName = newImageName
        self.newImageTags = newImageTags
    }
}

extension AppStreamClientTypes {

    public enum DynamicAppProvidersEnabled: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DynamicAppProvidersEnabled] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes the permissions for an image.
    public struct ImagePermissions {
        /// Indicates whether the image can be used for a fleet.
        public var allowFleet: Swift.Bool?
        /// Indicates whether the image can be used for an image builder.
        public var allowImageBuilder: Swift.Bool?

        public init(
            allowFleet: Swift.Bool? = nil,
            allowImageBuilder: Swift.Bool? = nil
        )
        {
            self.allowFleet = allowFleet
            self.allowImageBuilder = allowImageBuilder
        }
    }

}

extension AppStreamClientTypes {

    public enum ImageSharedWithOthers: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageSharedWithOthers] {
            return [
                .false,
                .true
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {

    public enum ImageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case copying
        case creating
        case deleting
        case failed
        case importing
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageState] {
            return [
                .available,
                .copying,
                .creating,
                .deleting,
                .failed,
                .importing,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .copying: return "COPYING"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .importing: return "IMPORTING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {

    public enum ImageStateChangeReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case imageBuilderNotAvailable
        case imageCopyFailure
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageStateChangeReasonCode] {
            return [
                .imageBuilderNotAvailable,
                .imageCopyFailure,
                .internalError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .imageBuilderNotAvailable: return "IMAGE_BUILDER_NOT_AVAILABLE"
            case .imageCopyFailure: return "IMAGE_COPY_FAILURE"
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes the reason why the last image state change occurred.
    public struct ImageStateChangeReason {
        /// The state change reason code.
        public var code: AppStreamClientTypes.ImageStateChangeReasonCode?
        /// The state change reason message.
        public var message: Swift.String?

        public init(
            code: AppStreamClientTypes.ImageStateChangeReasonCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension AppStreamClientTypes {

    public enum VisibilityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `private`
        case `public`
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [VisibilityType] {
            return [
                .private,
                .public,
                .shared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes an image.
    public struct Image {
        /// The applications associated with the image.
        public var applications: [AppStreamClientTypes.Application]?
        /// The version of the AppStream 2.0 agent to use for instances that are launched from this image.
        public var appstreamAgentVersion: Swift.String?
        /// The ARN of the image.
        public var arn: Swift.String?
        /// The ARN of the image from which this image was created.
        public var baseImageArn: Swift.String?
        /// The time the image was created.
        public var createdTime: Foundation.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The image name to display.
        public var displayName: Swift.String?
        /// Indicates whether dynamic app providers are enabled within an AppStream 2.0 image or not.
        public var dynamicAppProvidersEnabled: AppStreamClientTypes.DynamicAppProvidersEnabled?
        /// The name of the image builder that was used to create the private image. If the image is shared, this value is null.
        public var imageBuilderName: Swift.String?
        /// Indicates whether an image builder can be launched from this image.
        public var imageBuilderSupported: Swift.Bool?
        /// Describes the errors that are returned when a new image can't be created.
        public var imageErrors: [AppStreamClientTypes.ResourceError]?
        /// The permissions to provide to the destination AWS account for the specified image.
        public var imagePermissions: AppStreamClientTypes.ImagePermissions?
        /// Indicates whether the image is shared with another account ID.
        public var imageSharedWithOthers: AppStreamClientTypes.ImageSharedWithOthers?
        /// Indicates whether the image is using the latest AppStream 2.0 agent version or not.
        public var latestAppstreamAgentVersion: AppStreamClientTypes.LatestAppstreamAgentVersion?
        /// The name of the image.
        /// This member is required.
        public var name: Swift.String?
        /// The operating system platform of the image.
        public var platform: AppStreamClientTypes.PlatformType?
        /// The release date of the public base image. For private images, this date is the release date of the base image from which the image was created.
        public var publicBaseImageReleasedDate: Foundation.Date?
        /// The image starts in the PENDING state. If image creation succeeds, the state is AVAILABLE. If image creation fails, the state is FAILED.
        public var state: AppStreamClientTypes.ImageState?
        /// The reason why the last state change occurred.
        public var stateChangeReason: AppStreamClientTypes.ImageStateChangeReason?
        /// The supported instances families that determine which image a customer can use when the customer launches a fleet or image builder. The following instances families are supported:
        ///
        /// * General Purpose
        ///
        /// * Compute Optimized
        ///
        /// * Memory Optimized
        ///
        /// * Graphics
        ///
        /// * Graphics Design
        ///
        /// * Graphics Pro
        ///
        /// * Graphics G4
        ///
        /// * Graphics G5
        public var supportedInstanceFamilies: [Swift.String]?
        /// Indicates whether the image is public or private.
        public var visibility: AppStreamClientTypes.VisibilityType?

        public init(
            applications: [AppStreamClientTypes.Application]? = nil,
            appstreamAgentVersion: Swift.String? = nil,
            arn: Swift.String? = nil,
            baseImageArn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            dynamicAppProvidersEnabled: AppStreamClientTypes.DynamicAppProvidersEnabled? = nil,
            imageBuilderName: Swift.String? = nil,
            imageBuilderSupported: Swift.Bool? = nil,
            imageErrors: [AppStreamClientTypes.ResourceError]? = nil,
            imagePermissions: AppStreamClientTypes.ImagePermissions? = nil,
            imageSharedWithOthers: AppStreamClientTypes.ImageSharedWithOthers? = nil,
            latestAppstreamAgentVersion: AppStreamClientTypes.LatestAppstreamAgentVersion? = nil,
            name: Swift.String? = nil,
            platform: AppStreamClientTypes.PlatformType? = nil,
            publicBaseImageReleasedDate: Foundation.Date? = nil,
            state: AppStreamClientTypes.ImageState? = nil,
            stateChangeReason: AppStreamClientTypes.ImageStateChangeReason? = nil,
            supportedInstanceFamilies: [Swift.String]? = nil,
            visibility: AppStreamClientTypes.VisibilityType? = nil
        )
        {
            self.applications = applications
            self.appstreamAgentVersion = appstreamAgentVersion
            self.arn = arn
            self.baseImageArn = baseImageArn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.dynamicAppProvidersEnabled = dynamicAppProvidersEnabled
            self.imageBuilderName = imageBuilderName
            self.imageBuilderSupported = imageBuilderSupported
            self.imageErrors = imageErrors
            self.imagePermissions = imagePermissions
            self.imageSharedWithOthers = imageSharedWithOthers
            self.latestAppstreamAgentVersion = latestAppstreamAgentVersion
            self.name = name
            self.platform = platform
            self.publicBaseImageReleasedDate = publicBaseImageReleasedDate
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.supportedInstanceFamilies = supportedInstanceFamilies
            self.visibility = visibility
        }
    }

}

public struct CreateUpdatedImageOutput {
    /// Indicates whether a new image can be created.
    public var canUpdateImage: Swift.Bool?
    /// Describes an image.
    public var image: AppStreamClientTypes.Image?

    public init(
        canUpdateImage: Swift.Bool? = nil,
        image: AppStreamClientTypes.Image? = nil
    )
    {
        self.canUpdateImage = canUpdateImage
        self.image = image
    }
}

public struct CreateUsageReportSubscriptionInput {

    public init() { }
}

extension AppStreamClientTypes {

    public enum UsageReportSchedule: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case daily
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageReportSchedule] {
            return [
                .daily
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateUsageReportSubscriptionOutput {
    /// The Amazon S3 bucket where generated reports are stored. If you enabled on-instance session scripts and Amazon S3 logging for your session script configuration, AppStream 2.0 created an S3 bucket to store the script output. The bucket is unique to your account and Region. When you enable usage reporting in this case, AppStream 2.0 uses the same bucket to store your usage reports. If you haven't already enabled on-instance session scripts, when you enable usage reports, AppStream 2.0 creates a new S3 bucket.
    public var s3BucketName: Swift.String?
    /// The schedule for generating usage reports.
    public var schedule: AppStreamClientTypes.UsageReportSchedule?

    public init(
        s3BucketName: Swift.String? = nil,
        schedule: AppStreamClientTypes.UsageReportSchedule? = nil
    )
    {
        self.s3BucketName = s3BucketName
        self.schedule = schedule
    }
}

extension AppStreamClientTypes {

    public enum MessageAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case resend
        case suppress
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageAction] {
            return [
                .resend,
                .suppress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .resend: return "RESEND"
            case .suppress: return "SUPPRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateUserInput {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The first name, or given name, of the user.
    public var firstName: Swift.String?
    /// The last name, or surname, of the user.
    public var lastName: Swift.String?
    /// The action to take for the welcome email that is sent to a user after the user is created in the user pool. If you specify SUPPRESS, no email is sent. If you specify RESEND, do not specify the first name or last name of the user. If the value is null, the email is sent. The temporary password in the welcome email is valid for only 7 days. If users don’t set their passwords within 7 days, you must send them a new welcome email.
    public var messageAction: AppStreamClientTypes.MessageAction?
    /// The email address of the user. Users' email addresses are case-sensitive. During login, if they specify an email address that doesn't use the same capitalization as the email address specified when their user pool account was created, a "user does not exist" error message displays.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        messageAction: AppStreamClientTypes.MessageAction? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.firstName = firstName
        self.lastName = lastName
        self.messageAction = messageAction
        self.userName = userName
    }
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(authenticationType: \(Swift.String(describing: authenticationType)), messageAction: \(Swift.String(describing: messageAction)), firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", userName: \"CONTENT_REDACTED\")"}
}

public struct CreateUserOutput {

    public init() { }
}

/// The specified resource is in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message in the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteAppBlockInput {
    /// The name of the app block.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteAppBlockOutput {

    public init() { }
}

public struct DeleteAppBlockBuilderInput {
    /// The name of the app block builder.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteAppBlockBuilderOutput {

    public init() { }
}

public struct DeleteApplicationInput {
    /// The name of the application.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteApplicationOutput {

    public init() { }
}

public struct DeleteDirectoryConfigInput {
    /// The name of the directory configuration.
    /// This member is required.
    public var directoryName: Swift.String?

    public init(
        directoryName: Swift.String? = nil
    )
    {
        self.directoryName = directoryName
    }
}

public struct DeleteDirectoryConfigOutput {

    public init() { }
}

public struct DeleteEntitlementInput {
    /// The name of the entitlement.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the stack with which the entitlement is associated.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        name: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.name = name
        self.stackName = stackName
    }
}

public struct DeleteEntitlementOutput {

    public init() { }
}

public struct DeleteFleetInput {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteFleetOutput {

    public init() { }
}

public struct DeleteImageInput {
    /// The name of the image.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteImageOutput {
    /// Information about the image.
    public var image: AppStreamClientTypes.Image?

    public init(
        image: AppStreamClientTypes.Image? = nil
    )
    {
        self.image = image
    }
}

public struct DeleteImageBuilderInput {
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteImageBuilderOutput {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init(
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

public struct DeleteImagePermissionsInput {
    /// The name of the private image.
    /// This member is required.
    public var name: Swift.String?
    /// The 12-digit identifier of the AWS account for which to delete image permissions.
    /// This member is required.
    public var sharedAccountId: Swift.String?

    public init(
        name: Swift.String? = nil,
        sharedAccountId: Swift.String? = nil
    )
    {
        self.name = name
        self.sharedAccountId = sharedAccountId
    }
}

public struct DeleteImagePermissionsOutput {

    public init() { }
}

public struct DeleteStackInput {
    /// The name of the stack.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteStackOutput {

    public init() { }
}

public struct DeleteThemeForStackInput {
    /// The name of the stack for the theme.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        stackName: Swift.String? = nil
    )
    {
        self.stackName = stackName
    }
}

public struct DeleteThemeForStackOutput {

    public init() { }
}

public struct DeleteUsageReportSubscriptionInput {

    public init() { }
}

public struct DeleteUsageReportSubscriptionOutput {

    public init() { }
}

public struct DeleteUserInput {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The email address of the user. Users' email addresses are case-sensitive.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.userName = userName
    }
}

extension DeleteUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserInput(authenticationType: \(Swift.String(describing: authenticationType)), userName: \"CONTENT_REDACTED\")"}
}

public struct DeleteUserOutput {

    public init() { }
}

public struct DescribeAppBlockBuilderAppBlockAssociationsInput {
    /// The ARN of the app block.
    public var appBlockArn: Swift.String?
    /// The name of the app block builder.
    public var appBlockBuilderName: Swift.String?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        appBlockArn: Swift.String? = nil,
        appBlockBuilderName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBlockArn = appBlockArn
        self.appBlockBuilderName = appBlockBuilderName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeAppBlockBuilderAppBlockAssociationsOutput {
    /// This list of app block builders associated with app blocks.
    public var appBlockBuilderAppBlockAssociations: [AppStreamClientTypes.AppBlockBuilderAppBlockAssociation]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        appBlockBuilderAppBlockAssociations: [AppStreamClientTypes.AppBlockBuilderAppBlockAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBlockBuilderAppBlockAssociations = appBlockBuilderAppBlockAssociations
        self.nextToken = nextToken
    }
}

public struct DescribeAppBlockBuildersInput {
    /// The maximum size of each page of results. The maximum value is 25.
    public var maxResults: Swift.Int?
    /// The names of the app block builders.
    public var names: [Swift.String]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
    }
}

public struct DescribeAppBlockBuildersOutput {
    /// The list that describes one or more app block builders.
    public var appBlockBuilders: [AppStreamClientTypes.AppBlockBuilder]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        appBlockBuilders: [AppStreamClientTypes.AppBlockBuilder]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBlockBuilders = appBlockBuilders
        self.nextToken = nextToken
    }
}

public struct DescribeAppBlocksInput {
    /// The ARNs of the app blocks.
    public var arns: [Swift.String]?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        arns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arns = arns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeAppBlocksOutput {
    /// The app blocks in the list.
    public var appBlocks: [AppStreamClientTypes.AppBlock]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        appBlocks: [AppStreamClientTypes.AppBlock]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBlocks = appBlocks
        self.nextToken = nextToken
    }
}

public struct DescribeApplicationFleetAssociationsInput {
    /// The ARN of the application.
    public var applicationArn: Swift.String?
    /// The name of the fleet.
    public var fleetName: Swift.String?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        fleetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.fleetName = fleetName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeApplicationFleetAssociationsOutput {
    /// The application fleet associations in the list.
    public var applicationFleetAssociations: [AppStreamClientTypes.ApplicationFleetAssociation]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        applicationFleetAssociations: [AppStreamClientTypes.ApplicationFleetAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationFleetAssociations = applicationFleetAssociations
        self.nextToken = nextToken
    }
}

public struct DescribeApplicationsInput {
    /// The ARNs for the applications.
    public var arns: [Swift.String]?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        arns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arns = arns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeApplicationsOutput {
    /// The applications in the list.
    public var applications: [AppStreamClientTypes.Application]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        applications: [AppStreamClientTypes.Application]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

public struct DescribeDirectoryConfigsInput {
    /// The directory names.
    public var directoryNames: [Swift.String]?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        directoryNames: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryNames = directoryNames
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeDirectoryConfigsOutput {
    /// Information about the directory configurations. Note that although the response syntax in this topic includes the account password, this password is not returned in the actual response.
    public var directoryConfigs: [AppStreamClientTypes.DirectoryConfig]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        directoryConfigs: [AppStreamClientTypes.DirectoryConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryConfigs = directoryConfigs
        self.nextToken = nextToken
    }
}

public struct DescribeEntitlementsInput {
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The name of the entitlement.
    public var name: Swift.String?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The name of the stack with which the entitlement is associated.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.stackName = stackName
    }
}

public struct DescribeEntitlementsOutput {
    /// The entitlements.
    public var entitlements: [AppStreamClientTypes.Entitlement]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        entitlements: [AppStreamClientTypes.Entitlement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entitlements = entitlements
        self.nextToken = nextToken
    }
}

public struct DescribeFleetsInput {
    /// The names of the fleets to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

public struct DescribeFleetsOutput {
    /// Information about the fleets.
    public var fleets: [AppStreamClientTypes.Fleet]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        fleets: [AppStreamClientTypes.Fleet]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleets = fleets
        self.nextToken = nextToken
    }
}

public struct DescribeImageBuildersInput {
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The names of the image builders to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
    }
}

public struct DescribeImageBuildersOutput {
    /// Information about the image builders.
    public var imageBuilders: [AppStreamClientTypes.ImageBuilder]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        imageBuilders: [AppStreamClientTypes.ImageBuilder]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageBuilders = imageBuilders
        self.nextToken = nextToken
    }
}

public struct DescribeImagePermissionsInput {
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The name of the private image for which to describe permissions. The image must be one that you own.
    /// This member is required.
    public var name: Swift.String?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The 12-digit identifier of one or more AWS accounts with which the image is shared.
    public var sharedAwsAccountIds: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sharedAwsAccountIds: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.sharedAwsAccountIds = sharedAwsAccountIds
    }
}

extension AppStreamClientTypes {
    /// Describes the permissions that are available to the specified AWS account for a shared image.
    public struct SharedImagePermissions {
        /// Describes the permissions for a shared image.
        /// This member is required.
        public var imagePermissions: AppStreamClientTypes.ImagePermissions?
        /// The 12-digit identifier of the AWS account with which the image is shared.
        /// This member is required.
        public var sharedAccountId: Swift.String?

        public init(
            imagePermissions: AppStreamClientTypes.ImagePermissions? = nil,
            sharedAccountId: Swift.String? = nil
        )
        {
            self.imagePermissions = imagePermissions
            self.sharedAccountId = sharedAccountId
        }
    }

}

public struct DescribeImagePermissionsOutput {
    /// The name of the private image.
    public var name: Swift.String?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The permissions for a private image that you own.
    public var sharedImagePermissionsList: [AppStreamClientTypes.SharedImagePermissions]?

    public init(
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sharedImagePermissionsList: [AppStreamClientTypes.SharedImagePermissions]? = nil
    )
    {
        self.name = name
        self.nextToken = nextToken
        self.sharedImagePermissionsList = sharedImagePermissionsList
    }
}

public struct DescribeImagesInput {
    /// The ARNs of the public, private, and shared images to describe.
    public var arns: [Swift.String]?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The names of the public or private images to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The type of image (public, private, or shared) to describe.
    public var type: AppStreamClientTypes.VisibilityType?

    public init(
        arns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        type: AppStreamClientTypes.VisibilityType? = nil
    )
    {
        self.arns = arns
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
        self.type = type
    }
}

public struct DescribeImagesOutput {
    /// Information about the images.
    public var images: [AppStreamClientTypes.Image]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        images: [AppStreamClientTypes.Image]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.images = images
        self.nextToken = nextToken
    }
}

public struct DescribeSessionsInput {
    /// The authentication method. Specify API for a user authenticated using a streaming URL or SAML for a SAML federated user. The default is to authenticate users using a streaming URL.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The name of the fleet. This value is case-sensitive.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The identifier for the instance hosting the session.
    public var instanceId: Swift.String?
    /// The size of each page of results. The default value is 20 and the maximum value is 50.
    public var limit: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The name of the stack. This value is case-sensitive.
    /// This member is required.
    public var stackName: Swift.String?
    /// The user identifier (ID). If you specify a user ID, you must also specify the authentication type.
    public var userId: Swift.String?

    public init(
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        fleetName: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.fleetName = fleetName
        self.instanceId = instanceId
        self.limit = limit
        self.nextToken = nextToken
        self.stackName = stackName
        self.userId = userId
    }
}

extension AppStreamClientTypes {

    public enum SessionConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case notConnected
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionConnectionState] {
            return [
                .connected,
                .notConnected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .notConnected: return "NOT_CONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {

    /// Possible values for the state of a streaming session.
    public enum SessionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case expired
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionState] {
            return [
                .active,
                .expired,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .expired: return "EXPIRED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes a streaming session.
    public struct Session {
        /// The authentication method. The user is authenticated using a streaming URL (API) or SAML 2.0 federation (SAML).
        public var authenticationType: AppStreamClientTypes.AuthenticationType?
        /// Specifies whether a user is connected to the streaming session.
        public var connectionState: AppStreamClientTypes.SessionConnectionState?
        /// The name of the fleet for the streaming session.
        /// This member is required.
        public var fleetName: Swift.String?
        /// The identifier of the streaming session.
        /// This member is required.
        public var id: Swift.String?
        /// The identifier for the instance hosting the session.
        public var instanceId: Swift.String?
        /// The time when the streaming session is set to expire. This time is based on the MaxUserDurationinSeconds value, which determines the maximum length of time that a streaming session can run. A streaming session might end earlier than the time specified in SessionMaxExpirationTime, when the DisconnectTimeOutInSeconds elapses or the user chooses to end his or her session. If the DisconnectTimeOutInSeconds elapses, or the user chooses to end his or her session, the streaming instance is terminated and the streaming session ends.
        public var maxExpirationTime: Foundation.Date?
        /// The network details for the streaming session.
        public var networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration?
        /// The name of the stack for the streaming session.
        /// This member is required.
        public var stackName: Swift.String?
        /// The time when a streaming instance is dedicated for the user.
        public var startTime: Foundation.Date?
        /// The current state of the streaming session.
        /// This member is required.
        public var state: AppStreamClientTypes.SessionState?
        /// The identifier of the user for whom the session was created.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
            connectionState: AppStreamClientTypes.SessionConnectionState? = nil,
            fleetName: Swift.String? = nil,
            id: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            maxExpirationTime: Foundation.Date? = nil,
            networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration? = nil,
            stackName: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: AppStreamClientTypes.SessionState? = nil,
            userId: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.connectionState = connectionState
            self.fleetName = fleetName
            self.id = id
            self.instanceId = instanceId
            self.maxExpirationTime = maxExpirationTime
            self.networkAccessConfiguration = networkAccessConfiguration
            self.stackName = stackName
            self.startTime = startTime
            self.state = state
            self.userId = userId
        }
    }

}

public struct DescribeSessionsOutput {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the streaming sessions.
    public var sessions: [AppStreamClientTypes.Session]?

    public init(
        nextToken: Swift.String? = nil,
        sessions: [AppStreamClientTypes.Session]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

public struct DescribeStacksInput {
    /// The names of the stacks to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

public struct DescribeStacksOutput {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the stacks.
    public var stacks: [AppStreamClientTypes.Stack]?

    public init(
        nextToken: Swift.String? = nil,
        stacks: [AppStreamClientTypes.Stack]? = nil
    )
    {
        self.nextToken = nextToken
        self.stacks = stacks
    }
}

public struct DescribeThemeForStackInput {
    /// The name of the stack for the theme.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        stackName: Swift.String? = nil
    )
    {
        self.stackName = stackName
    }
}

public struct DescribeThemeForStackOutput {
    /// The theme object that contains the metadata of the custom branding.
    public var theme: AppStreamClientTypes.Theme?

    public init(
        theme: AppStreamClientTypes.Theme? = nil
    )
    {
        self.theme = theme
    }
}

public struct DescribeUsageReportSubscriptionsInput {
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AppStreamClientTypes {

    public enum UsageReportExecutionErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case internalServiceError
        case resourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageReportExecutionErrorCode] {
            return [
                .accessDenied,
                .internalServiceError,
                .resourceNotFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppStreamClientTypes {
    /// Describes the error that is returned when a usage report can't be generated.
    public struct LastReportGenerationExecutionError {
        /// The error code for the error that is returned when a usage report can't be generated.
        public var errorCode: AppStreamClientTypes.UsageReportExecutionErrorCode?
        /// The error message for the error that is returned when a usage report can't be generated.
        public var errorMessage: Swift.String?

        public init(
            errorCode: AppStreamClientTypes.UsageReportExecutionErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension AppStreamClientTypes {
    /// Describes information about the usage report subscription.
    public struct UsageReportSubscription {
        /// The time when the last usage report was generated.
        public var lastGeneratedReportDate: Foundation.Date?
        /// The Amazon S3 bucket where generated reports are stored. If you enabled on-instance session scripts and Amazon S3 logging for your session script configuration, AppStream 2.0 created an S3 bucket to store the script output. The bucket is unique to your account and Region. When you enable usage reporting in this case, AppStream 2.0 uses the same bucket to store your usage reports. If you haven't already enabled on-instance session scripts, when you enable usage reports, AppStream 2.0 creates a new S3 bucket.
        public var s3BucketName: Swift.String?
        /// The schedule for generating usage reports.
        public var schedule: AppStreamClientTypes.UsageReportSchedule?
        /// The errors that were returned if usage reports couldn't be generated.
        public var subscriptionErrors: [AppStreamClientTypes.LastReportGenerationExecutionError]?

        public init(
            lastGeneratedReportDate: Foundation.Date? = nil,
            s3BucketName: Swift.String? = nil,
            schedule: AppStreamClientTypes.UsageReportSchedule? = nil,
            subscriptionErrors: [AppStreamClientTypes.LastReportGenerationExecutionError]? = nil
        )
        {
            self.lastGeneratedReportDate = lastGeneratedReportDate
            self.s3BucketName = s3BucketName
            self.schedule = schedule
            self.subscriptionErrors = subscriptionErrors
        }
    }

}

public struct DescribeUsageReportSubscriptionsOutput {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the usage report subscription.
    public var usageReportSubscriptions: [AppStreamClientTypes.UsageReportSubscription]?

    public init(
        nextToken: Swift.String? = nil,
        usageReportSubscriptions: [AppStreamClientTypes.UsageReportSubscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.usageReportSubscriptions = usageReportSubscriptions
    }
}

public struct DescribeUsersInput {
    /// The authentication type for the users in the user pool to describe. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AppStreamClientTypes {
    /// Describes a user in the user pool.
    public struct User {
        /// The ARN of the user.
        public var arn: Swift.String?
        /// The authentication type for the user.
        /// This member is required.
        public var authenticationType: AppStreamClientTypes.AuthenticationType?
        /// The date and time the user was created in the user pool.
        public var createdTime: Foundation.Date?
        /// Specifies whether the user in the user pool is enabled.
        public var enabled: Swift.Bool?
        /// The first name, or given name, of the user.
        public var firstName: Swift.String?
        /// The last name, or surname, of the user.
        public var lastName: Swift.String?
        /// The status of the user in the user pool. The status can be one of the following:
        ///
        /// * UNCONFIRMED – The user is created but not confirmed.
        ///
        /// * CONFIRMED – The user is confirmed.
        ///
        /// * ARCHIVED – The user is no longer active.
        ///
        /// * COMPROMISED – The user is disabled because of a potential security threat.
        ///
        /// * UNKNOWN – The user status is not known.
        public var status: Swift.String?
        /// The email address of the user. Users' email addresses are case-sensitive.
        public var userName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
            createdTime: Foundation.Date? = nil,
            enabled: Swift.Bool? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            status: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.authenticationType = authenticationType
            self.createdTime = createdTime
            self.enabled = enabled
            self.firstName = firstName
            self.lastName = lastName
            self.status = status
            self.userName = userName
        }
    }

}

extension AppStreamClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(arn: \(Swift.String(describing: arn)), authenticationType: \(Swift.String(describing: authenticationType)), createdTime: \(Swift.String(describing: createdTime)), enabled: \(Swift.String(describing: enabled)), status: \(Swift.String(describing: status)), firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", userName: \"CONTENT_REDACTED\")"}
}

public struct DescribeUsersOutput {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about users in the user pool.
    public var users: [AppStreamClientTypes.User]?

    public init(
        nextToken: Swift.String? = nil,
        users: [AppStreamClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

public struct DescribeUserStackAssociationsInput {
    /// The authentication type for the user who is associated with the stack. You must specify USERPOOL.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The name of the stack that is associated with the user.
    public var stackName: Swift.String?
    /// The email address of the user who is associated with the stack. Users' email addresses are case-sensitive.
    public var userName: Swift.String?

    public init(
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stackName = stackName
        self.userName = userName
    }
}

extension DescribeUserStackAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserStackAssociationsInput(authenticationType: \(Swift.String(describing: authenticationType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), stackName: \(Swift.String(describing: stackName)), userName: \"CONTENT_REDACTED\")"}
}

public struct DescribeUserStackAssociationsOutput {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The UserStackAssociation objects.
    public var userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?

    public init(
        nextToken: Swift.String? = nil,
        userStackAssociations: [AppStreamClientTypes.UserStackAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.userStackAssociations = userStackAssociations
    }
}

public struct DisableUserInput {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The email address of the user. Users' email addresses are case-sensitive.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.userName = userName
    }
}

extension DisableUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableUserInput(authenticationType: \(Swift.String(describing: authenticationType)), userName: \"CONTENT_REDACTED\")"}
}

public struct DisableUserOutput {

    public init() { }
}

public struct DisassociateAppBlockBuilderAppBlockInput {
    /// The ARN of the app block.
    /// This member is required.
    public var appBlockArn: Swift.String?
    /// The name of the app block builder.
    /// This member is required.
    public var appBlockBuilderName: Swift.String?

    public init(
        appBlockArn: Swift.String? = nil,
        appBlockBuilderName: Swift.String? = nil
    )
    {
        self.appBlockArn = appBlockArn
        self.appBlockBuilderName = appBlockBuilderName
    }
}

public struct DisassociateAppBlockBuilderAppBlockOutput {

    public init() { }
}

public struct DisassociateApplicationFleetInput {
    /// The ARN of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        fleetName: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.fleetName = fleetName
    }
}

public struct DisassociateApplicationFleetOutput {

    public init() { }
}

public struct DisassociateApplicationFromEntitlementInput {
    /// The identifier of the application to remove from the entitlement.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The name of the entitlement.
    /// This member is required.
    public var entitlementName: Swift.String?
    /// The name of the stack with which the entitlement is associated.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        applicationIdentifier: Swift.String? = nil,
        entitlementName: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.entitlementName = entitlementName
        self.stackName = stackName
    }
}

public struct DisassociateApplicationFromEntitlementOutput {

    public init() { }
}

public struct DisassociateFleetInput {
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        fleetName: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.fleetName = fleetName
        self.stackName = stackName
    }
}

public struct DisassociateFleetOutput {

    public init() { }
}

public struct EnableUserInput {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The email address of the user. Users' email addresses are case-sensitive. During login, if they specify an email address that doesn't use the same capitalization as the email address specified when their user pool account was created, a "user does not exist" error message displays.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.userName = userName
    }
}

extension EnableUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableUserInput(authenticationType: \(Swift.String(describing: authenticationType)), userName: \"CONTENT_REDACTED\")"}
}

public struct EnableUserOutput {

    public init() { }
}

extension AppStreamClientTypes {
    /// The application associated to an entitlement. Access is controlled based on user attributes.
    public struct EntitledApplication {
        /// The identifier of the application.
        /// This member is required.
        public var applicationIdentifier: Swift.String?

        public init(
            applicationIdentifier: Swift.String? = nil
        )
        {
            self.applicationIdentifier = applicationIdentifier
        }
    }

}

public struct ExpireSessionInput {
    /// The identifier of the streaming session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

public struct ExpireSessionOutput {

    public init() { }
}

extension AppStreamClientTypes {

    /// The fleet attribute.
    public enum FleetAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case domainJoinInfo
        case iamRoleArn
        case maxSessionsPerInstance
        case sessionScriptS3Location
        case usbDeviceFilterStrings
        case vpcConfiguration
        case vpcConfigurationSecurityGroupIds
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetAttribute] {
            return [
                .domainJoinInfo,
                .iamRoleArn,
                .maxSessionsPerInstance,
                .sessionScriptS3Location,
                .usbDeviceFilterStrings,
                .vpcConfiguration,
                .vpcConfigurationSecurityGroupIds
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .domainJoinInfo: return "DOMAIN_JOIN_INFO"
            case .iamRoleArn: return "IAM_ROLE_ARN"
            case .maxSessionsPerInstance: return "MAX_SESSIONS_PER_INSTANCE"
            case .sessionScriptS3Location: return "SESSION_SCRIPT_S3_LOCATION"
            case .usbDeviceFilterStrings: return "USB_DEVICE_FILTER_STRINGS"
            case .vpcConfiguration: return "VPC_CONFIGURATION"
            case .vpcConfigurationSecurityGroupIds: return "VPC_CONFIGURATION_SECURITY_GROUP_IDS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListAssociatedFleetsInput {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.stackName = stackName
    }
}

public struct ListAssociatedFleetsOutput {
    /// The name of the fleet.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

public struct ListAssociatedStacksInput {
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        fleetName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetName = fleetName
        self.nextToken = nextToken
    }
}

public struct ListAssociatedStacksOutput {
    /// The name of the stack.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

public struct ListEntitledApplicationsInput {
    /// The name of the entitlement.
    /// This member is required.
    public var entitlementName: Swift.String?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The name of the stack with which the entitlement is associated.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        entitlementName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.entitlementName = entitlementName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stackName = stackName
    }
}

public struct ListEntitledApplicationsOutput {
    /// The entitled applications.
    public var entitledApplications: [AppStreamClientTypes.EntitledApplication]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init(
        entitledApplications: [AppStreamClientTypes.EntitledApplication]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entitledApplications = entitledApplications
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The information about the tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct StartAppBlockBuilderInput {
    /// The name of the app block builder.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct StartAppBlockBuilderOutput {
    /// Describes an app block builder.
    public var appBlockBuilder: AppStreamClientTypes.AppBlockBuilder?

    public init(
        appBlockBuilder: AppStreamClientTypes.AppBlockBuilder? = nil
    )
    {
        self.appBlockBuilder = appBlockBuilder
    }
}

public struct StartFleetInput {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct StartFleetOutput {

    public init() { }
}

public struct StartImageBuilderInput {
    /// The version of the AppStream 2.0 agent to use for this image builder. To use the latest version of the AppStream 2.0 agent, specify [LATEST].
    public var appstreamAgentVersion: Swift.String?
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?

    public init(
        appstreamAgentVersion: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appstreamAgentVersion = appstreamAgentVersion
        self.name = name
    }
}

public struct StartImageBuilderOutput {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init(
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

public struct StopAppBlockBuilderInput {
    /// The name of the app block builder.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct StopAppBlockBuilderOutput {
    /// Describes an app block builder.
    public var appBlockBuilder: AppStreamClientTypes.AppBlockBuilder?

    public init(
        appBlockBuilder: AppStreamClientTypes.AppBlockBuilder? = nil
    )
    {
        self.appBlockBuilder = appBlockBuilder
    }
}

public struct StopFleetInput {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct StopFleetOutput {

    public init() { }
}

public struct StopImageBuilderInput {
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct StopImageBuilderOutput {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init(
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to associate. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. If you do not specify a value, the value is set to an empty string. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys for the tags to disassociate.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateAppBlockBuilderInput {
    /// The list of interface VPC endpoint (interface endpoint) objects. Administrators can connect to the app block builder only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The attributes to delete from the app block builder.
    public var attributesToDelete: [AppStreamClientTypes.AppBlockBuilderAttribute]?
    /// The description of the app block builder.
    public var description: Swift.String?
    /// The display name of the app block builder.
    public var displayName: Swift.String?
    /// Enables or disables default internet access for the app block builder.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the app block builder. To assume a role, the app block builder calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The instance type to use when launching the app block builder. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.standard.xlarge
    ///
    /// * stream.standard.2xlarge
    public var instanceType: Swift.String?
    /// The unique name for the app block builder.
    /// This member is required.
    public var name: Swift.String?
    /// The platform of the app block builder. WINDOWS_SERVER_2019 is the only valid value.
    public var platform: AppStreamClientTypes.PlatformType?
    /// The VPC configuration for the app block builder. App block builders require that you specify at least two subnets in different availability zones.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init(
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        attributesToDelete: [AppStreamClientTypes.AppBlockBuilderAttribute]? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        iamRoleArn: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        name: Swift.String? = nil,
        platform: AppStreamClientTypes.PlatformType? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.attributesToDelete = attributesToDelete
        self.description = description
        self.displayName = displayName
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.iamRoleArn = iamRoleArn
        self.instanceType = instanceType
        self.name = name
        self.platform = platform
        self.vpcConfig = vpcConfig
    }
}

public struct UpdateAppBlockBuilderOutput {
    /// Describes an app block builder.
    public var appBlockBuilder: AppStreamClientTypes.AppBlockBuilder?

    public init(
        appBlockBuilder: AppStreamClientTypes.AppBlockBuilder? = nil
    )
    {
        self.appBlockBuilder = appBlockBuilder
    }
}

public struct UpdateApplicationInput {
    /// The ARN of the app block.
    public var appBlockArn: Swift.String?
    /// The attributes to delete for an application.
    public var attributesToDelete: [AppStreamClientTypes.ApplicationAttribute]?
    /// The description of the application.
    public var description: Swift.String?
    /// The display name of the application. This name is visible to users in the application catalog.
    public var displayName: Swift.String?
    /// The icon S3 location of the application.
    public var iconS3Location: AppStreamClientTypes.S3Location?
    /// The launch parameters of the application.
    public var launchParameters: Swift.String?
    /// The launch path of the application.
    public var launchPath: Swift.String?
    /// The name of the application. This name is visible to users when display name is not specified.
    /// This member is required.
    public var name: Swift.String?
    /// The working directory of the application.
    public var workingDirectory: Swift.String?

    public init(
        appBlockArn: Swift.String? = nil,
        attributesToDelete: [AppStreamClientTypes.ApplicationAttribute]? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        iconS3Location: AppStreamClientTypes.S3Location? = nil,
        launchParameters: Swift.String? = nil,
        launchPath: Swift.String? = nil,
        name: Swift.String? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.appBlockArn = appBlockArn
        self.attributesToDelete = attributesToDelete
        self.description = description
        self.displayName = displayName
        self.iconS3Location = iconS3Location
        self.launchParameters = launchParameters
        self.launchPath = launchPath
        self.name = name
        self.workingDirectory = workingDirectory
    }
}

public struct UpdateApplicationOutput {
    /// Describes an application in the application catalog.
    public var application: AppStreamClientTypes.Application?

    public init(
        application: AppStreamClientTypes.Application? = nil
    )
    {
        self.application = application
    }
}

public struct UpdateDirectoryConfigInput {
    /// The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory domain-joined streaming instances. Fallback is turned on by default when certificate-based authentication is Enabled . Fallback allows users to log in using their AD domain password if certificate-based authentication is unsuccessful, or to unlock a desktop lock screen. Enabled_no_directory_login_fallback enables certificate-based authentication, but does not allow users to log in using their AD domain password. Users will be disconnected to re-authenticate using certificates.
    public var certificateBasedAuthProperties: AppStreamClientTypes.CertificateBasedAuthProperties?
    /// The name of the Directory Config object.
    /// This member is required.
    public var directoryName: Swift.String?
    /// The distinguished names of the organizational units for computer accounts.
    public var organizationalUnitDistinguishedNames: [Swift.String]?
    /// The credentials for the service account used by the fleet or image builder to connect to the directory.
    public var serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?

    public init(
        certificateBasedAuthProperties: AppStreamClientTypes.CertificateBasedAuthProperties? = nil,
        directoryName: Swift.String? = nil,
        organizationalUnitDistinguishedNames: [Swift.String]? = nil,
        serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials? = nil
    )
    {
        self.certificateBasedAuthProperties = certificateBasedAuthProperties
        self.directoryName = directoryName
        self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
        self.serviceAccountCredentials = serviceAccountCredentials
    }
}

public struct UpdateDirectoryConfigOutput {
    /// Information about the Directory Config object.
    public var directoryConfig: AppStreamClientTypes.DirectoryConfig?

    public init(
        directoryConfig: AppStreamClientTypes.DirectoryConfig? = nil
    )
    {
        self.directoryConfig = directoryConfig
    }
}

public struct UpdateEntitlementInput {
    /// Specifies whether all or only selected apps are entitled.
    public var appVisibility: AppStreamClientTypes.AppVisibility?
    /// The attributes of the entitlement.
    public var attributes: [AppStreamClientTypes.EntitlementAttribute]?
    /// The description of the entitlement.
    public var description: Swift.String?
    /// The name of the entitlement.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the stack with which the entitlement is associated.
    /// This member is required.
    public var stackName: Swift.String?

    public init(
        appVisibility: AppStreamClientTypes.AppVisibility? = nil,
        attributes: [AppStreamClientTypes.EntitlementAttribute]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.appVisibility = appVisibility
        self.attributes = attributes
        self.description = description
        self.name = name
        self.stackName = stackName
    }
}

public struct UpdateEntitlementOutput {
    /// The entitlement.
    public var entitlement: AppStreamClientTypes.Entitlement?

    public init(
        entitlement: AppStreamClientTypes.Entitlement? = nil
    )
    {
        self.entitlement = entitlement
    }
}

public struct UpdateFleetInput {
    /// The fleet attributes to delete.
    public var attributesToDelete: [AppStreamClientTypes.FleetAttribute]?
    /// The desired capacity for the fleet. This is not allowed for Elastic fleets.
    public var computeCapacity: AppStreamClientTypes.ComputeCapacity?
    /// Deletes the VPC association for the specified fleet.
    @available(*, deprecated)
    public var deleteVpcConfig: Swift.Bool?
    /// The description to display.
    public var description: Swift.String?
    /// The amount of time that a streaming session remains active after users disconnect. If users try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance. Specify a value between 60 and 36000.
    public var disconnectTimeoutInSeconds: Swift.Int?
    /// The fleet name to display.
    public var displayName: Swift.String?
    /// The name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain.
    public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    /// Enables or disables default internet access for the fleet.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the fleet. To assume a role, a fleet instance calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the DisconnectTimeoutInSeconds time interval begins. Users are notified before they are disconnected due to inactivity. If users try to reconnect to the streaming session before the time interval specified in DisconnectTimeoutInSeconds elapses, they are connected to their previous session. Users are considered idle when they stop providing keyboard or mouse input during their streaming session. File uploads and downloads, audio in, audio out, and pixels changing do not qualify as user activity. If users continue to be idle after the time interval in IdleDisconnectTimeoutInSeconds elapses, they are disconnected. To prevent users from being disconnected due to inactivity, specify a value of 0. Otherwise, specify a value between 60 and 36000. The default value is 0. If you enable this feature, we recommend that you specify a value that corresponds exactly to a whole number of minutes (for example, 60, 120, and 180). If you don't do this, the value is rounded to the nearest minute. For example, if you specify a value of 70, users are disconnected after 1 minute of inactivity. If you specify a value that is at the midpoint between two different minutes, the value is rounded up. For example, if you specify a value of 90, users are disconnected after 2 minutes of inactivity.
    public var idleDisconnectTimeoutInSeconds: Swift.Int?
    /// The ARN of the public, private, or shared image to use.
    public var imageArn: Swift.String?
    /// The name of the image used to create the fleet.
    public var imageName: Swift.String?
    /// The instance type to use when launching fleet instances. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.standard.xlarge
    ///
    /// * stream.standard.2xlarge
    ///
    /// * stream.compute.large
    ///
    /// * stream.compute.xlarge
    ///
    /// * stream.compute.2xlarge
    ///
    /// * stream.compute.4xlarge
    ///
    /// * stream.compute.8xlarge
    ///
    /// * stream.memory.large
    ///
    /// * stream.memory.xlarge
    ///
    /// * stream.memory.2xlarge
    ///
    /// * stream.memory.4xlarge
    ///
    /// * stream.memory.8xlarge
    ///
    /// * stream.memory.z1d.large
    ///
    /// * stream.memory.z1d.xlarge
    ///
    /// * stream.memory.z1d.2xlarge
    ///
    /// * stream.memory.z1d.3xlarge
    ///
    /// * stream.memory.z1d.6xlarge
    ///
    /// * stream.memory.z1d.12xlarge
    ///
    /// * stream.graphics-design.large
    ///
    /// * stream.graphics-design.xlarge
    ///
    /// * stream.graphics-design.2xlarge
    ///
    /// * stream.graphics-design.4xlarge
    ///
    /// * stream.graphics-desktop.2xlarge
    ///
    /// * stream.graphics.g4dn.xlarge
    ///
    /// * stream.graphics.g4dn.2xlarge
    ///
    /// * stream.graphics.g4dn.4xlarge
    ///
    /// * stream.graphics.g4dn.8xlarge
    ///
    /// * stream.graphics.g4dn.12xlarge
    ///
    /// * stream.graphics.g4dn.16xlarge
    ///
    /// * stream.graphics-pro.4xlarge
    ///
    /// * stream.graphics-pro.8xlarge
    ///
    /// * stream.graphics-pro.16xlarge
    ///
    ///
    /// The following instance types are available for Elastic fleets:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.standard.xlarge
    ///
    /// * stream.standard.2xlarge
    public var instanceType: Swift.String?
    /// The maximum number of concurrent sessions for a fleet.
    public var maxConcurrentSessions: Swift.Int?
    /// The maximum number of user sessions on an instance. This only applies to multi-session fleets.
    public var maxSessionsPerInstance: Swift.Int?
    /// The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance. Specify a value between 600 and 432000.
    public var maxUserDurationInSeconds: Swift.Int?
    /// A unique name for the fleet.
    public var name: Swift.String?
    /// The platform of the fleet. WINDOWS_SERVER_2019 and AMAZON_LINUX2 are supported for Elastic fleets.
    public var platform: AppStreamClientTypes.PlatformType?
    /// The S3 location of the session scripts configuration zip file. This only applies to Elastic fleets.
    public var sessionScriptS3Location: AppStreamClientTypes.S3Location?
    /// The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When APP is specified, only the windows of applications opened by users display. When DESKTOP is specified, the standard desktop that is provided by the operating system displays. The default value is APP.
    public var streamView: AppStreamClientTypes.StreamView?
    /// The USB device filter strings that specify which USB devices a user can redirect to the fleet streaming session, when using the Windows native client. This is allowed but not required for Elastic fleets.
    public var usbDeviceFilterStrings: [Swift.String]?
    /// The VPC configuration for the fleet. This is required for Elastic fleets, but not required for other fleet types. Elastic fleets require that you specify at least two subnets in different availability zones.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init(
        attributesToDelete: [AppStreamClientTypes.FleetAttribute]? = nil,
        computeCapacity: AppStreamClientTypes.ComputeCapacity? = nil,
        deleteVpcConfig: Swift.Bool? = nil,
        description: Swift.String? = nil,
        disconnectTimeoutInSeconds: Swift.Int? = nil,
        displayName: Swift.String? = nil,
        domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        iamRoleArn: Swift.String? = nil,
        idleDisconnectTimeoutInSeconds: Swift.Int? = nil,
        imageArn: Swift.String? = nil,
        imageName: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        maxConcurrentSessions: Swift.Int? = nil,
        maxSessionsPerInstance: Swift.Int? = nil,
        maxUserDurationInSeconds: Swift.Int? = nil,
        name: Swift.String? = nil,
        platform: AppStreamClientTypes.PlatformType? = nil,
        sessionScriptS3Location: AppStreamClientTypes.S3Location? = nil,
        streamView: AppStreamClientTypes.StreamView? = nil,
        usbDeviceFilterStrings: [Swift.String]? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.attributesToDelete = attributesToDelete
        self.computeCapacity = computeCapacity
        self.deleteVpcConfig = deleteVpcConfig
        self.description = description
        self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.iamRoleArn = iamRoleArn
        self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.maxConcurrentSessions = maxConcurrentSessions
        self.maxSessionsPerInstance = maxSessionsPerInstance
        self.maxUserDurationInSeconds = maxUserDurationInSeconds
        self.name = name
        self.platform = platform
        self.sessionScriptS3Location = sessionScriptS3Location
        self.streamView = streamView
        self.usbDeviceFilterStrings = usbDeviceFilterStrings
        self.vpcConfig = vpcConfig
    }
}

public struct UpdateFleetOutput {
    /// Information about the fleet.
    public var fleet: AppStreamClientTypes.Fleet?

    public init(
        fleet: AppStreamClientTypes.Fleet? = nil
    )
    {
        self.fleet = fleet
    }
}

public struct UpdateImagePermissionsInput {
    /// The permissions for the image.
    /// This member is required.
    public var imagePermissions: AppStreamClientTypes.ImagePermissions?
    /// The name of the private image.
    /// This member is required.
    public var name: Swift.String?
    /// The 12-digit identifier of the AWS account for which you want add or update image permissions.
    /// This member is required.
    public var sharedAccountId: Swift.String?

    public init(
        imagePermissions: AppStreamClientTypes.ImagePermissions? = nil,
        name: Swift.String? = nil,
        sharedAccountId: Swift.String? = nil
    )
    {
        self.imagePermissions = imagePermissions
        self.name = name
        self.sharedAccountId = sharedAccountId
    }
}

public struct UpdateImagePermissionsOutput {

    public init() { }
}

extension AppStreamClientTypes {

    public enum StackAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessEndpoints
        case embedHostDomains
        case feedbackUrl
        case iamRoleArn
        case redirectUrl
        case storageConnectors
        case storageConnectorGoogleDrive
        case storageConnectorHomefolders
        case storageConnectorOneDrive
        case streamingExperienceSettings
        case themeName
        case userSettings
        case sdkUnknown(Swift.String)

        public static var allCases: [StackAttribute] {
            return [
                .accessEndpoints,
                .embedHostDomains,
                .feedbackUrl,
                .iamRoleArn,
                .redirectUrl,
                .storageConnectors,
                .storageConnectorGoogleDrive,
                .storageConnectorHomefolders,
                .storageConnectorOneDrive,
                .streamingExperienceSettings,
                .themeName,
                .userSettings
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessEndpoints: return "ACCESS_ENDPOINTS"
            case .embedHostDomains: return "EMBED_HOST_DOMAINS"
            case .feedbackUrl: return "FEEDBACK_URL"
            case .iamRoleArn: return "IAM_ROLE_ARN"
            case .redirectUrl: return "REDIRECT_URL"
            case .storageConnectors: return "STORAGE_CONNECTORS"
            case .storageConnectorGoogleDrive: return "STORAGE_CONNECTOR_GOOGLE_DRIVE"
            case .storageConnectorHomefolders: return "STORAGE_CONNECTOR_HOMEFOLDERS"
            case .storageConnectorOneDrive: return "STORAGE_CONNECTOR_ONE_DRIVE"
            case .streamingExperienceSettings: return "STREAMING_EXPERIENCE_SETTINGS"
            case .themeName: return "THEME_NAME"
            case .userSettings: return "USER_SETTINGS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateStackInput {
    /// The list of interface VPC endpoint (interface endpoint) objects. Users of the stack can connect to AppStream 2.0 only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The persistent application settings for users of a stack. When these settings are enabled, changes that users make to applications and Windows settings are automatically saved after each session and applied to the next session.
    public var applicationSettings: AppStreamClientTypes.ApplicationSettings?
    /// The stack attributes to delete.
    public var attributesToDelete: [AppStreamClientTypes.StackAttribute]?
    /// Deletes the storage connectors currently enabled for the stack.
    @available(*, deprecated)
    public var deleteStorageConnectors: Swift.Bool?
    /// The description to display.
    public var description: Swift.String?
    /// The stack name to display.
    public var displayName: Swift.String?
    /// The domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions.
    public var embedHostDomains: [Swift.String]?
    /// The URL that users are redirected to after they choose the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.
    public var feedbackURL: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var name: Swift.String?
    /// The URL that users are redirected to after their streaming session ends.
    public var redirectURL: Swift.String?
    /// The storage connectors to enable.
    public var storageConnectors: [AppStreamClientTypes.StorageConnector]?
    /// The streaming protocol you want your stack to prefer. This can be UDP or TCP. Currently, UDP is only supported in the Windows native client.
    public var streamingExperienceSettings: AppStreamClientTypes.StreamingExperienceSettings?
    /// The actions that are enabled or disabled for users during their streaming sessions. By default, these actions are enabled.
    public var userSettings: [AppStreamClientTypes.UserSetting]?

    public init(
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        applicationSettings: AppStreamClientTypes.ApplicationSettings? = nil,
        attributesToDelete: [AppStreamClientTypes.StackAttribute]? = nil,
        deleteStorageConnectors: Swift.Bool? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        embedHostDomains: [Swift.String]? = nil,
        feedbackURL: Swift.String? = nil,
        name: Swift.String? = nil,
        redirectURL: Swift.String? = nil,
        storageConnectors: [AppStreamClientTypes.StorageConnector]? = nil,
        streamingExperienceSettings: AppStreamClientTypes.StreamingExperienceSettings? = nil,
        userSettings: [AppStreamClientTypes.UserSetting]? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.applicationSettings = applicationSettings
        self.attributesToDelete = attributesToDelete
        self.deleteStorageConnectors = deleteStorageConnectors
        self.description = description
        self.displayName = displayName
        self.embedHostDomains = embedHostDomains
        self.feedbackURL = feedbackURL
        self.name = name
        self.redirectURL = redirectURL
        self.storageConnectors = storageConnectors
        self.streamingExperienceSettings = streamingExperienceSettings
        self.userSettings = userSettings
    }
}

public struct UpdateStackOutput {
    /// Information about the stack.
    public var stack: AppStreamClientTypes.Stack?

    public init(
        stack: AppStreamClientTypes.Stack? = nil
    )
    {
        self.stack = stack
    }
}

extension AppStreamClientTypes {

    public enum ThemeAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case footerLinks
        case sdkUnknown(Swift.String)

        public static var allCases: [ThemeAttribute] {
            return [
                .footerLinks
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .footerLinks: return "FOOTER_LINKS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateThemeForStackInput {
    /// The attributes to delete.
    public var attributesToDelete: [AppStreamClientTypes.ThemeAttribute]?
    /// The S3 location of the favicon. The favicon enables users to recognize their application streaming site in a browser full of tabs or bookmarks. It is displayed at the top of the browser tab for the application streaming site during users' streaming sessions.
    public var faviconS3Location: AppStreamClientTypes.S3Location?
    /// The links that are displayed in the footer of the streaming application catalog page. These links are helpful resources for users, such as the organization's IT support and product marketing sites.
    public var footerLinks: [AppStreamClientTypes.ThemeFooterLink]?
    /// The organization logo that appears on the streaming application catalog page.
    public var organizationLogoS3Location: AppStreamClientTypes.S3Location?
    /// The name of the stack for the theme.
    /// This member is required.
    public var stackName: Swift.String?
    /// Specifies whether custom branding should be applied to catalog page or not.
    public var state: AppStreamClientTypes.ThemeState?
    /// The color theme that is applied to website links, text, and buttons. These colors are also applied as accents in the background for the streaming application catalog page.
    public var themeStyling: AppStreamClientTypes.ThemeStyling?
    /// The title that is displayed at the top of the browser tab during users' application streaming sessions.
    public var titleText: Swift.String?

    public init(
        attributesToDelete: [AppStreamClientTypes.ThemeAttribute]? = nil,
        faviconS3Location: AppStreamClientTypes.S3Location? = nil,
        footerLinks: [AppStreamClientTypes.ThemeFooterLink]? = nil,
        organizationLogoS3Location: AppStreamClientTypes.S3Location? = nil,
        stackName: Swift.String? = nil,
        state: AppStreamClientTypes.ThemeState? = nil,
        themeStyling: AppStreamClientTypes.ThemeStyling? = nil,
        titleText: Swift.String? = nil
    )
    {
        self.attributesToDelete = attributesToDelete
        self.faviconS3Location = faviconS3Location
        self.footerLinks = footerLinks
        self.organizationLogoS3Location = organizationLogoS3Location
        self.stackName = stackName
        self.state = state
        self.themeStyling = themeStyling
        self.titleText = titleText
    }
}

public struct UpdateThemeForStackOutput {
    /// The theme object that contains the metadata of the custom branding.
    public var theme: AppStreamClientTypes.Theme?

    public init(
        theme: AppStreamClientTypes.Theme? = nil
    )
    {
        self.theme = theme
    }
}

extension AssociateAppBlockBuilderAppBlockInput {

    static func urlPathProvider(_ value: AssociateAppBlockBuilderAppBlockInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateApplicationFleetInput {

    static func urlPathProvider(_ value: AssociateApplicationFleetInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateApplicationToEntitlementInput {

    static func urlPathProvider(_ value: AssociateApplicationToEntitlementInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateFleetInput {

    static func urlPathProvider(_ value: AssociateFleetInput) -> Swift.String? {
        return "/"
    }
}

extension BatchAssociateUserStackInput {

    static func urlPathProvider(_ value: BatchAssociateUserStackInput) -> Swift.String? {
        return "/"
    }
}

extension BatchDisassociateUserStackInput {

    static func urlPathProvider(_ value: BatchDisassociateUserStackInput) -> Swift.String? {
        return "/"
    }
}

extension CopyImageInput {

    static func urlPathProvider(_ value: CopyImageInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAppBlockInput {

    static func urlPathProvider(_ value: CreateAppBlockInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAppBlockBuilderInput {

    static func urlPathProvider(_ value: CreateAppBlockBuilderInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAppBlockBuilderStreamingURLInput {

    static func urlPathProvider(_ value: CreateAppBlockBuilderStreamingURLInput) -> Swift.String? {
        return "/"
    }
}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDirectoryConfigInput {

    static func urlPathProvider(_ value: CreateDirectoryConfigInput) -> Swift.String? {
        return "/"
    }
}

extension CreateEntitlementInput {

    static func urlPathProvider(_ value: CreateEntitlementInput) -> Swift.String? {
        return "/"
    }
}

extension CreateFleetInput {

    static func urlPathProvider(_ value: CreateFleetInput) -> Swift.String? {
        return "/"
    }
}

extension CreateImageBuilderInput {

    static func urlPathProvider(_ value: CreateImageBuilderInput) -> Swift.String? {
        return "/"
    }
}

extension CreateImageBuilderStreamingURLInput {

    static func urlPathProvider(_ value: CreateImageBuilderStreamingURLInput) -> Swift.String? {
        return "/"
    }
}

extension CreateStackInput {

    static func urlPathProvider(_ value: CreateStackInput) -> Swift.String? {
        return "/"
    }
}

extension CreateStreamingURLInput {

    static func urlPathProvider(_ value: CreateStreamingURLInput) -> Swift.String? {
        return "/"
    }
}

extension CreateThemeForStackInput {

    static func urlPathProvider(_ value: CreateThemeForStackInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUpdatedImageInput {

    static func urlPathProvider(_ value: CreateUpdatedImageInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUsageReportSubscriptionInput {

    static func urlPathProvider(_ value: CreateUsageReportSubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUserInput {

    static func urlPathProvider(_ value: CreateUserInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAppBlockInput {

    static func urlPathProvider(_ value: DeleteAppBlockInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAppBlockBuilderInput {

    static func urlPathProvider(_ value: DeleteAppBlockBuilderInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationInput {

    static func urlPathProvider(_ value: DeleteApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDirectoryConfigInput {

    static func urlPathProvider(_ value: DeleteDirectoryConfigInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEntitlementInput {

    static func urlPathProvider(_ value: DeleteEntitlementInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteFleetInput {

    static func urlPathProvider(_ value: DeleteFleetInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteImageInput {

    static func urlPathProvider(_ value: DeleteImageInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteImageBuilderInput {

    static func urlPathProvider(_ value: DeleteImageBuilderInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteImagePermissionsInput {

    static func urlPathProvider(_ value: DeleteImagePermissionsInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteStackInput {

    static func urlPathProvider(_ value: DeleteStackInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteThemeForStackInput {

    static func urlPathProvider(_ value: DeleteThemeForStackInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteUsageReportSubscriptionInput {

    static func urlPathProvider(_ value: DeleteUsageReportSubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteUserInput {

    static func urlPathProvider(_ value: DeleteUserInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAppBlockBuilderAppBlockAssociationsInput {

    static func urlPathProvider(_ value: DescribeAppBlockBuilderAppBlockAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAppBlockBuildersInput {

    static func urlPathProvider(_ value: DescribeAppBlockBuildersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAppBlocksInput {

    static func urlPathProvider(_ value: DescribeAppBlocksInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeApplicationFleetAssociationsInput {

    static func urlPathProvider(_ value: DescribeApplicationFleetAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeApplicationsInput {

    static func urlPathProvider(_ value: DescribeApplicationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDirectoryConfigsInput {

    static func urlPathProvider(_ value: DescribeDirectoryConfigsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEntitlementsInput {

    static func urlPathProvider(_ value: DescribeEntitlementsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFleetsInput {

    static func urlPathProvider(_ value: DescribeFleetsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeImageBuildersInput {

    static func urlPathProvider(_ value: DescribeImageBuildersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeImagePermissionsInput {

    static func urlPathProvider(_ value: DescribeImagePermissionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeImagesInput {

    static func urlPathProvider(_ value: DescribeImagesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSessionsInput {

    static func urlPathProvider(_ value: DescribeSessionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeStacksInput {

    static func urlPathProvider(_ value: DescribeStacksInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeThemeForStackInput {

    static func urlPathProvider(_ value: DescribeThemeForStackInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeUsageReportSubscriptionsInput {

    static func urlPathProvider(_ value: DescribeUsageReportSubscriptionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeUsersInput {

    static func urlPathProvider(_ value: DescribeUsersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeUserStackAssociationsInput {

    static func urlPathProvider(_ value: DescribeUserStackAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension DisableUserInput {

    static func urlPathProvider(_ value: DisableUserInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateAppBlockBuilderAppBlockInput {

    static func urlPathProvider(_ value: DisassociateAppBlockBuilderAppBlockInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateApplicationFleetInput {

    static func urlPathProvider(_ value: DisassociateApplicationFleetInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateApplicationFromEntitlementInput {

    static func urlPathProvider(_ value: DisassociateApplicationFromEntitlementInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateFleetInput {

    static func urlPathProvider(_ value: DisassociateFleetInput) -> Swift.String? {
        return "/"
    }
}

extension EnableUserInput {

    static func urlPathProvider(_ value: EnableUserInput) -> Swift.String? {
        return "/"
    }
}

extension ExpireSessionInput {

    static func urlPathProvider(_ value: ExpireSessionInput) -> Swift.String? {
        return "/"
    }
}

extension ListAssociatedFleetsInput {

    static func urlPathProvider(_ value: ListAssociatedFleetsInput) -> Swift.String? {
        return "/"
    }
}

extension ListAssociatedStacksInput {

    static func urlPathProvider(_ value: ListAssociatedStacksInput) -> Swift.String? {
        return "/"
    }
}

extension ListEntitledApplicationsInput {

    static func urlPathProvider(_ value: ListEntitledApplicationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension StartAppBlockBuilderInput {

    static func urlPathProvider(_ value: StartAppBlockBuilderInput) -> Swift.String? {
        return "/"
    }
}

extension StartFleetInput {

    static func urlPathProvider(_ value: StartFleetInput) -> Swift.String? {
        return "/"
    }
}

extension StartImageBuilderInput {

    static func urlPathProvider(_ value: StartImageBuilderInput) -> Swift.String? {
        return "/"
    }
}

extension StopAppBlockBuilderInput {

    static func urlPathProvider(_ value: StopAppBlockBuilderInput) -> Swift.String? {
        return "/"
    }
}

extension StopFleetInput {

    static func urlPathProvider(_ value: StopFleetInput) -> Swift.String? {
        return "/"
    }
}

extension StopImageBuilderInput {

    static func urlPathProvider(_ value: StopImageBuilderInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAppBlockBuilderInput {

    static func urlPathProvider(_ value: UpdateAppBlockBuilderInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDirectoryConfigInput {

    static func urlPathProvider(_ value: UpdateDirectoryConfigInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateEntitlementInput {

    static func urlPathProvider(_ value: UpdateEntitlementInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateFleetInput {

    static func urlPathProvider(_ value: UpdateFleetInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateImagePermissionsInput {

    static func urlPathProvider(_ value: UpdateImagePermissionsInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateStackInput {

    static func urlPathProvider(_ value: UpdateStackInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateThemeForStackInput {

    static func urlPathProvider(_ value: UpdateThemeForStackInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateAppBlockBuilderAppBlockInput {

    static func write(value: AssociateAppBlockBuilderAppBlockInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppBlockArn"].write(value.appBlockArn)
        try writer["AppBlockBuilderName"].write(value.appBlockBuilderName)
    }
}

extension AssociateApplicationFleetInput {

    static func write(value: AssociateApplicationFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["FleetName"].write(value.fleetName)
    }
}

extension AssociateApplicationToEntitlementInput {

    static func write(value: AssociateApplicationToEntitlementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationIdentifier"].write(value.applicationIdentifier)
        try writer["EntitlementName"].write(value.entitlementName)
        try writer["StackName"].write(value.stackName)
    }
}

extension AssociateFleetInput {

    static func write(value: AssociateFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetName"].write(value.fleetName)
        try writer["StackName"].write(value.stackName)
    }
}

extension BatchAssociateUserStackInput {

    static func write(value: BatchAssociateUserStackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UserStackAssociations"].writeList(value.userStackAssociations, memberWritingClosure: AppStreamClientTypes.UserStackAssociation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDisassociateUserStackInput {

    static func write(value: BatchDisassociateUserStackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UserStackAssociations"].writeList(value.userStackAssociations, memberWritingClosure: AppStreamClientTypes.UserStackAssociation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CopyImageInput {

    static func write(value: CopyImageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationImageDescription"].write(value.destinationImageDescription)
        try writer["DestinationImageName"].write(value.destinationImageName)
        try writer["DestinationRegion"].write(value.destinationRegion)
        try writer["SourceImageName"].write(value.sourceImageName)
    }
}

extension CreateAppBlockInput {

    static func write(value: CreateAppBlockInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["Name"].write(value.name)
        try writer["PackagingType"].write(value.packagingType)
        try writer["PostSetupScriptDetails"].write(value.postSetupScriptDetails, with: AppStreamClientTypes.ScriptDetails.write(value:to:))
        try writer["SetupScriptDetails"].write(value.setupScriptDetails, with: AppStreamClientTypes.ScriptDetails.write(value:to:))
        try writer["SourceS3Location"].write(value.sourceS3Location, with: AppStreamClientTypes.S3Location.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateAppBlockBuilderInput {

    static func write(value: CreateAppBlockBuilderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessEndpoints"].writeList(value.accessEndpoints, memberWritingClosure: AppStreamClientTypes.AccessEndpoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["EnableDefaultInternetAccess"].write(value.enableDefaultInternetAccess)
        try writer["IamRoleArn"].write(value.iamRoleArn)
        try writer["InstanceType"].write(value.instanceType)
        try writer["Name"].write(value.name)
        try writer["Platform"].write(value.platform)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["VpcConfig"].write(value.vpcConfig, with: AppStreamClientTypes.VpcConfig.write(value:to:))
    }
}

extension CreateAppBlockBuilderStreamingURLInput {

    static func write(value: CreateAppBlockBuilderStreamingURLInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppBlockBuilderName"].write(value.appBlockBuilderName)
        try writer["Validity"].write(value.validity)
    }
}

extension CreateApplicationInput {

    static func write(value: CreateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppBlockArn"].write(value.appBlockArn)
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["IconS3Location"].write(value.iconS3Location, with: AppStreamClientTypes.S3Location.write(value:to:))
        try writer["InstanceFamilies"].writeList(value.instanceFamilies, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LaunchParameters"].write(value.launchParameters)
        try writer["LaunchPath"].write(value.launchPath)
        try writer["Name"].write(value.name)
        try writer["Platforms"].writeList(value.platforms, memberWritingClosure: SmithyReadWrite.WritingClosureBox<AppStreamClientTypes.PlatformType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["WorkingDirectory"].write(value.workingDirectory)
    }
}

extension CreateDirectoryConfigInput {

    static func write(value: CreateDirectoryConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateBasedAuthProperties"].write(value.certificateBasedAuthProperties, with: AppStreamClientTypes.CertificateBasedAuthProperties.write(value:to:))
        try writer["DirectoryName"].write(value.directoryName)
        try writer["OrganizationalUnitDistinguishedNames"].writeList(value.organizationalUnitDistinguishedNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ServiceAccountCredentials"].write(value.serviceAccountCredentials, with: AppStreamClientTypes.ServiceAccountCredentials.write(value:to:))
    }
}

extension CreateEntitlementInput {

    static func write(value: CreateEntitlementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppVisibility"].write(value.appVisibility)
        try writer["Attributes"].writeList(value.attributes, memberWritingClosure: AppStreamClientTypes.EntitlementAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["StackName"].write(value.stackName)
    }
}

extension CreateFleetInput {

    static func write(value: CreateFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComputeCapacity"].write(value.computeCapacity, with: AppStreamClientTypes.ComputeCapacity.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["DisconnectTimeoutInSeconds"].write(value.disconnectTimeoutInSeconds)
        try writer["DisplayName"].write(value.displayName)
        try writer["DomainJoinInfo"].write(value.domainJoinInfo, with: AppStreamClientTypes.DomainJoinInfo.write(value:to:))
        try writer["EnableDefaultInternetAccess"].write(value.enableDefaultInternetAccess)
        try writer["FleetType"].write(value.fleetType)
        try writer["IamRoleArn"].write(value.iamRoleArn)
        try writer["IdleDisconnectTimeoutInSeconds"].write(value.idleDisconnectTimeoutInSeconds)
        try writer["ImageArn"].write(value.imageArn)
        try writer["ImageName"].write(value.imageName)
        try writer["InstanceType"].write(value.instanceType)
        try writer["MaxConcurrentSessions"].write(value.maxConcurrentSessions)
        try writer["MaxSessionsPerInstance"].write(value.maxSessionsPerInstance)
        try writer["MaxUserDurationInSeconds"].write(value.maxUserDurationInSeconds)
        try writer["Name"].write(value.name)
        try writer["Platform"].write(value.platform)
        try writer["SessionScriptS3Location"].write(value.sessionScriptS3Location, with: AppStreamClientTypes.S3Location.write(value:to:))
        try writer["StreamView"].write(value.streamView)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["UsbDeviceFilterStrings"].writeList(value.usbDeviceFilterStrings, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcConfig"].write(value.vpcConfig, with: AppStreamClientTypes.VpcConfig.write(value:to:))
    }
}

extension CreateImageBuilderInput {

    static func write(value: CreateImageBuilderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessEndpoints"].writeList(value.accessEndpoints, memberWritingClosure: AppStreamClientTypes.AccessEndpoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AppstreamAgentVersion"].write(value.appstreamAgentVersion)
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["DomainJoinInfo"].write(value.domainJoinInfo, with: AppStreamClientTypes.DomainJoinInfo.write(value:to:))
        try writer["EnableDefaultInternetAccess"].write(value.enableDefaultInternetAccess)
        try writer["IamRoleArn"].write(value.iamRoleArn)
        try writer["ImageArn"].write(value.imageArn)
        try writer["ImageName"].write(value.imageName)
        try writer["InstanceType"].write(value.instanceType)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["VpcConfig"].write(value.vpcConfig, with: AppStreamClientTypes.VpcConfig.write(value:to:))
    }
}

extension CreateImageBuilderStreamingURLInput {

    static func write(value: CreateImageBuilderStreamingURLInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Validity"].write(value.validity)
    }
}

extension CreateStackInput {

    static func write(value: CreateStackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessEndpoints"].writeList(value.accessEndpoints, memberWritingClosure: AppStreamClientTypes.AccessEndpoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ApplicationSettings"].write(value.applicationSettings, with: AppStreamClientTypes.ApplicationSettings.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["EmbedHostDomains"].writeList(value.embedHostDomains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FeedbackURL"].write(value.feedbackURL)
        try writer["Name"].write(value.name)
        try writer["RedirectURL"].write(value.redirectURL)
        try writer["StorageConnectors"].writeList(value.storageConnectors, memberWritingClosure: AppStreamClientTypes.StorageConnector.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StreamingExperienceSettings"].write(value.streamingExperienceSettings, with: AppStreamClientTypes.StreamingExperienceSettings.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["UserSettings"].writeList(value.userSettings, memberWritingClosure: AppStreamClientTypes.UserSetting.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateStreamingURLInput {

    static func write(value: CreateStreamingURLInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationId"].write(value.applicationId)
        try writer["FleetName"].write(value.fleetName)
        try writer["SessionContext"].write(value.sessionContext)
        try writer["StackName"].write(value.stackName)
        try writer["UserId"].write(value.userId)
        try writer["Validity"].write(value.validity)
    }
}

extension CreateThemeForStackInput {

    static func write(value: CreateThemeForStackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FaviconS3Location"].write(value.faviconS3Location, with: AppStreamClientTypes.S3Location.write(value:to:))
        try writer["FooterLinks"].writeList(value.footerLinks, memberWritingClosure: AppStreamClientTypes.ThemeFooterLink.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrganizationLogoS3Location"].write(value.organizationLogoS3Location, with: AppStreamClientTypes.S3Location.write(value:to:))
        try writer["StackName"].write(value.stackName)
        try writer["ThemeStyling"].write(value.themeStyling)
        try writer["TitleText"].write(value.titleText)
    }
}

extension CreateUpdatedImageInput {

    static func write(value: CreateUpdatedImageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dryRun"].write(value.dryRun)
        try writer["existingImageName"].write(value.existingImageName)
        try writer["newImageDescription"].write(value.newImageDescription)
        try writer["newImageDisplayName"].write(value.newImageDisplayName)
        try writer["newImageName"].write(value.newImageName)
        try writer["newImageTags"].writeMap(value.newImageTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateUsageReportSubscriptionInput {

    static func write(value: CreateUsageReportSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension CreateUserInput {

    static func write(value: CreateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationType"].write(value.authenticationType)
        try writer["FirstName"].write(value.firstName)
        try writer["LastName"].write(value.lastName)
        try writer["MessageAction"].write(value.messageAction)
        try writer["UserName"].write(value.userName)
    }
}

extension DeleteAppBlockInput {

    static func write(value: DeleteAppBlockInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteAppBlockBuilderInput {

    static func write(value: DeleteAppBlockBuilderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteApplicationInput {

    static func write(value: DeleteApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteDirectoryConfigInput {

    static func write(value: DeleteDirectoryConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DirectoryName"].write(value.directoryName)
    }
}

extension DeleteEntitlementInput {

    static func write(value: DeleteEntitlementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["StackName"].write(value.stackName)
    }
}

extension DeleteFleetInput {

    static func write(value: DeleteFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteImageInput {

    static func write(value: DeleteImageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteImageBuilderInput {

    static func write(value: DeleteImageBuilderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteImagePermissionsInput {

    static func write(value: DeleteImagePermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["SharedAccountId"].write(value.sharedAccountId)
    }
}

extension DeleteStackInput {

    static func write(value: DeleteStackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteThemeForStackInput {

    static func write(value: DeleteThemeForStackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StackName"].write(value.stackName)
    }
}

extension DeleteUsageReportSubscriptionInput {

    static func write(value: DeleteUsageReportSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteUserInput {

    static func write(value: DeleteUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationType"].write(value.authenticationType)
        try writer["UserName"].write(value.userName)
    }
}

extension DescribeAppBlockBuilderAppBlockAssociationsInput {

    static func write(value: DescribeAppBlockBuilderAppBlockAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppBlockArn"].write(value.appBlockArn)
        try writer["AppBlockBuilderName"].write(value.appBlockBuilderName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeAppBlockBuildersInput {

    static func write(value: DescribeAppBlockBuildersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["Names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeAppBlocksInput {

    static func write(value: DescribeAppBlocksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arns"].writeList(value.arns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeApplicationFleetAssociationsInput {

    static func write(value: DescribeApplicationFleetAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["FleetName"].write(value.fleetName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeApplicationsInput {

    static func write(value: DescribeApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arns"].writeList(value.arns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeDirectoryConfigsInput {

    static func write(value: DescribeDirectoryConfigsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DirectoryNames"].writeList(value.directoryNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeEntitlementsInput {

    static func write(value: DescribeEntitlementsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["Name"].write(value.name)
        try writer["NextToken"].write(value.nextToken)
        try writer["StackName"].write(value.stackName)
    }
}

extension DescribeFleetsInput {

    static func write(value: DescribeFleetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeImageBuildersInput {

    static func write(value: DescribeImageBuildersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["Names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeImagePermissionsInput {

    static func write(value: DescribeImagePermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["Name"].write(value.name)
        try writer["NextToken"].write(value.nextToken)
        try writer["SharedAwsAccountIds"].writeList(value.sharedAwsAccountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeImagesInput {

    static func write(value: DescribeImagesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arns"].writeList(value.arns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["Names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
        try writer["Type"].write(value.type)
    }
}

extension DescribeSessionsInput {

    static func write(value: DescribeSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationType"].write(value.authenticationType)
        try writer["FleetName"].write(value.fleetName)
        try writer["InstanceId"].write(value.instanceId)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["StackName"].write(value.stackName)
        try writer["UserId"].write(value.userId)
    }
}

extension DescribeStacksInput {

    static func write(value: DescribeStacksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeThemeForStackInput {

    static func write(value: DescribeThemeForStackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StackName"].write(value.stackName)
    }
}

extension DescribeUsageReportSubscriptionsInput {

    static func write(value: DescribeUsageReportSubscriptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeUsersInput {

    static func write(value: DescribeUsersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationType"].write(value.authenticationType)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeUserStackAssociationsInput {

    static func write(value: DescribeUserStackAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationType"].write(value.authenticationType)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StackName"].write(value.stackName)
        try writer["UserName"].write(value.userName)
    }
}

extension DisableUserInput {

    static func write(value: DisableUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationType"].write(value.authenticationType)
        try writer["UserName"].write(value.userName)
    }
}

extension DisassociateAppBlockBuilderAppBlockInput {

    static func write(value: DisassociateAppBlockBuilderAppBlockInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppBlockArn"].write(value.appBlockArn)
        try writer["AppBlockBuilderName"].write(value.appBlockBuilderName)
    }
}

extension DisassociateApplicationFleetInput {

    static func write(value: DisassociateApplicationFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["FleetName"].write(value.fleetName)
    }
}

extension DisassociateApplicationFromEntitlementInput {

    static func write(value: DisassociateApplicationFromEntitlementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationIdentifier"].write(value.applicationIdentifier)
        try writer["EntitlementName"].write(value.entitlementName)
        try writer["StackName"].write(value.stackName)
    }
}

extension DisassociateFleetInput {

    static func write(value: DisassociateFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetName"].write(value.fleetName)
        try writer["StackName"].write(value.stackName)
    }
}

extension EnableUserInput {

    static func write(value: EnableUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationType"].write(value.authenticationType)
        try writer["UserName"].write(value.userName)
    }
}

extension ExpireSessionInput {

    static func write(value: ExpireSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SessionId"].write(value.sessionId)
    }
}

extension ListAssociatedFleetsInput {

    static func write(value: ListAssociatedFleetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["StackName"].write(value.stackName)
    }
}

extension ListAssociatedStacksInput {

    static func write(value: ListAssociatedStacksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetName"].write(value.fleetName)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListEntitledApplicationsInput {

    static func write(value: ListEntitledApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntitlementName"].write(value.entitlementName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StackName"].write(value.stackName)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension StartAppBlockBuilderInput {

    static func write(value: StartAppBlockBuilderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension StartFleetInput {

    static func write(value: StartFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension StartImageBuilderInput {

    static func write(value: StartImageBuilderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppstreamAgentVersion"].write(value.appstreamAgentVersion)
        try writer["Name"].write(value.name)
    }
}

extension StopAppBlockBuilderInput {

    static func write(value: StopAppBlockBuilderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension StopFleetInput {

    static func write(value: StopFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension StopImageBuilderInput {

    static func write(value: StopImageBuilderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAppBlockBuilderInput {

    static func write(value: UpdateAppBlockBuilderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessEndpoints"].writeList(value.accessEndpoints, memberWritingClosure: AppStreamClientTypes.AccessEndpoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AttributesToDelete"].writeList(value.attributesToDelete, memberWritingClosure: SmithyReadWrite.WritingClosureBox<AppStreamClientTypes.AppBlockBuilderAttribute>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["EnableDefaultInternetAccess"].write(value.enableDefaultInternetAccess)
        try writer["IamRoleArn"].write(value.iamRoleArn)
        try writer["InstanceType"].write(value.instanceType)
        try writer["Name"].write(value.name)
        try writer["Platform"].write(value.platform)
        try writer["VpcConfig"].write(value.vpcConfig, with: AppStreamClientTypes.VpcConfig.write(value:to:))
    }
}

extension UpdateApplicationInput {

    static func write(value: UpdateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppBlockArn"].write(value.appBlockArn)
        try writer["AttributesToDelete"].writeList(value.attributesToDelete, memberWritingClosure: SmithyReadWrite.WritingClosureBox<AppStreamClientTypes.ApplicationAttribute>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["IconS3Location"].write(value.iconS3Location, with: AppStreamClientTypes.S3Location.write(value:to:))
        try writer["LaunchParameters"].write(value.launchParameters)
        try writer["LaunchPath"].write(value.launchPath)
        try writer["Name"].write(value.name)
        try writer["WorkingDirectory"].write(value.workingDirectory)
    }
}

extension UpdateDirectoryConfigInput {

    static func write(value: UpdateDirectoryConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateBasedAuthProperties"].write(value.certificateBasedAuthProperties, with: AppStreamClientTypes.CertificateBasedAuthProperties.write(value:to:))
        try writer["DirectoryName"].write(value.directoryName)
        try writer["OrganizationalUnitDistinguishedNames"].writeList(value.organizationalUnitDistinguishedNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ServiceAccountCredentials"].write(value.serviceAccountCredentials, with: AppStreamClientTypes.ServiceAccountCredentials.write(value:to:))
    }
}

extension UpdateEntitlementInput {

    static func write(value: UpdateEntitlementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppVisibility"].write(value.appVisibility)
        try writer["Attributes"].writeList(value.attributes, memberWritingClosure: AppStreamClientTypes.EntitlementAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["StackName"].write(value.stackName)
    }
}

extension UpdateFleetInput {

    static func write(value: UpdateFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributesToDelete"].writeList(value.attributesToDelete, memberWritingClosure: SmithyReadWrite.WritingClosureBox<AppStreamClientTypes.FleetAttribute>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComputeCapacity"].write(value.computeCapacity, with: AppStreamClientTypes.ComputeCapacity.write(value:to:))
        try writer["DeleteVpcConfig"].write(value.deleteVpcConfig)
        try writer["Description"].write(value.description)
        try writer["DisconnectTimeoutInSeconds"].write(value.disconnectTimeoutInSeconds)
        try writer["DisplayName"].write(value.displayName)
        try writer["DomainJoinInfo"].write(value.domainJoinInfo, with: AppStreamClientTypes.DomainJoinInfo.write(value:to:))
        try writer["EnableDefaultInternetAccess"].write(value.enableDefaultInternetAccess)
        try writer["IamRoleArn"].write(value.iamRoleArn)
        try writer["IdleDisconnectTimeoutInSeconds"].write(value.idleDisconnectTimeoutInSeconds)
        try writer["ImageArn"].write(value.imageArn)
        try writer["ImageName"].write(value.imageName)
        try writer["InstanceType"].write(value.instanceType)
        try writer["MaxConcurrentSessions"].write(value.maxConcurrentSessions)
        try writer["MaxSessionsPerInstance"].write(value.maxSessionsPerInstance)
        try writer["MaxUserDurationInSeconds"].write(value.maxUserDurationInSeconds)
        try writer["Name"].write(value.name)
        try writer["Platform"].write(value.platform)
        try writer["SessionScriptS3Location"].write(value.sessionScriptS3Location, with: AppStreamClientTypes.S3Location.write(value:to:))
        try writer["StreamView"].write(value.streamView)
        try writer["UsbDeviceFilterStrings"].writeList(value.usbDeviceFilterStrings, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcConfig"].write(value.vpcConfig, with: AppStreamClientTypes.VpcConfig.write(value:to:))
    }
}

extension UpdateImagePermissionsInput {

    static func write(value: UpdateImagePermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImagePermissions"].write(value.imagePermissions, with: AppStreamClientTypes.ImagePermissions.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["SharedAccountId"].write(value.sharedAccountId)
    }
}

extension UpdateStackInput {

    static func write(value: UpdateStackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessEndpoints"].writeList(value.accessEndpoints, memberWritingClosure: AppStreamClientTypes.AccessEndpoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ApplicationSettings"].write(value.applicationSettings, with: AppStreamClientTypes.ApplicationSettings.write(value:to:))
        try writer["AttributesToDelete"].writeList(value.attributesToDelete, memberWritingClosure: SmithyReadWrite.WritingClosureBox<AppStreamClientTypes.StackAttribute>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DeleteStorageConnectors"].write(value.deleteStorageConnectors)
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["EmbedHostDomains"].writeList(value.embedHostDomains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FeedbackURL"].write(value.feedbackURL)
        try writer["Name"].write(value.name)
        try writer["RedirectURL"].write(value.redirectURL)
        try writer["StorageConnectors"].writeList(value.storageConnectors, memberWritingClosure: AppStreamClientTypes.StorageConnector.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StreamingExperienceSettings"].write(value.streamingExperienceSettings, with: AppStreamClientTypes.StreamingExperienceSettings.write(value:to:))
        try writer["UserSettings"].writeList(value.userSettings, memberWritingClosure: AppStreamClientTypes.UserSetting.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateThemeForStackInput {

    static func write(value: UpdateThemeForStackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributesToDelete"].writeList(value.attributesToDelete, memberWritingClosure: SmithyReadWrite.WritingClosureBox<AppStreamClientTypes.ThemeAttribute>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FaviconS3Location"].write(value.faviconS3Location, with: AppStreamClientTypes.S3Location.write(value:to:))
        try writer["FooterLinks"].writeList(value.footerLinks, memberWritingClosure: AppStreamClientTypes.ThemeFooterLink.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrganizationLogoS3Location"].write(value.organizationLogoS3Location, with: AppStreamClientTypes.S3Location.write(value:to:))
        try writer["StackName"].write(value.stackName)
        try writer["State"].write(value.state)
        try writer["ThemeStyling"].write(value.themeStyling)
        try writer["TitleText"].write(value.titleText)
    }
}

extension AssociateAppBlockBuilderAppBlockOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateAppBlockBuilderAppBlockOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateAppBlockBuilderAppBlockOutput()
        value.appBlockBuilderAppBlockAssociation = try reader["AppBlockBuilderAppBlockAssociation"].readIfPresent(with: AppStreamClientTypes.AppBlockBuilderAppBlockAssociation.read(from:))
        return value
    }
}

extension AssociateApplicationFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateApplicationFleetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateApplicationFleetOutput()
        value.applicationFleetAssociation = try reader["ApplicationFleetAssociation"].readIfPresent(with: AppStreamClientTypes.ApplicationFleetAssociation.read(from:))
        return value
    }
}

extension AssociateApplicationToEntitlementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateApplicationToEntitlementOutput {
        return AssociateApplicationToEntitlementOutput()
    }
}

extension AssociateFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateFleetOutput {
        return AssociateFleetOutput()
    }
}

extension BatchAssociateUserStackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchAssociateUserStackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchAssociateUserStackOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.UserStackAssociationError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDisassociateUserStackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDisassociateUserStackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDisassociateUserStackOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.UserStackAssociationError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CopyImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CopyImageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CopyImageOutput()
        value.destinationImageName = try reader["DestinationImageName"].readIfPresent()
        return value
    }
}

extension CreateAppBlockOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAppBlockOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAppBlockOutput()
        value.appBlock = try reader["AppBlock"].readIfPresent(with: AppStreamClientTypes.AppBlock.read(from:))
        return value
    }
}

extension CreateAppBlockBuilderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAppBlockBuilderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAppBlockBuilderOutput()
        value.appBlockBuilder = try reader["AppBlockBuilder"].readIfPresent(with: AppStreamClientTypes.AppBlockBuilder.read(from:))
        return value
    }
}

extension CreateAppBlockBuilderStreamingURLOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAppBlockBuilderStreamingURLOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAppBlockBuilderStreamingURLOutput()
        value.expires = try reader["Expires"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.streamingURL = try reader["StreamingURL"].readIfPresent()
        return value
    }
}

extension CreateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationOutput()
        value.application = try reader["Application"].readIfPresent(with: AppStreamClientTypes.Application.read(from:))
        return value
    }
}

extension CreateDirectoryConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDirectoryConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDirectoryConfigOutput()
        value.directoryConfig = try reader["DirectoryConfig"].readIfPresent(with: AppStreamClientTypes.DirectoryConfig.read(from:))
        return value
    }
}

extension CreateEntitlementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEntitlementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEntitlementOutput()
        value.entitlement = try reader["Entitlement"].readIfPresent(with: AppStreamClientTypes.Entitlement.read(from:))
        return value
    }
}

extension CreateFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFleetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFleetOutput()
        value.fleet = try reader["Fleet"].readIfPresent(with: AppStreamClientTypes.Fleet.read(from:))
        return value
    }
}

extension CreateImageBuilderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateImageBuilderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateImageBuilderOutput()
        value.imageBuilder = try reader["ImageBuilder"].readIfPresent(with: AppStreamClientTypes.ImageBuilder.read(from:))
        return value
    }
}

extension CreateImageBuilderStreamingURLOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateImageBuilderStreamingURLOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateImageBuilderStreamingURLOutput()
        value.expires = try reader["Expires"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.streamingURL = try reader["StreamingURL"].readIfPresent()
        return value
    }
}

extension CreateStackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStackOutput()
        value.stack = try reader["Stack"].readIfPresent(with: AppStreamClientTypes.Stack.read(from:))
        return value
    }
}

extension CreateStreamingURLOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStreamingURLOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStreamingURLOutput()
        value.expires = try reader["Expires"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.streamingURL = try reader["StreamingURL"].readIfPresent()
        return value
    }
}

extension CreateThemeForStackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateThemeForStackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateThemeForStackOutput()
        value.theme = try reader["Theme"].readIfPresent(with: AppStreamClientTypes.Theme.read(from:))
        return value
    }
}

extension CreateUpdatedImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUpdatedImageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUpdatedImageOutput()
        value.canUpdateImage = try reader["canUpdateImage"].readIfPresent()
        value.image = try reader["image"].readIfPresent(with: AppStreamClientTypes.Image.read(from:))
        return value
    }
}

extension CreateUsageReportSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUsageReportSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUsageReportSubscriptionOutput()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.schedule = try reader["Schedule"].readIfPresent()
        return value
    }
}

extension CreateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserOutput {
        return CreateUserOutput()
    }
}

extension DeleteAppBlockOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppBlockOutput {
        return DeleteAppBlockOutput()
    }
}

extension DeleteAppBlockBuilderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppBlockBuilderOutput {
        return DeleteAppBlockBuilderOutput()
    }
}

extension DeleteApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationOutput {
        return DeleteApplicationOutput()
    }
}

extension DeleteDirectoryConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDirectoryConfigOutput {
        return DeleteDirectoryConfigOutput()
    }
}

extension DeleteEntitlementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEntitlementOutput {
        return DeleteEntitlementOutput()
    }
}

extension DeleteFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFleetOutput {
        return DeleteFleetOutput()
    }
}

extension DeleteImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteImageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteImageOutput()
        value.image = try reader["Image"].readIfPresent(with: AppStreamClientTypes.Image.read(from:))
        return value
    }
}

extension DeleteImageBuilderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteImageBuilderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteImageBuilderOutput()
        value.imageBuilder = try reader["ImageBuilder"].readIfPresent(with: AppStreamClientTypes.ImageBuilder.read(from:))
        return value
    }
}

extension DeleteImagePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteImagePermissionsOutput {
        return DeleteImagePermissionsOutput()
    }
}

extension DeleteStackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStackOutput {
        return DeleteStackOutput()
    }
}

extension DeleteThemeForStackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteThemeForStackOutput {
        return DeleteThemeForStackOutput()
    }
}

extension DeleteUsageReportSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUsageReportSubscriptionOutput {
        return DeleteUsageReportSubscriptionOutput()
    }
}

extension DeleteUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserOutput {
        return DeleteUserOutput()
    }
}

extension DescribeAppBlockBuilderAppBlockAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAppBlockBuilderAppBlockAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAppBlockBuilderAppBlockAssociationsOutput()
        value.appBlockBuilderAppBlockAssociations = try reader["AppBlockBuilderAppBlockAssociations"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.AppBlockBuilderAppBlockAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeAppBlockBuildersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAppBlockBuildersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAppBlockBuildersOutput()
        value.appBlockBuilders = try reader["AppBlockBuilders"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.AppBlockBuilder.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeAppBlocksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAppBlocksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAppBlocksOutput()
        value.appBlocks = try reader["AppBlocks"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.AppBlock.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeApplicationFleetAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicationFleetAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationFleetAssociationsOutput()
        value.applicationFleetAssociations = try reader["ApplicationFleetAssociations"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.ApplicationFleetAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationsOutput()
        value.applications = try reader["Applications"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.Application.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeDirectoryConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDirectoryConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDirectoryConfigsOutput()
        value.directoryConfigs = try reader["DirectoryConfigs"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.DirectoryConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeEntitlementsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEntitlementsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEntitlementsOutput()
        value.entitlements = try reader["Entitlements"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.Entitlement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeFleetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFleetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFleetsOutput()
        value.fleets = try reader["Fleets"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.Fleet.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeImageBuildersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeImageBuildersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeImageBuildersOutput()
        value.imageBuilders = try reader["ImageBuilders"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.ImageBuilder.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeImagePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeImagePermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeImagePermissionsOutput()
        value.name = try reader["Name"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.sharedImagePermissionsList = try reader["SharedImagePermissionsList"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.SharedImagePermissions.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeImagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeImagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeImagesOutput()
        value.images = try reader["Images"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.Image.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSessionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.sessions = try reader["Sessions"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.Session.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeStacksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeStacksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeStacksOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.stacks = try reader["Stacks"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.Stack.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeThemeForStackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeThemeForStackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeThemeForStackOutput()
        value.theme = try reader["Theme"].readIfPresent(with: AppStreamClientTypes.Theme.read(from:))
        return value
    }
}

extension DescribeUsageReportSubscriptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeUsageReportSubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeUsageReportSubscriptionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.usageReportSubscriptions = try reader["UsageReportSubscriptions"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.UsageReportSubscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeUsersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.users = try reader["Users"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.User.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeUserStackAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeUserStackAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeUserStackAssociationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.userStackAssociations = try reader["UserStackAssociations"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.UserStackAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DisableUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableUserOutput {
        return DisableUserOutput()
    }
}

extension DisassociateAppBlockBuilderAppBlockOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateAppBlockBuilderAppBlockOutput {
        return DisassociateAppBlockBuilderAppBlockOutput()
    }
}

extension DisassociateApplicationFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateApplicationFleetOutput {
        return DisassociateApplicationFleetOutput()
    }
}

extension DisassociateApplicationFromEntitlementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateApplicationFromEntitlementOutput {
        return DisassociateApplicationFromEntitlementOutput()
    }
}

extension DisassociateFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateFleetOutput {
        return DisassociateFleetOutput()
    }
}

extension EnableUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableUserOutput {
        return EnableUserOutput()
    }
}

extension ExpireSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExpireSessionOutput {
        return ExpireSessionOutput()
    }
}

extension ListAssociatedFleetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssociatedFleetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssociatedFleetsOutput()
        value.names = try reader["Names"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAssociatedStacksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssociatedStacksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssociatedStacksOutput()
        value.names = try reader["Names"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEntitledApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEntitledApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEntitledApplicationsOutput()
        value.entitledApplications = try reader["EntitledApplications"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.EntitledApplication.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension StartAppBlockBuilderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAppBlockBuilderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAppBlockBuilderOutput()
        value.appBlockBuilder = try reader["AppBlockBuilder"].readIfPresent(with: AppStreamClientTypes.AppBlockBuilder.read(from:))
        return value
    }
}

extension StartFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartFleetOutput {
        return StartFleetOutput()
    }
}

extension StartImageBuilderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartImageBuilderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartImageBuilderOutput()
        value.imageBuilder = try reader["ImageBuilder"].readIfPresent(with: AppStreamClientTypes.ImageBuilder.read(from:))
        return value
    }
}

extension StopAppBlockBuilderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopAppBlockBuilderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopAppBlockBuilderOutput()
        value.appBlockBuilder = try reader["AppBlockBuilder"].readIfPresent(with: AppStreamClientTypes.AppBlockBuilder.read(from:))
        return value
    }
}

extension StopFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopFleetOutput {
        return StopFleetOutput()
    }
}

extension StopImageBuilderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopImageBuilderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopImageBuilderOutput()
        value.imageBuilder = try reader["ImageBuilder"].readIfPresent(with: AppStreamClientTypes.ImageBuilder.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAppBlockBuilderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAppBlockBuilderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAppBlockBuilderOutput()
        value.appBlockBuilder = try reader["AppBlockBuilder"].readIfPresent(with: AppStreamClientTypes.AppBlockBuilder.read(from:))
        return value
    }
}

extension UpdateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApplicationOutput()
        value.application = try reader["Application"].readIfPresent(with: AppStreamClientTypes.Application.read(from:))
        return value
    }
}

extension UpdateDirectoryConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDirectoryConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDirectoryConfigOutput()
        value.directoryConfig = try reader["DirectoryConfig"].readIfPresent(with: AppStreamClientTypes.DirectoryConfig.read(from:))
        return value
    }
}

extension UpdateEntitlementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEntitlementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEntitlementOutput()
        value.entitlement = try reader["Entitlement"].readIfPresent(with: AppStreamClientTypes.Entitlement.read(from:))
        return value
    }
}

extension UpdateFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFleetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFleetOutput()
        value.fleet = try reader["Fleet"].readIfPresent(with: AppStreamClientTypes.Fleet.read(from:))
        return value
    }
}

extension UpdateImagePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateImagePermissionsOutput {
        return UpdateImagePermissionsOutput()
    }
}

extension UpdateStackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateStackOutput()
        value.stack = try reader["Stack"].readIfPresent(with: AppStreamClientTypes.Stack.read(from:))
        return value
    }
}

extension UpdateThemeForStackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateThemeForStackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateThemeForStackOutput()
        value.theme = try reader["Theme"].readIfPresent(with: AppStreamClientTypes.Theme.read(from:))
        return value
    }
}

enum AssociateAppBlockBuilderAppBlockOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateApplicationFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateApplicationToEntitlementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntitlementNotFoundException": return try EntitlementNotFoundException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "IncompatibleImageException": return try IncompatibleImageException.makeError(baseError: baseError)
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchAssociateUserStackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDisassociateUserStackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CopyImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IncompatibleImageException": return try IncompatibleImageException.makeError(baseError: baseError)
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotAvailableException": return try ResourceNotAvailableException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAppBlockOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAppBlockBuilderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidRoleException": return try InvalidRoleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "RequestLimitExceededException": return try RequestLimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotAvailableException": return try ResourceNotAvailableException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAppBlockBuilderStreamingURLOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDirectoryConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "InvalidRoleException": return try InvalidRoleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEntitlementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntitlementAlreadyExistsException": return try EntitlementAlreadyExistsException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "IncompatibleImageException": return try IncompatibleImageException.makeError(baseError: baseError)
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidRoleException": return try InvalidRoleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "RequestLimitExceededException": return try RequestLimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotAvailableException": return try ResourceNotAvailableException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateImageBuilderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "IncompatibleImageException": return try IncompatibleImageException.makeError(baseError: baseError)
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidRoleException": return try InvalidRoleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "RequestLimitExceededException": return try RequestLimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotAvailableException": return try ResourceNotAvailableException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateImageBuilderStreamingURLOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidRoleException": return try InvalidRoleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStreamingURLOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotAvailableException": return try ResourceNotAvailableException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateThemeForStackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUpdatedImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "IncompatibleImageException": return try IncompatibleImageException.makeError(baseError: baseError)
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUsageReportSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "InvalidRoleException": return try InvalidRoleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppBlockOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppBlockBuilderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDirectoryConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEntitlementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntitlementNotFoundException": return try EntitlementNotFoundException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteImageBuilderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteImagePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotAvailableException": return try ResourceNotAvailableException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteThemeForStackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUsageReportSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAppBlockBuilderAppBlockAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAppBlockBuildersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAppBlocksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicationFleetAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDirectoryConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEntitlementsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntitlementNotFoundException": return try EntitlementNotFoundException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFleetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeImageBuildersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeImagePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeImagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeStacksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeThemeForStackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeUsageReportSubscriptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeUserStackAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateAppBlockBuilderAppBlockOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateApplicationFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateApplicationFromEntitlementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntitlementNotFoundException": return try EntitlementNotFoundException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExpireSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssociatedFleetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssociatedStacksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEntitledApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntitlementNotFoundException": return try EntitlementNotFoundException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAppBlockBuilderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "RequestLimitExceededException": return try RequestLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotAvailableException": return try ResourceNotAvailableException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "InvalidRoleException": return try InvalidRoleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "RequestLimitExceededException": return try RequestLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotAvailableException": return try ResourceNotAvailableException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartImageBuilderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "IncompatibleImageException": return try IncompatibleImageException.makeError(baseError: baseError)
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "ResourceNotAvailableException": return try ResourceNotAvailableException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopAppBlockBuilderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopImageBuilderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAppBlockBuilderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidRoleException": return try InvalidRoleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "RequestLimitExceededException": return try RequestLimitExceededException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotAvailableException": return try ResourceNotAvailableException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDirectoryConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidRoleException": return try InvalidRoleException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEntitlementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntitlementNotFoundException": return try EntitlementNotFoundException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "IncompatibleImageException": return try IncompatibleImageException.makeError(baseError: baseError)
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidRoleException": return try InvalidRoleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "RequestLimitExceededException": return try RequestLimitExceededException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotAvailableException": return try ResourceNotAvailableException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateImagePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotAvailableException": return try ResourceNotAvailableException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "IncompatibleImageException": return try IncompatibleImageException.makeError(baseError: baseError)
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidRoleException": return try InvalidRoleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateThemeForStackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidAccountStatusException": return try InvalidAccountStatusException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidParameterCombinationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterCombinationException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterCombinationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OperationNotPermittedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OperationNotPermittedException {
        let reader = baseError.errorBodyReader
        var value = OperationNotPermittedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentModificationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntitlementNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EntitlementNotFoundException {
        let reader = baseError.errorBodyReader
        var value = EntitlementNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IncompatibleImageException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IncompatibleImageException {
        let reader = baseError.errorBodyReader
        var value = IncompatibleImageException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidAccountStatusException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidAccountStatusException {
        let reader = baseError.errorBodyReader
        var value = InvalidAccountStatusException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotAvailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotAvailableException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotAvailableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RequestLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RequestLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = RequestLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRoleException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRoleException {
        let reader = baseError.errorBodyReader
        var value = InvalidRoleException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntitlementAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EntitlementAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = EntitlementAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AppStreamClientTypes.AppBlockBuilderAppBlockAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.AppBlockBuilderAppBlockAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.AppBlockBuilderAppBlockAssociation()
        value.appBlockArn = try reader["AppBlockArn"].readIfPresent() ?? ""
        value.appBlockBuilderName = try reader["AppBlockBuilderName"].readIfPresent() ?? ""
        return value
    }
}

extension AppStreamClientTypes.ApplicationFleetAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.ApplicationFleetAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.ApplicationFleetAssociation()
        value.fleetName = try reader["FleetName"].readIfPresent() ?? ""
        value.applicationArn = try reader["ApplicationArn"].readIfPresent() ?? ""
        return value
    }
}

extension AppStreamClientTypes.UserStackAssociationError {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.UserStackAssociationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.UserStackAssociationError()
        value.userStackAssociation = try reader["UserStackAssociation"].readIfPresent(with: AppStreamClientTypes.UserStackAssociation.read(from:))
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.UserStackAssociation {

    static func write(value: AppStreamClientTypes.UserStackAssociation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationType"].write(value.authenticationType)
        try writer["SendEmailNotification"].write(value.sendEmailNotification)
        try writer["StackName"].write(value.stackName)
        try writer["UserName"].write(value.userName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.UserStackAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.UserStackAssociation()
        value.stackName = try reader["StackName"].readIfPresent() ?? ""
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        value.authenticationType = try reader["AuthenticationType"].readIfPresent() ?? .sdkUnknown("")
        value.sendEmailNotification = try reader["SendEmailNotification"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.AppBlock {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.AppBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.AppBlock()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.sourceS3Location = try reader["SourceS3Location"].readIfPresent(with: AppStreamClientTypes.S3Location.read(from:))
        value.setupScriptDetails = try reader["SetupScriptDetails"].readIfPresent(with: AppStreamClientTypes.ScriptDetails.read(from:))
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.postSetupScriptDetails = try reader["PostSetupScriptDetails"].readIfPresent(with: AppStreamClientTypes.ScriptDetails.read(from:))
        value.packagingType = try reader["PackagingType"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.appBlockErrors = try reader["AppBlockErrors"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.ErrorDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppStreamClientTypes.ErrorDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.ErrorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.ErrorDetails()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.ScriptDetails {

    static func write(value: AppStreamClientTypes.ScriptDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExecutableParameters"].write(value.executableParameters)
        try writer["ExecutablePath"].write(value.executablePath)
        try writer["ScriptS3Location"].write(value.scriptS3Location, with: AppStreamClientTypes.S3Location.write(value:to:))
        try writer["TimeoutInSeconds"].write(value.timeoutInSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.ScriptDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.ScriptDetails()
        value.scriptS3Location = try reader["ScriptS3Location"].readIfPresent(with: AppStreamClientTypes.S3Location.read(from:))
        value.executablePath = try reader["ExecutablePath"].readIfPresent() ?? ""
        value.executableParameters = try reader["ExecutableParameters"].readIfPresent()
        value.timeoutInSeconds = try reader["TimeoutInSeconds"].readIfPresent() ?? 0
        return value
    }
}

extension AppStreamClientTypes.S3Location {

    static func write(value: AppStreamClientTypes.S3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Bucket"].write(value.s3Bucket)
        try writer["S3Key"].write(value.s3Key)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.S3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.S3Location()
        value.s3Bucket = try reader["S3Bucket"].readIfPresent() ?? ""
        value.s3Key = try reader["S3Key"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.AppBlockBuilder {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.AppBlockBuilder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.AppBlockBuilder()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent() ?? .sdkUnknown("")
        value.instanceType = try reader["InstanceType"].readIfPresent() ?? ""
        value.enableDefaultInternetAccess = try reader["EnableDefaultInternetAccess"].readIfPresent()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: AppStreamClientTypes.VpcConfig.read(from:))
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.appBlockBuilderErrors = try reader["AppBlockBuilderErrors"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.ResourceError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.stateChangeReason = try reader["StateChangeReason"].readIfPresent(with: AppStreamClientTypes.AppBlockBuilderStateChangeReason.read(from:))
        value.accessEndpoints = try reader["AccessEndpoints"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.AccessEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppStreamClientTypes.AccessEndpoint {

    static func write(value: AppStreamClientTypes.AccessEndpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointType"].write(value.endpointType)
        try writer["VpceId"].write(value.vpceId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.AccessEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.AccessEndpoint()
        value.endpointType = try reader["EndpointType"].readIfPresent() ?? .sdkUnknown("")
        value.vpceId = try reader["VpceId"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.AppBlockBuilderStateChangeReason {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.AppBlockBuilderStateChangeReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.AppBlockBuilderStateChangeReason()
        value.code = try reader["Code"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.ResourceError {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.ResourceError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.ResourceError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.errorTimestamp = try reader["ErrorTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AppStreamClientTypes.VpcConfig {

    static func write(value: AppStreamClientTypes.VpcConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.VpcConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.VpcConfig()
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppStreamClientTypes.Application {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.Application {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.Application()
        value.name = try reader["Name"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.iconURL = try reader["IconURL"].readIfPresent()
        value.launchPath = try reader["LaunchPath"].readIfPresent()
        value.launchParameters = try reader["LaunchParameters"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.metadata = try reader["Metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.workingDirectory = try reader["WorkingDirectory"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.appBlockArn = try reader["AppBlockArn"].readIfPresent()
        value.iconS3Location = try reader["IconS3Location"].readIfPresent(with: AppStreamClientTypes.S3Location.read(from:))
        value.platforms = try reader["Platforms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppStreamClientTypes.PlatformType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceFamilies = try reader["InstanceFamilies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AppStreamClientTypes.DirectoryConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.DirectoryConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.DirectoryConfig()
        value.directoryName = try reader["DirectoryName"].readIfPresent() ?? ""
        value.organizationalUnitDistinguishedNames = try reader["OrganizationalUnitDistinguishedNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.serviceAccountCredentials = try reader["ServiceAccountCredentials"].readIfPresent(with: AppStreamClientTypes.ServiceAccountCredentials.read(from:))
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.certificateBasedAuthProperties = try reader["CertificateBasedAuthProperties"].readIfPresent(with: AppStreamClientTypes.CertificateBasedAuthProperties.read(from:))
        return value
    }
}

extension AppStreamClientTypes.CertificateBasedAuthProperties {

    static func write(value: AppStreamClientTypes.CertificateBasedAuthProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateAuthorityArn"].write(value.certificateAuthorityArn)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.CertificateBasedAuthProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.CertificateBasedAuthProperties()
        value.status = try reader["Status"].readIfPresent()
        value.certificateAuthorityArn = try reader["CertificateAuthorityArn"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.ServiceAccountCredentials {

    static func write(value: AppStreamClientTypes.ServiceAccountCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountName"].write(value.accountName)
        try writer["AccountPassword"].write(value.accountPassword)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.ServiceAccountCredentials {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.ServiceAccountCredentials()
        value.accountName = try reader["AccountName"].readIfPresent() ?? ""
        value.accountPassword = try reader["AccountPassword"].readIfPresent() ?? ""
        return value
    }
}

extension AppStreamClientTypes.Entitlement {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.Entitlement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.Entitlement()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.stackName = try reader["StackName"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.appVisibility = try reader["AppVisibility"].readIfPresent() ?? .sdkUnknown("")
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.EntitlementAttribute.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AppStreamClientTypes.EntitlementAttribute {

    static func write(value: AppStreamClientTypes.EntitlementAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.EntitlementAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.EntitlementAttribute()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension AppStreamClientTypes.Fleet {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.Fleet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.Fleet()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.imageName = try reader["ImageName"].readIfPresent()
        value.imageArn = try reader["ImageArn"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent() ?? ""
        value.fleetType = try reader["FleetType"].readIfPresent()
        value.computeCapacityStatus = try reader["ComputeCapacityStatus"].readIfPresent(with: AppStreamClientTypes.ComputeCapacityStatus.read(from:))
        value.maxUserDurationInSeconds = try reader["MaxUserDurationInSeconds"].readIfPresent()
        value.disconnectTimeoutInSeconds = try reader["DisconnectTimeoutInSeconds"].readIfPresent()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: AppStreamClientTypes.VpcConfig.read(from:))
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.fleetErrors = try reader["FleetErrors"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.FleetError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.enableDefaultInternetAccess = try reader["EnableDefaultInternetAccess"].readIfPresent()
        value.domainJoinInfo = try reader["DomainJoinInfo"].readIfPresent(with: AppStreamClientTypes.DomainJoinInfo.read(from:))
        value.idleDisconnectTimeoutInSeconds = try reader["IdleDisconnectTimeoutInSeconds"].readIfPresent()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        value.streamView = try reader["StreamView"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent()
        value.maxConcurrentSessions = try reader["MaxConcurrentSessions"].readIfPresent()
        value.usbDeviceFilterStrings = try reader["UsbDeviceFilterStrings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sessionScriptS3Location = try reader["SessionScriptS3Location"].readIfPresent(with: AppStreamClientTypes.S3Location.read(from:))
        value.maxSessionsPerInstance = try reader["MaxSessionsPerInstance"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.DomainJoinInfo {

    static func write(value: AppStreamClientTypes.DomainJoinInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DirectoryName"].write(value.directoryName)
        try writer["OrganizationalUnitDistinguishedName"].write(value.organizationalUnitDistinguishedName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.DomainJoinInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.DomainJoinInfo()
        value.directoryName = try reader["DirectoryName"].readIfPresent()
        value.organizationalUnitDistinguishedName = try reader["OrganizationalUnitDistinguishedName"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.FleetError {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.FleetError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.FleetError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.ComputeCapacityStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.ComputeCapacityStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.ComputeCapacityStatus()
        value.desired = try reader["Desired"].readIfPresent() ?? 0
        value.running = try reader["Running"].readIfPresent()
        value.inUse = try reader["InUse"].readIfPresent()
        value.available = try reader["Available"].readIfPresent()
        value.desiredUserSessions = try reader["DesiredUserSessions"].readIfPresent()
        value.availableUserSessions = try reader["AvailableUserSessions"].readIfPresent()
        value.activeUserSessions = try reader["ActiveUserSessions"].readIfPresent()
        value.actualUserSessions = try reader["ActualUserSessions"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.ImageBuilder {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.ImageBuilder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.ImageBuilder()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent()
        value.imageArn = try reader["ImageArn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: AppStreamClientTypes.VpcConfig.read(from:))
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.stateChangeReason = try reader["StateChangeReason"].readIfPresent(with: AppStreamClientTypes.ImageBuilderStateChangeReason.read(from:))
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.enableDefaultInternetAccess = try reader["EnableDefaultInternetAccess"].readIfPresent()
        value.domainJoinInfo = try reader["DomainJoinInfo"].readIfPresent(with: AppStreamClientTypes.DomainJoinInfo.read(from:))
        value.networkAccessConfiguration = try reader["NetworkAccessConfiguration"].readIfPresent(with: AppStreamClientTypes.NetworkAccessConfiguration.read(from:))
        value.imageBuilderErrors = try reader["ImageBuilderErrors"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.ResourceError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.appstreamAgentVersion = try reader["AppstreamAgentVersion"].readIfPresent()
        value.accessEndpoints = try reader["AccessEndpoints"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.AccessEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.latestAppstreamAgentVersion = try reader["LatestAppstreamAgentVersion"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.NetworkAccessConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.NetworkAccessConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.NetworkAccessConfiguration()
        value.eniPrivateIpAddress = try reader["EniPrivateIpAddress"].readIfPresent()
        value.eniId = try reader["EniId"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.ImageBuilderStateChangeReason {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.ImageBuilderStateChangeReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.ImageBuilderStateChangeReason()
        value.code = try reader["Code"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.Stack {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.Stack {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.Stack()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.storageConnectors = try reader["StorageConnectors"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.StorageConnector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.redirectURL = try reader["RedirectURL"].readIfPresent()
        value.feedbackURL = try reader["FeedbackURL"].readIfPresent()
        value.stackErrors = try reader["StackErrors"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.StackError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.userSettings = try reader["UserSettings"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.UserSetting.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.applicationSettings = try reader["ApplicationSettings"].readIfPresent(with: AppStreamClientTypes.ApplicationSettingsResponse.read(from:))
        value.accessEndpoints = try reader["AccessEndpoints"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.AccessEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.embedHostDomains = try reader["EmbedHostDomains"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.streamingExperienceSettings = try reader["StreamingExperienceSettings"].readIfPresent(with: AppStreamClientTypes.StreamingExperienceSettings.read(from:))
        return value
    }
}

extension AppStreamClientTypes.StreamingExperienceSettings {

    static func write(value: AppStreamClientTypes.StreamingExperienceSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PreferredProtocol"].write(value.preferredProtocol)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.StreamingExperienceSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.StreamingExperienceSettings()
        value.preferredProtocol = try reader["PreferredProtocol"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.ApplicationSettingsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.ApplicationSettingsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.ApplicationSettingsResponse()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.settingsGroup = try reader["SettingsGroup"].readIfPresent()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.UserSetting {

    static func write(value: AppStreamClientTypes.UserSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["MaximumLength"].write(value.maximumLength)
        try writer["Permission"].write(value.permission)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.UserSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.UserSetting()
        value.action = try reader["Action"].readIfPresent() ?? .sdkUnknown("")
        value.permission = try reader["Permission"].readIfPresent() ?? .sdkUnknown("")
        value.maximumLength = try reader["MaximumLength"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.StackError {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.StackError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.StackError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.StorageConnector {

    static func write(value: AppStreamClientTypes.StorageConnector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorType"].write(value.connectorType)
        try writer["Domains"].writeList(value.domains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceIdentifier"].write(value.resourceIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.StorageConnector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.StorageConnector()
        value.connectorType = try reader["ConnectorType"].readIfPresent() ?? .sdkUnknown("")
        value.resourceIdentifier = try reader["ResourceIdentifier"].readIfPresent()
        value.domains = try reader["Domains"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppStreamClientTypes.Theme {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.Theme {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.Theme()
        value.stackName = try reader["StackName"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.themeTitleText = try reader["ThemeTitleText"].readIfPresent()
        value.themeStyling = try reader["ThemeStyling"].readIfPresent()
        value.themeFooterLinks = try reader["ThemeFooterLinks"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.ThemeFooterLink.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.themeOrganizationLogoURL = try reader["ThemeOrganizationLogoURL"].readIfPresent()
        value.themeFaviconURL = try reader["ThemeFaviconURL"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AppStreamClientTypes.ThemeFooterLink {

    static func write(value: AppStreamClientTypes.ThemeFooterLink?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayName"].write(value.displayName)
        try writer["FooterLinkURL"].write(value.footerLinkURL)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.ThemeFooterLink {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.ThemeFooterLink()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.footerLinkURL = try reader["FooterLinkURL"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.Image {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.Image {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.Image()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent()
        value.baseImageArn = try reader["BaseImageArn"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.imageBuilderSupported = try reader["ImageBuilderSupported"].readIfPresent()
        value.imageBuilderName = try reader["ImageBuilderName"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.stateChangeReason = try reader["StateChangeReason"].readIfPresent(with: AppStreamClientTypes.ImageStateChangeReason.read(from:))
        value.applications = try reader["Applications"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.Application.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.publicBaseImageReleasedDate = try reader["PublicBaseImageReleasedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.appstreamAgentVersion = try reader["AppstreamAgentVersion"].readIfPresent()
        value.imagePermissions = try reader["ImagePermissions"].readIfPresent(with: AppStreamClientTypes.ImagePermissions.read(from:))
        value.imageErrors = try reader["ImageErrors"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.ResourceError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.latestAppstreamAgentVersion = try reader["LatestAppstreamAgentVersion"].readIfPresent()
        value.supportedInstanceFamilies = try reader["SupportedInstanceFamilies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dynamicAppProvidersEnabled = try reader["DynamicAppProvidersEnabled"].readIfPresent()
        value.imageSharedWithOthers = try reader["ImageSharedWithOthers"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.ImagePermissions {

    static func write(value: AppStreamClientTypes.ImagePermissions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowFleet"].write(value.allowFleet)
        try writer["allowImageBuilder"].write(value.allowImageBuilder)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.ImagePermissions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.ImagePermissions()
        value.allowFleet = try reader["allowFleet"].readIfPresent()
        value.allowImageBuilder = try reader["allowImageBuilder"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.ImageStateChangeReason {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.ImageStateChangeReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.ImageStateChangeReason()
        value.code = try reader["Code"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.SharedImagePermissions {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.SharedImagePermissions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.SharedImagePermissions()
        value.sharedAccountId = try reader["sharedAccountId"].readIfPresent() ?? ""
        value.imagePermissions = try reader["imagePermissions"].readIfPresent(with: AppStreamClientTypes.ImagePermissions.read(from:))
        return value
    }
}

extension AppStreamClientTypes.Session {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.Session {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.Session()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.userId = try reader["UserId"].readIfPresent() ?? ""
        value.stackName = try reader["StackName"].readIfPresent() ?? ""
        value.fleetName = try reader["FleetName"].readIfPresent() ?? ""
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.connectionState = try reader["ConnectionState"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maxExpirationTime = try reader["MaxExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.authenticationType = try reader["AuthenticationType"].readIfPresent()
        value.networkAccessConfiguration = try reader["NetworkAccessConfiguration"].readIfPresent(with: AppStreamClientTypes.NetworkAccessConfiguration.read(from:))
        value.instanceId = try reader["InstanceId"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.UsageReportSubscription {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.UsageReportSubscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.UsageReportSubscription()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.schedule = try reader["Schedule"].readIfPresent()
        value.lastGeneratedReportDate = try reader["LastGeneratedReportDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.subscriptionErrors = try reader["SubscriptionErrors"].readListIfPresent(memberReadingClosure: AppStreamClientTypes.LastReportGenerationExecutionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppStreamClientTypes.LastReportGenerationExecutionError {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.LastReportGenerationExecutionError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.LastReportGenerationExecutionError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension AppStreamClientTypes.User {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.User {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.User()
        value.arn = try reader["Arn"].readIfPresent()
        value.userName = try reader["UserName"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.firstName = try reader["FirstName"].readIfPresent()
        value.lastName = try reader["LastName"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.authenticationType = try reader["AuthenticationType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppStreamClientTypes.EntitledApplication {

    static func read(from reader: SmithyJSON.Reader) throws -> AppStreamClientTypes.EntitledApplication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppStreamClientTypes.EntitledApplication()
        value.applicationIdentifier = try reader["ApplicationIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension AppStreamClientTypes.ComputeCapacity {

    static func write(value: AppStreamClientTypes.ComputeCapacity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DesiredInstances"].write(value.desiredInstances)
        try writer["DesiredSessions"].write(value.desiredSessions)
    }
}

extension AppStreamClientTypes.ApplicationSettings {

    static func write(value: AppStreamClientTypes.ApplicationSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["SettingsGroup"].write(value.settingsGroup)
    }
}

public enum AppStreamClientTypes {}
