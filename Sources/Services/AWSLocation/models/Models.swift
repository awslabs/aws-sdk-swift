// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied because of insufficient access or permissions. Check with an administrator to verify your permissions.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociateTrackerConsumerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerArn = "ConsumerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerArn = self.consumerArn {
            try encodeContainer.encode(consumerArn, forKey: .consumerArn)
        }
    }
}

extension AssociateTrackerConsumerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trackerName = trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/consumers"
    }
}

public struct AssociateTrackerConsumerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the geofence collection to be associated to tracker resource. Used when you need to specify a resource across all AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
    /// This member is required.
    public var consumerArn: Swift.String?
    /// The name of the tracker resource to be associated with a geofence collection.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        consumerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.consumerArn = consumerArn
        self.trackerName = trackerName
    }
}

struct AssociateTrackerConsumerInputBody: Swift.Equatable {
    let consumerArn: Swift.String?
}

extension AssociateTrackerConsumerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerArn = "ConsumerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumerArn)
        consumerArn = consumerArnDecoded
    }
}

extension AssociateTrackerConsumerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateTrackerConsumerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateTrackerConsumerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateTrackerConsumerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateTrackerConsumerOutputResponse: Swift.Equatable {

    public init () { }
}

extension LocationClientTypes.BatchDeleteDevicePositionHistoryError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case error = "Error"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes {
    /// Contains the tracker resource details.
    public struct BatchDeleteDevicePositionHistoryError: Swift.Equatable {
        /// The ID of the device for this position.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains the batch request error details associated with the request.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?

        public init (
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
        }
    }

}

extension BatchDeleteDevicePositionHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceIds = deviceIds {
            var deviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceIds)
            for id0 in deviceIds {
                try deviceIdsContainer.encode(id0)
            }
        }
    }
}

extension BatchDeleteDevicePositionHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trackerName = trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/delete-positions"
    }
}

public struct BatchDeleteDevicePositionHistoryInput: Swift.Equatable {
    /// Devices whose position history you want to delete.
    ///
    /// * For example, for two devices: “DeviceIds” : [DeviceId1,DeviceId2]
    /// This member is required.
    public var deviceIds: [Swift.String]?
    /// The name of the tracker resource to delete the device position history from.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        deviceIds: [Swift.String]? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceIds = deviceIds
        self.trackerName = trackerName
    }
}

struct BatchDeleteDevicePositionHistoryInputBody: Swift.Equatable {
    let deviceIds: [Swift.String]?
}

extension BatchDeleteDevicePositionHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceIds)
        var deviceIdsDecoded0:[Swift.String]? = nil
        if let deviceIdsContainer = deviceIdsContainer {
            deviceIdsDecoded0 = [Swift.String]()
            for string0 in deviceIdsContainer {
                if let string0 = string0 {
                    deviceIdsDecoded0?.append(string0)
                }
            }
        }
        deviceIds = deviceIdsDecoded0
    }
}

extension BatchDeleteDevicePositionHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteDevicePositionHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDeleteDevicePositionHistoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteDevicePositionHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDeleteDevicePositionHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteDevicePositionHistoryOutputResponse: Swift.Equatable {
    /// Contains error details for each device history that failed to delete.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchDeleteDevicePositionHistoryError]?

    public init (
        errors: [LocationClientTypes.BatchDeleteDevicePositionHistoryError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteDevicePositionHistoryOutputResponseBody: Swift.Equatable {
    let errors: [LocationClientTypes.BatchDeleteDevicePositionHistoryError]?
}

extension BatchDeleteDevicePositionHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchDeleteDevicePositionHistoryError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchDeleteDevicePositionHistoryError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchDeleteDevicePositionHistoryError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension LocationClientTypes.BatchDeleteGeofenceError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case geofenceId = "GeofenceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let geofenceId = self.geofenceId {
            try encodeContainer.encode(geofenceId, forKey: .geofenceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes {
    /// Contains error details for each geofence that failed to delete from the geofence collection.
    public struct BatchDeleteGeofenceError: Swift.Equatable {
        /// Contains details associated to the batch error.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// The geofence associated with the error message.
        /// This member is required.
        public var geofenceId: Swift.String?

        public init (
            error: LocationClientTypes.BatchItemError? = nil,
            geofenceId: Swift.String? = nil
        )
        {
            self.error = error
            self.geofenceId = geofenceId
        }
    }

}

extension BatchDeleteGeofenceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geofenceIds = "GeofenceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geofenceIds = geofenceIds {
            var geofenceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .geofenceIds)
            for id0 in geofenceIds {
                try geofenceIdsContainer.encode(id0)
            }
        }
    }
}

extension BatchDeleteGeofenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collectionName = collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/delete-geofences"
    }
}

public struct BatchDeleteGeofenceInput: Swift.Equatable {
    /// The geofence collection storing the geofences to be deleted.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The batch of geofences to be deleted.
    /// This member is required.
    public var geofenceIds: [Swift.String]?

    public init (
        collectionName: Swift.String? = nil,
        geofenceIds: [Swift.String]? = nil
    )
    {
        self.collectionName = collectionName
        self.geofenceIds = geofenceIds
    }
}

struct BatchDeleteGeofenceInputBody: Swift.Equatable {
    let geofenceIds: [Swift.String]?
}

extension BatchDeleteGeofenceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geofenceIds = "GeofenceIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .geofenceIds)
        var geofenceIdsDecoded0:[Swift.String]? = nil
        if let geofenceIdsContainer = geofenceIdsContainer {
            geofenceIdsDecoded0 = [Swift.String]()
            for string0 in geofenceIdsContainer {
                if let string0 = string0 {
                    geofenceIdsDecoded0?.append(string0)
                }
            }
        }
        geofenceIds = geofenceIdsDecoded0
    }
}

extension BatchDeleteGeofenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteGeofenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDeleteGeofenceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteGeofenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDeleteGeofenceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteGeofenceOutputResponse: Swift.Equatable {
    /// Contains error details for each geofence that failed to delete.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchDeleteGeofenceError]?

    public init (
        errors: [LocationClientTypes.BatchDeleteGeofenceError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteGeofenceOutputResponseBody: Swift.Equatable {
    let errors: [LocationClientTypes.BatchDeleteGeofenceError]?
}

extension BatchDeleteGeofenceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchDeleteGeofenceError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchDeleteGeofenceError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchDeleteGeofenceError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension LocationClientTypes.BatchEvaluateGeofencesError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case error = "Error"
        case sampleTime = "SampleTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let sampleTime = self.sampleTime {
            try encodeContainer.encodeTimestamp(sampleTime, format: .dateTime, forKey: .sampleTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes {
    /// Contains error details for each device that failed to evaluate its position against the geofences in a given geofence collection.
    public struct BatchEvaluateGeofencesError: Swift.Equatable {
        /// The device associated with the position evaluation error.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains details associated to the batch error.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// Specifies a timestamp for when the error occurred in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init (
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }
    }

}

extension BatchEvaluateGeofencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePositionUpdates = "DevicePositionUpdates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devicePositionUpdates = devicePositionUpdates {
            var devicePositionUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devicePositionUpdates)
            for devicepositionupdate0 in devicePositionUpdates {
                try devicePositionUpdatesContainer.encode(devicepositionupdate0)
            }
        }
    }
}

extension BatchEvaluateGeofencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collectionName = collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/positions"
    }
}

public struct BatchEvaluateGeofencesInput: Swift.Equatable {
    /// The geofence collection used in evaluating the position of devices against its geofences.
    /// This member is required.
    public var collectionName: Swift.String?
    /// Contains device details for each device to be evaluated against the given geofence collection.
    /// This member is required.
    public var devicePositionUpdates: [LocationClientTypes.DevicePositionUpdate]?

    public init (
        collectionName: Swift.String? = nil,
        devicePositionUpdates: [LocationClientTypes.DevicePositionUpdate]? = nil
    )
    {
        self.collectionName = collectionName
        self.devicePositionUpdates = devicePositionUpdates
    }
}

struct BatchEvaluateGeofencesInputBody: Swift.Equatable {
    let devicePositionUpdates: [LocationClientTypes.DevicePositionUpdate]?
}

extension BatchEvaluateGeofencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePositionUpdates = "DevicePositionUpdates"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePositionUpdatesContainer = try containerValues.decodeIfPresent([LocationClientTypes.DevicePositionUpdate?].self, forKey: .devicePositionUpdates)
        var devicePositionUpdatesDecoded0:[LocationClientTypes.DevicePositionUpdate]? = nil
        if let devicePositionUpdatesContainer = devicePositionUpdatesContainer {
            devicePositionUpdatesDecoded0 = [LocationClientTypes.DevicePositionUpdate]()
            for structure0 in devicePositionUpdatesContainer {
                if let structure0 = structure0 {
                    devicePositionUpdatesDecoded0?.append(structure0)
                }
            }
        }
        devicePositionUpdates = devicePositionUpdatesDecoded0
    }
}

extension BatchEvaluateGeofencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchEvaluateGeofencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchEvaluateGeofencesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchEvaluateGeofencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchEvaluateGeofencesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchEvaluateGeofencesOutputResponse: Swift.Equatable {
    /// Contains error details for each device that failed to evaluate its position against the given geofence collection.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchEvaluateGeofencesError]?

    public init (
        errors: [LocationClientTypes.BatchEvaluateGeofencesError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchEvaluateGeofencesOutputResponseBody: Swift.Equatable {
    let errors: [LocationClientTypes.BatchEvaluateGeofencesError]?
}

extension BatchEvaluateGeofencesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchEvaluateGeofencesError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchEvaluateGeofencesError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchEvaluateGeofencesError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension LocationClientTypes.BatchGetDevicePositionError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case error = "Error"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes {
    /// Contains error details for each device that didn't return a position.
    public struct BatchGetDevicePositionError: Swift.Equatable {
        /// The ID of the device that didn't return a position.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains details related to the error code.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?

        public init (
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
        }
    }

}

extension BatchGetDevicePositionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceIds = deviceIds {
            var deviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceIds)
            for id0 in deviceIds {
                try deviceIdsContainer.encode(id0)
            }
        }
    }
}

extension BatchGetDevicePositionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trackerName = trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/get-positions"
    }
}

public struct BatchGetDevicePositionInput: Swift.Equatable {
    /// Devices whose position you want to retrieve.
    ///
    /// * For example, for two devices: device-ids=DeviceId1&device-ids=DeviceId2
    /// This member is required.
    public var deviceIds: [Swift.String]?
    /// The tracker resource retrieving the device position.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        deviceIds: [Swift.String]? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceIds = deviceIds
        self.trackerName = trackerName
    }
}

struct BatchGetDevicePositionInputBody: Swift.Equatable {
    let deviceIds: [Swift.String]?
}

extension BatchGetDevicePositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceIds)
        var deviceIdsDecoded0:[Swift.String]? = nil
        if let deviceIdsContainer = deviceIdsContainer {
            deviceIdsDecoded0 = [Swift.String]()
            for string0 in deviceIdsContainer {
                if let string0 = string0 {
                    deviceIdsDecoded0?.append(string0)
                }
            }
        }
        deviceIds = deviceIdsDecoded0
    }
}

extension BatchGetDevicePositionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetDevicePositionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetDevicePositionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetDevicePositionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetDevicePositionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devicePositions = output.devicePositions
            self.errors = output.errors
        } else {
            self.devicePositions = nil
            self.errors = nil
        }
    }
}

public struct BatchGetDevicePositionOutputResponse: Swift.Equatable {
    /// Contains device position details such as the device ID, position, and timestamps for when the position was received and sampled.
    /// This member is required.
    public var devicePositions: [LocationClientTypes.DevicePosition]?
    /// Contains error details for each device that failed to send its position to the tracker resource.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchGetDevicePositionError]?

    public init (
        devicePositions: [LocationClientTypes.DevicePosition]? = nil,
        errors: [LocationClientTypes.BatchGetDevicePositionError]? = nil
    )
    {
        self.devicePositions = devicePositions
        self.errors = errors
    }
}

struct BatchGetDevicePositionOutputResponseBody: Swift.Equatable {
    let errors: [LocationClientTypes.BatchGetDevicePositionError]?
    let devicePositions: [LocationClientTypes.DevicePosition]?
}

extension BatchGetDevicePositionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePositions = "DevicePositions"
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchGetDevicePositionError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchGetDevicePositionError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchGetDevicePositionError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let devicePositionsContainer = try containerValues.decodeIfPresent([LocationClientTypes.DevicePosition?].self, forKey: .devicePositions)
        var devicePositionsDecoded0:[LocationClientTypes.DevicePosition]? = nil
        if let devicePositionsContainer = devicePositionsContainer {
            devicePositionsDecoded0 = [LocationClientTypes.DevicePosition]()
            for structure0 in devicePositionsContainer {
                if let structure0 = structure0 {
                    devicePositionsDecoded0?.append(structure0)
                }
            }
        }
        devicePositions = devicePositionsDecoded0
    }
}

extension LocationClientTypes.BatchItemError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes {
    /// Contains the batch request error details associated with the request.
    public struct BatchItemError: Swift.Equatable {
        /// The error code associated with the batch request error.
        public var code: LocationClientTypes.BatchItemErrorCode?
        /// A message with the reason for the batch request error.
        public var message: Swift.String?

        public init (
            code: LocationClientTypes.BatchItemErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension LocationClientTypes {
    public enum BatchItemErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Access to the resource was denied.
        case accessdeniederror
        /// The target resource already exists.
        case conflicterror
        /// Internal server error.
        case internalservererror
        /// The target resource does not exist.
        case resourcenotfounderror
        /// Too many requests.
        case throttlingerror
        /// Input fails to satisfy the constraints specified by the service.
        case validationerror
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchItemErrorCode] {
            return [
                .accessdeniederror,
                .conflicterror,
                .internalservererror,
                .resourcenotfounderror,
                .throttlingerror,
                .validationerror,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniederror: return "AccessDeniedError"
            case .conflicterror: return "ConflictError"
            case .internalservererror: return "InternalServerError"
            case .resourcenotfounderror: return "ResourceNotFoundError"
            case .throttlingerror: return "ThrottlingError"
            case .validationerror: return "ValidationError"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchItemErrorCode(rawValue: rawValue) ?? BatchItemErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes.BatchPutGeofenceError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case geofenceId = "GeofenceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let geofenceId = self.geofenceId {
            try encodeContainer.encode(geofenceId, forKey: .geofenceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes {
    /// Contains error details for each geofence that failed to be stored in a given geofence collection.
    public struct BatchPutGeofenceError: Swift.Equatable {
        /// Contains details associated to the batch error.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// The geofence associated with the error message.
        /// This member is required.
        public var geofenceId: Swift.String?

        public init (
            error: LocationClientTypes.BatchItemError? = nil,
            geofenceId: Swift.String? = nil
        )
        {
            self.error = error
            self.geofenceId = geofenceId
        }
    }

}

extension BatchPutGeofenceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for batchputgeofencerequestentry0 in entries {
                try entriesContainer.encode(batchputgeofencerequestentry0)
            }
        }
    }
}

extension BatchPutGeofenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collectionName = collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/put-geofences"
    }
}

public struct BatchPutGeofenceInput: Swift.Equatable {
    /// The geofence collection storing the geofences.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The batch of geofences to be stored in a geofence collection.
    /// This member is required.
    public var entries: [LocationClientTypes.BatchPutGeofenceRequestEntry]?

    public init (
        collectionName: Swift.String? = nil,
        entries: [LocationClientTypes.BatchPutGeofenceRequestEntry]? = nil
    )
    {
        self.collectionName = collectionName
        self.entries = entries
    }
}

struct BatchPutGeofenceInputBody: Swift.Equatable {
    let entries: [LocationClientTypes.BatchPutGeofenceRequestEntry]?
}

extension BatchPutGeofenceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchPutGeofenceRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.BatchPutGeofenceRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.BatchPutGeofenceRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchPutGeofenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchPutGeofenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchPutGeofenceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchPutGeofenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchPutGeofenceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.successes = output.successes
        } else {
            self.errors = nil
            self.successes = nil
        }
    }
}

public struct BatchPutGeofenceOutputResponse: Swift.Equatable {
    /// Contains additional error details for each geofence that failed to be stored in a geofence collection.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchPutGeofenceError]?
    /// Contains each geofence that was successfully stored in a geofence collection.
    /// This member is required.
    public var successes: [LocationClientTypes.BatchPutGeofenceSuccess]?

    public init (
        errors: [LocationClientTypes.BatchPutGeofenceError]? = nil,
        successes: [LocationClientTypes.BatchPutGeofenceSuccess]? = nil
    )
    {
        self.errors = errors
        self.successes = successes
    }
}

struct BatchPutGeofenceOutputResponseBody: Swift.Equatable {
    let successes: [LocationClientTypes.BatchPutGeofenceSuccess]?
    let errors: [LocationClientTypes.BatchPutGeofenceError]?
}

extension BatchPutGeofenceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
        case successes = "Successes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successesContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchPutGeofenceSuccess?].self, forKey: .successes)
        var successesDecoded0:[LocationClientTypes.BatchPutGeofenceSuccess]? = nil
        if let successesContainer = successesContainer {
            successesDecoded0 = [LocationClientTypes.BatchPutGeofenceSuccess]()
            for structure0 in successesContainer {
                if let structure0 = structure0 {
                    successesDecoded0?.append(structure0)
                }
            }
        }
        successes = successesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchPutGeofenceError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchPutGeofenceError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchPutGeofenceError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension LocationClientTypes.BatchPutGeofenceRequestEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geofenceId = "GeofenceId"
        case geometry = "Geometry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geofenceId = self.geofenceId {
            try encodeContainer.encode(geofenceId, forKey: .geofenceId)
        }
        if let geometry = self.geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.GeofenceGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
    }
}

extension LocationClientTypes {
    /// Contains geofence geometry details.
    public struct BatchPutGeofenceRequestEntry: Swift.Equatable {
        /// The identifier for the geofence to be stored in a given geofence collection.
        /// This member is required.
        public var geofenceId: Swift.String?
        /// Contains the details of the position of the geofence. Can be either a polygon or a circle. Including both will return a validation error. Each [ geofence polygon](https://docs.aws.amazon.com/location-geofences/latest/APIReference/API_GeofenceGeometry.html) can have a maximum of 1,000 vertices.
        /// This member is required.
        public var geometry: LocationClientTypes.GeofenceGeometry?

        public init (
            geofenceId: Swift.String? = nil,
            geometry: LocationClientTypes.GeofenceGeometry? = nil
        )
        {
            self.geofenceId = geofenceId
            self.geometry = geometry
        }
    }

}

extension LocationClientTypes.BatchPutGeofenceSuccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case geofenceId = "GeofenceId"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let geofenceId = self.geofenceId {
            try encodeContainer.encode(geofenceId, forKey: .geofenceId)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes {
    /// Contains a summary of each geofence that was successfully stored in a given geofence collection.
    public struct BatchPutGeofenceSuccess: Swift.Equatable {
        /// The timestamp for when the geofence was stored in a geofence collection in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The geofence successfully stored in a geofence collection.
        /// This member is required.
        public var geofenceId: Swift.String?
        /// The timestamp for when the geofence was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            createTime: ClientRuntime.Date? = nil,
            geofenceId: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.updateTime = updateTime
        }
    }

}

extension LocationClientTypes.BatchUpdateDevicePositionError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case error = "Error"
        case sampleTime = "SampleTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let sampleTime = self.sampleTime {
            try encodeContainer.encodeTimestamp(sampleTime, format: .dateTime, forKey: .sampleTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes {
    /// Contains error details for each device that failed to update its position.
    public struct BatchUpdateDevicePositionError: Swift.Equatable {
        /// The device associated with the failed location update.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains details related to the error code such as the error code and error message.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// The timestamp at which the device position was determined. Uses [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init (
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }
    }

}

extension BatchUpdateDevicePositionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updates = "Updates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updates = updates {
            var updatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updates)
            for devicepositionupdate0 in updates {
                try updatesContainer.encode(devicepositionupdate0)
            }
        }
    }
}

extension BatchUpdateDevicePositionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trackerName = trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/positions"
    }
}

public struct BatchUpdateDevicePositionInput: Swift.Equatable {
    /// The name of the tracker resource to update.
    /// This member is required.
    public var trackerName: Swift.String?
    /// Contains the position update details for each device.
    /// This member is required.
    public var updates: [LocationClientTypes.DevicePositionUpdate]?

    public init (
        trackerName: Swift.String? = nil,
        updates: [LocationClientTypes.DevicePositionUpdate]? = nil
    )
    {
        self.trackerName = trackerName
        self.updates = updates
    }
}

struct BatchUpdateDevicePositionInputBody: Swift.Equatable {
    let updates: [LocationClientTypes.DevicePositionUpdate]?
}

extension BatchUpdateDevicePositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updates = "Updates"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatesContainer = try containerValues.decodeIfPresent([LocationClientTypes.DevicePositionUpdate?].self, forKey: .updates)
        var updatesDecoded0:[LocationClientTypes.DevicePositionUpdate]? = nil
        if let updatesContainer = updatesContainer {
            updatesDecoded0 = [LocationClientTypes.DevicePositionUpdate]()
            for structure0 in updatesContainer {
                if let structure0 = structure0 {
                    updatesDecoded0?.append(structure0)
                }
            }
        }
        updates = updatesDecoded0
    }
}

extension BatchUpdateDevicePositionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchUpdateDevicePositionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchUpdateDevicePositionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchUpdateDevicePositionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchUpdateDevicePositionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchUpdateDevicePositionOutputResponse: Swift.Equatable {
    /// Contains error details for each device that failed to update its position.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchUpdateDevicePositionError]?

    public init (
        errors: [LocationClientTypes.BatchUpdateDevicePositionError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchUpdateDevicePositionOutputResponseBody: Swift.Equatable {
    let errors: [LocationClientTypes.BatchUpdateDevicePositionError]?
}

extension BatchUpdateDevicePositionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchUpdateDevicePositionError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchUpdateDevicePositionError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchUpdateDevicePositionError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension LocationClientTypes.CalculateRouteCarModeOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avoidFerries = "AvoidFerries"
        case avoidTolls = "AvoidTolls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let avoidFerries = self.avoidFerries {
            try encodeContainer.encode(avoidFerries, forKey: .avoidFerries)
        }
        if let avoidTolls = self.avoidTolls {
            try encodeContainer.encode(avoidTolls, forKey: .avoidTolls)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let avoidFerriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .avoidFerries)
        avoidFerries = avoidFerriesDecoded
        let avoidTollsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .avoidTolls)
        avoidTolls = avoidTollsDecoded
    }
}

extension LocationClientTypes {
    /// Contains details about additional route preferences for requests that specify TravelMode as Car.
    public struct CalculateRouteCarModeOptions: Swift.Equatable {
        /// Avoids ferries when calculating routes. Default Value: false Valid Values: false | true
        public var avoidFerries: Swift.Bool?
        /// Avoids tolls when calculating routes. Default Value: false Valid Values: false | true
        public var avoidTolls: Swift.Bool?

        public init (
            avoidFerries: Swift.Bool? = nil,
            avoidTolls: Swift.Bool? = nil
        )
        {
            self.avoidFerries = avoidFerries
            self.avoidTolls = avoidTolls
        }
    }

}

extension CalculateRouteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRouteInput(calculatorName: \(Swift.String(describing: calculatorName)), carModeOptions: \(Swift.String(describing: carModeOptions)), departNow: \(Swift.String(describing: departNow)), departureTime: \(Swift.String(describing: departureTime)), distanceUnit: \(Swift.String(describing: distanceUnit)), includeLegGeometry: \(Swift.String(describing: includeLegGeometry)), travelMode: \(Swift.String(describing: travelMode)), truckModeOptions: \(Swift.String(describing: truckModeOptions)), waypointPositions: \(Swift.String(describing: waypointPositions)), departurePosition: \"CONTENT_REDACTED\", destinationPosition: \"CONTENT_REDACTED\")"}
}

extension CalculateRouteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case carModeOptions = "CarModeOptions"
        case departNow = "DepartNow"
        case departurePosition = "DeparturePosition"
        case departureTime = "DepartureTime"
        case destinationPosition = "DestinationPosition"
        case distanceUnit = "DistanceUnit"
        case includeLegGeometry = "IncludeLegGeometry"
        case travelMode = "TravelMode"
        case truckModeOptions = "TruckModeOptions"
        case waypointPositions = "WaypointPositions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let carModeOptions = self.carModeOptions {
            try encodeContainer.encode(carModeOptions, forKey: .carModeOptions)
        }
        if let departNow = self.departNow {
            try encodeContainer.encode(departNow, forKey: .departNow)
        }
        if let departurePosition = departurePosition {
            var departurePositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .departurePosition)
            for double0 in departurePosition {
                try departurePositionContainer.encode(double0)
            }
        }
        if let departureTime = self.departureTime {
            try encodeContainer.encodeTimestamp(departureTime, format: .dateTime, forKey: .departureTime)
        }
        if let destinationPosition = destinationPosition {
            var destinationPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPosition)
            for double0 in destinationPosition {
                try destinationPositionContainer.encode(double0)
            }
        }
        if let distanceUnit = self.distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let includeLegGeometry = self.includeLegGeometry {
            try encodeContainer.encode(includeLegGeometry, forKey: .includeLegGeometry)
        }
        if let travelMode = self.travelMode {
            try encodeContainer.encode(travelMode.rawValue, forKey: .travelMode)
        }
        if let truckModeOptions = self.truckModeOptions {
            try encodeContainer.encode(truckModeOptions, forKey: .truckModeOptions)
        }
        if let waypointPositions = waypointPositions {
            var waypointPositionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .waypointPositions)
            for position0 in waypointPositions {
                var position0Container = waypointPositionsContainer.nestedUnkeyedContainer()
                for double1 in position0 {
                    try position0Container.encode(double1)
                }
            }
        }
    }
}

extension CalculateRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let calculatorName = calculatorName else {
            return nil
        }
        return "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())/calculate/route"
    }
}

public struct CalculateRouteInput: Swift.Equatable {
    /// The name of the route calculator resource that you want to use to calculate the route.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// Specifies route preferences when traveling by Car, such as avoiding routes that use ferries or tolls. Requirements: TravelMode must be specified as Car.
    public var carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions?
    /// Sets the time of departure as the current time. Uses the current time to calculate a route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route. Default Value: false Valid Values: false | true
    public var departNow: Swift.Bool?
    /// The start position for the route. Defined in [World Geodetic System (WGS 84)](https://earth-info.nga.mil/index.php?dir=wgs84&action=wgs84) format: [longitude, latitude].
    ///
    /// * For example, [-123.115, 49.285]
    ///
    ///
    /// If you specify a departure that's not located on a road, Amazon Location [moves the position to the nearest road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html). If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a 400 RoutesValidationException error. Valid Values: [-180 to 180,-90 to 90]
    /// This member is required.
    public var departurePosition: [Swift.Double]?
    /// Specifies the desired time of departure. Uses the given time to calculate the route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route. Setting a departure time in the past returns a 400 ValidationException error.
    ///
    /// * In [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ. For example, 2020–07-2T12:15:20.000Z+01:00
    public var departureTime: ClientRuntime.Date?
    /// The finish position for the route. Defined in [World Geodetic System (WGS 84)](https://earth-info.nga.mil/index.php?dir=wgs84&action=wgs84) format: [longitude, latitude].
    ///
    /// * For example, [-122.339, 47.615]
    ///
    ///
    /// If you specify a destination that's not located on a road, Amazon Location [moves the position to the nearest road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html). Valid Values: [-180 to 180,-90 to 90]
    /// This member is required.
    public var destinationPosition: [Swift.Double]?
    /// Set the unit system to specify the distance. Default Value: Kilometers
    public var distanceUnit: LocationClientTypes.DistanceUnit?
    /// Set to include the geometry details in the result for each path between a pair of positions. Default Value: false Valid Values: false | true
    public var includeLegGeometry: Swift.Bool?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. You can choose Car, Truck, or Walking as options for the TravelMode. The TravelMode you specify also determines how you specify route preferences:
    ///
    /// * If traveling by Car use the CarModeOptions parameter.
    ///
    /// * If traveling by Truck use the TruckModeOptions parameter.
    ///
    ///
    /// Default Value: Car
    public var travelMode: LocationClientTypes.TravelMode?
    /// Specifies route preferences when traveling by Truck, such as avoiding routes that use ferries or tolls, and truck specifications to consider when choosing an optimal road. Requirements: TravelMode must be specified as Truck.
    public var truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions?
    /// Specifies an ordered list of up to 23 intermediate positions to include along a route between the departure position and destination position.
    ///
    /// * For example, from the DeparturePosition[-123.115, 49.285], the route follows the order that the waypoint positions are given [[-122.757, 49.0021],[-122.349, 47.620]]
    ///
    ///
    /// If you specify a waypoint position that's not located on a road, Amazon Location [moves the position to the nearest road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html). Specifying more than 23 waypoints returns a 400 ValidationException error. If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a 400 RoutesValidationException error. Valid Values: [-180 to 180,-90 to 90]
    public var waypointPositions: [[Swift.Double]]?

    public init (
        calculatorName: Swift.String? = nil,
        carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions? = nil,
        departNow: Swift.Bool? = nil,
        departurePosition: [Swift.Double]? = nil,
        departureTime: ClientRuntime.Date? = nil,
        destinationPosition: [Swift.Double]? = nil,
        distanceUnit: LocationClientTypes.DistanceUnit? = nil,
        includeLegGeometry: Swift.Bool? = nil,
        travelMode: LocationClientTypes.TravelMode? = nil,
        truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions? = nil,
        waypointPositions: [[Swift.Double]]? = nil
    )
    {
        self.calculatorName = calculatorName
        self.carModeOptions = carModeOptions
        self.departNow = departNow
        self.departurePosition = departurePosition
        self.departureTime = departureTime
        self.destinationPosition = destinationPosition
        self.distanceUnit = distanceUnit
        self.includeLegGeometry = includeLegGeometry
        self.travelMode = travelMode
        self.truckModeOptions = truckModeOptions
        self.waypointPositions = waypointPositions
    }
}

struct CalculateRouteInputBody: Swift.Equatable {
    let departurePosition: [Swift.Double]?
    let destinationPosition: [Swift.Double]?
    let waypointPositions: [[Swift.Double]]?
    let travelMode: LocationClientTypes.TravelMode?
    let departureTime: ClientRuntime.Date?
    let departNow: Swift.Bool?
    let distanceUnit: LocationClientTypes.DistanceUnit?
    let includeLegGeometry: Swift.Bool?
    let carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions?
    let truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions?
}

extension CalculateRouteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case carModeOptions = "CarModeOptions"
        case departNow = "DepartNow"
        case departurePosition = "DeparturePosition"
        case departureTime = "DepartureTime"
        case destinationPosition = "DestinationPosition"
        case distanceUnit = "DistanceUnit"
        case includeLegGeometry = "IncludeLegGeometry"
        case travelMode = "TravelMode"
        case truckModeOptions = "TruckModeOptions"
        case waypointPositions = "WaypointPositions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let departurePositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .departurePosition)
        var departurePositionDecoded0:[Swift.Double]? = nil
        if let departurePositionContainer = departurePositionContainer {
            departurePositionDecoded0 = [Swift.Double]()
            for double0 in departurePositionContainer {
                if let double0 = double0 {
                    departurePositionDecoded0?.append(double0)
                }
            }
        }
        departurePosition = departurePositionDecoded0
        let destinationPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .destinationPosition)
        var destinationPositionDecoded0:[Swift.Double]? = nil
        if let destinationPositionContainer = destinationPositionContainer {
            destinationPositionDecoded0 = [Swift.Double]()
            for double0 in destinationPositionContainer {
                if let double0 = double0 {
                    destinationPositionDecoded0?.append(double0)
                }
            }
        }
        destinationPosition = destinationPositionDecoded0
        let waypointPositionsContainer = try containerValues.decodeIfPresent([[Swift.Double?]?].self, forKey: .waypointPositions)
        var waypointPositionsDecoded0:[[Swift.Double]]? = nil
        if let waypointPositionsContainer = waypointPositionsContainer {
            waypointPositionsDecoded0 = [[Swift.Double]]()
            for list0 in waypointPositionsContainer {
                var list0Decoded0: [Swift.Double]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.Double]()
                    for double1 in list0 {
                        if let double1 = double1 {
                            list0Decoded0?.append(double1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    waypointPositionsDecoded0?.append(list0Decoded0)
                }
            }
        }
        waypointPositions = waypointPositionsDecoded0
        let travelModeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.TravelMode.self, forKey: .travelMode)
        travelMode = travelModeDecoded
        let departureTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .departureTime)
        departureTime = departureTimeDecoded
        let departNowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .departNow)
        departNow = departNowDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let includeLegGeometryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeLegGeometry)
        includeLegGeometry = includeLegGeometryDecoded
        let carModeOptionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.CalculateRouteCarModeOptions.self, forKey: .carModeOptions)
        carModeOptions = carModeOptionsDecoded
        let truckModeOptionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.CalculateRouteTruckModeOptions.self, forKey: .truckModeOptions)
        truckModeOptions = truckModeOptionsDecoded
    }
}

extension CalculateRouteMatrixInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case carModeOptions = "CarModeOptions"
        case departNow = "DepartNow"
        case departurePositions = "DeparturePositions"
        case departureTime = "DepartureTime"
        case destinationPositions = "DestinationPositions"
        case distanceUnit = "DistanceUnit"
        case travelMode = "TravelMode"
        case truckModeOptions = "TruckModeOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let carModeOptions = self.carModeOptions {
            try encodeContainer.encode(carModeOptions, forKey: .carModeOptions)
        }
        if let departNow = self.departNow {
            try encodeContainer.encode(departNow, forKey: .departNow)
        }
        if let departurePositions = departurePositions {
            var departurePositionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .departurePositions)
            for position0 in departurePositions {
                var position0Container = departurePositionsContainer.nestedUnkeyedContainer()
                for double1 in position0 {
                    try position0Container.encode(double1)
                }
            }
        }
        if let departureTime = self.departureTime {
            try encodeContainer.encodeTimestamp(departureTime, format: .dateTime, forKey: .departureTime)
        }
        if let destinationPositions = destinationPositions {
            var destinationPositionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPositions)
            for position0 in destinationPositions {
                var position0Container = destinationPositionsContainer.nestedUnkeyedContainer()
                for double1 in position0 {
                    try position0Container.encode(double1)
                }
            }
        }
        if let distanceUnit = self.distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let travelMode = self.travelMode {
            try encodeContainer.encode(travelMode.rawValue, forKey: .travelMode)
        }
        if let truckModeOptions = self.truckModeOptions {
            try encodeContainer.encode(truckModeOptions, forKey: .truckModeOptions)
        }
    }
}

extension CalculateRouteMatrixInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let calculatorName = calculatorName else {
            return nil
        }
        return "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())/calculate/route-matrix"
    }
}

public struct CalculateRouteMatrixInput: Swift.Equatable {
    /// The name of the route calculator resource that you want to use to calculate the route matrix.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// Specifies route preferences when traveling by Car, such as avoiding routes that use ferries or tolls. Requirements: TravelMode must be specified as Car.
    public var carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions?
    /// Sets the time of departure as the current time. Uses the current time to calculate the route matrix. You can't set both DepartureTime and DepartNow. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix. Default Value: false Valid Values: false | true
    public var departNow: Swift.Bool?
    /// The list of departure (origin) positions for the route matrix. An array of points, each of which is itself a 2-value array defined in [WGS 84](https://earth-info.nga.mil/GandG/wgs84/index.html) format: [longitude, latitude]. For example, [-123.115, 49.285]. Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See [ Position restrictions](https://docs.aws.amazon.com/location/latest/developerguide/calculate-route-matrix.html#matrix-routing-position-limits) in the Amazon Location Service Developer Guide. For route calculators that use Esri as the data provider, if you specify a departure that's not located on a road, Amazon Location [ moves the position to the nearest road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html). The snapped value is available in the result in SnappedDeparturePositions. Valid Values: [-180 to 180,-90 to 90]
    /// This member is required.
    public var departurePositions: [[Swift.Double]]?
    /// Specifies the desired time of departure. Uses the given time to calculate the route matrix. You can't set both DepartureTime and DepartNow. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix. Setting a departure time in the past returns a 400 ValidationException error.
    ///
    /// * In [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ. For example, 2020–07-2T12:15:20.000Z+01:00
    public var departureTime: ClientRuntime.Date?
    /// The list of destination positions for the route matrix. An array of points, each of which is itself a 2-value array defined in [WGS 84](https://earth-info.nga.mil/GandG/wgs84/index.html) format: [longitude, latitude]. For example, [-122.339, 47.615] Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See [ Position restrictions](https://docs.aws.amazon.com/location/latest/developerguide/calculate-route-matrix.html#matrix-routing-position-limits) in the Amazon Location Service Developer Guide. For route calculators that use Esri as the data provider, if you specify a destination that's not located on a road, Amazon Location [ moves the position to the nearest road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html). The snapped value is available in the result in SnappedDestinationPositions. Valid Values: [-180 to 180,-90 to 90]
    /// This member is required.
    public var destinationPositions: [[Swift.Double]]?
    /// Set the unit system to specify the distance. Default Value: Kilometers
    public var distanceUnit: LocationClientTypes.DistanceUnit?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. The TravelMode you specify also determines how you specify route preferences:
    ///
    /// * If traveling by Car use the CarModeOptions parameter.
    ///
    /// * If traveling by Truck use the TruckModeOptions parameter.
    ///
    ///
    /// Default Value: Car
    public var travelMode: LocationClientTypes.TravelMode?
    /// Specifies route preferences when traveling by Truck, such as avoiding routes that use ferries or tolls, and truck specifications to consider when choosing an optimal road. Requirements: TravelMode must be specified as Truck.
    public var truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions?

    public init (
        calculatorName: Swift.String? = nil,
        carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions? = nil,
        departNow: Swift.Bool? = nil,
        departurePositions: [[Swift.Double]]? = nil,
        departureTime: ClientRuntime.Date? = nil,
        destinationPositions: [[Swift.Double]]? = nil,
        distanceUnit: LocationClientTypes.DistanceUnit? = nil,
        travelMode: LocationClientTypes.TravelMode? = nil,
        truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions? = nil
    )
    {
        self.calculatorName = calculatorName
        self.carModeOptions = carModeOptions
        self.departNow = departNow
        self.departurePositions = departurePositions
        self.departureTime = departureTime
        self.destinationPositions = destinationPositions
        self.distanceUnit = distanceUnit
        self.travelMode = travelMode
        self.truckModeOptions = truckModeOptions
    }
}

struct CalculateRouteMatrixInputBody: Swift.Equatable {
    let departurePositions: [[Swift.Double]]?
    let destinationPositions: [[Swift.Double]]?
    let travelMode: LocationClientTypes.TravelMode?
    let departureTime: ClientRuntime.Date?
    let departNow: Swift.Bool?
    let distanceUnit: LocationClientTypes.DistanceUnit?
    let carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions?
    let truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions?
}

extension CalculateRouteMatrixInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case carModeOptions = "CarModeOptions"
        case departNow = "DepartNow"
        case departurePositions = "DeparturePositions"
        case departureTime = "DepartureTime"
        case destinationPositions = "DestinationPositions"
        case distanceUnit = "DistanceUnit"
        case travelMode = "TravelMode"
        case truckModeOptions = "TruckModeOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let departurePositionsContainer = try containerValues.decodeIfPresent([[Swift.Double?]?].self, forKey: .departurePositions)
        var departurePositionsDecoded0:[[Swift.Double]]? = nil
        if let departurePositionsContainer = departurePositionsContainer {
            departurePositionsDecoded0 = [[Swift.Double]]()
            for list0 in departurePositionsContainer {
                var list0Decoded0: [Swift.Double]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.Double]()
                    for double1 in list0 {
                        if let double1 = double1 {
                            list0Decoded0?.append(double1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    departurePositionsDecoded0?.append(list0Decoded0)
                }
            }
        }
        departurePositions = departurePositionsDecoded0
        let destinationPositionsContainer = try containerValues.decodeIfPresent([[Swift.Double?]?].self, forKey: .destinationPositions)
        var destinationPositionsDecoded0:[[Swift.Double]]? = nil
        if let destinationPositionsContainer = destinationPositionsContainer {
            destinationPositionsDecoded0 = [[Swift.Double]]()
            for list0 in destinationPositionsContainer {
                var list0Decoded0: [Swift.Double]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.Double]()
                    for double1 in list0 {
                        if let double1 = double1 {
                            list0Decoded0?.append(double1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    destinationPositionsDecoded0?.append(list0Decoded0)
                }
            }
        }
        destinationPositions = destinationPositionsDecoded0
        let travelModeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.TravelMode.self, forKey: .travelMode)
        travelMode = travelModeDecoded
        let departureTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .departureTime)
        departureTime = departureTimeDecoded
        let departNowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .departNow)
        departNow = departNowDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let carModeOptionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.CalculateRouteCarModeOptions.self, forKey: .carModeOptions)
        carModeOptions = carModeOptionsDecoded
        let truckModeOptionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.CalculateRouteTruckModeOptions.self, forKey: .truckModeOptions)
        truckModeOptions = truckModeOptionsDecoded
    }
}

extension CalculateRouteMatrixOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CalculateRouteMatrixOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CalculateRouteMatrixOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CalculateRouteMatrixOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CalculateRouteMatrixOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.routeMatrix = output.routeMatrix
            self.snappedDeparturePositions = output.snappedDeparturePositions
            self.snappedDestinationPositions = output.snappedDestinationPositions
            self.summary = output.summary
        } else {
            self.routeMatrix = nil
            self.snappedDeparturePositions = nil
            self.snappedDestinationPositions = nil
            self.summary = nil
        }
    }
}

/// Returns the result of the route matrix calculation.
public struct CalculateRouteMatrixOutputResponse: Swift.Equatable {
    /// The calculated route matrix containing the results for all pairs of DeparturePositions to DestinationPositions. Each row corresponds to one entry in DeparturePositions. Each entry in the row corresponds to the route from that entry in DeparturePositions to an entry in DestinationPositions.
    /// This member is required.
    public var routeMatrix: [[LocationClientTypes.RouteMatrixEntry]]?
    /// For routes calculated using an Esri route calculator resource, departure positions are snapped to the closest road. For Esri route calculator resources, this returns the list of departure/origin positions used for calculation of the RouteMatrix.
    public var snappedDeparturePositions: [[Swift.Double]]?
    /// The list of destination positions for the route matrix used for calculation of the RouteMatrix.
    public var snappedDestinationPositions: [[Swift.Double]]?
    /// Contains information about the route matrix, DataSource, DistanceUnit, RouteCount and ErrorCount.
    /// This member is required.
    public var summary: LocationClientTypes.CalculateRouteMatrixSummary?

    public init (
        routeMatrix: [[LocationClientTypes.RouteMatrixEntry]]? = nil,
        snappedDeparturePositions: [[Swift.Double]]? = nil,
        snappedDestinationPositions: [[Swift.Double]]? = nil,
        summary: LocationClientTypes.CalculateRouteMatrixSummary? = nil
    )
    {
        self.routeMatrix = routeMatrix
        self.snappedDeparturePositions = snappedDeparturePositions
        self.snappedDestinationPositions = snappedDestinationPositions
        self.summary = summary
    }
}

struct CalculateRouteMatrixOutputResponseBody: Swift.Equatable {
    let routeMatrix: [[LocationClientTypes.RouteMatrixEntry]]?
    let snappedDeparturePositions: [[Swift.Double]]?
    let snappedDestinationPositions: [[Swift.Double]]?
    let summary: LocationClientTypes.CalculateRouteMatrixSummary?
}

extension CalculateRouteMatrixOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routeMatrix = "RouteMatrix"
        case snappedDeparturePositions = "SnappedDeparturePositions"
        case snappedDestinationPositions = "SnappedDestinationPositions"
        case summary = "Summary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeMatrixContainer = try containerValues.decodeIfPresent([[LocationClientTypes.RouteMatrixEntry?]?].self, forKey: .routeMatrix)
        var routeMatrixDecoded0:[[LocationClientTypes.RouteMatrixEntry]]? = nil
        if let routeMatrixContainer = routeMatrixContainer {
            routeMatrixDecoded0 = [[LocationClientTypes.RouteMatrixEntry]]()
            for list0 in routeMatrixContainer {
                var list0Decoded0: [LocationClientTypes.RouteMatrixEntry]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [LocationClientTypes.RouteMatrixEntry]()
                    for structure1 in list0 {
                        if let structure1 = structure1 {
                            list0Decoded0?.append(structure1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    routeMatrixDecoded0?.append(list0Decoded0)
                }
            }
        }
        routeMatrix = routeMatrixDecoded0
        let snappedDeparturePositionsContainer = try containerValues.decodeIfPresent([[Swift.Double?]?].self, forKey: .snappedDeparturePositions)
        var snappedDeparturePositionsDecoded0:[[Swift.Double]]? = nil
        if let snappedDeparturePositionsContainer = snappedDeparturePositionsContainer {
            snappedDeparturePositionsDecoded0 = [[Swift.Double]]()
            for list0 in snappedDeparturePositionsContainer {
                var list0Decoded0: [Swift.Double]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.Double]()
                    for double1 in list0 {
                        if let double1 = double1 {
                            list0Decoded0?.append(double1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    snappedDeparturePositionsDecoded0?.append(list0Decoded0)
                }
            }
        }
        snappedDeparturePositions = snappedDeparturePositionsDecoded0
        let snappedDestinationPositionsContainer = try containerValues.decodeIfPresent([[Swift.Double?]?].self, forKey: .snappedDestinationPositions)
        var snappedDestinationPositionsDecoded0:[[Swift.Double]]? = nil
        if let snappedDestinationPositionsContainer = snappedDestinationPositionsContainer {
            snappedDestinationPositionsDecoded0 = [[Swift.Double]]()
            for list0 in snappedDestinationPositionsContainer {
                var list0Decoded0: [Swift.Double]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.Double]()
                    for double1 in list0 {
                        if let double1 = double1 {
                            list0Decoded0?.append(double1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    snappedDestinationPositionsDecoded0?.append(list0Decoded0)
                }
            }
        }
        snappedDestinationPositions = snappedDestinationPositionsDecoded0
        let summaryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.CalculateRouteMatrixSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension LocationClientTypes.CalculateRouteMatrixSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case distanceUnit = "DistanceUnit"
        case errorCount = "ErrorCount"
        case routeCount = "RouteCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let distanceUnit = self.distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let errorCount = self.errorCount {
            try encodeContainer.encode(errorCount, forKey: .errorCount)
        }
        if let routeCount = self.routeCount {
            try encodeContainer.encode(routeCount, forKey: .routeCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let routeCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .routeCount)
        routeCount = routeCountDecoded
        let errorCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorCount)
        errorCount = errorCountDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
    }
}

extension LocationClientTypes {
    /// A summary of the calculated route matrix.
    public struct CalculateRouteMatrixSummary: Swift.Equatable {
        /// The data provider of traffic and road network data used to calculate the routes. Indicates one of the available providers:
        ///
        /// * Esri
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// The unit of measurement for route distances.
        /// This member is required.
        public var distanceUnit: LocationClientTypes.DistanceUnit?
        /// The count of error results in the route matrix. If this number is 0, all routes were calculated successfully.
        /// This member is required.
        public var errorCount: Swift.Int?
        /// The count of cells in the route matrix. Equal to the number of DeparturePositions multiplied by the number of DestinationPositions.
        /// This member is required.
        public var routeCount: Swift.Int?

        public init (
            dataSource: Swift.String? = nil,
            distanceUnit: LocationClientTypes.DistanceUnit? = nil,
            errorCount: Swift.Int? = nil,
            routeCount: Swift.Int? = nil
        )
        {
            self.dataSource = dataSource
            self.distanceUnit = distanceUnit
            self.errorCount = errorCount
            self.routeCount = routeCount
        }
    }

}

extension CalculateRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CalculateRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CalculateRouteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CalculateRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CalculateRouteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.legs = output.legs
            self.summary = output.summary
        } else {
            self.legs = nil
            self.summary = nil
        }
    }
}

/// Returns the result of the route calculation. Metadata includes legs and route summary.
public struct CalculateRouteOutputResponse: Swift.Equatable {
    /// Contains details about each path between a pair of positions included along a route such as: StartPosition, EndPosition, Distance, DurationSeconds, Geometry, and Steps. The number of legs returned corresponds to one fewer than the total number of positions in the request. For example, a route with a departure position and destination position returns one leg with the positions [snapped to a nearby road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html):
    ///
    /// * The StartPosition is the departure position.
    ///
    /// * The EndPosition is the destination position.
    ///
    ///
    /// A route with a waypoint between the departure and destination position returns two legs with the positions snapped to a nearby road:
    ///
    /// * Leg 1: The StartPosition is the departure position . The EndPosition is the waypoint positon.
    ///
    /// * Leg 2: The StartPosition is the waypoint position. The EndPosition is the destination position.
    /// This member is required.
    public var legs: [LocationClientTypes.Leg]?
    /// Contains information about the whole route, such as: RouteBBox, DataSource, Distance, DistanceUnit, and DurationSeconds.
    /// This member is required.
    public var summary: LocationClientTypes.CalculateRouteSummary?

    public init (
        legs: [LocationClientTypes.Leg]? = nil,
        summary: LocationClientTypes.CalculateRouteSummary? = nil
    )
    {
        self.legs = legs
        self.summary = summary
    }
}

struct CalculateRouteOutputResponseBody: Swift.Equatable {
    let legs: [LocationClientTypes.Leg]?
    let summary: LocationClientTypes.CalculateRouteSummary?
}

extension CalculateRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case legs = "Legs"
        case summary = "Summary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let legsContainer = try containerValues.decodeIfPresent([LocationClientTypes.Leg?].self, forKey: .legs)
        var legsDecoded0:[LocationClientTypes.Leg]? = nil
        if let legsContainer = legsContainer {
            legsDecoded0 = [LocationClientTypes.Leg]()
            for structure0 in legsContainer {
                if let structure0 = structure0 {
                    legsDecoded0?.append(structure0)
                }
            }
        }
        legs = legsDecoded0
        let summaryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.CalculateRouteSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension LocationClientTypes.CalculateRouteSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case distance = "Distance"
        case distanceUnit = "DistanceUnit"
        case durationSeconds = "DurationSeconds"
        case routeBBox = "RouteBBox"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let distance = self.distance {
            try encodeContainer.encode(distance, forKey: .distance)
        }
        if let distanceUnit = self.distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let routeBBox = routeBBox {
            var routeBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routeBBox)
            for double0 in routeBBox {
                try routeBBoxContainer.encode(double0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .routeBBox)
        var routeBBoxDecoded0:[Swift.Double]? = nil
        if let routeBBoxContainer = routeBBoxContainer {
            routeBBoxDecoded0 = [Swift.Double]()
            for double0 in routeBBoxContainer {
                if let double0 = double0 {
                    routeBBoxDecoded0?.append(double0)
                }
            }
        }
        routeBBox = routeBBoxDecoded0
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let distanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .distance)
        distance = distanceDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
    }
}

extension LocationClientTypes.CalculateRouteSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRouteSummary(dataSource: \(Swift.String(describing: dataSource)), distance: \(Swift.String(describing: distance)), distanceUnit: \(Swift.String(describing: distanceUnit)), durationSeconds: \(Swift.String(describing: durationSeconds)), routeBBox: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// A summary of the calculated route.
    public struct CalculateRouteSummary: Swift.Equatable {
        /// The data provider of traffic and road network data used to calculate the route. Indicates one of the available providers:
        ///
        /// * Esri
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// The total distance covered by the route. The sum of the distance travelled between every stop on the route. If Esri is the data source for the route calculator, the route distance can’t be greater than 400 km. If the route exceeds 400 km, the response is a 400 RoutesValidationException error.
        /// This member is required.
        public var distance: Swift.Double?
        /// The unit of measurement for route distances.
        /// This member is required.
        public var distanceUnit: LocationClientTypes.DistanceUnit?
        /// The total travel time for the route measured in seconds. The sum of the travel time between every stop on the route.
        /// This member is required.
        public var durationSeconds: Swift.Double?
        /// Specifies a geographical box surrounding a route. Used to zoom into a route when displaying it in a map. For example, [min x, min y, max x, max y]. The first 2 bbox parameters describe the lower southwest corner:
        ///
        /// * The first bbox position is the X coordinate or longitude of the lower southwest corner.
        ///
        /// * The second bbox position is the Y coordinate or latitude of the lower southwest corner.
        ///
        ///
        /// The next 2 bbox parameters describe the upper northeast corner:
        ///
        /// * The third bbox position is the X coordinate, or longitude of the upper northeast corner.
        ///
        /// * The fourth bbox position is the Y coordinate, or latitude of the upper northeast corner.
        /// This member is required.
        public var routeBBox: [Swift.Double]?

        public init (
            dataSource: Swift.String? = nil,
            distance: Swift.Double? = nil,
            distanceUnit: LocationClientTypes.DistanceUnit? = nil,
            durationSeconds: Swift.Double? = nil,
            routeBBox: [Swift.Double]? = nil
        )
        {
            self.dataSource = dataSource
            self.distance = distance
            self.distanceUnit = distanceUnit
            self.durationSeconds = durationSeconds
            self.routeBBox = routeBBox
        }
    }

}

extension LocationClientTypes.CalculateRouteTruckModeOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avoidFerries = "AvoidFerries"
        case avoidTolls = "AvoidTolls"
        case dimensions = "Dimensions"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let avoidFerries = self.avoidFerries {
            try encodeContainer.encode(avoidFerries, forKey: .avoidFerries)
        }
        if let avoidTolls = self.avoidTolls {
            try encodeContainer.encode(avoidTolls, forKey: .avoidTolls)
        }
        if let dimensions = self.dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
        if let weight = self.weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let avoidFerriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .avoidFerries)
        avoidFerries = avoidFerriesDecoded
        let avoidTollsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .avoidTolls)
        avoidTolls = avoidTollsDecoded
        let dimensionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.TruckDimensions.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let weightDecoded = try containerValues.decodeIfPresent(LocationClientTypes.TruckWeight.self, forKey: .weight)
        weight = weightDecoded
    }
}

extension LocationClientTypes {
    /// Contains details about additional route preferences for requests that specify TravelMode as Truck.
    public struct CalculateRouteTruckModeOptions: Swift.Equatable {
        /// Avoids ferries when calculating routes. Default Value: false Valid Values: false | true
        public var avoidFerries: Swift.Bool?
        /// Avoids tolls when calculating routes. Default Value: false Valid Values: false | true
        public var avoidTolls: Swift.Bool?
        /// Specifies the truck's dimension specifications including length, height, width, and unit of measurement. Used to avoid roads that can't support the truck's dimensions.
        public var dimensions: LocationClientTypes.TruckDimensions?
        /// Specifies the truck's weight specifications including total weight and unit of measurement. Used to avoid roads that can't support the truck's weight.
        public var weight: LocationClientTypes.TruckWeight?

        public init (
            avoidFerries: Swift.Bool? = nil,
            avoidTolls: Swift.Bool? = nil,
            dimensions: LocationClientTypes.TruckDimensions? = nil,
            weight: LocationClientTypes.TruckWeight? = nil
        )
        {
            self.avoidFerries = avoidFerries
            self.avoidTolls = avoidTolls
            self.dimensions = dimensions
            self.weight = weight
        }
    }

}

extension LocationClientTypes.Circle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case center = "Center"
        case radius = "Radius"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let center = center {
            var centerContainer = encodeContainer.nestedUnkeyedContainer(forKey: .center)
            for double0 in center {
                try centerContainer.encode(double0)
            }
        }
        if let radius = self.radius {
            try encodeContainer.encode(radius, forKey: .radius)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let centerContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .center)
        var centerDecoded0:[Swift.Double]? = nil
        if let centerContainer = centerContainer {
            centerDecoded0 = [Swift.Double]()
            for double0 in centerContainer {
                if let double0 = double0 {
                    centerDecoded0?.append(double0)
                }
            }
        }
        center = centerDecoded0
        let radiusDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .radius)
        radius = radiusDecoded
    }
}

extension LocationClientTypes.Circle: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension LocationClientTypes {
    /// A circle on the earth, as defined by a center point and a radius.
    public struct Circle: Swift.Equatable {
        /// A single point geometry, specifying the center of the circle, using [WGS 84](https://gisgeography.com/wgs84-world-geodetic-system/) coordinates, in the form [longitude, latitude].
        /// This member is required.
        public var center: [Swift.Double]?
        /// The radius of the circle in meters. Must be greater than zero and no larger than 100,000 (100 kilometers).
        /// This member is required.
        public var radius: Swift.Double?

        public init (
            center: [Swift.Double]? = nil,
            radius: Swift.Double? = nil
        )
        {
            self.center = center
            self.radius = radius
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was unsuccessful because of a conflict.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateGeofenceCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionName = "CollectionName"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectionName = self.collectionName {
            try encodeContainer.encode(collectionName, forKey: .collectionName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = self.pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateGeofenceCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/geofencing/v0/collections"
    }
}

public struct CreateGeofenceCollectionInput: Swift.Equatable {
    /// A custom name for the geofence collection. Requirements:
    ///
    /// * Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique geofence collection name.
    ///
    /// * No spaces allowed. For example, ExampleGeofenceCollection.
    /// This member is required.
    public var collectionName: Swift.String?
    /// An optional description for the geofence collection.
    public var description: Swift.String?
    /// A key identifier for an [AWS KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html). Enter a key ID, key ARN, alias name, or alias ARN.
    public var kmsKeyId: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// This parameter is no longer used.
    @available(*, deprecated, message: "Deprecated. No longer allowed. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?
    /// Applies one or more tags to the geofence collection. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource
    ///
    /// * Each resource tag must be unique with a maximum of one value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?

    public init (
        collectionName: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.collectionName = collectionName
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
    }
}

struct CreateGeofenceCollectionInputBody: Swift.Equatable {
    let collectionName: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let pricingPlanDataSource: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let kmsKeyId: Swift.String?
}

extension CreateGeofenceCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionName = "CollectionName"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension CreateGeofenceCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGeofenceCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGeofenceCollectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGeofenceCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateGeofenceCollectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.collectionArn = output.collectionArn
            self.collectionName = output.collectionName
            self.createTime = output.createTime
        } else {
            self.collectionArn = nil
            self.collectionName = nil
            self.createTime = nil
        }
    }
}

public struct CreateGeofenceCollectionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you need to specify a resource across all AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
    /// This member is required.
    public var collectionArn: Swift.String?
    /// The name for the geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The timestamp for when the geofence collection was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var createTime: ClientRuntime.Date?

    public init (
        collectionArn: Swift.String? = nil,
        collectionName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil
    )
    {
        self.collectionArn = collectionArn
        self.collectionName = collectionName
        self.createTime = createTime
    }
}

struct CreateGeofenceCollectionOutputResponseBody: Swift.Equatable {
    let collectionName: Swift.String?
    let collectionArn: Swift.String?
    let createTime: ClientRuntime.Date?
}

extension CreateGeofenceCollectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionArn = "CollectionArn"
        case collectionName = "CollectionName"
        case createTime = "CreateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let collectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionArn)
        collectionArn = collectionArnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

extension CreateMapInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case mapName = "MapName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mapName = self.mapName {
            try encodeContainer.encode(mapName, forKey: .mapName)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateMapInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/maps/v0/maps"
    }
}

public struct CreateMapInput: Swift.Equatable {
    /// Specifies the MapConfiguration, including the map style, for the map resource that you create. The map style defines the look of maps and the data provider for your map resource.
    /// This member is required.
    public var configuration: LocationClientTypes.MapConfiguration?
    /// An optional description for the map resource.
    public var description: Swift.String?
    /// The name for the map resource. Requirements:
    ///
    /// * Must contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique map resource name.
    ///
    /// * No spaces allowed. For example, ExampleMap.
    /// This member is required.
    public var mapName: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Applies one or more tags to the map resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource
    ///
    /// * Each resource tag must be unique with a maximum of one value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?

    public init (
        configuration: LocationClientTypes.MapConfiguration? = nil,
        description: Swift.String? = nil,
        mapName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.configuration = configuration
        self.description = description
        self.mapName = mapName
        self.pricingPlan = pricingPlan
        self.tags = tags
    }
}

struct CreateMapInputBody: Swift.Equatable {
    let mapName: Swift.String?
    let configuration: LocationClientTypes.MapConfiguration?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateMapInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case mapName = "MapName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapName)
        mapName = mapNameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(LocationClientTypes.MapConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMapOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMapOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateMapOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMapOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateMapOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.mapArn = output.mapArn
            self.mapName = output.mapName
        } else {
            self.createTime = nil
            self.mapArn = nil
            self.mapName = nil
        }
    }
}

public struct CreateMapOutputResponse: Swift.Equatable {
    /// The timestamp for when the map resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the map resource. Used to specify a resource across all AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:map/ExampleMap
    /// This member is required.
    public var mapArn: Swift.String?
    /// The name of the map resource.
    /// This member is required.
    public var mapName: Swift.String?

    public init (
        createTime: ClientRuntime.Date? = nil,
        mapArn: Swift.String? = nil,
        mapName: Swift.String? = nil
    )
    {
        self.createTime = createTime
        self.mapArn = mapArn
        self.mapName = mapName
    }
}

struct CreateMapOutputResponseBody: Swift.Equatable {
    let mapName: Swift.String?
    let mapArn: Swift.String?
    let createTime: ClientRuntime.Date?
}

extension CreateMapOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case mapArn = "MapArn"
        case mapName = "MapName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapName)
        mapName = mapNameDecoded
        let mapArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapArn)
        mapArn = mapArnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

extension CreatePlaceIndexInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case dataSourceConfiguration = "DataSourceConfiguration"
        case description = "Description"
        case indexName = "IndexName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let dataSourceConfiguration = self.dataSourceConfiguration {
            try encodeContainer.encode(dataSourceConfiguration, forKey: .dataSourceConfiguration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePlaceIndexInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/places/v0/indexes"
    }
}

public struct CreatePlaceIndexInput: Swift.Equatable {
    /// Specifies the geospatial data provider for the new place index. This field is case-sensitive. Enter the valid values as shown. For example, entering HERE returns an error. Valid values include:
    ///
    /// * Esri – For additional information about [Esri](https://docs.aws.amazon.com/location/latest/developerguide/esri.html)'s coverage in your region of interest, see [Esri details on geocoding coverage](https://developers.arcgis.com/rest/geocode/api-reference/geocode-coverage.htm).
    ///
    /// * Here – For additional information about [HERE Technologies](https://docs.aws.amazon.com/location/latest/developerguide/HERE.html)' coverage in your region of interest, see [HERE details on goecoding coverage](https://developer.here.com/documentation/geocoder/dev_guide/topics/coverage-geocoder.html). If you specify HERE Technologies (Here) as the data provider, you may not [store results](https://docs.aws.amazon.com/location-places/latest/APIReference/API_DataSourceConfiguration.html) for locations in Japan. For more information, see the [AWS Service Terms](https://aws.amazon.com/service-terms/) for Amazon Location Service.
    ///
    ///
    /// For additional information , see [Data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html) on the Amazon Location Service Developer Guide.
    /// This member is required.
    public var dataSource: Swift.String?
    /// Specifies the data storage option requesting Places.
    public var dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    /// The optional description for the place index resource.
    public var description: Swift.String?
    /// The name of the place index resource. Requirements:
    ///
    /// * Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique place index resource name.
    ///
    /// * No spaces allowed. For example, ExamplePlaceIndex.
    /// This member is required.
    public var indexName: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Applies one or more tags to the place index resource. A tag is a key-value pair that helps you manage, identify, search, and filter your resources. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource.
    ///
    /// * Each tag key must be unique and must have exactly one associated value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?

    public init (
        dataSource: Swift.String? = nil,
        dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        indexName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dataSource = dataSource
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.indexName = indexName
        self.pricingPlan = pricingPlan
        self.tags = tags
    }
}

struct CreatePlaceIndexInputBody: Swift.Equatable {
    let indexName: Swift.String?
    let dataSource: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
    let dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    let tags: [Swift.String:Swift.String]?
}

extension CreatePlaceIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case dataSourceConfiguration = "DataSourceConfiguration"
        case description = "Description"
        case indexName = "IndexName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePlaceIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePlaceIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePlaceIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePlaceIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePlaceIndexOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.indexArn = output.indexArn
            self.indexName = output.indexName
        } else {
            self.createTime = nil
            self.indexArn = nil
            self.indexName = nil
        }
    }
}

public struct CreatePlaceIndexOutputResponse: Swift.Equatable {
    /// The timestamp for when the place index resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the place index resource. Used to specify a resource across AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:place-index/ExamplePlaceIndex
    /// This member is required.
    public var indexArn: Swift.String?
    /// The name for the place index resource.
    /// This member is required.
    public var indexName: Swift.String?

    public init (
        createTime: ClientRuntime.Date? = nil,
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil
    )
    {
        self.createTime = createTime
        self.indexArn = indexArn
        self.indexName = indexName
    }
}

struct CreatePlaceIndexOutputResponseBody: Swift.Equatable {
    let indexName: Swift.String?
    let indexArn: Swift.String?
    let createTime: ClientRuntime.Date?
}

extension CreatePlaceIndexOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case indexArn = "IndexArn"
        case indexName = "IndexName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let indexArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexArn)
        indexArn = indexArnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

extension CreateRouteCalculatorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorName = "CalculatorName"
        case dataSource = "DataSource"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculatorName = self.calculatorName {
            try encodeContainer.encode(calculatorName, forKey: .calculatorName)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRouteCalculatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/routes/v0/calculators"
    }
}

public struct CreateRouteCalculatorInput: Swift.Equatable {
    /// The name of the route calculator resource. Requirements:
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9) , hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique Route calculator resource name.
    ///
    /// * No spaces allowed. For example, ExampleRouteCalculator.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// Specifies the data provider of traffic and road network data. This field is case-sensitive. Enter the valid values as shown. For example, entering HERE returns an error. Route calculators that use Esri as a data source only calculate routes that are shorter than 400 km. Valid values include:
    ///
    /// * Esri – For additional information about [Esri](https://docs.aws.amazon.com/location/latest/developerguide/esri.html)'s coverage in your region of interest, see [Esri details on street networks and traffic coverage](https://doc.arcgis.com/en/arcgis-online/reference/network-coverage.htm).
    ///
    /// * Here – For additional information about [HERE Technologies](https://docs.aws.amazon.com/location/latest/developerguide/HERE.html)' coverage in your region of interest, see [HERE car routing coverage](https://developer.here.com/documentation/routing-api/dev_guide/topics/coverage/car-routing.html) and [HERE truck routing coverage](https://developer.here.com/documentation/routing-api/dev_guide/topics/coverage/truck-routing.html).
    ///
    ///
    /// For additional information , see [Data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html) on the Amazon Location Service Developer Guide.
    /// This member is required.
    public var dataSource: Swift.String?
    /// The optional description for the route calculator resource.
    public var description: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Applies one or more tags to the route calculator resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them.
    ///
    /// * For example: { "tag1" : "value1", "tag2" : "value2"}
    ///
    ///
    /// Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource
    ///
    /// * Each resource tag must be unique with a maximum of one value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?

    public init (
        calculatorName: Swift.String? = nil,
        dataSource: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.calculatorName = calculatorName
        self.dataSource = dataSource
        self.description = description
        self.pricingPlan = pricingPlan
        self.tags = tags
    }
}

struct CreateRouteCalculatorInputBody: Swift.Equatable {
    let calculatorName: Swift.String?
    let dataSource: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRouteCalculatorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorName = "CalculatorName"
        case dataSource = "DataSource"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorName)
        calculatorName = calculatorNameDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRouteCalculatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRouteCalculatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRouteCalculatorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRouteCalculatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRouteCalculatorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.calculatorArn = output.calculatorArn
            self.calculatorName = output.calculatorName
            self.createTime = output.createTime
        } else {
            self.calculatorArn = nil
            self.calculatorName = nil
            self.createTime = nil
        }
    }
}

public struct CreateRouteCalculatorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the route calculator resource. Use the ARN when you specify a resource across all AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:route-calculator/ExampleCalculator
    /// This member is required.
    public var calculatorArn: Swift.String?
    /// The name of the route calculator resource.
    ///
    /// * For example, ExampleRouteCalculator.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// The timestamp when the route calculator resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    ///
    /// * For example, 2020–07-2T12:15:20.000Z+01:00
    /// This member is required.
    public var createTime: ClientRuntime.Date?

    public init (
        calculatorArn: Swift.String? = nil,
        calculatorName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil
    )
    {
        self.calculatorArn = calculatorArn
        self.calculatorName = calculatorName
        self.createTime = createTime
    }
}

struct CreateRouteCalculatorOutputResponseBody: Swift.Equatable {
    let calculatorName: Swift.String?
    let calculatorArn: Swift.String?
    let createTime: ClientRuntime.Date?
}

extension CreateRouteCalculatorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorArn = "CalculatorArn"
        case calculatorName = "CalculatorName"
        case createTime = "CreateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorName)
        calculatorName = calculatorNameDecoded
        let calculatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorArn)
        calculatorArn = calculatorArnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

extension CreateTrackerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case positionFiltering = "PositionFiltering"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
        case trackerName = "TrackerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let positionFiltering = self.positionFiltering {
            try encodeContainer.encode(positionFiltering.rawValue, forKey: .positionFiltering)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = self.pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let trackerName = self.trackerName {
            try encodeContainer.encode(trackerName, forKey: .trackerName)
        }
    }
}

extension CreateTrackerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tracking/v0/trackers"
    }
}

public struct CreateTrackerInput: Swift.Equatable {
    /// An optional description for the tracker resource.
    public var description: Swift.String?
    /// A key identifier for an [AWS KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html). Enter a key ID, key ARN, alias name, or alias ARN.
    public var kmsKeyId: Swift.String?
    /// Specifies the position filtering for the tracker resource. Valid values:
    ///
    /// * TimeBased - Location updates are evaluated against linked geofence collections, but not every location update is stored. If your update frequency is more often than 30 seconds, only one update per 30 seconds is stored for each unique device ID.
    ///
    /// * DistanceBased - If the device has moved less than 30 m (98.4 ft), location updates are ignored. Location updates within this area are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map.
    ///
    /// * AccuracyBased - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This can reduce the effects of GPS noise when displaying device trajectories on a map, and can help control your costs by reducing the number of geofence evaluations.
    ///
    ///
    /// This field is optional. If not specified, the default value is TimeBased.
    public var positionFiltering: LocationClientTypes.PositionFiltering?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// This parameter is no longer used.
    @available(*, deprecated, message: "Deprecated. No longer allowed. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?
    /// Applies one or more tags to the tracker resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource
    ///
    /// * Each resource tag must be unique with a maximum of one value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?
    /// The name for the tracker resource. Requirements:
    ///
    /// * Contain only alphanumeric characters (A-Z, a-z, 0-9) , hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique tracker resource name.
    ///
    /// * No spaces allowed. For example, ExampleTracker.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        positionFiltering: LocationClientTypes.PositionFiltering? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.positionFiltering = positionFiltering
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
        self.trackerName = trackerName
    }
}

struct CreateTrackerInputBody: Swift.Equatable {
    let trackerName: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let kmsKeyId: Swift.String?
    let pricingPlanDataSource: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let positionFiltering: LocationClientTypes.PositionFiltering?
}

extension CreateTrackerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case positionFiltering = "PositionFiltering"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
        case trackerName = "TrackerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let positionFilteringDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PositionFiltering.self, forKey: .positionFiltering)
        positionFiltering = positionFilteringDecoded
    }
}

extension CreateTrackerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTrackerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTrackerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTrackerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTrackerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.trackerArn = output.trackerArn
            self.trackerName = output.trackerName
        } else {
            self.createTime = nil
            self.trackerArn = nil
            self.trackerName = nil
        }
    }
}

public struct CreateTrackerOutputResponse: Swift.Equatable {
    /// The timestamp for when the tracker resource was created in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify a resource across all AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
    /// This member is required.
    public var trackerArn: Swift.String?
    /// The name of the tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        createTime: ClientRuntime.Date? = nil,
        trackerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.createTime = createTime
        self.trackerArn = trackerArn
        self.trackerName = trackerName
    }
}

struct CreateTrackerOutputResponseBody: Swift.Equatable {
    let trackerName: Swift.String?
    let trackerArn: Swift.String?
    let createTime: ClientRuntime.Date?
}

extension CreateTrackerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case trackerArn = "TrackerArn"
        case trackerName = "TrackerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let trackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerArn)
        trackerArn = trackerArnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

extension LocationClientTypes.DataSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intendedUse = "IntendedUse"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intendedUse = self.intendedUse {
            try encodeContainer.encode(intendedUse.rawValue, forKey: .intendedUse)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intendedUseDecoded = try containerValues.decodeIfPresent(LocationClientTypes.IntendedUse.self, forKey: .intendedUse)
        intendedUse = intendedUseDecoded
    }
}

extension LocationClientTypes {
    /// Specifies the data storage option chosen for requesting Places. When using Amazon Location Places:
    ///
    /// * If using HERE Technologies as a data provider, you can't store results for locations in Japan by setting IntendedUse to Storage. parameter.
    ///
    /// * Under the MobileAssetTracking or MobilAssetManagement pricing plan, you can't store results from your place index resources by setting IntendedUse to Storage. This returns a validation exception error.
    ///
    ///
    /// For more information, see the [AWS Service Terms](https://aws.amazon.com/service-terms/) for Amazon Location Service.
    public struct DataSourceConfiguration: Swift.Equatable {
        /// Specifies how the results of an operation will be stored by the caller. Valid values include:
        ///
        /// * SingleUse specifies that the results won't be stored.
        ///
        /// * Storage specifies that the result can be cached or stored in a database.
        ///
        ///
        /// Default value: SingleUse
        public var intendedUse: LocationClientTypes.IntendedUse?

        public init (
            intendedUse: LocationClientTypes.IntendedUse? = nil
        )
        {
            self.intendedUse = intendedUse
        }
    }

}

extension DeleteGeofenceCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collectionName = collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())"
    }
}

public struct DeleteGeofenceCollectionInput: Swift.Equatable {
    /// The name of the geofence collection to be deleted.
    /// This member is required.
    public var collectionName: Swift.String?

    public init (
        collectionName: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
    }
}

struct DeleteGeofenceCollectionInputBody: Swift.Equatable {
}

extension DeleteGeofenceCollectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGeofenceCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGeofenceCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGeofenceCollectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGeofenceCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGeofenceCollectionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteMapInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mapName = mapName else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())"
    }
}

public struct DeleteMapInput: Swift.Equatable {
    /// The name of the map resource to be deleted.
    /// This member is required.
    public var mapName: Swift.String?

    public init (
        mapName: Swift.String? = nil
    )
    {
        self.mapName = mapName
    }
}

struct DeleteMapInputBody: Swift.Equatable {
}

extension DeleteMapInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMapOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMapOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMapOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMapOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMapOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePlaceIndexInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let indexName = indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())"
    }
}

public struct DeletePlaceIndexInput: Swift.Equatable {
    /// The name of the place index resource to be deleted.
    /// This member is required.
    public var indexName: Swift.String?

    public init (
        indexName: Swift.String? = nil
    )
    {
        self.indexName = indexName
    }
}

struct DeletePlaceIndexInputBody: Swift.Equatable {
}

extension DeletePlaceIndexInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePlaceIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePlaceIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePlaceIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePlaceIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePlaceIndexOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRouteCalculatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let calculatorName = calculatorName else {
            return nil
        }
        return "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())"
    }
}

public struct DeleteRouteCalculatorInput: Swift.Equatable {
    /// The name of the route calculator resource to be deleted.
    /// This member is required.
    public var calculatorName: Swift.String?

    public init (
        calculatorName: Swift.String? = nil
    )
    {
        self.calculatorName = calculatorName
    }
}

struct DeleteRouteCalculatorInputBody: Swift.Equatable {
}

extension DeleteRouteCalculatorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRouteCalculatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRouteCalculatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRouteCalculatorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRouteCalculatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRouteCalculatorOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteTrackerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trackerName = trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())"
    }
}

public struct DeleteTrackerInput: Swift.Equatable {
    /// The name of the tracker resource to be deleted.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        trackerName: Swift.String? = nil
    )
    {
        self.trackerName = trackerName
    }
}

struct DeleteTrackerInputBody: Swift.Equatable {
}

extension DeleteTrackerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTrackerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTrackerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTrackerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTrackerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTrackerOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeGeofenceCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collectionName = collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())"
    }
}

public struct DescribeGeofenceCollectionInput: Swift.Equatable {
    /// The name of the geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?

    public init (
        collectionName: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
    }
}

struct DescribeGeofenceCollectionInputBody: Swift.Equatable {
}

extension DescribeGeofenceCollectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGeofenceCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGeofenceCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeGeofenceCollectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGeofenceCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeGeofenceCollectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.collectionArn = output.collectionArn
            self.collectionName = output.collectionName
            self.createTime = output.createTime
            self.description = output.description
            self.kmsKeyId = output.kmsKeyId
            self.pricingPlan = output.pricingPlan
            self.pricingPlanDataSource = output.pricingPlanDataSource
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.collectionArn = nil
            self.collectionName = nil
            self.createTime = nil
            self.description = nil
            self.kmsKeyId = nil
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct DescribeGeofenceCollectionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you need to specify a resource across all AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
    /// This member is required.
    public var collectionArn: Swift.String?
    /// The name of the geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The timestamp for when the geofence resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The optional description for the geofence collection.
    /// This member is required.
    public var description: Swift.String?
    /// A key identifier for an [AWS KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html) assigned to the Amazon Location resource
    public var kmsKeyId: Swift.String?
    /// No longer used. Always returns RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// No longer used. Always returns an empty string.
    @available(*, deprecated, message: "Deprecated. Unused. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?
    /// Displays the key, value pairs of tags associated with this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp for when the geofence collection was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        collectionArn: Swift.String? = nil,
        collectionName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.collectionArn = collectionArn
        self.collectionName = collectionName
        self.createTime = createTime
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct DescribeGeofenceCollectionOutputResponseBody: Swift.Equatable {
    let collectionName: Swift.String?
    let collectionArn: Swift.String?
    let description: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let pricingPlanDataSource: Swift.String?
    let kmsKeyId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
}

extension DescribeGeofenceCollectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionArn = "CollectionArn"
        case collectionName = "CollectionName"
        case createTime = "CreateTime"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let collectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionArn)
        collectionArn = collectionArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension DescribeMapInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mapName = mapName else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())"
    }
}

public struct DescribeMapInput: Swift.Equatable {
    /// The name of the map resource.
    /// This member is required.
    public var mapName: Swift.String?

    public init (
        mapName: Swift.String? = nil
    )
    {
        self.mapName = mapName
    }
}

struct DescribeMapInputBody: Swift.Equatable {
}

extension DescribeMapInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeMapOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMapOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeMapOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMapOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeMapOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configuration = output.configuration
            self.createTime = output.createTime
            self.dataSource = output.dataSource
            self.description = output.description
            self.mapArn = output.mapArn
            self.mapName = output.mapName
            self.pricingPlan = output.pricingPlan
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.configuration = nil
            self.createTime = nil
            self.dataSource = nil
            self.description = nil
            self.mapArn = nil
            self.mapName = nil
            self.pricingPlan = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct DescribeMapOutputResponse: Swift.Equatable {
    /// Specifies the map tile style selected from a partner data provider.
    /// This member is required.
    public var configuration: LocationClientTypes.MapConfiguration?
    /// The timestamp for when the map resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// Specifies the data provider for the associated map tiles.
    /// This member is required.
    public var dataSource: Swift.String?
    /// The optional description for the map resource.
    /// This member is required.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) for the map resource. Used to specify a resource across all AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:map/ExampleMap
    /// This member is required.
    public var mapArn: Swift.String?
    /// The map style selected from an available provider.
    /// This member is required.
    public var mapName: Swift.String?
    /// No longer used. Always returns RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Tags associated with the map resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp for when the map resource was last update in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        configuration: LocationClientTypes.MapConfiguration? = nil,
        createTime: ClientRuntime.Date? = nil,
        dataSource: Swift.String? = nil,
        description: Swift.String? = nil,
        mapArn: Swift.String? = nil,
        mapName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.configuration = configuration
        self.createTime = createTime
        self.dataSource = dataSource
        self.description = description
        self.mapArn = mapArn
        self.mapName = mapName
        self.pricingPlan = pricingPlan
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct DescribeMapOutputResponseBody: Swift.Equatable {
    let mapName: Swift.String?
    let mapArn: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let dataSource: Swift.String?
    let configuration: LocationClientTypes.MapConfiguration?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
}

extension DescribeMapOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case description = "Description"
        case mapArn = "MapArn"
        case mapName = "MapName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapName)
        mapName = mapNameDecoded
        let mapArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapArn)
        mapArn = mapArnDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(LocationClientTypes.MapConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension DescribePlaceIndexInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let indexName = indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())"
    }
}

public struct DescribePlaceIndexInput: Swift.Equatable {
    /// The name of the place index resource.
    /// This member is required.
    public var indexName: Swift.String?

    public init (
        indexName: Swift.String? = nil
    )
    {
        self.indexName = indexName
    }
}

struct DescribePlaceIndexInputBody: Swift.Equatable {
}

extension DescribePlaceIndexInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePlaceIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePlaceIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribePlaceIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePlaceIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribePlaceIndexOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.dataSource = output.dataSource
            self.dataSourceConfiguration = output.dataSourceConfiguration
            self.description = output.description
            self.indexArn = output.indexArn
            self.indexName = output.indexName
            self.pricingPlan = output.pricingPlan
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.createTime = nil
            self.dataSource = nil
            self.dataSourceConfiguration = nil
            self.description = nil
            self.indexArn = nil
            self.indexName = nil
            self.pricingPlan = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct DescribePlaceIndexOutputResponse: Swift.Equatable {
    /// The timestamp for when the place index resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The data provider of geospatial data. Values can be one of the following:
    ///
    /// * Esri
    ///
    /// * Here
    ///
    ///
    /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
    /// This member is required.
    public var dataSource: Swift.String?
    /// The specified data storage option for requesting Places.
    /// This member is required.
    public var dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    /// The optional description for the place index resource.
    /// This member is required.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) for the place index resource. Used to specify a resource across AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:place-index/ExamplePlaceIndex
    /// This member is required.
    public var indexArn: Swift.String?
    /// The name of the place index resource being described.
    /// This member is required.
    public var indexName: Swift.String?
    /// No longer used. Always returns RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Tags associated with place index resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp for when the place index resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        createTime: ClientRuntime.Date? = nil,
        dataSource: Swift.String? = nil,
        dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.dataSource = dataSource
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.indexArn = indexArn
        self.indexName = indexName
        self.pricingPlan = pricingPlan
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct DescribePlaceIndexOutputResponseBody: Swift.Equatable {
    let indexName: Swift.String?
    let indexArn: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let dataSource: Swift.String?
    let dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    let tags: [Swift.String:Swift.String]?
}

extension DescribePlaceIndexOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case dataSourceConfiguration = "DataSourceConfiguration"
        case description = "Description"
        case indexArn = "IndexArn"
        case indexName = "IndexName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let indexArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexArn)
        indexArn = indexArnDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeRouteCalculatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let calculatorName = calculatorName else {
            return nil
        }
        return "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())"
    }
}

public struct DescribeRouteCalculatorInput: Swift.Equatable {
    /// The name of the route calculator resource.
    /// This member is required.
    public var calculatorName: Swift.String?

    public init (
        calculatorName: Swift.String? = nil
    )
    {
        self.calculatorName = calculatorName
    }
}

struct DescribeRouteCalculatorInputBody: Swift.Equatable {
}

extension DescribeRouteCalculatorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRouteCalculatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRouteCalculatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRouteCalculatorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRouteCalculatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRouteCalculatorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.calculatorArn = output.calculatorArn
            self.calculatorName = output.calculatorName
            self.createTime = output.createTime
            self.dataSource = output.dataSource
            self.description = output.description
            self.pricingPlan = output.pricingPlan
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.calculatorArn = nil
            self.calculatorName = nil
            self.createTime = nil
            self.dataSource = nil
            self.description = nil
            self.pricingPlan = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct DescribeRouteCalculatorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the Route calculator resource. Use the ARN when you specify a resource across AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:route-calculator/ExampleCalculator
    /// This member is required.
    public var calculatorArn: Swift.String?
    /// The name of the route calculator resource being described.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// The timestamp when the route calculator resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    ///
    /// * For example, 2020–07-2T12:15:20.000Z+01:00
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The data provider of traffic and road network data. Indicates one of the available providers:
    ///
    /// * Esri
    ///
    /// * Here
    ///
    ///
    /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
    /// This member is required.
    public var dataSource: Swift.String?
    /// The optional description of the route calculator resource.
    /// This member is required.
    public var description: Swift.String?
    /// Always returns RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Tags associated with route calculator resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp when the route calculator resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    ///
    /// * For example, 2020–07-2T12:15:20.000Z+01:00
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        calculatorArn: Swift.String? = nil,
        calculatorName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        dataSource: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.calculatorArn = calculatorArn
        self.calculatorName = calculatorName
        self.createTime = createTime
        self.dataSource = dataSource
        self.description = description
        self.pricingPlan = pricingPlan
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct DescribeRouteCalculatorOutputResponseBody: Swift.Equatable {
    let calculatorName: Swift.String?
    let calculatorArn: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let dataSource: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeRouteCalculatorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorArn = "CalculatorArn"
        case calculatorName = "CalculatorName"
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorName)
        calculatorName = calculatorNameDecoded
        let calculatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorArn)
        calculatorArn = calculatorArnDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeTrackerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trackerName = trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())"
    }
}

public struct DescribeTrackerInput: Swift.Equatable {
    /// The name of the tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        trackerName: Swift.String? = nil
    )
    {
        self.trackerName = trackerName
    }
}

struct DescribeTrackerInputBody: Swift.Equatable {
}

extension DescribeTrackerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTrackerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrackerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTrackerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrackerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTrackerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.description = output.description
            self.kmsKeyId = output.kmsKeyId
            self.positionFiltering = output.positionFiltering
            self.pricingPlan = output.pricingPlan
            self.pricingPlanDataSource = output.pricingPlanDataSource
            self.tags = output.tags
            self.trackerArn = output.trackerArn
            self.trackerName = output.trackerName
            self.updateTime = output.updateTime
        } else {
            self.createTime = nil
            self.description = nil
            self.kmsKeyId = nil
            self.positionFiltering = nil
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.tags = nil
            self.trackerArn = nil
            self.trackerName = nil
            self.updateTime = nil
        }
    }
}

public struct DescribeTrackerOutputResponse: Swift.Equatable {
    /// The timestamp for when the tracker resource was created in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The optional description for the tracker resource.
    /// This member is required.
    public var description: Swift.String?
    /// A key identifier for an [AWS KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html) assigned to the Amazon Location resource.
    public var kmsKeyId: Swift.String?
    /// The position filtering method of the tracker resource.
    public var positionFiltering: LocationClientTypes.PositionFiltering?
    /// Always returns RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// No longer used. Always returns an empty string.
    @available(*, deprecated, message: "Deprecated. Unused. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?
    /// The tags associated with the tracker resource.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify a resource across all AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
    /// This member is required.
    public var trackerArn: Swift.String?
    /// The name of the tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?
    /// The timestamp for when the tracker resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        createTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        positionFiltering: LocationClientTypes.PositionFiltering? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.positionFiltering = positionFiltering
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
        self.trackerArn = trackerArn
        self.trackerName = trackerName
        self.updateTime = updateTime
    }
}

struct DescribeTrackerOutputResponseBody: Swift.Equatable {
    let trackerName: Swift.String?
    let trackerArn: Swift.String?
    let description: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let pricingPlanDataSource: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let kmsKeyId: Swift.String?
    let positionFiltering: LocationClientTypes.PositionFiltering?
}

extension DescribeTrackerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case positionFiltering = "PositionFiltering"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
        case trackerArn = "TrackerArn"
        case trackerName = "TrackerName"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let trackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerArn)
        trackerArn = trackerArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let positionFilteringDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PositionFiltering.self, forKey: .positionFiltering)
        positionFiltering = positionFilteringDecoded
    }
}

extension LocationClientTypes.DevicePosition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accuracy = "Accuracy"
        case deviceId = "DeviceId"
        case position = "Position"
        case positionProperties = "PositionProperties"
        case receivedTime = "ReceivedTime"
        case sampleTime = "SampleTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accuracy = self.accuracy {
            try encodeContainer.encode(accuracy, forKey: .accuracy)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for double0 in position {
                try positionContainer.encode(double0)
            }
        }
        if let positionProperties = positionProperties {
            var positionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .positionProperties)
            for (dictKey0, propertyMap0) in positionProperties {
                try positionPropertiesContainer.encode(propertyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let receivedTime = self.receivedTime {
            try encodeContainer.encodeTimestamp(receivedTime, format: .dateTime, forKey: .receivedTime)
        }
        if let sampleTime = self.sampleTime {
            try encodeContainer.encodeTimestamp(sampleTime, format: .dateTime, forKey: .sampleTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let receivedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .receivedTime)
        receivedTime = receivedTimeDecoded
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
        let accuracyDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PositionalAccuracy.self, forKey: .accuracy)
        accuracy = accuracyDecoded
        let positionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .positionProperties)
        var positionPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let positionPropertiesContainer = positionPropertiesContainer {
            positionPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in positionPropertiesContainer {
                if let string0 = string0 {
                    positionPropertiesDecoded0?[key0] = string0
                }
            }
        }
        positionProperties = positionPropertiesDecoded0
    }
}

extension LocationClientTypes.DevicePosition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DevicePosition(accuracy: \(Swift.String(describing: accuracy)), deviceId: \(Swift.String(describing: deviceId)), receivedTime: \(Swift.String(describing: receivedTime)), sampleTime: \(Swift.String(describing: sampleTime)), position: \"CONTENT_REDACTED\", positionProperties: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Contains the device position details.
    public struct DevicePosition: Swift.Equatable {
        /// The accuracy of the device position.
        public var accuracy: LocationClientTypes.PositionalAccuracy?
        /// The device whose position you retrieved.
        public var deviceId: Swift.String?
        /// The last known device position.
        /// This member is required.
        public var position: [Swift.Double]?
        /// The properties associated with the position.
        public var positionProperties: [Swift.String:Swift.String]?
        /// The timestamp for when the tracker resource received the device position in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var receivedTime: ClientRuntime.Date?
        /// The timestamp at which the device's position was determined. Uses [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init (
            accuracy: LocationClientTypes.PositionalAccuracy? = nil,
            deviceId: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            positionProperties: [Swift.String:Swift.String]? = nil,
            receivedTime: ClientRuntime.Date? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.receivedTime = receivedTime
            self.sampleTime = sampleTime
        }
    }

}

extension LocationClientTypes.DevicePositionUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accuracy = "Accuracy"
        case deviceId = "DeviceId"
        case position = "Position"
        case positionProperties = "PositionProperties"
        case sampleTime = "SampleTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accuracy = self.accuracy {
            try encodeContainer.encode(accuracy, forKey: .accuracy)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for double0 in position {
                try positionContainer.encode(double0)
            }
        }
        if let positionProperties = positionProperties {
            var positionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .positionProperties)
            for (dictKey0, propertyMap0) in positionProperties {
                try positionPropertiesContainer.encode(propertyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sampleTime = self.sampleTime {
            try encodeContainer.encodeTimestamp(sampleTime, format: .dateTime, forKey: .sampleTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
        let accuracyDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PositionalAccuracy.self, forKey: .accuracy)
        accuracy = accuracyDecoded
        let positionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .positionProperties)
        var positionPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let positionPropertiesContainer = positionPropertiesContainer {
            positionPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in positionPropertiesContainer {
                if let string0 = string0 {
                    positionPropertiesDecoded0?[key0] = string0
                }
            }
        }
        positionProperties = positionPropertiesDecoded0
    }
}

extension LocationClientTypes.DevicePositionUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DevicePositionUpdate(accuracy: \(Swift.String(describing: accuracy)), deviceId: \(Swift.String(describing: deviceId)), sampleTime: \(Swift.String(describing: sampleTime)), position: \"CONTENT_REDACTED\", positionProperties: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Contains the position update details for a device.
    public struct DevicePositionUpdate: Swift.Equatable {
        /// The accuracy of the device position.
        public var accuracy: LocationClientTypes.PositionalAccuracy?
        /// The device associated to the position update.
        /// This member is required.
        public var deviceId: Swift.String?
        /// The latest device position defined in [WGS 84](https://earth-info.nga.mil/index.php?dir=wgs84&action=wgs84) format: [X or longitude, Y or latitude].
        /// This member is required.
        public var position: [Swift.Double]?
        /// Associates one of more properties with the position update. A property is a key-value pair stored with the position update and added to any geofence event the update may trigger. Format: "key" : "value"
        public var positionProperties: [Swift.String:Swift.String]?
        /// The timestamp at which the device's position was determined. Uses [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init (
            accuracy: LocationClientTypes.PositionalAccuracy? = nil,
            deviceId: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            positionProperties: [Swift.String:Swift.String]? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.sampleTime = sampleTime
        }
    }

}

extension LocationClientTypes {
    public enum DimensionUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case feet
        case meters
        case sdkUnknown(Swift.String)

        public static var allCases: [DimensionUnit] {
            return [
                .feet,
                .meters,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .feet: return "Feet"
            case .meters: return "Meters"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DimensionUnit(rawValue: rawValue) ?? DimensionUnit.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateTrackerConsumerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trackerName = trackerName else {
            return nil
        }
        guard let consumerArn = consumerArn else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/consumers/\(consumerArn.urlPercentEncoding())"
    }
}

public struct DisassociateTrackerConsumerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the geofence collection to be disassociated from the tracker resource. Used when you need to specify a resource across all AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
    /// This member is required.
    public var consumerArn: Swift.String?
    /// The name of the tracker resource to be dissociated from the consumer.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        consumerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.consumerArn = consumerArn
        self.trackerName = trackerName
    }
}

struct DisassociateTrackerConsumerInputBody: Swift.Equatable {
}

extension DisassociateTrackerConsumerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateTrackerConsumerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateTrackerConsumerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateTrackerConsumerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateTrackerConsumerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateTrackerConsumerOutputResponse: Swift.Equatable {

    public init () { }
}

extension LocationClientTypes {
    public enum DistanceUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kilometers
        case miles
        case sdkUnknown(Swift.String)

        public static var allCases: [DistanceUnit] {
            return [
                .kilometers,
                .miles,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kilometers: return "Kilometers"
            case .miles: return "Miles"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DistanceUnit(rawValue: rawValue) ?? DistanceUnit.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes.GeofenceGeometry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case circle = "Circle"
        case polygon = "Polygon"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let circle = self.circle {
            try encodeContainer.encode(circle, forKey: .circle)
        }
        if let polygon = polygon {
            var polygonContainer = encodeContainer.nestedUnkeyedContainer(forKey: .polygon)
            for linearring0 in polygon {
                var linearring0Container = polygonContainer.nestedUnkeyedContainer()
                for position1 in linearring0 {
                    var position1Container = linearring0Container.nestedUnkeyedContainer()
                    for double2 in position1 {
                        try position1Container.encode(double2)
                    }
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let polygonContainer = try containerValues.decodeIfPresent([[[Swift.Double?]?]?].self, forKey: .polygon)
        var polygonDecoded0:[[[Swift.Double]]]? = nil
        if let polygonContainer = polygonContainer {
            polygonDecoded0 = [[[Swift.Double]]]()
            for list0 in polygonContainer {
                var list0Decoded0: [[Swift.Double]]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [[Swift.Double]]()
                    for list1 in list0 {
                        var list1Decoded1: [Swift.Double]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [Swift.Double]()
                            for double2 in list1 {
                                if let double2 = double2 {
                                    list1Decoded1?.append(double2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            list0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    polygonDecoded0?.append(list0Decoded0)
                }
            }
        }
        polygon = polygonDecoded0
        let circleDecoded = try containerValues.decodeIfPresent(LocationClientTypes.Circle.self, forKey: .circle)
        circle = circleDecoded
    }
}

extension LocationClientTypes.GeofenceGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeofenceGeometry(polygon: \(Swift.String(describing: polygon)), circle: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Contains the geofence geometry details. A geofence geometry is made up of either a polygon or a circle. Can be either a polygon or a circle. Including both will return a validation error. Amazon Location doesn't currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian.
    public struct GeofenceGeometry: Swift.Equatable {
        /// A circle on the earth, as defined by a center point and a radius.
        public var circle: LocationClientTypes.Circle?
        /// A polygon is a list of linear rings which are each made up of a list of vertices. Each vertex is a 2-dimensional point of the form: [longitude, latitude]. This is represented as an array of doubles of length 2 (so [double, double]). An array of 4 or more vertices, where the first and last vertex are the same (to form a closed boundary), is called a linear ring. The linear ring vertices must be listed in counter-clockwise order around the ring’s interior. The linear ring is represented as an array of vertices, or an array of arrays of doubles ([[double, double], ...]). A geofence consists of a single linear ring. To allow for future expansion, the Polygon parameter takes an array of linear rings, which is represented as an array of arrays of arrays of doubles ([[[double, double], ...], ...]). A linear ring for use in geofences can consist of between 4 and 1,000 vertices.
        public var polygon: [[[Swift.Double]]]?

        public init (
            circle: LocationClientTypes.Circle? = nil,
            polygon: [[[Swift.Double]]]? = nil
        )
        {
            self.circle = circle
            self.polygon = polygon
        }
    }

}

extension GetDevicePositionHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTimeExclusive = "EndTimeExclusive"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeInclusive = "StartTimeInclusive"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTimeExclusive = self.endTimeExclusive {
            try encodeContainer.encodeTimestamp(endTimeExclusive, format: .dateTime, forKey: .endTimeExclusive)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTimeInclusive = self.startTimeInclusive {
            try encodeContainer.encodeTimestamp(startTimeInclusive, format: .dateTime, forKey: .startTimeInclusive)
        }
    }
}

extension GetDevicePositionHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trackerName = trackerName else {
            return nil
        }
        guard let deviceId = deviceId else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())/list-positions"
    }
}

public struct GetDevicePositionHistoryInput: Swift.Equatable {
    /// The device whose position history you want to retrieve.
    /// This member is required.
    public var deviceId: Swift.String?
    /// Specify the end time for the position history in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be the time that the request is made. Requirement:
    ///
    /// * The time specified for EndTimeExclusive must be after the time for StartTimeInclusive.
    public var endTimeExclusive: ClientRuntime.Date?
    /// An optional limit for the number of device positions returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?
    /// Specify the start time for the position history in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be 24 hours prior to the time that the request is made. Requirement:
    ///
    /// * The time specified for StartTimeInclusive must be before EndTimeExclusive.
    public var startTimeInclusive: ClientRuntime.Date?
    /// The tracker resource receiving the request for the device position history.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        endTimeExclusive: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTimeInclusive: ClientRuntime.Date? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.endTimeExclusive = endTimeExclusive
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeInclusive = startTimeInclusive
        self.trackerName = trackerName
    }
}

struct GetDevicePositionHistoryInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let startTimeInclusive: ClientRuntime.Date?
    let endTimeExclusive: ClientRuntime.Date?
    let maxResults: Swift.Int?
}

extension GetDevicePositionHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTimeExclusive = "EndTimeExclusive"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeInclusive = "StartTimeInclusive"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let startTimeInclusiveDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTimeInclusive)
        startTimeInclusive = startTimeInclusiveDecoded
        let endTimeExclusiveDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTimeExclusive)
        endTimeExclusive = endTimeExclusiveDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetDevicePositionHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicePositionHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDevicePositionHistoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicePositionHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDevicePositionHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devicePositions = output.devicePositions
            self.nextToken = output.nextToken
        } else {
            self.devicePositions = nil
            self.nextToken = nil
        }
    }
}

public struct GetDevicePositionHistoryOutputResponse: Swift.Equatable {
    /// Contains the position history details for the requested device.
    /// This member is required.
    public var devicePositions: [LocationClientTypes.DevicePosition]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        devicePositions: [LocationClientTypes.DevicePosition]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devicePositions = devicePositions
        self.nextToken = nextToken
    }
}

struct GetDevicePositionHistoryOutputResponseBody: Swift.Equatable {
    let devicePositions: [LocationClientTypes.DevicePosition]?
    let nextToken: Swift.String?
}

extension GetDevicePositionHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePositions = "DevicePositions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePositionsContainer = try containerValues.decodeIfPresent([LocationClientTypes.DevicePosition?].self, forKey: .devicePositions)
        var devicePositionsDecoded0:[LocationClientTypes.DevicePosition]? = nil
        if let devicePositionsContainer = devicePositionsContainer {
            devicePositionsDecoded0 = [LocationClientTypes.DevicePosition]()
            for structure0 in devicePositionsContainer {
                if let structure0 = structure0 {
                    devicePositionsDecoded0?.append(structure0)
                }
            }
        }
        devicePositions = devicePositionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDevicePositionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trackerName = trackerName else {
            return nil
        }
        guard let deviceId = deviceId else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())/positions/latest"
    }
}

public struct GetDevicePositionInput: Swift.Equatable {
    /// The device whose position you want to retrieve.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The tracker resource receiving the position update.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.trackerName = trackerName
    }
}

struct GetDevicePositionInputBody: Swift.Equatable {
}

extension GetDevicePositionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDevicePositionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicePositionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDevicePositionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicePositionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicePositionOutputResponse(accuracy: \(Swift.String(describing: accuracy)), deviceId: \(Swift.String(describing: deviceId)), receivedTime: \(Swift.String(describing: receivedTime)), sampleTime: \(Swift.String(describing: sampleTime)), position: \"CONTENT_REDACTED\", positionProperties: \"CONTENT_REDACTED\")"}
}

extension GetDevicePositionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDevicePositionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accuracy = output.accuracy
            self.deviceId = output.deviceId
            self.position = output.position
            self.positionProperties = output.positionProperties
            self.receivedTime = output.receivedTime
            self.sampleTime = output.sampleTime
        } else {
            self.accuracy = nil
            self.deviceId = nil
            self.position = nil
            self.positionProperties = nil
            self.receivedTime = nil
            self.sampleTime = nil
        }
    }
}

public struct GetDevicePositionOutputResponse: Swift.Equatable {
    /// The accuracy of the device position.
    public var accuracy: LocationClientTypes.PositionalAccuracy?
    /// The device whose position you retrieved.
    public var deviceId: Swift.String?
    /// The last known device position.
    /// This member is required.
    public var position: [Swift.Double]?
    /// The properties associated with the position.
    public var positionProperties: [Swift.String:Swift.String]?
    /// The timestamp for when the tracker resource received the device position in [ ISO 8601 ](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var receivedTime: ClientRuntime.Date?
    /// The timestamp at which the device's position was determined. Uses [ ISO 8601 ](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var sampleTime: ClientRuntime.Date?

    public init (
        accuracy: LocationClientTypes.PositionalAccuracy? = nil,
        deviceId: Swift.String? = nil,
        position: [Swift.Double]? = nil,
        positionProperties: [Swift.String:Swift.String]? = nil,
        receivedTime: ClientRuntime.Date? = nil,
        sampleTime: ClientRuntime.Date? = nil
    )
    {
        self.accuracy = accuracy
        self.deviceId = deviceId
        self.position = position
        self.positionProperties = positionProperties
        self.receivedTime = receivedTime
        self.sampleTime = sampleTime
    }
}

struct GetDevicePositionOutputResponseBody: Swift.Equatable {
    let deviceId: Swift.String?
    let sampleTime: ClientRuntime.Date?
    let receivedTime: ClientRuntime.Date?
    let position: [Swift.Double]?
    let accuracy: LocationClientTypes.PositionalAccuracy?
    let positionProperties: [Swift.String:Swift.String]?
}

extension GetDevicePositionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accuracy = "Accuracy"
        case deviceId = "DeviceId"
        case position = "Position"
        case positionProperties = "PositionProperties"
        case receivedTime = "ReceivedTime"
        case sampleTime = "SampleTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let receivedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .receivedTime)
        receivedTime = receivedTimeDecoded
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
        let accuracyDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PositionalAccuracy.self, forKey: .accuracy)
        accuracy = accuracyDecoded
        let positionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .positionProperties)
        var positionPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let positionPropertiesContainer = positionPropertiesContainer {
            positionPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in positionPropertiesContainer {
                if let string0 = string0 {
                    positionPropertiesDecoded0?[key0] = string0
                }
            }
        }
        positionProperties = positionPropertiesDecoded0
    }
}

extension GetGeofenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collectionName = collectionName else {
            return nil
        }
        guard let geofenceId = geofenceId else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/geofences/\(geofenceId.urlPercentEncoding())"
    }
}

public struct GetGeofenceInput: Swift.Equatable {
    /// The geofence collection storing the target geofence.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The geofence you're retrieving details for.
    /// This member is required.
    public var geofenceId: Swift.String?

    public init (
        collectionName: Swift.String? = nil,
        geofenceId: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
        self.geofenceId = geofenceId
    }
}

struct GetGeofenceInputBody: Swift.Equatable {
}

extension GetGeofenceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGeofenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGeofenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetGeofenceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGeofenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetGeofenceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.geofenceId = output.geofenceId
            self.geometry = output.geometry
            self.status = output.status
            self.updateTime = output.updateTime
        } else {
            self.createTime = nil
            self.geofenceId = nil
            self.geometry = nil
            self.status = nil
            self.updateTime = nil
        }
    }
}

public struct GetGeofenceOutputResponse: Swift.Equatable {
    /// The timestamp for when the geofence collection was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The geofence identifier.
    /// This member is required.
    public var geofenceId: Swift.String?
    /// Contains the geofence geometry details describing a polygon or a circle.
    /// This member is required.
    public var geometry: LocationClientTypes.GeofenceGeometry?
    /// Identifies the state of the geofence. A geofence will hold one of the following states:
    ///
    /// * ACTIVE — The geofence has been indexed by the system.
    ///
    /// * PENDING — The geofence is being processed by the system.
    ///
    /// * FAILED — The geofence failed to be indexed by the system.
    ///
    /// * DELETED — The geofence has been deleted from the system index.
    ///
    /// * DELETING — The geofence is being deleted from the system index.
    /// This member is required.
    public var status: Swift.String?
    /// The timestamp for when the geofence collection was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        createTime: ClientRuntime.Date? = nil,
        geofenceId: Swift.String? = nil,
        geometry: LocationClientTypes.GeofenceGeometry? = nil,
        status: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.geofenceId = geofenceId
        self.geometry = geometry
        self.status = status
        self.updateTime = updateTime
    }
}

struct GetGeofenceOutputResponseBody: Swift.Equatable {
    let geofenceId: Swift.String?
    let geometry: LocationClientTypes.GeofenceGeometry?
    let status: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
}

extension GetGeofenceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case geofenceId = "GeofenceId"
        case geometry = "Geometry"
        case status = "Status"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.GeofenceGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension GetMapGlyphsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mapName = mapName else {
            return nil
        }
        guard let fontStack = fontStack else {
            return nil
        }
        guard let fontUnicodeRange = fontUnicodeRange else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())/glyphs/\(fontStack.urlPercentEncoding())/\(fontUnicodeRange.urlPercentEncoding())"
    }
}

public struct GetMapGlyphsInput: Swift.Equatable {
    /// A comma-separated list of fonts to load glyphs from in order of preference. For example, Noto Sans Regular, Arial Unicode. Valid fonts stacks for [Esri](https://docs.aws.amazon.com/location/latest/developerguide/esri.html) styles:
    ///
    /// * VectorEsriDarkGrayCanvas – Ubuntu Medium Italic | Ubuntu Medium | Ubuntu Italic | Ubuntu Regular | Ubuntu Bold
    ///
    /// * VectorEsriLightGrayCanvas – Ubuntu Italic | Ubuntu Regular | Ubuntu Light | Ubuntu Bold
    ///
    /// * VectorEsriTopographic – Noto Sans Italic | Noto Sans Regular | Noto Sans Bold | Noto Serif Regular | Roboto Condensed Light Italic
    ///
    /// * VectorEsriStreets – Arial Regular | Arial Italic | Arial Bold
    ///
    /// * VectorEsriNavigation – Arial Regular | Arial Italic | Arial Bold
    ///
    ///
    /// Valid font stacks for [HERE Technologies](https://docs.aws.amazon.com/location/latest/developerguide/HERE.html) styles:
    ///
    /// * VectorHereContrast – Fira GO Regular | Fira GO Bold
    ///
    /// * VectorHereExplore, VectorHereExploreTruck, HybridHereExploreSatellite – Fira GO Italic | Fira GO Map | Fira GO Map Bold | Noto Sans CJK JP Bold | Noto Sans CJK JP Light | Noto Sans CJK JP Regular
    ///
    ///
    /// Valid font stacks for [Open Data (Preview)](https://docs.aws.amazon.com/location/latest/developerguide/open-data.html) styles:
    ///
    /// * VectorOpenDataStandardLight – Amazon Ember Regular,Noto Sans Regular | Amazon Ember Bold,Noto Sans Bold | Amazon Ember Medium,Noto Sans Medium | Amazon Ember Regular Italic,Noto Sans Italic | Amazon Ember Condensed RC Regular,Noto Sans Regular | Amazon Ember Condensed RC Bold,Noto Sans Bold
    ///
    ///
    /// The fonts used by VectorOpenDataStandardLight are combined fonts that use Amazon Ember for most glyphs but Noto Sans for glyphs unsupported by Amazon Ember.
    /// This member is required.
    public var fontStack: Swift.String?
    /// A Unicode range of characters to download glyphs for. Each response will contain 256 characters. For example, 0–255 includes all characters from range U+0000 to 00FF. Must be aligned to multiples of 256.
    /// This member is required.
    public var fontUnicodeRange: Swift.String?
    /// The map resource associated with the glyph ﬁle.
    /// This member is required.
    public var mapName: Swift.String?

    public init (
        fontStack: Swift.String? = nil,
        fontUnicodeRange: Swift.String? = nil,
        mapName: Swift.String? = nil
    )
    {
        self.fontStack = fontStack
        self.fontUnicodeRange = fontUnicodeRange
        self.mapName = mapName
    }
}

struct GetMapGlyphsInputBody: Swift.Equatable {
}

extension GetMapGlyphsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMapGlyphsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMapGlyphsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMapGlyphsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMapGlyphsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.blob = data
        } else {
            self.blob = nil
        }
    }
}

public struct GetMapGlyphsOutputResponse: Swift.Equatable {
    /// The blob's content type.
    public var blob: ClientRuntime.Data?
    /// The map glyph content type. For example, application/octet-stream.
    public var contentType: Swift.String?

    public init (
        blob: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.contentType = contentType
    }
}

struct GetMapGlyphsOutputResponseBody: Swift.Equatable {
    let blob: ClientRuntime.Data?
}

extension GetMapGlyphsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blob = "Blob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .blob)
        blob = blobDecoded
    }
}

extension GetMapSpritesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mapName = mapName else {
            return nil
        }
        guard let fileName = fileName else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())/sprites/\(fileName.urlPercentEncoding())"
    }
}

public struct GetMapSpritesInput: Swift.Equatable {
    /// The name of the sprite ﬁle. Use the following ﬁle names for the sprite sheet:
    ///
    /// * sprites.png
    ///
    /// * sprites@2x.png for high pixel density displays
    ///
    ///
    /// For the JSON document containing image offsets. Use the following ﬁle names:
    ///
    /// * sprites.json
    ///
    /// * sprites@2x.json for high pixel density displays
    /// This member is required.
    public var fileName: Swift.String?
    /// The map resource associated with the sprite ﬁle.
    /// This member is required.
    public var mapName: Swift.String?

    public init (
        fileName: Swift.String? = nil,
        mapName: Swift.String? = nil
    )
    {
        self.fileName = fileName
        self.mapName = mapName
    }
}

struct GetMapSpritesInputBody: Swift.Equatable {
}

extension GetMapSpritesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMapSpritesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMapSpritesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMapSpritesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMapSpritesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.blob = data
        } else {
            self.blob = nil
        }
    }
}

public struct GetMapSpritesOutputResponse: Swift.Equatable {
    /// Contains the body of the sprite sheet or JSON offset ﬁle.
    public var blob: ClientRuntime.Data?
    /// The content type of the sprite sheet and offsets. For example, the sprite sheet content type is image/png, and the sprite offset JSON document is application/json.
    public var contentType: Swift.String?

    public init (
        blob: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.contentType = contentType
    }
}

struct GetMapSpritesOutputResponseBody: Swift.Equatable {
    let blob: ClientRuntime.Data?
}

extension GetMapSpritesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blob = "Blob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .blob)
        blob = blobDecoded
    }
}

extension GetMapStyleDescriptorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mapName = mapName else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())/style-descriptor"
    }
}

public struct GetMapStyleDescriptorInput: Swift.Equatable {
    /// The map resource to retrieve the style descriptor from.
    /// This member is required.
    public var mapName: Swift.String?

    public init (
        mapName: Swift.String? = nil
    )
    {
        self.mapName = mapName
    }
}

struct GetMapStyleDescriptorInputBody: Swift.Equatable {
}

extension GetMapStyleDescriptorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMapStyleDescriptorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMapStyleDescriptorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMapStyleDescriptorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMapStyleDescriptorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.blob = data
        } else {
            self.blob = nil
        }
    }
}

public struct GetMapStyleDescriptorOutputResponse: Swift.Equatable {
    /// Contains the body of the style descriptor.
    public var blob: ClientRuntime.Data?
    /// The style descriptor's content type. For example, application/json.
    public var contentType: Swift.String?

    public init (
        blob: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.contentType = contentType
    }
}

struct GetMapStyleDescriptorOutputResponseBody: Swift.Equatable {
    let blob: ClientRuntime.Data?
}

extension GetMapStyleDescriptorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blob = "Blob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .blob)
        blob = blobDecoded
    }
}

extension GetMapTileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mapName = mapName else {
            return nil
        }
        guard let z = z else {
            return nil
        }
        guard let x = x else {
            return nil
        }
        guard let y = y else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())/tiles/\(z.urlPercentEncoding())/\(x.urlPercentEncoding())/\(y.urlPercentEncoding())"
    }
}

public struct GetMapTileInput: Swift.Equatable {
    /// The map resource to retrieve the map tiles from.
    /// This member is required.
    public var mapName: Swift.String?
    /// The X axis value for the map tile.
    /// This member is required.
    public var x: Swift.String?
    /// The Y axis value for the map tile.
    /// This member is required.
    public var y: Swift.String?
    /// The zoom value for the map tile.
    /// This member is required.
    public var z: Swift.String?

    public init (
        mapName: Swift.String? = nil,
        x: Swift.String? = nil,
        y: Swift.String? = nil,
        z: Swift.String? = nil
    )
    {
        self.mapName = mapName
        self.x = x
        self.y = y
        self.z = z
    }
}

struct GetMapTileInputBody: Swift.Equatable {
}

extension GetMapTileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMapTileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMapTileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMapTileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMapTileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.blob = data
        } else {
            self.blob = nil
        }
    }
}

public struct GetMapTileOutputResponse: Swift.Equatable {
    /// Contains Mapbox Vector Tile (MVT) data.
    public var blob: ClientRuntime.Data?
    /// The map tile's content type. For example, application/vnd.mapbox-vector-tile.
    public var contentType: Swift.String?

    public init (
        blob: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.contentType = contentType
    }
}

struct GetMapTileOutputResponseBody: Swift.Equatable {
    let blob: ClientRuntime.Data?
}

extension GetMapTileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blob = "Blob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .blob)
        blob = blobDecoded
    }
}

extension GetPlaceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let language = language {
                let languageQueryItem = ClientRuntime.URLQueryItem(name: "language".urlPercentEncoding(), value: Swift.String(language).urlPercentEncoding())
                items.append(languageQueryItem)
            }
            return items
        }
    }
}

extension GetPlaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let indexName = indexName else {
            return nil
        }
        guard let placeId = placeId else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())/places/\(placeId.urlPercentEncoding())"
    }
}

public struct GetPlaceInput: Swift.Equatable {
    /// The name of the place index resource that you want to use for the search.
    /// This member is required.
    public var indexName: Swift.String?
    /// The preferred language used to return results. The value must be a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for a location around Athens, Greece, with the language parameter set to en. The city in the results will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the city in the results will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    public var language: Swift.String?
    /// The identifier of the place to find.
    /// This member is required.
    public var placeId: Swift.String?

    public init (
        indexName: Swift.String? = nil,
        language: Swift.String? = nil,
        placeId: Swift.String? = nil
    )
    {
        self.indexName = indexName
        self.language = language
        self.placeId = placeId
    }
}

struct GetPlaceInputBody: Swift.Equatable {
}

extension GetPlaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPlaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPlaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPlaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPlaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPlaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.place = output.place
        } else {
            self.place = nil
        }
    }
}

public struct GetPlaceOutputResponse: Swift.Equatable {
    /// Details about the result, such as its address and position.
    /// This member is required.
    public var place: LocationClientTypes.Place?

    public init (
        place: LocationClientTypes.Place? = nil
    )
    {
        self.place = place
    }
}

struct GetPlaceOutputResponseBody: Swift.Equatable {
    let place: LocationClientTypes.Place?
}

extension GetPlaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case place = "Place"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.Place.self, forKey: .place)
        place = placeDecoded
    }
}

extension LocationClientTypes {
    public enum IntendedUse: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleuse
        /// Indicates that results of the operation may be stored locally.
        case storage
        case sdkUnknown(Swift.String)

        public static var allCases: [IntendedUse] {
            return [
                .singleuse,
                .storage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .singleuse: return "SingleUse"
            case .storage: return "Storage"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntendedUse(rawValue: rawValue) ?? IntendedUse.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has failed to process because of an unknown server error, exception, or failure.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes.Leg: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distance = "Distance"
        case durationSeconds = "DurationSeconds"
        case endPosition = "EndPosition"
        case geometry = "Geometry"
        case startPosition = "StartPosition"
        case steps = "Steps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distance = self.distance {
            try encodeContainer.encode(distance, forKey: .distance)
        }
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let endPosition = endPosition {
            var endPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endPosition)
            for double0 in endPosition {
                try endPositionContainer.encode(double0)
            }
        }
        if let geometry = self.geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
        if let startPosition = startPosition {
            var startPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startPosition)
            for double0 in startPosition {
                try startPositionContainer.encode(double0)
            }
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for step0 in steps {
                try stepsContainer.encode(step0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .startPosition)
        var startPositionDecoded0:[Swift.Double]? = nil
        if let startPositionContainer = startPositionContainer {
            startPositionDecoded0 = [Swift.Double]()
            for double0 in startPositionContainer {
                if let double0 = double0 {
                    startPositionDecoded0?.append(double0)
                }
            }
        }
        startPosition = startPositionDecoded0
        let endPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .endPosition)
        var endPositionDecoded0:[Swift.Double]? = nil
        if let endPositionContainer = endPositionContainer {
            endPositionDecoded0 = [Swift.Double]()
            for double0 in endPositionContainer {
                if let double0 = double0 {
                    endPositionDecoded0?.append(double0)
                }
            }
        }
        endPosition = endPositionDecoded0
        let distanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .distance)
        distance = distanceDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.LegGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let stepsContainer = try containerValues.decodeIfPresent([LocationClientTypes.Step?].self, forKey: .steps)
        var stepsDecoded0:[LocationClientTypes.Step]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [LocationClientTypes.Step]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension LocationClientTypes.Leg: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Leg(distance: \(Swift.String(describing: distance)), durationSeconds: \(Swift.String(describing: durationSeconds)), geometry: \(Swift.String(describing: geometry)), steps: \(Swift.String(describing: steps)), endPosition: \"CONTENT_REDACTED\", startPosition: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Contains the calculated route's details for each path between a pair of positions. The number of legs returned corresponds to one fewer than the total number of positions in the request. For example, a route with a departure position and destination position returns one leg with the positions [snapped to a nearby road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html):
    ///
    /// * The StartPosition is the departure position.
    ///
    /// * The EndPosition is the destination position.
    ///
    ///
    /// A route with a waypoint between the departure and destination position returns two legs with the positions snapped to a nearby road:
    ///
    /// * Leg 1: The StartPosition is the departure position . The EndPosition is the waypoint positon.
    ///
    /// * Leg 2: The StartPosition is the waypoint position. The EndPosition is the destination position.
    public struct Leg: Swift.Equatable {
        /// The distance between the leg's StartPosition and EndPosition along a calculated route.
        ///
        /// * The default measurement is Kilometers unless the request specifies a DistanceUnit of Miles.
        /// This member is required.
        public var distance: Swift.Double?
        /// The estimated travel time between the leg's StartPosition and EndPosition. The travel mode and departure time that you specify in the request determines the calculated time.
        /// This member is required.
        public var durationSeconds: Swift.Double?
        /// The terminating position of the leg. Follows the format [longitude,latitude]. If the EndPosition isn't located on a road, it's [snapped to a nearby road](https://docs.aws.amazon.com/location/latest/developerguide/nap-to-nearby-road.html).
        /// This member is required.
        public var endPosition: [Swift.Double]?
        /// Contains the calculated route's path as a linestring geometry.
        public var geometry: LocationClientTypes.LegGeometry?
        /// The starting position of the leg. Follows the format [longitude,latitude]. If the StartPosition isn't located on a road, it's [snapped to a nearby road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html).
        /// This member is required.
        public var startPosition: [Swift.Double]?
        /// Contains a list of steps, which represent subsections of a leg. Each step provides instructions for how to move to the next step in the leg such as the step's start position, end position, travel distance, travel duration, and geometry offset.
        /// This member is required.
        public var steps: [LocationClientTypes.Step]?

        public init (
            distance: Swift.Double? = nil,
            durationSeconds: Swift.Double? = nil,
            endPosition: [Swift.Double]? = nil,
            geometry: LocationClientTypes.LegGeometry? = nil,
            startPosition: [Swift.Double]? = nil,
            steps: [LocationClientTypes.Step]? = nil
        )
        {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.endPosition = endPosition
            self.geometry = geometry
            self.startPosition = startPosition
            self.steps = steps
        }
    }

}

extension LocationClientTypes.LegGeometry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lineString = "LineString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lineString = lineString {
            var lineStringContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineString)
            for position0 in lineString {
                var position0Container = lineStringContainer.nestedUnkeyedContainer()
                for double1 in position0 {
                    try position0Container.encode(double1)
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineStringContainer = try containerValues.decodeIfPresent([[Swift.Double?]?].self, forKey: .lineString)
        var lineStringDecoded0:[[Swift.Double]]? = nil
        if let lineStringContainer = lineStringContainer {
            lineStringDecoded0 = [[Swift.Double]]()
            for list0 in lineStringContainer {
                var list0Decoded0: [Swift.Double]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.Double]()
                    for double1 in list0 {
                        if let double1 = double1 {
                            list0Decoded0?.append(double1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    lineStringDecoded0?.append(list0Decoded0)
                }
            }
        }
        lineString = lineStringDecoded0
    }
}

extension LocationClientTypes {
    /// Contains the geometry details for each path between a pair of positions. Used in plotting a route leg on a map.
    public struct LegGeometry: Swift.Equatable {
        /// An ordered list of positions used to plot a route on a map. The first position is closest to the start position for the leg, and the last position is the closest to the end position for the leg.
        ///
        /// * For example, [[-123.117, 49.284],[-123.115, 49.285],[-123.115, 49.285]]
        public var lineString: [[Swift.Double]]?

        public init (
            lineString: [[Swift.Double]]? = nil
        )
        {
            self.lineString = lineString
        }
    }

}

extension ListDevicePositionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDevicePositionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trackerName = trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/list-positions"
    }
}

public struct ListDevicePositionsInput: Swift.Equatable {
    /// An optional limit for the number of entries returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?
    /// The tracker resource containing the requested devices.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trackerName = trackerName
    }
}

struct ListDevicePositionsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDevicePositionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDevicePositionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicePositionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDevicePositionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicePositionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDevicePositionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevicePositionsOutputResponse: Swift.Equatable {
    /// Contains details about each device's last known position. These details includes the device ID, the time when the position was sampled on the device, the time that the service received the update, and the most recent coordinates.
    /// This member is required.
    public var entries: [LocationClientTypes.ListDevicePositionsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        entries: [LocationClientTypes.ListDevicePositionsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListDevicePositionsOutputResponseBody: Swift.Equatable {
    let entries: [LocationClientTypes.ListDevicePositionsResponseEntry]?
    let nextToken: Swift.String?
}

extension ListDevicePositionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListDevicePositionsResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListDevicePositionsResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListDevicePositionsResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LocationClientTypes.ListDevicePositionsResponseEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accuracy = "Accuracy"
        case deviceId = "DeviceId"
        case position = "Position"
        case positionProperties = "PositionProperties"
        case sampleTime = "SampleTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accuracy = self.accuracy {
            try encodeContainer.encode(accuracy, forKey: .accuracy)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for double0 in position {
                try positionContainer.encode(double0)
            }
        }
        if let positionProperties = positionProperties {
            var positionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .positionProperties)
            for (dictKey0, propertyMap0) in positionProperties {
                try positionPropertiesContainer.encode(propertyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sampleTime = self.sampleTime {
            try encodeContainer.encodeTimestamp(sampleTime, format: .dateTime, forKey: .sampleTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
        let accuracyDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PositionalAccuracy.self, forKey: .accuracy)
        accuracy = accuracyDecoded
        let positionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .positionProperties)
        var positionPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let positionPropertiesContainer = positionPropertiesContainer {
            positionPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in positionPropertiesContainer {
                if let string0 = string0 {
                    positionPropertiesDecoded0?[key0] = string0
                }
            }
        }
        positionProperties = positionPropertiesDecoded0
    }
}

extension LocationClientTypes.ListDevicePositionsResponseEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevicePositionsResponseEntry(accuracy: \(Swift.String(describing: accuracy)), deviceId: \(Swift.String(describing: deviceId)), sampleTime: \(Swift.String(describing: sampleTime)), position: \"CONTENT_REDACTED\", positionProperties: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Contains the tracker resource details.
    public struct ListDevicePositionsResponseEntry: Swift.Equatable {
        /// The accuracy of the device position.
        public var accuracy: LocationClientTypes.PositionalAccuracy?
        /// The ID of the device for this position.
        /// This member is required.
        public var deviceId: Swift.String?
        /// The last known device position. Empty if no positions currently stored.
        /// This member is required.
        public var position: [Swift.Double]?
        /// The properties associated with the position.
        public var positionProperties: [Swift.String:Swift.String]?
        /// The timestamp at which the device position was determined. Uses [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init (
            accuracy: LocationClientTypes.PositionalAccuracy? = nil,
            deviceId: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            positionProperties: [Swift.String:Swift.String]? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.sampleTime = sampleTime
        }
    }

}

extension ListGeofenceCollectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGeofenceCollectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/geofencing/v0/list-collections"
    }
}

public struct ListGeofenceCollectionsInput: Swift.Equatable {
    /// An optional limit for the number of resources returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGeofenceCollectionsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListGeofenceCollectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGeofenceCollectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGeofenceCollectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGeofenceCollectionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGeofenceCollectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGeofenceCollectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListGeofenceCollectionsOutputResponse: Swift.Equatable {
    /// Lists the geofence collections that exist in your AWS account.
    /// This member is required.
    public var entries: [LocationClientTypes.ListGeofenceCollectionsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        entries: [LocationClientTypes.ListGeofenceCollectionsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListGeofenceCollectionsOutputResponseBody: Swift.Equatable {
    let entries: [LocationClientTypes.ListGeofenceCollectionsResponseEntry]?
    let nextToken: Swift.String?
}

extension ListGeofenceCollectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListGeofenceCollectionsResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListGeofenceCollectionsResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListGeofenceCollectionsResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LocationClientTypes.ListGeofenceCollectionsResponseEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionName = "CollectionName"
        case createTime = "CreateTime"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectionName = self.collectionName {
            try encodeContainer.encode(collectionName, forKey: .collectionName)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = self.pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes {
    /// Contains the geofence collection details.
    public struct ListGeofenceCollectionsResponseEntry: Swift.Equatable {
        /// The name of the geofence collection.
        /// This member is required.
        public var collectionName: Swift.String?
        /// The timestamp for when the geofence collection was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description for the geofence collection
        /// This member is required.
        public var description: Swift.String?
        /// No longer used. Always returns RequestBasedUsage.
        @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// No longer used. Always returns an empty string.
        @available(*, deprecated, message: "Deprecated. Unused. API deprecated since 2022-02-01")
        public var pricingPlanDataSource: Swift.String?
        /// Specifies a timestamp for when the resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            collectionName: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            pricingPlanDataSource: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.updateTime = updateTime
        }
    }

}

extension LocationClientTypes.ListGeofenceResponseEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case geofenceId = "GeofenceId"
        case geometry = "Geometry"
        case status = "Status"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let geofenceId = self.geofenceId {
            try encodeContainer.encode(geofenceId, forKey: .geofenceId)
        }
        if let geometry = self.geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.GeofenceGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes {
    /// Contains a list of geofences stored in a given geofence collection.
    public struct ListGeofenceResponseEntry: Swift.Equatable {
        /// The timestamp for when the geofence was stored in a geofence collection in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The geofence identifier.
        /// This member is required.
        public var geofenceId: Swift.String?
        /// Contains the geofence geometry details describing a polygon or a circle.
        /// This member is required.
        public var geometry: LocationClientTypes.GeofenceGeometry?
        /// Identifies the state of the geofence. A geofence will hold one of the following states:
        ///
        /// * ACTIVE — The geofence has been indexed by the system.
        ///
        /// * PENDING — The geofence is being processed by the system.
        ///
        /// * FAILED — The geofence failed to be indexed by the system.
        ///
        /// * DELETED — The geofence has been deleted from the system index.
        ///
        /// * DELETING — The geofence is being deleted from the system index.
        /// This member is required.
        public var status: Swift.String?
        /// The timestamp for when the geofence was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            createTime: ClientRuntime.Date? = nil,
            geofenceId: Swift.String? = nil,
            geometry: LocationClientTypes.GeofenceGeometry? = nil,
            status: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.geometry = geometry
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension ListGeofencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGeofencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collectionName = collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/list-geofences"
    }
}

public struct ListGeofencesInput: Swift.Equatable {
    /// The name of the geofence collection storing the list of geofences.
    /// This member is required.
    public var collectionName: Swift.String?
    /// An optional limit for the number of geofences returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init (
        collectionName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGeofencesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListGeofencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGeofencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGeofencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGeofencesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGeofencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGeofencesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListGeofencesOutputResponse: Swift.Equatable {
    /// Contains a list of geofences stored in the geofence collection.
    /// This member is required.
    public var entries: [LocationClientTypes.ListGeofenceResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        entries: [LocationClientTypes.ListGeofenceResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListGeofencesOutputResponseBody: Swift.Equatable {
    let entries: [LocationClientTypes.ListGeofenceResponseEntry]?
    let nextToken: Swift.String?
}

extension ListGeofencesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListGeofenceResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListGeofenceResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListGeofenceResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMapsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMapsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/maps/v0/list-maps"
    }
}

public struct ListMapsInput: Swift.Equatable {
    /// An optional limit for the number of resources returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMapsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListMapsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMapsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMapsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMapsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMapsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMapsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListMapsOutputResponse: Swift.Equatable {
    /// Contains a list of maps in your AWS account
    /// This member is required.
    public var entries: [LocationClientTypes.ListMapsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        entries: [LocationClientTypes.ListMapsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListMapsOutputResponseBody: Swift.Equatable {
    let entries: [LocationClientTypes.ListMapsResponseEntry]?
    let nextToken: Swift.String?
}

extension ListMapsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListMapsResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListMapsResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListMapsResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LocationClientTypes.ListMapsResponseEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case description = "Description"
        case mapName = "MapName"
        case pricingPlan = "PricingPlan"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mapName = self.mapName {
            try encodeContainer.encode(mapName, forKey: .mapName)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapName)
        mapName = mapNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes {
    /// Contains details of an existing map resource in your AWS account.
    public struct ListMapsResponseEntry: Swift.Equatable {
        /// The timestamp for when the map resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// Specifies the data provider for the associated map tiles.
        /// This member is required.
        public var dataSource: Swift.String?
        /// The description for the map resource.
        /// This member is required.
        public var description: Swift.String?
        /// The name of the associated map resource.
        /// This member is required.
        public var mapName: Swift.String?
        /// No longer used. Always returns RequestBasedUsage.
        @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// The timestamp for when the map resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            createTime: ClientRuntime.Date? = nil,
            dataSource: Swift.String? = nil,
            description: Swift.String? = nil,
            mapName: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapName = mapName
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }
    }

}

extension ListPlaceIndexesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPlaceIndexesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/places/v0/list-indexes"
    }
}

public struct ListPlaceIndexesInput: Swift.Equatable {
    /// An optional limit for the maximum number of results returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPlaceIndexesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListPlaceIndexesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPlaceIndexesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPlaceIndexesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPlaceIndexesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPlaceIndexesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPlaceIndexesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListPlaceIndexesOutputResponse: Swift.Equatable {
    /// Lists the place index resources that exist in your AWS account
    /// This member is required.
    public var entries: [LocationClientTypes.ListPlaceIndexesResponseEntry]?
    /// A pagination token indicating that there are additional pages available. You can use the token in a new request to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        entries: [LocationClientTypes.ListPlaceIndexesResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListPlaceIndexesOutputResponseBody: Swift.Equatable {
    let entries: [LocationClientTypes.ListPlaceIndexesResponseEntry]?
    let nextToken: Swift.String?
}

extension ListPlaceIndexesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListPlaceIndexesResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListPlaceIndexesResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListPlaceIndexesResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LocationClientTypes.ListPlaceIndexesResponseEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case description = "Description"
        case indexName = "IndexName"
        case pricingPlan = "PricingPlan"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes {
    /// A place index resource listed in your AWS account.
    public struct ListPlaceIndexesResponseEntry: Swift.Equatable {
        /// The timestamp for when the place index resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The data provider of geospatial data. Values can be one of the following:
        ///
        /// * Esri
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// The optional description for the place index resource.
        /// This member is required.
        public var description: Swift.String?
        /// The name of the place index resource.
        /// This member is required.
        public var indexName: Swift.String?
        /// No longer used. Always returns RequestBasedUsage.
        @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// The timestamp for when the place index resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            createTime: ClientRuntime.Date? = nil,
            dataSource: Swift.String? = nil,
            description: Swift.String? = nil,
            indexName: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.indexName = indexName
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }
    }

}

extension ListRouteCalculatorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRouteCalculatorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/routes/v0/list-calculators"
    }
}

public struct ListRouteCalculatorsInput: Swift.Equatable {
    /// An optional maximum number of results returned in a single call. Default Value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default Value: null
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRouteCalculatorsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListRouteCalculatorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRouteCalculatorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRouteCalculatorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRouteCalculatorsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRouteCalculatorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRouteCalculatorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListRouteCalculatorsOutputResponse: Swift.Equatable {
    /// Lists the route calculator resources that exist in your AWS account
    /// This member is required.
    public var entries: [LocationClientTypes.ListRouteCalculatorsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a subsequent request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        entries: [LocationClientTypes.ListRouteCalculatorsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListRouteCalculatorsOutputResponseBody: Swift.Equatable {
    let entries: [LocationClientTypes.ListRouteCalculatorsResponseEntry]?
    let nextToken: Swift.String?
}

extension ListRouteCalculatorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListRouteCalculatorsResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListRouteCalculatorsResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListRouteCalculatorsResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LocationClientTypes.ListRouteCalculatorsResponseEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorName = "CalculatorName"
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculatorName = self.calculatorName {
            try encodeContainer.encode(calculatorName, forKey: .calculatorName)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorName)
        calculatorName = calculatorNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes {
    /// A route calculator resource listed in your AWS account.
    public struct ListRouteCalculatorsResponseEntry: Swift.Equatable {
        /// The name of the route calculator resource.
        /// This member is required.
        public var calculatorName: Swift.String?
        /// The timestamp when the route calculator resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        ///
        /// * For example, 2020–07-2T12:15:20.000Z+01:00
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The data provider of traffic and road network data. Indicates one of the available providers:
        ///
        /// * Esri
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// The optional description of the route calculator resource.
        /// This member is required.
        public var description: Swift.String?
        /// Always returns RequestBasedUsage.
        @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// The timestamp when the route calculator resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        ///
        /// * For example, 2020–07-2T12:15:20.000Z+01:00
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            calculatorName: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            dataSource: Swift.String? = nil,
            description: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.calculatorName = calculatorName
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }
    }

}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
    ///
    /// * Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Tags that have been applied to the specified resource. Tags are mapped from the tag key to the tag value: "TagKey" : "TagValue".
    ///
    /// * Format example: {"tag1" : "value1", "tag2" : "value2"}
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTrackerConsumersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTrackerConsumersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trackerName = trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/list-consumers"
    }
}

public struct ListTrackerConsumersInput: Swift.Equatable {
    /// An optional limit for the number of resources returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?
    /// The tracker resource whose associated geofence collections you want to list.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trackerName = trackerName
    }
}

struct ListTrackerConsumersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTrackerConsumersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrackerConsumersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTrackerConsumersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTrackerConsumersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTrackerConsumersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTrackerConsumersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.consumerArns = output.consumerArns
            self.nextToken = output.nextToken
        } else {
            self.consumerArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListTrackerConsumersOutputResponse: Swift.Equatable {
    /// Contains the list of geofence collection ARNs associated to the tracker resource.
    /// This member is required.
    public var consumerArns: [Swift.String]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        consumerArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.consumerArns = consumerArns
        self.nextToken = nextToken
    }
}

struct ListTrackerConsumersOutputResponseBody: Swift.Equatable {
    let consumerArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListTrackerConsumersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerArns = "ConsumerArns"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .consumerArns)
        var consumerArnsDecoded0:[Swift.String]? = nil
        if let consumerArnsContainer = consumerArnsContainer {
            consumerArnsDecoded0 = [Swift.String]()
            for string0 in consumerArnsContainer {
                if let string0 = string0 {
                    consumerArnsDecoded0?.append(string0)
                }
            }
        }
        consumerArns = consumerArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrackersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTrackersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tracking/v0/list-trackers"
    }
}

public struct ListTrackersInput: Swift.Equatable {
    /// An optional limit for the number of resources returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTrackersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTrackersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrackersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTrackersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTrackersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTrackersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTrackersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListTrackersOutputResponse: Swift.Equatable {
    /// Contains tracker resources in your AWS account. Details include tracker name, description and timestamps for when the tracker was created and last updated.
    /// This member is required.
    public var entries: [LocationClientTypes.ListTrackersResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        entries: [LocationClientTypes.ListTrackersResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListTrackersOutputResponseBody: Swift.Equatable {
    let entries: [LocationClientTypes.ListTrackersResponseEntry]?
    let nextToken: Swift.String?
}

extension ListTrackersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListTrackersResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListTrackersResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListTrackersResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LocationClientTypes.ListTrackersResponseEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case trackerName = "TrackerName"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = self.pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
        if let trackerName = self.trackerName {
            try encodeContainer.encode(trackerName, forKey: .trackerName)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes {
    /// Contains the tracker resource details.
    public struct ListTrackersResponseEntry: Swift.Equatable {
        /// The timestamp for when the tracker resource was created in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description for the tracker resource.
        /// This member is required.
        public var description: Swift.String?
        /// Always returns RequestBasedUsage.
        @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// No longer used. Always returns an empty string.
        @available(*, deprecated, message: "Deprecated. Unused. API deprecated since 2022-02-01")
        public var pricingPlanDataSource: Swift.String?
        /// The name of the tracker resource.
        /// This member is required.
        public var trackerName: Swift.String?
        /// The timestamp at which the device's position was determined. Uses [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            pricingPlanDataSource: Swift.String? = nil,
            trackerName: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.trackerName = trackerName
            self.updateTime = updateTime
        }
    }

}

extension LocationClientTypes.MapConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case style = "Style"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let style = self.style {
            try encodeContainer.encode(style, forKey: .style)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let styleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .style)
        style = styleDecoded
    }
}

extension LocationClientTypes {
    /// Specifies the map tile style selected from an available provider.
    public struct MapConfiguration: Swift.Equatable {
        /// Specifies the map style selected from an available data provider. Valid [Esri map styles](https://docs.aws.amazon.com/location/latest/developerguide/esri.html):
        ///
        /// * VectorEsriDarkGrayCanvas – The Esri Dark Gray Canvas map style. A vector basemap with a dark gray, neutral background with minimal colors, labels, and features that's designed to draw attention to your thematic content.
        ///
        /// * RasterEsriImagery – The Esri Imagery map style. A raster basemap that provides one meter or better satellite and aerial imagery in many parts of the world and lower resolution satellite imagery worldwide.
        ///
        /// * VectorEsriLightGrayCanvas – The Esri Light Gray Canvas map style, which provides a detailed vector basemap with a light gray, neutral background style with minimal colors, labels, and features that's designed to draw attention to your thematic content.
        ///
        /// * VectorEsriTopographic – The Esri Light map style, which provides a detailed vector basemap with a classic Esri map style.
        ///
        /// * VectorEsriStreets – The Esri World Streets map style, which provides a detailed vector basemap for the world symbolized with a classic Esri street map style. The vector tile layer is similar in content and style to the World Street Map raster map.
        ///
        /// * VectorEsriNavigation – The Esri World Navigation map style, which provides a detailed basemap for the world symbolized with a custom navigation map style that's designed for use during the day in mobile devices.
        ///
        ///
        /// Valid [HERE Technologies map styles](https://docs.aws.amazon.com/location/latest/developerguide/HERE.html):
        ///
        /// * VectorHereContrast – The HERE Contrast (Berlin) map style is a high contrast detailed base map of the world that blends 3D and 2D rendering. The VectorHereContrast style has been renamed from VectorHereBerlin. VectorHereBerlin has been deprecated, but will continue to work in applications that use it.
        ///
        /// * VectorHereExplore – A default HERE map style containing a neutral, global map and its features including roads, buildings, landmarks, and water features. It also now includes a fully designed map of Japan.
        ///
        /// * VectorHereExploreTruck – A global map containing truck restrictions and attributes (e.g. width / height / HAZMAT) symbolized with highlighted segments and icons on top of HERE Explore to support use cases within transport and logistics.
        ///
        /// * RasterHereExploreSatellite – A global map containing high resolution satellite imagery.
        ///
        /// * HybridHereExploreSatellite – A global map displaying the road network, street names, and city labels over satellite imagery. This style will automatically retrieve both raster and vector tiles, and your charges will be based on total tiles retrieved. Hybrid styles use both vector and raster tiles when rendering the map that you see. This means that more tiles are retrieved than when using either vector or raster tiles alone. Your charges will include all tiles retrieved.
        ///
        ///
        /// Valid [Open Data (Preview) map styles](https://docs.aws.amazon.com/location/latest/developerguide/open-data.html):
        ///
        /// * VectorOpenDataStandardLight – The Open Data Standard Light (preview) map style provides a detailed basemap for the world suitable for website and mobile application use. The map includes highways major roads, minor roads, railways, water features, cities, parks, landmarks, building footprints, and administrative boundaries. Open Data maps is in preview. We may add, change, or remove features before announcing general availability. For more information, see [Open Data is in preview release](https://docs.aws.amazon.com/location/latest/developerguide/open-data.html#open-data-preview).
        /// This member is required.
        public var style: Swift.String?

        public init (
            style: Swift.String? = nil
        )
        {
            self.style = style
        }
    }

}

extension LocationClientTypes.Place: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressNumber = "AddressNumber"
        case country = "Country"
        case geometry = "Geometry"
        case interpolated = "Interpolated"
        case label = "Label"
        case municipality = "Municipality"
        case neighborhood = "Neighborhood"
        case postalCode = "PostalCode"
        case region = "Region"
        case street = "Street"
        case subRegion = "SubRegion"
        case timeZone = "TimeZone"
        case unitNumber = "UnitNumber"
        case unitType = "UnitType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressNumber = self.addressNumber {
            try encodeContainer.encode(addressNumber, forKey: .addressNumber)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let geometry = self.geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
        if let interpolated = self.interpolated {
            try encodeContainer.encode(interpolated, forKey: .interpolated)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let municipality = self.municipality {
            try encodeContainer.encode(municipality, forKey: .municipality)
        }
        if let neighborhood = self.neighborhood {
            try encodeContainer.encode(neighborhood, forKey: .neighborhood)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let street = self.street {
            try encodeContainer.encode(street, forKey: .street)
        }
        if let subRegion = self.subRegion {
            try encodeContainer.encode(subRegion, forKey: .subRegion)
        }
        if let timeZone = self.timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
        if let unitNumber = self.unitNumber {
            try encodeContainer.encode(unitNumber, forKey: .unitNumber)
        }
        if let unitType = self.unitType {
            try encodeContainer.encode(unitType, forKey: .unitType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PlaceGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let addressNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressNumber)
        addressNumber = addressNumberDecoded
        let streetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street)
        street = streetDecoded
        let neighborhoodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .neighborhood)
        neighborhood = neighborhoodDecoded
        let municipalityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .municipality)
        municipality = municipalityDecoded
        let subRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subRegion)
        subRegion = subRegionDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let interpolatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .interpolated)
        interpolated = interpolatedDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(LocationClientTypes.TimeZone.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let unitTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unitType)
        unitType = unitTypeDecoded
        let unitNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unitNumber)
        unitNumber = unitNumberDecoded
    }
}

extension LocationClientTypes {
    /// Contains details about addresses or points of interest that match the search criteria. Not all details are included with all responses. Some details may only be returned by specific data partners.
    public struct Place: Swift.Equatable {
        /// The numerical portion of an address, such as a building number.
        public var addressNumber: Swift.String?
        /// A country/region specified using [ISO 3166](https://www.iso.org/iso-3166-country-codes.html) 3-digit country/region code. For example, CAN.
        public var country: Swift.String?
        /// Places uses a point geometry to specify a location or a Place.
        /// This member is required.
        public var geometry: LocationClientTypes.PlaceGeometry?
        /// True if the result is interpolated from other known places. False if the Place is a known place. Not returned when the partner does not provide the information. For example, returns False for an address location that is found in the partner data, but returns True if an address does not exist in the partner data and its location is calculated by interpolating between other known addresses.
        public var interpolated: Swift.Bool?
        /// The full name and address of the point of interest such as a city, region, or country. For example, 123 Any Street, Any Town, USA.
        public var label: Swift.String?
        /// A name for a local area, such as a city or town name. For example, Toronto.
        public var municipality: Swift.String?
        /// The name of a community district. For example, Downtown.
        public var neighborhood: Swift.String?
        /// A group of numbers and letters in a country-specific format, which accompanies the address for the purpose of identifying a location.
        public var postalCode: Swift.String?
        /// A name for an area or geographical division, such as a province or state name. For example, British Columbia.
        public var region: Swift.String?
        /// The name for a street or a road to identify a location. For example, Main Street.
        public var street: Swift.String?
        /// A country, or an area that's part of a larger region. For example, Metro Vancouver.
        public var subRegion: Swift.String?
        /// The time zone in which the Place is located. Returned only when using HERE as the selected partner.
        public var timeZone: LocationClientTypes.TimeZone?
        /// For addresses with multiple units, the unit identifier. Can include numbers and letters, for example 3B or Unit 123. Returned only for a place index that uses Esri as a data provider. Is not returned for SearchPlaceIndexForPosition.
        public var unitNumber: Swift.String?
        /// For addresses with a UnitNumber, the type of unit. For example, Apartment.
        public var unitType: Swift.String?

        public init (
            addressNumber: Swift.String? = nil,
            country: Swift.String? = nil,
            geometry: LocationClientTypes.PlaceGeometry? = nil,
            interpolated: Swift.Bool? = nil,
            label: Swift.String? = nil,
            municipality: Swift.String? = nil,
            neighborhood: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            region: Swift.String? = nil,
            street: Swift.String? = nil,
            subRegion: Swift.String? = nil,
            timeZone: LocationClientTypes.TimeZone? = nil,
            unitNumber: Swift.String? = nil,
            unitType: Swift.String? = nil
        )
        {
            self.addressNumber = addressNumber
            self.country = country
            self.geometry = geometry
            self.interpolated = interpolated
            self.label = label
            self.municipality = municipality
            self.neighborhood = neighborhood
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.subRegion = subRegion
            self.timeZone = timeZone
            self.unitNumber = unitNumber
            self.unitType = unitType
        }
    }

}

extension LocationClientTypes.PlaceGeometry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case point = "Point"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let point = point {
            var pointContainer = encodeContainer.nestedUnkeyedContainer(forKey: .point)
            for double0 in point {
                try pointContainer.encode(double0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pointContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .point)
        var pointDecoded0:[Swift.Double]? = nil
        if let pointContainer = pointContainer {
            pointDecoded0 = [Swift.Double]()
            for double0 in pointContainer {
                if let double0 = double0 {
                    pointDecoded0?.append(double0)
                }
            }
        }
        point = pointDecoded0
    }
}

extension LocationClientTypes.PlaceGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlaceGeometry(point: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Places uses a point geometry to specify a location or a Place.
    public struct PlaceGeometry: Swift.Equatable {
        /// A single point geometry specifies a location for a Place using [WGS 84](https://gisgeography.com/wgs84-world-geodetic-system/) coordinates:
        ///
        /// * x — Specifies the x coordinate or longitude.
        ///
        /// * y — Specifies the y coordinate or latitude.
        public var point: [Swift.Double]?

        public init (
            point: [Swift.Double]? = nil
        )
        {
            self.point = point
        }
    }

}

extension LocationClientTypes {
    public enum PositionFiltering: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Filters device position updates according to their accuracy
        case accuracybased
        /// Filters device position updates according to the distance between them
        case distancebased
        /// Filters device position updates according to their sample time
        case timebased
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionFiltering] {
            return [
                .accuracybased,
                .distancebased,
                .timebased,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accuracybased: return "AccuracyBased"
            case .distancebased: return "DistanceBased"
            case .timebased: return "TimeBased"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PositionFiltering(rawValue: rawValue) ?? PositionFiltering.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes.PositionalAccuracy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case horizontal = "Horizontal"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let horizontal = self.horizontal {
            try encodeContainer.encode(horizontal, forKey: .horizontal)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let horizontalDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .horizontal)
        horizontal = horizontalDecoded
    }
}

extension LocationClientTypes {
    /// Defines the level of certainty of the position.
    public struct PositionalAccuracy: Swift.Equatable {
        /// Estimated maximum distance, in meters, between the measured position and the true position of a device, along the Earth's surface.
        /// This member is required.
        public var horizontal: Swift.Double?

        public init (
            horizontal: Swift.Double? = nil
        )
        {
            self.horizontal = horizontal
        }
    }

}

extension LocationClientTypes {
    public enum PricingPlan: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// This pricing plan must be picked for mobile asset management use cases
        case mobileassetmanagement
        /// This pricing plan must be picked for mobile asset tracking use cases.
        case mobileassettracking
        /// This pricing plan should be used for request based billing.
        case requestbasedusage
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingPlan] {
            return [
                .mobileassetmanagement,
                .mobileassettracking,
                .requestbasedusage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mobileassetmanagement: return "MobileAssetManagement"
            case .mobileassettracking: return "MobileAssetTracking"
            case .requestbasedusage: return "RequestBasedUsage"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PricingPlan(rawValue: rawValue) ?? PricingPlan.sdkUnknown(rawValue)
        }
    }
}

extension PutGeofenceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geometry = "Geometry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geometry = self.geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
    }
}

extension PutGeofenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collectionName = collectionName else {
            return nil
        }
        guard let geofenceId = geofenceId else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/geofences/\(geofenceId.urlPercentEncoding())"
    }
}

public struct PutGeofenceInput: Swift.Equatable {
    /// The geofence collection to store the geofence in.
    /// This member is required.
    public var collectionName: Swift.String?
    /// An identifier for the geofence. For example, ExampleGeofence-1.
    /// This member is required.
    public var geofenceId: Swift.String?
    /// Contains the details to specify the position of the geofence. Can be either a polygon or a circle. Including both will return a validation error. Each [ geofence polygon](https://docs.aws.amazon.com/location-geofences/latest/APIReference/API_GeofenceGeometry.html) can have a maximum of 1,000 vertices.
    /// This member is required.
    public var geometry: LocationClientTypes.GeofenceGeometry?

    public init (
        collectionName: Swift.String? = nil,
        geofenceId: Swift.String? = nil,
        geometry: LocationClientTypes.GeofenceGeometry? = nil
    )
    {
        self.collectionName = collectionName
        self.geofenceId = geofenceId
        self.geometry = geometry
    }
}

struct PutGeofenceInputBody: Swift.Equatable {
    let geometry: LocationClientTypes.GeofenceGeometry?
}

extension PutGeofenceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geometry = "Geometry"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.GeofenceGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
    }
}

extension PutGeofenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutGeofenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutGeofenceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutGeofenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutGeofenceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.geofenceId = output.geofenceId
            self.updateTime = output.updateTime
        } else {
            self.createTime = nil
            self.geofenceId = nil
            self.updateTime = nil
        }
    }
}

public struct PutGeofenceOutputResponse: Swift.Equatable {
    /// The timestamp for when the geofence was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The geofence identifier entered in the request.
    /// This member is required.
    public var geofenceId: Swift.String?
    /// The timestamp for when the geofence was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        createTime: ClientRuntime.Date? = nil,
        geofenceId: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.geofenceId = geofenceId
        self.updateTime = updateTime
    }
}

struct PutGeofenceOutputResponseBody: Swift.Equatable {
    let geofenceId: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
}

extension PutGeofenceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case geofenceId = "GeofenceId"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource that you've entered was not found in your AWS account.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes.RouteMatrixEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distance = "Distance"
        case durationSeconds = "DurationSeconds"
        case error = "Error"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distance = self.distance {
            try encodeContainer.encode(distance, forKey: .distance)
        }
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .distance)
        distance = distanceDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.RouteMatrixEntryError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes {
    /// The result for the calculated route of one DeparturePositionDestinationPosition pair.
    public struct RouteMatrixEntry: Swift.Equatable {
        /// The total distance of travel for the route.
        public var distance: Swift.Double?
        /// The expected duration of travel for the route.
        public var durationSeconds: Swift.Double?
        /// An error corresponding to the calculation of a route between the DeparturePosition and DestinationPosition.
        public var error: LocationClientTypes.RouteMatrixEntryError?

        public init (
            distance: Swift.Double? = nil,
            durationSeconds: Swift.Double? = nil,
            error: LocationClientTypes.RouteMatrixEntryError? = nil
        )
        {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.error = error
        }
    }

}

extension LocationClientTypes.RouteMatrixEntryError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.RouteMatrixErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes {
    /// An error corresponding to the calculation of a route between the DeparturePosition and DestinationPosition. The error code can be one of the following:
    ///
    /// * RouteNotFound - Unable to find a valid route with the given parameters.
    ///
    ///
    ///
    ///
    /// * RouteTooLong - Route calculation went beyond the maximum size of a route and was terminated before completion.
    ///
    ///
    ///
    ///
    /// * PositionsNotFound - One or more of the input positions were not found on the route network.
    ///
    ///
    ///
    ///
    /// * DestinationPositionNotFound - The destination position was not found on the route network.
    ///
    ///
    ///
    ///
    /// * DeparturePositionNotFound - The departure position was not found on the route network.
    ///
    ///
    ///
    ///
    /// * OtherValidationError - The given inputs were not valid or a route was not found. More information is given in the error Message
    public struct RouteMatrixEntryError: Swift.Equatable {
        /// The type of error which occurred for the route calculation.
        /// This member is required.
        public var code: LocationClientTypes.RouteMatrixErrorCode?
        /// A message about the error that occurred for the route calculation.
        public var message: Swift.String?

        public init (
            code: LocationClientTypes.RouteMatrixErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension LocationClientTypes {
    public enum RouteMatrixErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case departurepositionnotfound
        case destinationpositionnotfound
        case othervalidationerror
        case positionsnotfound
        case routenotfound
        case routetoolong
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteMatrixErrorCode] {
            return [
                .departurepositionnotfound,
                .destinationpositionnotfound,
                .othervalidationerror,
                .positionsnotfound,
                .routenotfound,
                .routetoolong,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .departurepositionnotfound: return "DeparturePositionNotFound"
            case .destinationpositionnotfound: return "DestinationPositionNotFound"
            case .othervalidationerror: return "OtherValidationError"
            case .positionsnotfound: return "PositionsNotFound"
            case .routenotfound: return "RouteNotFound"
            case .routetoolong: return "RouteTooLong"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteMatrixErrorCode(rawValue: rawValue) ?? RouteMatrixErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes.SearchForPositionResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distance = "Distance"
        case place = "Place"
        case placeId = "PlaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distance = self.distance {
            try encodeContainer.encode(distance, forKey: .distance)
        }
        if let place = self.place {
            try encodeContainer.encode(place, forKey: .place)
        }
        if let placeId = self.placeId {
            try encodeContainer.encode(placeId, forKey: .placeId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.Place.self, forKey: .place)
        place = placeDecoded
        let distanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .distance)
        distance = distanceDecoded
        let placeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placeId)
        placeId = placeIdDecoded
    }
}

extension LocationClientTypes {
    /// Contains a search result from a position search query that is run on a place index resource.
    public struct SearchForPositionResult: Swift.Equatable {
        /// The distance in meters of a great-circle arc between the query position and the result. A great-circle arc is the shortest path on a sphere, in this case the Earth. This returns the shortest distance between two locations.
        /// This member is required.
        public var distance: Swift.Double?
        /// Details about the search result, such as its address and position.
        /// This member is required.
        public var place: LocationClientTypes.Place?
        /// The unique identifier of the place. You can use this with the GetPlace operation to find the place again later. For SearchPlaceIndexForPosition operations, the PlaceId is returned only by place indexes that use HERE as a data provider.
        public var placeId: Swift.String?

        public init (
            distance: Swift.Double? = nil,
            place: LocationClientTypes.Place? = nil,
            placeId: Swift.String? = nil
        )
        {
            self.distance = distance
            self.place = place
            self.placeId = placeId
        }
    }

}

extension LocationClientTypes.SearchForSuggestionsResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case placeId = "PlaceId"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let placeId = self.placeId {
            try encodeContainer.encode(placeId, forKey: .placeId)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let placeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placeId)
        placeId = placeIdDecoded
    }
}

extension LocationClientTypes {
    /// Contains a place suggestion resulting from a place suggestion query that is run on a place index resource.
    public struct SearchForSuggestionsResult: Swift.Equatable {
        /// The unique identifier of the place. You can use this with the GetPlace operation to find the place again later. For SearchPlaceIndexForSuggestions operations, the PlaceId is returned by place indexes that use HERE or Esri as data providers.
        public var placeId: Swift.String?
        /// The text of the place suggestion, typically formatted as an address string.
        /// This member is required.
        public var text: Swift.String?

        public init (
            placeId: Swift.String? = nil,
            text: Swift.String? = nil
        )
        {
            self.placeId = placeId
            self.text = text
        }
    }

}

extension LocationClientTypes.SearchForTextResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distance = "Distance"
        case place = "Place"
        case placeId = "PlaceId"
        case relevance = "Relevance"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distance = self.distance {
            try encodeContainer.encode(distance, forKey: .distance)
        }
        if let place = self.place {
            try encodeContainer.encode(place, forKey: .place)
        }
        if let placeId = self.placeId {
            try encodeContainer.encode(placeId, forKey: .placeId)
        }
        if let relevance = self.relevance {
            try encodeContainer.encode(relevance, forKey: .relevance)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.Place.self, forKey: .place)
        place = placeDecoded
        let distanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .distance)
        distance = distanceDecoded
        let relevanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .relevance)
        relevance = relevanceDecoded
        let placeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placeId)
        placeId = placeIdDecoded
    }
}

extension LocationClientTypes {
    /// Contains a search result from a text search query that is run on a place index resource.
    public struct SearchForTextResult: Swift.Equatable {
        /// The distance in meters of a great-circle arc between the bias position specified and the result. Distance will be returned only if a bias position was specified in the query. A great-circle arc is the shortest path on a sphere, in this case the Earth. This returns the shortest distance between two locations.
        public var distance: Swift.Double?
        /// Details about the search result, such as its address and position.
        /// This member is required.
        public var place: LocationClientTypes.Place?
        /// The unique identifier of the place. You can use this with the GetPlace operation to find the place again later. For SearchPlaceIndexForText operations, the PlaceId is returned only by place indexes that use HERE as a data provider.
        public var placeId: Swift.String?
        /// The relative confidence in the match for a result among the results returned. For example, if more fields for an address match (including house number, street, city, country/region, and postal code), the relevance score is closer to 1. Returned only when the partner selected is Esri.
        public var relevance: Swift.Double?

        public init (
            distance: Swift.Double? = nil,
            place: LocationClientTypes.Place? = nil,
            placeId: Swift.String? = nil,
            relevance: Swift.Double? = nil
        )
        {
            self.distance = distance
            self.place = place
            self.placeId = placeId
            self.relevance = relevance
        }
    }

}

extension SearchPlaceIndexForPositionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForPositionInput(indexName: \(Swift.String(describing: indexName)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), position: \"CONTENT_REDACTED\")"}
}

extension SearchPlaceIndexForPositionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language = "Language"
        case maxResults = "MaxResults"
        case position = "Position"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for double0 in position {
                try positionContainer.encode(double0)
            }
        }
    }
}

extension SearchPlaceIndexForPositionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let indexName = indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())/search/position"
    }
}

public struct SearchPlaceIndexForPositionInput: Swift.Equatable {
    /// The name of the place index resource you want to use for the search.
    /// This member is required.
    public var indexName: Swift.String?
    /// The preferred language used to return results. The value must be a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for a location around Athens, Greece, with the language parameter set to en. The city in the results will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the city in the results will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    public var language: Swift.String?
    /// An optional parameter. The maximum number of results returned per request. Default value: 50
    public var maxResults: Swift.Int
    /// Specifies the longitude and latitude of the position to query. This parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents a position with longitude -123.1174 and latitude 49.2847.
    /// This member is required.
    public var position: [Swift.Double]?

    public init (
        indexName: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        position: [Swift.Double]? = nil
    )
    {
        self.indexName = indexName
        self.language = language
        self.maxResults = maxResults
        self.position = position
    }
}

struct SearchPlaceIndexForPositionInputBody: Swift.Equatable {
    let position: [Swift.Double]?
    let maxResults: Swift.Int
    let language: Swift.String?
}

extension SearchPlaceIndexForPositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language = "Language"
        case maxResults = "MaxResults"
        case position = "Position"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension SearchPlaceIndexForPositionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchPlaceIndexForPositionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchPlaceIndexForPositionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchPlaceIndexForPositionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchPlaceIndexForPositionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.results = output.results
            self.summary = output.summary
        } else {
            self.results = nil
            self.summary = nil
        }
    }
}

public struct SearchPlaceIndexForPositionOutputResponse: Swift.Equatable {
    /// Returns a list of Places closest to the specified position. Each result contains additional information about the Places returned.
    /// This member is required.
    public var results: [LocationClientTypes.SearchForPositionResult]?
    /// Contains a summary of the request. Echoes the input values for Position, Language, MaxResults, and the DataSource of the place index.
    /// This member is required.
    public var summary: LocationClientTypes.SearchPlaceIndexForPositionSummary?

    public init (
        results: [LocationClientTypes.SearchForPositionResult]? = nil,
        summary: LocationClientTypes.SearchPlaceIndexForPositionSummary? = nil
    )
    {
        self.results = results
        self.summary = summary
    }
}

struct SearchPlaceIndexForPositionOutputResponseBody: Swift.Equatable {
    let summary: LocationClientTypes.SearchPlaceIndexForPositionSummary?
    let results: [LocationClientTypes.SearchForPositionResult]?
}

extension SearchPlaceIndexForPositionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
        case summary = "Summary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.SearchPlaceIndexForPositionSummary.self, forKey: .summary)
        summary = summaryDecoded
        let resultsContainer = try containerValues.decodeIfPresent([LocationClientTypes.SearchForPositionResult?].self, forKey: .results)
        var resultsDecoded0:[LocationClientTypes.SearchForPositionResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [LocationClientTypes.SearchForPositionResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

extension LocationClientTypes.SearchPlaceIndexForPositionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case language = "Language"
        case maxResults = "MaxResults"
        case position = "Position"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for double0 in position {
                try positionContainer.encode(double0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension LocationClientTypes.SearchPlaceIndexForPositionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForPositionSummary(dataSource: \(Swift.String(describing: dataSource)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), position: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// A summary of the request sent by using SearchPlaceIndexForPosition.
    public struct SearchPlaceIndexForPositionSummary: Swift.Equatable {
        /// The geospatial data provider attached to the place index resource specified in the request. Values can be one of the following:
        ///
        /// * Esri
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// The preferred language used to return results. Matches the language in the request. The value is a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English.
        public var language: Swift.String?
        /// Contains the optional result count limit that is specified in the request. Default value: 50
        public var maxResults: Swift.Int
        /// The position specified in the request.
        /// This member is required.
        public var position: [Swift.Double]?

        public init (
            dataSource: Swift.String? = nil,
            language: Swift.String? = nil,
            maxResults: Swift.Int = 0,
            position: [Swift.Double]? = nil
        )
        {
            self.dataSource = dataSource
            self.language = language
            self.maxResults = maxResults
            self.position = position
        }
    }

}

extension SearchPlaceIndexForSuggestionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForSuggestionsInput(filterCountries: \(Swift.String(describing: filterCountries)), indexName: \(Swift.String(describing: indexName)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), biasPosition: \"CONTENT_REDACTED\", filterBBox: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension SearchPlaceIndexForSuggestionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case biasPosition = "BiasPosition"
        case filterBBox = "FilterBBox"
        case filterCountries = "FilterCountries"
        case language = "Language"
        case maxResults = "MaxResults"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let biasPosition = biasPosition {
            var biasPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .biasPosition)
            for double0 in biasPosition {
                try biasPositionContainer.encode(double0)
            }
        }
        if let filterBBox = filterBBox {
            var filterBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterBBox)
            for double0 in filterBBox {
                try filterBBoxContainer.encode(double0)
            }
        }
        if let filterCountries = filterCountries {
            var filterCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCountries)
            for countrycode0 in filterCountries {
                try filterCountriesContainer.encode(countrycode0)
            }
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension SearchPlaceIndexForSuggestionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let indexName = indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())/search/suggestions"
    }
}

public struct SearchPlaceIndexForSuggestionsInput: Swift.Equatable {
    /// An optional parameter that indicates a preference for place suggestions that are closer to a specified position. If provided, this parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847. BiasPosition and FilterBBox are mutually exclusive. Specifying both options results in an error.
    public var biasPosition: [Swift.Double]?
    /// An optional parameter that limits the search results by returning only suggestions within a specified bounding box. If provided, this parameter must contain a total of four consecutive numbers in two pairs. The first pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the southwest corner of the bounding box; the second pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the northeast corner of the bounding box. For example, [-12.7935, -37.4835, -12.0684, -36.9542] represents a bounding box where the southwest corner has longitude -12.7935 and latitude -37.4835, and the northeast corner has longitude -12.0684 and latitude -36.9542. FilterBBox and BiasPosition are mutually exclusive. Specifying both options results in an error.
    public var filterBBox: [Swift.Double]?
    /// An optional parameter that limits the search results by returning only suggestions within the provided list of countries.
    ///
    /// * Use the [ISO 3166](https://www.iso.org/iso-3166-country-codes.html) 3-digit country code. For example, Australia uses three upper-case characters: AUS.
    public var filterCountries: [Swift.String]?
    /// The name of the place index resource you want to use for the search.
    /// This member is required.
    public var indexName: Swift.String?
    /// The preferred language used to return results. The value must be a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English. This setting affects the languages used in the results. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for Athens, Gr to get suggestions with the language parameter set to en. The results found will most likely be returned as Athens, Greece. If you set the language parameter to el, for Greek, then the result found will more likely be returned as Αθήνα, Ελλάδα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    public var language: Swift.String?
    /// An optional parameter. The maximum number of results returned per request. The default: 5
    public var maxResults: Swift.Int?
    /// The free-form partial text to use to generate place suggestions. For example, eiffel tow.
    /// This member is required.
    public var text: Swift.String?

    public init (
        biasPosition: [Swift.Double]? = nil,
        filterBBox: [Swift.Double]? = nil,
        filterCountries: [Swift.String]? = nil,
        indexName: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        text: Swift.String? = nil
    )
    {
        self.biasPosition = biasPosition
        self.filterBBox = filterBBox
        self.filterCountries = filterCountries
        self.indexName = indexName
        self.language = language
        self.maxResults = maxResults
        self.text = text
    }
}

struct SearchPlaceIndexForSuggestionsInputBody: Swift.Equatable {
    let text: Swift.String?
    let biasPosition: [Swift.Double]?
    let filterBBox: [Swift.Double]?
    let filterCountries: [Swift.String]?
    let maxResults: Swift.Int?
    let language: Swift.String?
}

extension SearchPlaceIndexForSuggestionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case biasPosition = "BiasPosition"
        case filterBBox = "FilterBBox"
        case filterCountries = "FilterCountries"
        case language = "Language"
        case maxResults = "MaxResults"
        case text = "Text"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let biasPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .biasPosition)
        var biasPositionDecoded0:[Swift.Double]? = nil
        if let biasPositionContainer = biasPositionContainer {
            biasPositionDecoded0 = [Swift.Double]()
            for double0 in biasPositionContainer {
                if let double0 = double0 {
                    biasPositionDecoded0?.append(double0)
                }
            }
        }
        biasPosition = biasPositionDecoded0
        let filterBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .filterBBox)
        var filterBBoxDecoded0:[Swift.Double]? = nil
        if let filterBBoxContainer = filterBBoxContainer {
            filterBBoxDecoded0 = [Swift.Double]()
            for double0 in filterBBoxContainer {
                if let double0 = double0 {
                    filterBBoxDecoded0?.append(double0)
                }
            }
        }
        filterBBox = filterBBoxDecoded0
        let filterCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterCountries)
        var filterCountriesDecoded0:[Swift.String]? = nil
        if let filterCountriesContainer = filterCountriesContainer {
            filterCountriesDecoded0 = [Swift.String]()
            for string0 in filterCountriesContainer {
                if let string0 = string0 {
                    filterCountriesDecoded0?.append(string0)
                }
            }
        }
        filterCountries = filterCountriesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension SearchPlaceIndexForSuggestionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchPlaceIndexForSuggestionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchPlaceIndexForSuggestionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchPlaceIndexForSuggestionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchPlaceIndexForSuggestionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.results = output.results
            self.summary = output.summary
        } else {
            self.results = nil
            self.summary = nil
        }
    }
}

public struct SearchPlaceIndexForSuggestionsOutputResponse: Swift.Equatable {
    /// A list of place suggestions that best match the search text.
    /// This member is required.
    public var results: [LocationClientTypes.SearchForSuggestionsResult]?
    /// Contains a summary of the request. Echoes the input values for BiasPosition, FilterBBox, FilterCountries, Language, MaxResults, and Text. Also includes the DataSource of the place index.
    /// This member is required.
    public var summary: LocationClientTypes.SearchPlaceIndexForSuggestionsSummary?

    public init (
        results: [LocationClientTypes.SearchForSuggestionsResult]? = nil,
        summary: LocationClientTypes.SearchPlaceIndexForSuggestionsSummary? = nil
    )
    {
        self.results = results
        self.summary = summary
    }
}

struct SearchPlaceIndexForSuggestionsOutputResponseBody: Swift.Equatable {
    let summary: LocationClientTypes.SearchPlaceIndexForSuggestionsSummary?
    let results: [LocationClientTypes.SearchForSuggestionsResult]?
}

extension SearchPlaceIndexForSuggestionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
        case summary = "Summary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.SearchPlaceIndexForSuggestionsSummary.self, forKey: .summary)
        summary = summaryDecoded
        let resultsContainer = try containerValues.decodeIfPresent([LocationClientTypes.SearchForSuggestionsResult?].self, forKey: .results)
        var resultsDecoded0:[LocationClientTypes.SearchForSuggestionsResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [LocationClientTypes.SearchForSuggestionsResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

extension LocationClientTypes.SearchPlaceIndexForSuggestionsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case biasPosition = "BiasPosition"
        case dataSource = "DataSource"
        case filterBBox = "FilterBBox"
        case filterCountries = "FilterCountries"
        case language = "Language"
        case maxResults = "MaxResults"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let biasPosition = biasPosition {
            var biasPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .biasPosition)
            for double0 in biasPosition {
                try biasPositionContainer.encode(double0)
            }
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let filterBBox = filterBBox {
            var filterBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterBBox)
            for double0 in filterBBox {
                try filterBBoxContainer.encode(double0)
            }
        }
        if let filterCountries = filterCountries {
            var filterCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCountries)
            for countrycode0 in filterCountries {
                try filterCountriesContainer.encode(countrycode0)
            }
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let biasPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .biasPosition)
        var biasPositionDecoded0:[Swift.Double]? = nil
        if let biasPositionContainer = biasPositionContainer {
            biasPositionDecoded0 = [Swift.Double]()
            for double0 in biasPositionContainer {
                if let double0 = double0 {
                    biasPositionDecoded0?.append(double0)
                }
            }
        }
        biasPosition = biasPositionDecoded0
        let filterBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .filterBBox)
        var filterBBoxDecoded0:[Swift.Double]? = nil
        if let filterBBoxContainer = filterBBoxContainer {
            filterBBoxDecoded0 = [Swift.Double]()
            for double0 in filterBBoxContainer {
                if let double0 = double0 {
                    filterBBoxDecoded0?.append(double0)
                }
            }
        }
        filterBBox = filterBBoxDecoded0
        let filterCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterCountries)
        var filterCountriesDecoded0:[Swift.String]? = nil
        if let filterCountriesContainer = filterCountriesContainer {
            filterCountriesDecoded0 = [Swift.String]()
            for string0 in filterCountriesContainer {
                if let string0 = string0 {
                    filterCountriesDecoded0?.append(string0)
                }
            }
        }
        filterCountries = filterCountriesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension LocationClientTypes.SearchPlaceIndexForSuggestionsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForSuggestionsSummary(dataSource: \(Swift.String(describing: dataSource)), filterCountries: \(Swift.String(describing: filterCountries)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), biasPosition: \"CONTENT_REDACTED\", filterBBox: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// A summary of the request sent by using SearchPlaceIndexForSuggestions.
    public struct SearchPlaceIndexForSuggestionsSummary: Swift.Equatable {
        /// Contains the coordinates for the optional bias position specified in the request. This parameter contains a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.
        public var biasPosition: [Swift.Double]?
        /// The geospatial data provider attached to the place index resource specified in the request. Values can be one of the following:
        ///
        /// * Esri
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// Contains the coordinates for the optional bounding box specified in the request.
        public var filterBBox: [Swift.Double]?
        /// Contains the optional country filter specified in the request.
        public var filterCountries: [Swift.String]?
        /// The preferred language used to return results. Matches the language in the request. The value is a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English.
        public var language: Swift.String?
        /// Contains the optional result count limit specified in the request.
        public var maxResults: Swift.Int?
        /// The free-form partial text input specified in the request.
        /// This member is required.
        public var text: Swift.String?

        public init (
            biasPosition: [Swift.Double]? = nil,
            dataSource: Swift.String? = nil,
            filterBBox: [Swift.Double]? = nil,
            filterCountries: [Swift.String]? = nil,
            language: Swift.String? = nil,
            maxResults: Swift.Int? = nil,
            text: Swift.String? = nil
        )
        {
            self.biasPosition = biasPosition
            self.dataSource = dataSource
            self.filterBBox = filterBBox
            self.filterCountries = filterCountries
            self.language = language
            self.maxResults = maxResults
            self.text = text
        }
    }

}

extension SearchPlaceIndexForTextInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForTextInput(filterCountries: \(Swift.String(describing: filterCountries)), indexName: \(Swift.String(describing: indexName)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), biasPosition: \"CONTENT_REDACTED\", filterBBox: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension SearchPlaceIndexForTextInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case biasPosition = "BiasPosition"
        case filterBBox = "FilterBBox"
        case filterCountries = "FilterCountries"
        case language = "Language"
        case maxResults = "MaxResults"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let biasPosition = biasPosition {
            var biasPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .biasPosition)
            for double0 in biasPosition {
                try biasPositionContainer.encode(double0)
            }
        }
        if let filterBBox = filterBBox {
            var filterBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterBBox)
            for double0 in filterBBox {
                try filterBBoxContainer.encode(double0)
            }
        }
        if let filterCountries = filterCountries {
            var filterCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCountries)
            for countrycode0 in filterCountries {
                try filterCountriesContainer.encode(countrycode0)
            }
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension SearchPlaceIndexForTextInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let indexName = indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())/search/text"
    }
}

public struct SearchPlaceIndexForTextInput: Swift.Equatable {
    /// An optional parameter that indicates a preference for places that are closer to a specified position. If provided, this parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847. BiasPosition and FilterBBox are mutually exclusive. Specifying both options results in an error.
    public var biasPosition: [Swift.Double]?
    /// An optional parameter that limits the search results by returning only places that are within the provided bounding box. If provided, this parameter must contain a total of four consecutive numbers in two pairs. The first pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the southwest corner of the bounding box; the second pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the northeast corner of the bounding box. For example, [-12.7935, -37.4835, -12.0684, -36.9542] represents a bounding box where the southwest corner has longitude -12.7935 and latitude -37.4835, and the northeast corner has longitude -12.0684 and latitude -36.9542. FilterBBox and BiasPosition are mutually exclusive. Specifying both options results in an error.
    public var filterBBox: [Swift.Double]?
    /// An optional parameter that limits the search results by returning only places that are in a specified list of countries.
    ///
    /// * Valid values include [ISO 3166](https://www.iso.org/iso-3166-country-codes.html) 3-digit country codes. For example, Australia uses three upper-case characters: AUS.
    public var filterCountries: [Swift.String]?
    /// The name of the place index resource you want to use for the search.
    /// This member is required.
    public var indexName: Swift.String?
    /// The preferred language used to return results. The value must be a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for Athens, Greece, with the language parameter set to en. The result found will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the result found will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    public var language: Swift.String?
    /// An optional parameter. The maximum number of results returned per request. The default: 50
    public var maxResults: Swift.Int
    /// The address, name, city, or region to be used in the search in free-form text format. For example, 123 Any Street.
    /// This member is required.
    public var text: Swift.String?

    public init (
        biasPosition: [Swift.Double]? = nil,
        filterBBox: [Swift.Double]? = nil,
        filterCountries: [Swift.String]? = nil,
        indexName: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        text: Swift.String? = nil
    )
    {
        self.biasPosition = biasPosition
        self.filterBBox = filterBBox
        self.filterCountries = filterCountries
        self.indexName = indexName
        self.language = language
        self.maxResults = maxResults
        self.text = text
    }
}

struct SearchPlaceIndexForTextInputBody: Swift.Equatable {
    let text: Swift.String?
    let biasPosition: [Swift.Double]?
    let filterBBox: [Swift.Double]?
    let filterCountries: [Swift.String]?
    let maxResults: Swift.Int
    let language: Swift.String?
}

extension SearchPlaceIndexForTextInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case biasPosition = "BiasPosition"
        case filterBBox = "FilterBBox"
        case filterCountries = "FilterCountries"
        case language = "Language"
        case maxResults = "MaxResults"
        case text = "Text"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let biasPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .biasPosition)
        var biasPositionDecoded0:[Swift.Double]? = nil
        if let biasPositionContainer = biasPositionContainer {
            biasPositionDecoded0 = [Swift.Double]()
            for double0 in biasPositionContainer {
                if let double0 = double0 {
                    biasPositionDecoded0?.append(double0)
                }
            }
        }
        biasPosition = biasPositionDecoded0
        let filterBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .filterBBox)
        var filterBBoxDecoded0:[Swift.Double]? = nil
        if let filterBBoxContainer = filterBBoxContainer {
            filterBBoxDecoded0 = [Swift.Double]()
            for double0 in filterBBoxContainer {
                if let double0 = double0 {
                    filterBBoxDecoded0?.append(double0)
                }
            }
        }
        filterBBox = filterBBoxDecoded0
        let filterCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterCountries)
        var filterCountriesDecoded0:[Swift.String]? = nil
        if let filterCountriesContainer = filterCountriesContainer {
            filterCountriesDecoded0 = [Swift.String]()
            for string0 in filterCountriesContainer {
                if let string0 = string0 {
                    filterCountriesDecoded0?.append(string0)
                }
            }
        }
        filterCountries = filterCountriesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension SearchPlaceIndexForTextOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchPlaceIndexForTextOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchPlaceIndexForTextOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchPlaceIndexForTextOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchPlaceIndexForTextOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.results = output.results
            self.summary = output.summary
        } else {
            self.results = nil
            self.summary = nil
        }
    }
}

public struct SearchPlaceIndexForTextOutputResponse: Swift.Equatable {
    /// A list of Places matching the input text. Each result contains additional information about the specific point of interest. Not all response properties are included with all responses. Some properties may only be returned by specific data partners.
    /// This member is required.
    public var results: [LocationClientTypes.SearchForTextResult]?
    /// Contains a summary of the request. Echoes the input values for BiasPosition, FilterBBox, FilterCountries, Language, MaxResults, and Text. Also includes the DataSource of the place index and the bounding box, ResultBBox, which surrounds the search results.
    /// This member is required.
    public var summary: LocationClientTypes.SearchPlaceIndexForTextSummary?

    public init (
        results: [LocationClientTypes.SearchForTextResult]? = nil,
        summary: LocationClientTypes.SearchPlaceIndexForTextSummary? = nil
    )
    {
        self.results = results
        self.summary = summary
    }
}

struct SearchPlaceIndexForTextOutputResponseBody: Swift.Equatable {
    let summary: LocationClientTypes.SearchPlaceIndexForTextSummary?
    let results: [LocationClientTypes.SearchForTextResult]?
}

extension SearchPlaceIndexForTextOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
        case summary = "Summary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.SearchPlaceIndexForTextSummary.self, forKey: .summary)
        summary = summaryDecoded
        let resultsContainer = try containerValues.decodeIfPresent([LocationClientTypes.SearchForTextResult?].self, forKey: .results)
        var resultsDecoded0:[LocationClientTypes.SearchForTextResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [LocationClientTypes.SearchForTextResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

extension LocationClientTypes.SearchPlaceIndexForTextSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case biasPosition = "BiasPosition"
        case dataSource = "DataSource"
        case filterBBox = "FilterBBox"
        case filterCountries = "FilterCountries"
        case language = "Language"
        case maxResults = "MaxResults"
        case resultBBox = "ResultBBox"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let biasPosition = biasPosition {
            var biasPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .biasPosition)
            for double0 in biasPosition {
                try biasPositionContainer.encode(double0)
            }
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let filterBBox = filterBBox {
            var filterBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterBBox)
            for double0 in filterBBox {
                try filterBBoxContainer.encode(double0)
            }
        }
        if let filterCountries = filterCountries {
            var filterCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCountries)
            for countrycode0 in filterCountries {
                try filterCountriesContainer.encode(countrycode0)
            }
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let resultBBox = resultBBox {
            var resultBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resultBBox)
            for double0 in resultBBox {
                try resultBBoxContainer.encode(double0)
            }
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let biasPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .biasPosition)
        var biasPositionDecoded0:[Swift.Double]? = nil
        if let biasPositionContainer = biasPositionContainer {
            biasPositionDecoded0 = [Swift.Double]()
            for double0 in biasPositionContainer {
                if let double0 = double0 {
                    biasPositionDecoded0?.append(double0)
                }
            }
        }
        biasPosition = biasPositionDecoded0
        let filterBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .filterBBox)
        var filterBBoxDecoded0:[Swift.Double]? = nil
        if let filterBBoxContainer = filterBBoxContainer {
            filterBBoxDecoded0 = [Swift.Double]()
            for double0 in filterBBoxContainer {
                if let double0 = double0 {
                    filterBBoxDecoded0?.append(double0)
                }
            }
        }
        filterBBox = filterBBoxDecoded0
        let filterCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterCountries)
        var filterCountriesDecoded0:[Swift.String]? = nil
        if let filterCountriesContainer = filterCountriesContainer {
            filterCountriesDecoded0 = [Swift.String]()
            for string0 in filterCountriesContainer {
                if let string0 = string0 {
                    filterCountriesDecoded0?.append(string0)
                }
            }
        }
        filterCountries = filterCountriesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let resultBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .resultBBox)
        var resultBBoxDecoded0:[Swift.Double]? = nil
        if let resultBBoxContainer = resultBBoxContainer {
            resultBBoxDecoded0 = [Swift.Double]()
            for double0 in resultBBoxContainer {
                if let double0 = double0 {
                    resultBBoxDecoded0?.append(double0)
                }
            }
        }
        resultBBox = resultBBoxDecoded0
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension LocationClientTypes.SearchPlaceIndexForTextSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForTextSummary(dataSource: \(Swift.String(describing: dataSource)), filterCountries: \(Swift.String(describing: filterCountries)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), biasPosition: \"CONTENT_REDACTED\", filterBBox: \"CONTENT_REDACTED\", resultBBox: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// A summary of the request sent by using SearchPlaceIndexForText.
    public struct SearchPlaceIndexForTextSummary: Swift.Equatable {
        /// Contains the coordinates for the optional bias position specified in the request. This parameter contains a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.
        public var biasPosition: [Swift.Double]?
        /// The geospatial data provider attached to the place index resource specified in the request. Values can be one of the following:
        ///
        /// * Esri
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// Contains the coordinates for the optional bounding box specified in the request.
        public var filterBBox: [Swift.Double]?
        /// Contains the optional country filter specified in the request.
        public var filterCountries: [Swift.String]?
        /// The preferred language used to return results. Matches the language in the request. The value is a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English.
        public var language: Swift.String?
        /// Contains the optional result count limit specified in the request.
        public var maxResults: Swift.Int
        /// The bounding box that fully contains all search results. If you specified the optional FilterBBox parameter in the request, ResultBBox is contained within FilterBBox.
        public var resultBBox: [Swift.Double]?
        /// The search text specified in the request.
        /// This member is required.
        public var text: Swift.String?

        public init (
            biasPosition: [Swift.Double]? = nil,
            dataSource: Swift.String? = nil,
            filterBBox: [Swift.Double]? = nil,
            filterCountries: [Swift.String]? = nil,
            language: Swift.String? = nil,
            maxResults: Swift.Int = 0,
            resultBBox: [Swift.Double]? = nil,
            text: Swift.String? = nil
        )
        {
            self.biasPosition = biasPosition
            self.dataSource = dataSource
            self.filterBBox = filterBBox
            self.filterCountries = filterCountries
            self.language = language
            self.maxResults = maxResults
            self.resultBBox = resultBBox
            self.text = text
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation was denied because the request would exceed the maximum [quota](https://docs.aws.amazon.com/location/latest/developerguide/location-quotas.html) set for Amazon Location Service.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message with the reason for the service quota exceeded exception error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes.Step: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distance = "Distance"
        case durationSeconds = "DurationSeconds"
        case endPosition = "EndPosition"
        case geometryOffset = "GeometryOffset"
        case startPosition = "StartPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distance = self.distance {
            try encodeContainer.encode(distance, forKey: .distance)
        }
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let endPosition = endPosition {
            var endPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endPosition)
            for double0 in endPosition {
                try endPositionContainer.encode(double0)
            }
        }
        if let geometryOffset = self.geometryOffset {
            try encodeContainer.encode(geometryOffset, forKey: .geometryOffset)
        }
        if let startPosition = startPosition {
            var startPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startPosition)
            for double0 in startPosition {
                try startPositionContainer.encode(double0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .startPosition)
        var startPositionDecoded0:[Swift.Double]? = nil
        if let startPositionContainer = startPositionContainer {
            startPositionDecoded0 = [Swift.Double]()
            for double0 in startPositionContainer {
                if let double0 = double0 {
                    startPositionDecoded0?.append(double0)
                }
            }
        }
        startPosition = startPositionDecoded0
        let endPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .endPosition)
        var endPositionDecoded0:[Swift.Double]? = nil
        if let endPositionContainer = endPositionContainer {
            endPositionDecoded0 = [Swift.Double]()
            for double0 in endPositionContainer {
                if let double0 = double0 {
                    endPositionDecoded0?.append(double0)
                }
            }
        }
        endPosition = endPositionDecoded0
        let distanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .distance)
        distance = distanceDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let geometryOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .geometryOffset)
        geometryOffset = geometryOffsetDecoded
    }
}

extension LocationClientTypes.Step: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Step(distance: \(Swift.String(describing: distance)), durationSeconds: \(Swift.String(describing: durationSeconds)), geometryOffset: \(Swift.String(describing: geometryOffset)), endPosition: \"CONTENT_REDACTED\", startPosition: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Represents an element of a leg within a route. A step contains instructions for how to move to the next step in the leg.
    public struct Step: Swift.Equatable {
        /// The travel distance between the step's StartPosition and EndPosition.
        /// This member is required.
        public var distance: Swift.Double?
        /// The estimated travel time, in seconds, from the step's StartPosition to the EndPosition. . The travel mode and departure time that you specify in the request determines the calculated time.
        /// This member is required.
        public var durationSeconds: Swift.Double?
        /// The end position of a step. If the position the last step in the leg, this position is the same as the end position of the leg.
        /// This member is required.
        public var endPosition: [Swift.Double]?
        /// Represents the start position, or index, in a sequence of steps within the leg's line string geometry. For example, the index of the first step in a leg geometry is 0. Included in the response for queries that set IncludeLegGeometry to True.
        public var geometryOffset: Swift.Int?
        /// The starting position of a step. If the position is the first step in the leg, this position is the same as the start position of the leg.
        /// This member is required.
        public var startPosition: [Swift.Double]?

        public init (
            distance: Swift.Double? = nil,
            durationSeconds: Swift.Double? = nil,
            endPosition: [Swift.Double]? = nil,
            geometryOffset: Swift.Int? = nil,
            startPosition: [Swift.Double]? = nil
        )
        {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.endPosition = endPosition
            self.geometryOffset = geometryOffset
            self.startPosition = startPosition
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource whose tags you want to update.
    ///
    /// * Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Applies one or more tags to specific resource. A tag is a key-value pair that helps you manage, identify, search, and filter your resources. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource.
    ///
    /// * Each tag key must be unique and must have exactly one associated value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied because of request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes.TimeZone: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case offset = "Offset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let offset = self.offset {
            try encodeContainer.encode(offset, forKey: .offset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offset)
        offset = offsetDecoded
    }
}

extension LocationClientTypes {
    /// Information about a time zone. Includes the name of the time zone and the offset from UTC in seconds.
    public struct TimeZone: Swift.Equatable {
        /// The name of the time zone, following the [ IANA time zone standard](https://www.iana.org/time-zones). For example, America/Los_Angeles.
        /// This member is required.
        public var name: Swift.String?
        /// The time zone's offset, in seconds, from UTC.
        public var offset: Swift.Int?

        public init (
            name: Swift.String? = nil,
            offset: Swift.Int? = nil
        )
        {
            self.name = name
            self.offset = offset
        }
    }

}

extension LocationClientTypes {
    public enum TravelMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case car
        case truck
        case walking
        case sdkUnknown(Swift.String)

        public static var allCases: [TravelMode] {
            return [
                .car,
                .truck,
                .walking,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .car: return "Car"
            case .truck: return "Truck"
            case .walking: return "Walking"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TravelMode(rawValue: rawValue) ?? TravelMode.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes.TruckDimensions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case height = "Height"
        case length = "Length"
        case unit = "Unit"
        case width = "Width"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let height = self.height {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let length = self.length {
            try encodeContainer.encode(length, forKey: .length)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let width = self.width {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lengthDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .length)
        length = lengthDecoded
        let heightDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .height)
        height = heightDecoded
        let widthDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .width)
        width = widthDecoded
        let unitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DimensionUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension LocationClientTypes {
    /// Contains details about the truck dimensions in the unit of measurement that you specify. Used to filter out roads that can't support or allow the specified dimensions for requests that specify TravelMode as Truck.
    public struct TruckDimensions: Swift.Equatable {
        /// The height of the truck.
        ///
        /// * For example, 4.5.
        ///
        ///
        /// For routes calculated with a HERE resource, this value must be between 0 and 50 meters.
        public var height: Swift.Double?
        /// The length of the truck.
        ///
        /// * For example, 15.5.
        ///
        ///
        /// For routes calculated with a HERE resource, this value must be between 0 and 300 meters.
        public var length: Swift.Double?
        /// Specifies the unit of measurement for the truck dimensions. Default Value: Meters
        public var unit: LocationClientTypes.DimensionUnit?
        /// The width of the truck.
        ///
        /// * For example, 4.5.
        ///
        ///
        /// For routes calculated with a HERE resource, this value must be between 0 and 50 meters.
        public var width: Swift.Double?

        public init (
            height: Swift.Double? = nil,
            length: Swift.Double? = nil,
            unit: LocationClientTypes.DimensionUnit? = nil,
            width: Swift.Double? = nil
        )
        {
            self.height = height
            self.length = length
            self.unit = unit
            self.width = width
        }
    }

}

extension LocationClientTypes.TruckWeight: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case total = "Total"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .total)
        total = totalDecoded
        let unitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.VehicleWeightUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension LocationClientTypes {
    /// Contains details about the truck's weight specifications. Used to avoid roads that can't support or allow the total weight for requests that specify TravelMode as Truck.
    public struct TruckWeight: Swift.Equatable {
        /// The total weight of the truck.
        ///
        /// * For example, 3500.
        public var total: Swift.Double?
        /// The unit of measurement to use for the truck weight. Default Value: Kilograms
        public var unit: LocationClientTypes.VehicleWeightUnit?

        public init (
            total: Swift.Double? = nil,
            unit: LocationClientTypes.VehicleWeightUnit? = nil
        )
        {
            self.total = total
            self.unit = unit
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource from which you want to remove tags.
    ///
    /// * Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateGeofenceCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = self.pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
    }
}

extension UpdateGeofenceCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collectionName = collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())"
    }
}

public struct UpdateGeofenceCollectionInput: Swift.Equatable {
    /// The name of the geofence collection to update.
    /// This member is required.
    public var collectionName: Swift.String?
    /// Updates the description for the geofence collection.
    public var description: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// This parameter is no longer used.
    @available(*, deprecated, message: "Deprecated. No longer allowed. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?

    public init (
        collectionName: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
        self.description = description
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
    }
}

struct UpdateGeofenceCollectionInputBody: Swift.Equatable {
    let pricingPlan: LocationClientTypes.PricingPlan?
    let pricingPlanDataSource: Swift.String?
    let description: Swift.String?
}

extension UpdateGeofenceCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGeofenceCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGeofenceCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGeofenceCollectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGeofenceCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateGeofenceCollectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.collectionArn = output.collectionArn
            self.collectionName = output.collectionName
            self.updateTime = output.updateTime
        } else {
            self.collectionArn = nil
            self.collectionName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateGeofenceCollectionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated geofence collection. Used to specify a resource across AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
    /// This member is required.
    public var collectionArn: Swift.String?
    /// The name of the updated geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The time when the geofence collection was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        collectionArn: Swift.String? = nil,
        collectionName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.collectionArn = collectionArn
        self.collectionName = collectionName
        self.updateTime = updateTime
    }
}

struct UpdateGeofenceCollectionOutputResponseBody: Swift.Equatable {
    let collectionName: Swift.String?
    let collectionArn: Swift.String?
    let updateTime: ClientRuntime.Date?
}

extension UpdateGeofenceCollectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionArn = "CollectionArn"
        case collectionName = "CollectionName"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let collectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionArn)
        collectionArn = collectionArnDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension UpdateMapInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
    }
}

extension UpdateMapInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mapName = mapName else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())"
    }
}

public struct UpdateMapInput: Swift.Equatable {
    /// Updates the description for the map resource.
    public var description: Swift.String?
    /// The name of the map resource to update.
    /// This member is required.
    public var mapName: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?

    public init (
        description: Swift.String? = nil,
        mapName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil
    )
    {
        self.description = description
        self.mapName = mapName
        self.pricingPlan = pricingPlan
    }
}

struct UpdateMapInputBody: Swift.Equatable {
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
}

extension UpdateMapInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateMapOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMapOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateMapOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMapOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateMapOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mapArn = output.mapArn
            self.mapName = output.mapName
            self.updateTime = output.updateTime
        } else {
            self.mapArn = nil
            self.mapName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateMapOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated map resource. Used to specify a resource across AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:map/ExampleMap
    /// This member is required.
    public var mapArn: Swift.String?
    /// The name of the updated map resource.
    /// This member is required.
    public var mapName: Swift.String?
    /// The timestamp for when the map resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        mapArn: Swift.String? = nil,
        mapName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.mapArn = mapArn
        self.mapName = mapName
        self.updateTime = updateTime
    }
}

struct UpdateMapOutputResponseBody: Swift.Equatable {
    let mapName: Swift.String?
    let mapArn: Swift.String?
    let updateTime: ClientRuntime.Date?
}

extension UpdateMapOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mapArn = "MapArn"
        case mapName = "MapName"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapName)
        mapName = mapNameDecoded
        let mapArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapArn)
        mapArn = mapArnDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension UpdatePlaceIndexInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceConfiguration = "DataSourceConfiguration"
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceConfiguration = self.dataSourceConfiguration {
            try encodeContainer.encode(dataSourceConfiguration, forKey: .dataSourceConfiguration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
    }
}

extension UpdatePlaceIndexInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let indexName = indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())"
    }
}

public struct UpdatePlaceIndexInput: Swift.Equatable {
    /// Updates the data storage option for the place index resource.
    public var dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    /// Updates the description for the place index resource.
    public var description: Swift.String?
    /// The name of the place index resource to update.
    /// This member is required.
    public var indexName: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?

    public init (
        dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        indexName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil
    )
    {
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.indexName = indexName
        self.pricingPlan = pricingPlan
    }
}

struct UpdatePlaceIndexInputBody: Swift.Equatable {
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
    let dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
}

extension UpdatePlaceIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceConfiguration = "DataSourceConfiguration"
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
    }
}

extension UpdatePlaceIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePlaceIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePlaceIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePlaceIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdatePlaceIndexOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.indexArn = output.indexArn
            self.indexName = output.indexName
            self.updateTime = output.updateTime
        } else {
            self.indexArn = nil
            self.indexName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdatePlaceIndexOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the upated place index resource. Used to specify a resource across AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:place- index/ExamplePlaceIndex
    /// This member is required.
    public var indexArn: Swift.String?
    /// The name of the updated place index resource.
    /// This member is required.
    public var indexName: Swift.String?
    /// The timestamp for when the place index resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.indexArn = indexArn
        self.indexName = indexName
        self.updateTime = updateTime
    }
}

struct UpdatePlaceIndexOutputResponseBody: Swift.Equatable {
    let indexName: Swift.String?
    let indexArn: Swift.String?
    let updateTime: ClientRuntime.Date?
}

extension UpdatePlaceIndexOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexArn = "IndexArn"
        case indexName = "IndexName"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let indexArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexArn)
        indexArn = indexArnDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension UpdateRouteCalculatorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
    }
}

extension UpdateRouteCalculatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let calculatorName = calculatorName else {
            return nil
        }
        return "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())"
    }
}

public struct UpdateRouteCalculatorInput: Swift.Equatable {
    /// The name of the route calculator resource to update.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// Updates the description for the route calculator resource.
    public var description: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?

    public init (
        calculatorName: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil
    )
    {
        self.calculatorName = calculatorName
        self.description = description
        self.pricingPlan = pricingPlan
    }
}

struct UpdateRouteCalculatorInputBody: Swift.Equatable {
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
}

extension UpdateRouteCalculatorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRouteCalculatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRouteCalculatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRouteCalculatorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRouteCalculatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateRouteCalculatorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.calculatorArn = output.calculatorArn
            self.calculatorName = output.calculatorName
            self.updateTime = output.updateTime
        } else {
            self.calculatorArn = nil
            self.calculatorName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateRouteCalculatorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated route calculator resource. Used to specify a resource across AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:route- calculator/ExampleCalculator
    /// This member is required.
    public var calculatorArn: Swift.String?
    /// The name of the updated route calculator resource.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// The timestamp for when the route calculator was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        calculatorArn: Swift.String? = nil,
        calculatorName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.calculatorArn = calculatorArn
        self.calculatorName = calculatorName
        self.updateTime = updateTime
    }
}

struct UpdateRouteCalculatorOutputResponseBody: Swift.Equatable {
    let calculatorName: Swift.String?
    let calculatorArn: Swift.String?
    let updateTime: ClientRuntime.Date?
}

extension UpdateRouteCalculatorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorArn = "CalculatorArn"
        case calculatorName = "CalculatorName"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorName)
        calculatorName = calculatorNameDecoded
        let calculatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorArn)
        calculatorArn = calculatorArnDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension UpdateTrackerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case positionFiltering = "PositionFiltering"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let positionFiltering = self.positionFiltering {
            try encodeContainer.encode(positionFiltering.rawValue, forKey: .positionFiltering)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = self.pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
    }
}

extension UpdateTrackerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let trackerName = trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())"
    }
}

public struct UpdateTrackerInput: Swift.Equatable {
    /// Updates the description for the tracker resource.
    public var description: Swift.String?
    /// Updates the position filtering for the tracker resource. Valid values:
    ///
    /// * TimeBased - Location updates are evaluated against linked geofence collections, but not every location update is stored. If your update frequency is more often than 30 seconds, only one update per 30 seconds is stored for each unique device ID.
    ///
    /// * DistanceBased - If the device has moved less than 30 m (98.4 ft), location updates are ignored. Location updates within this distance are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map.
    ///
    /// * AccuracyBased - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This helps educe the effects of GPS noise when displaying device trajectories on a map, and can help control costs by reducing the number of geofence evaluations.
    public var positionFiltering: LocationClientTypes.PositionFiltering?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// This parameter is no longer used.
    @available(*, deprecated, message: "Deprecated. No longer allowed. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?
    /// The name of the tracker resource to update.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        description: Swift.String? = nil,
        positionFiltering: LocationClientTypes.PositionFiltering? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.description = description
        self.positionFiltering = positionFiltering
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.trackerName = trackerName
    }
}

struct UpdateTrackerInputBody: Swift.Equatable {
    let pricingPlan: LocationClientTypes.PricingPlan?
    let pricingPlanDataSource: Swift.String?
    let description: Swift.String?
    let positionFiltering: LocationClientTypes.PositionFiltering?
}

extension UpdateTrackerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case positionFiltering = "PositionFiltering"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let positionFilteringDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PositionFiltering.self, forKey: .positionFiltering)
        positionFiltering = positionFilteringDecoded
    }
}

extension UpdateTrackerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTrackerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateTrackerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTrackerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateTrackerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trackerArn = output.trackerArn
            self.trackerName = output.trackerName
            self.updateTime = output.updateTime
        } else {
            self.trackerArn = nil
            self.trackerName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateTrackerOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated tracker resource. Used to specify a resource across AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
    /// This member is required.
    public var trackerArn: Swift.String?
    /// The name of the updated tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?
    /// The timestamp for when the tracker resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        trackerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.trackerArn = trackerArn
        self.trackerName = trackerName
        self.updateTime = updateTime
    }
}

struct UpdateTrackerOutputResponseBody: Swift.Equatable {
    let trackerName: Swift.String?
    let trackerArn: Swift.String?
    let updateTime: ClientRuntime.Date?
}

extension UpdateTrackerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trackerArn = "TrackerArn"
        case trackerName = "TrackerName"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let trackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerArn)
        trackerArn = trackerArnDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input failed to meet the constraints specified by the AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The field where the invalid entry was detected.
    /// This member is required.
    public var fieldList: [LocationClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// A message with the reason for the validation exception error.
    /// This member is required.
    public var reason: LocationClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [LocationClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: LocationClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: LocationClientTypes.ValidationExceptionReason?
    let fieldList: [LocationClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList = "fieldList"
        case message = "message"
        case reason = "reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(LocationClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([LocationClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[LocationClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [LocationClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension LocationClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes {
    /// The input failed to meet the constraints specified by the AWS service in a specified field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message with the reason for the validation exception error.
        /// This member is required.
        public var message: Swift.String?
        /// The field name where the invalid entry was detected.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension LocationClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The input cannot be parsed. For example a required JSON document, ARN identifier, date value, or numeric field cannot be parsed.
        case cannotparse
        /// The input is present and parsable, but it is otherwise invalid. For example, a required numeric argument is outside the allowed range.
        case fieldvalidationfailed
        /// The required input is missing.
        case missing
        /// The input is invalid but no more specific reason is applicable.
        case other
        /// No such operation is supported.
        case unknownoperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotparse,
                .fieldvalidationfailed,
                .missing,
                .other,
                .unknownoperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotparse: return "CannotParse"
            case .fieldvalidationfailed: return "FieldValidationFailed"
            case .missing: return "Missing"
            case .other: return "Other"
            case .unknownoperation: return "UnknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes {
    public enum VehicleWeightUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kilograms
        case pounds
        case sdkUnknown(Swift.String)

        public static var allCases: [VehicleWeightUnit] {
            return [
                .kilograms,
                .pounds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kilograms: return "Kilograms"
            case .pounds: return "Pounds"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VehicleWeightUnit(rawValue: rawValue) ?? VehicleWeightUnit.sdkUnknown(rawValue)
        }
    }
}
