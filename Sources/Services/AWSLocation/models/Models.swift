// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request was denied because of insufficient access or permissions. Check with an administrator to verify your permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LocationClientTypes.ApiKeyFilter {

    static func write(value: LocationClientTypes.ApiKeyFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyStatus"].write(value.keyStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.ApiKeyFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.ApiKeyFilter()
        value.keyStatus = try reader["KeyStatus"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// Options for filtering API keys.
    public struct ApiKeyFilter {
        /// Filter on Active or Expired API keys.
        public var keyStatus: LocationClientTypes.Status?

        public init(
            keyStatus: LocationClientTypes.Status? = nil
        )
        {
            self.keyStatus = keyStatus
        }
    }

}

extension LocationClientTypes.ApiKeyRestrictions {

    static func write(value: LocationClientTypes.ApiKeyRestrictions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowActions"].writeList(value.allowActions, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AllowReferers"].writeList(value.allowReferers, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AllowResources"].writeList(value.allowResources, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.ApiKeyRestrictions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.ApiKeyRestrictions()
        value.allowActions = try reader["AllowActions"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowResources = try reader["AllowResources"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowReferers = try reader["AllowReferers"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LocationClientTypes {
    /// API Restrictions on the allowed actions, resources, and referers for an API key resource.
    public struct ApiKeyRestrictions {
        /// A list of allowed actions that an API key resource grants permissions to perform. You must have at least one action for each type of resource. For example, if you have a place resource, you must include at least one place action. The following are valid values for the actions.
        ///
        /// * Map actions
        ///
        /// * geo:GetMap* - Allows all actions needed for map rendering.
        ///
        ///
        ///
        ///
        /// * Place actions
        ///
        /// * geo:SearchPlaceIndexForText - Allows geocoding.
        ///
        /// * geo:SearchPlaceIndexForPosition - Allows reverse geocoding.
        ///
        /// * geo:SearchPlaceIndexForSuggestions - Allows generating suggestions from text.
        ///
        /// * GetPlace - Allows finding a place by place ID.
        ///
        ///
        ///
        ///
        /// * Route actions
        ///
        /// * geo:CalculateRoute - Allows point to point routing.
        ///
        /// * geo:CalculateRouteMatrix - Allows calculating a matrix of routes.
        ///
        ///
        ///
        ///
        ///
        /// You must use these strings exactly. For example, to provide access to map rendering, the only valid action is geo:GetMap* as an input to the list. ["geo:GetMap*"] is valid but ["geo:GetMapTile"] is not. Similarly, you cannot use ["geo:SearchPlaceIndexFor*"] - you must list each of the Place actions separately.
        /// This member is required.
        public var allowActions: [Swift.String]?
        /// An optional list of allowed HTTP referers for which requests must originate from. Requests using this API key from other domains will not be allowed. Requirements:
        ///
        /// * Contain only alphanumeric characters (A–Z, a–z, 0–9) or any symbols in this list $\-._+!*`(),;/?:@=&
        ///
        /// * May contain a percent (%) if followed by 2 hexadecimal digits (A-F, a-f, 0-9); this is used for URL encoding purposes.
        ///
        /// * May contain wildcard characters question mark (?) and asterisk (*). Question mark (?) will replace any single character (including hexadecimal digits). Asterisk (*) will replace any multiple characters (including multiple hexadecimal digits).
        ///
        /// * No spaces allowed. For example, https://example.com.
        public var allowReferers: [Swift.String]?
        /// A list of allowed resource ARNs that a API key bearer can perform actions on.
        ///
        /// * The ARN must be the correct ARN for a map, place, or route ARN. You may include wildcards in the resource-id to match multiple resources of the same type.
        ///
        /// * The resources must be in the same partition, region, and account-id as the key that is being created.
        ///
        /// * Other than wildcards, you must include the full ARN, including the arn, partition, service, region, account-id and resource-id delimited by colons (:).
        ///
        /// * No spaces allowed, even with wildcards. For example, arn:aws:geo:region:account-id:map/ExampleMap*.
        ///
        ///
        /// For more information about ARN format, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
        /// This member is required.
        public var allowResources: [Swift.String]?

        public init(
            allowActions: [Swift.String]? = nil,
            allowReferers: [Swift.String]? = nil,
            allowResources: [Swift.String]? = nil
        )
        {
            self.allowActions = allowActions
            self.allowReferers = allowReferers
            self.allowResources = allowResources
        }
    }

}

extension AssociateTrackerConsumerInput {

    static func urlPathProvider(_ value: AssociateTrackerConsumerInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/consumers"
    }
}

extension AssociateTrackerConsumerInput {

    static func write(value: AssociateTrackerConsumerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConsumerArn"].write(value.consumerArn)
    }
}

public struct AssociateTrackerConsumerInput {
    /// The Amazon Resource Name (ARN) for the geofence collection to be associated to tracker resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
    /// This member is required.
    public var consumerArn: Swift.String?
    /// The name of the tracker resource to be associated with a geofence collection.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        consumerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.consumerArn = consumerArn
        self.trackerName = trackerName
    }
}

extension AssociateTrackerConsumerOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> AssociateTrackerConsumerOutput {
        return AssociateTrackerConsumerOutput()
    }
}

public struct AssociateTrackerConsumerOutput {

    public init() { }
}

enum AssociateTrackerConsumerOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.BatchDeleteDevicePositionHistoryError {

    static func write(value: LocationClientTypes.BatchDeleteDevicePositionHistoryError?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceId"].write(value.deviceId)
        try writer["Error"].write(value.error, with: LocationClientTypes.BatchItemError.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.BatchDeleteDevicePositionHistoryError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.BatchDeleteDevicePositionHistoryError()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: LocationClientTypes.BatchItemError.read(from:))
        return value
    }
}

extension LocationClientTypes {
    /// Contains the tracker resource details.
    public struct BatchDeleteDevicePositionHistoryError {
        /// The ID of the device for this position.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains the batch request error details associated with the request.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?

        public init(
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
        }
    }

}

extension BatchDeleteDevicePositionHistoryInput {

    static func urlPathProvider(_ value: BatchDeleteDevicePositionHistoryInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/delete-positions"
    }
}

extension BatchDeleteDevicePositionHistoryInput {

    static func write(value: BatchDeleteDevicePositionHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceIds"].writeList(value.deviceIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct BatchDeleteDevicePositionHistoryInput {
    /// Devices whose position history you want to delete.
    ///
    /// * For example, for two devices: “DeviceIds” : [DeviceId1,DeviceId2]
    /// This member is required.
    public var deviceIds: [Swift.String]?
    /// The name of the tracker resource to delete the device position history from.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        deviceIds: [Swift.String]? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceIds = deviceIds
        self.trackerName = trackerName
    }
}

extension BatchDeleteDevicePositionHistoryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> BatchDeleteDevicePositionHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteDevicePositionHistoryOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: LocationClientTypes.BatchDeleteDevicePositionHistoryError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct BatchDeleteDevicePositionHistoryOutput {
    /// Contains error details for each device history that failed to delete.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchDeleteDevicePositionHistoryError]?

    public init(
        errors: [LocationClientTypes.BatchDeleteDevicePositionHistoryError]? = nil
    )
    {
        self.errors = errors
    }
}

enum BatchDeleteDevicePositionHistoryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.BatchDeleteGeofenceError {

    static func write(value: LocationClientTypes.BatchDeleteGeofenceError?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Error"].write(value.error, with: LocationClientTypes.BatchItemError.write(value:to:))
        try writer["GeofenceId"].write(value.geofenceId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.BatchDeleteGeofenceError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.BatchDeleteGeofenceError()
        value.geofenceId = try reader["GeofenceId"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: LocationClientTypes.BatchItemError.read(from:))
        return value
    }
}

extension LocationClientTypes {
    /// Contains error details for each geofence that failed to delete from the geofence collection.
    public struct BatchDeleteGeofenceError {
        /// Contains details associated to the batch error.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// The geofence associated with the error message.
        /// This member is required.
        public var geofenceId: Swift.String?

        public init(
            error: LocationClientTypes.BatchItemError? = nil,
            geofenceId: Swift.String? = nil
        )
        {
            self.error = error
            self.geofenceId = geofenceId
        }
    }

}

extension BatchDeleteGeofenceInput {

    static func urlPathProvider(_ value: BatchDeleteGeofenceInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/delete-geofences"
    }
}

extension BatchDeleteGeofenceInput {

    static func write(value: BatchDeleteGeofenceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GeofenceIds"].writeList(value.geofenceIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct BatchDeleteGeofenceInput {
    /// The geofence collection storing the geofences to be deleted.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The batch of geofences to be deleted.
    /// This member is required.
    public var geofenceIds: [Swift.String]?

    public init(
        collectionName: Swift.String? = nil,
        geofenceIds: [Swift.String]? = nil
    )
    {
        self.collectionName = collectionName
        self.geofenceIds = geofenceIds
    }
}

extension BatchDeleteGeofenceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> BatchDeleteGeofenceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteGeofenceOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: LocationClientTypes.BatchDeleteGeofenceError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct BatchDeleteGeofenceOutput {
    /// Contains error details for each geofence that failed to delete.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchDeleteGeofenceError]?

    public init(
        errors: [LocationClientTypes.BatchDeleteGeofenceError]? = nil
    )
    {
        self.errors = errors
    }
}

enum BatchDeleteGeofenceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.BatchEvaluateGeofencesError {

    static func write(value: LocationClientTypes.BatchEvaluateGeofencesError?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceId"].write(value.deviceId)
        try writer["Error"].write(value.error, with: LocationClientTypes.BatchItemError.write(value:to:))
        try writer["SampleTime"].writeTimestamp(value.sampleTime, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.BatchEvaluateGeofencesError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.BatchEvaluateGeofencesError()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.sampleTime = try reader["SampleTime"].readTimestampIfPresent(format: .dateTime)
        value.error = try reader["Error"].readIfPresent(with: LocationClientTypes.BatchItemError.read(from:))
        return value
    }
}

extension LocationClientTypes {
    /// Contains error details for each device that failed to evaluate its position against the geofences in a given geofence collection.
    public struct BatchEvaluateGeofencesError {
        /// The device associated with the position evaluation error.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains details associated to the batch error.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// Specifies a timestamp for when the error occurred in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init(
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }
    }

}

extension BatchEvaluateGeofencesInput {

    static func urlPathProvider(_ value: BatchEvaluateGeofencesInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/positions"
    }
}

extension BatchEvaluateGeofencesInput {

    static func write(value: BatchEvaluateGeofencesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DevicePositionUpdates"].writeList(value.devicePositionUpdates, memberWritingClosure: LocationClientTypes.DevicePositionUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct BatchEvaluateGeofencesInput {
    /// The geofence collection used in evaluating the position of devices against its geofences.
    /// This member is required.
    public var collectionName: Swift.String?
    /// Contains device details for each device to be evaluated against the given geofence collection.
    /// This member is required.
    public var devicePositionUpdates: [LocationClientTypes.DevicePositionUpdate]?

    public init(
        collectionName: Swift.String? = nil,
        devicePositionUpdates: [LocationClientTypes.DevicePositionUpdate]? = nil
    )
    {
        self.collectionName = collectionName
        self.devicePositionUpdates = devicePositionUpdates
    }
}

extension BatchEvaluateGeofencesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> BatchEvaluateGeofencesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchEvaluateGeofencesOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: LocationClientTypes.BatchEvaluateGeofencesError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct BatchEvaluateGeofencesOutput {
    /// Contains error details for each device that failed to evaluate its position against the given geofence collection.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchEvaluateGeofencesError]?

    public init(
        errors: [LocationClientTypes.BatchEvaluateGeofencesError]? = nil
    )
    {
        self.errors = errors
    }
}

enum BatchEvaluateGeofencesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.BatchGetDevicePositionError {

    static func write(value: LocationClientTypes.BatchGetDevicePositionError?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceId"].write(value.deviceId)
        try writer["Error"].write(value.error, with: LocationClientTypes.BatchItemError.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.BatchGetDevicePositionError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.BatchGetDevicePositionError()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: LocationClientTypes.BatchItemError.read(from:))
        return value
    }
}

extension LocationClientTypes {
    /// Contains error details for each device that didn't return a position.
    public struct BatchGetDevicePositionError {
        /// The ID of the device that didn't return a position.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains details related to the error code.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?

        public init(
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
        }
    }

}

extension BatchGetDevicePositionInput {

    static func urlPathProvider(_ value: BatchGetDevicePositionInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/get-positions"
    }
}

extension BatchGetDevicePositionInput {

    static func write(value: BatchGetDevicePositionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceIds"].writeList(value.deviceIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct BatchGetDevicePositionInput {
    /// Devices whose position you want to retrieve.
    ///
    /// * For example, for two devices: device-ids=DeviceId1&device-ids=DeviceId2
    /// This member is required.
    public var deviceIds: [Swift.String]?
    /// The tracker resource retrieving the device position.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        deviceIds: [Swift.String]? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceIds = deviceIds
        self.trackerName = trackerName
    }
}

extension BatchGetDevicePositionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> BatchGetDevicePositionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetDevicePositionOutput()
        value.devicePositions = try reader["DevicePositions"].readListIfPresent(memberReadingClosure: LocationClientTypes.DevicePosition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: LocationClientTypes.BatchGetDevicePositionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct BatchGetDevicePositionOutput {
    /// Contains device position details such as the device ID, position, and timestamps for when the position was received and sampled.
    /// This member is required.
    public var devicePositions: [LocationClientTypes.DevicePosition]?
    /// Contains error details for each device that failed to send its position to the tracker resource.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchGetDevicePositionError]?

    public init(
        devicePositions: [LocationClientTypes.DevicePosition]? = nil,
        errors: [LocationClientTypes.BatchGetDevicePositionError]? = nil
    )
    {
        self.devicePositions = devicePositions
        self.errors = errors
    }
}

enum BatchGetDevicePositionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.BatchItemError {

    static func write(value: LocationClientTypes.BatchItemError?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Code"].write(value.code)
        try writer["Message"].write(value.message)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.BatchItemError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.BatchItemError()
        value.code = try reader["Code"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// Contains the batch request error details associated with the request.
    public struct BatchItemError {
        /// The error code associated with the batch request error.
        public var code: LocationClientTypes.BatchItemErrorCode?
        /// A message with the reason for the batch request error.
        public var message: Swift.String?

        public init(
            code: LocationClientTypes.BatchItemErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension LocationClientTypes {

    public enum BatchItemErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Access to the resource was denied.
        case accessdeniederror
        /// The target resource already exists.
        case conflicterror
        /// Internal server error.
        case internalservererror
        /// The target resource does not exist.
        case resourcenotfounderror
        /// Too many requests.
        case throttlingerror
        /// Input fails to satisfy the constraints specified by the service.
        case validationerror
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchItemErrorCode] {
            return [
                .accessdeniederror,
                .conflicterror,
                .internalservererror,
                .resourcenotfounderror,
                .throttlingerror,
                .validationerror,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessdeniederror: return "AccessDeniedError"
            case .conflicterror: return "ConflictError"
            case .internalservererror: return "InternalServerError"
            case .resourcenotfounderror: return "ResourceNotFoundError"
            case .throttlingerror: return "ThrottlingError"
            case .validationerror: return "ValidationError"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LocationClientTypes.BatchPutGeofenceError {

    static func write(value: LocationClientTypes.BatchPutGeofenceError?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Error"].write(value.error, with: LocationClientTypes.BatchItemError.write(value:to:))
        try writer["GeofenceId"].write(value.geofenceId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.BatchPutGeofenceError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.BatchPutGeofenceError()
        value.geofenceId = try reader["GeofenceId"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: LocationClientTypes.BatchItemError.read(from:))
        return value
    }
}

extension LocationClientTypes {
    /// Contains error details for each geofence that failed to be stored in a given geofence collection.
    public struct BatchPutGeofenceError {
        /// Contains details associated to the batch error.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// The geofence associated with the error message.
        /// This member is required.
        public var geofenceId: Swift.String?

        public init(
            error: LocationClientTypes.BatchItemError? = nil,
            geofenceId: Swift.String? = nil
        )
        {
            self.error = error
            self.geofenceId = geofenceId
        }
    }

}

extension BatchPutGeofenceInput {

    static func urlPathProvider(_ value: BatchPutGeofenceInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/put-geofences"
    }
}

extension BatchPutGeofenceInput {

    static func write(value: BatchPutGeofenceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Entries"].writeList(value.entries, memberWritingClosure: LocationClientTypes.BatchPutGeofenceRequestEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct BatchPutGeofenceInput {
    /// The geofence collection storing the geofences.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The batch of geofences to be stored in a geofence collection.
    /// This member is required.
    public var entries: [LocationClientTypes.BatchPutGeofenceRequestEntry]?

    public init(
        collectionName: Swift.String? = nil,
        entries: [LocationClientTypes.BatchPutGeofenceRequestEntry]? = nil
    )
    {
        self.collectionName = collectionName
        self.entries = entries
    }
}

extension BatchPutGeofenceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> BatchPutGeofenceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchPutGeofenceOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: LocationClientTypes.BatchPutGeofenceError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.successes = try reader["Successes"].readListIfPresent(memberReadingClosure: LocationClientTypes.BatchPutGeofenceSuccess.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct BatchPutGeofenceOutput {
    /// Contains additional error details for each geofence that failed to be stored in a geofence collection.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchPutGeofenceError]?
    /// Contains each geofence that was successfully stored in a geofence collection.
    /// This member is required.
    public var successes: [LocationClientTypes.BatchPutGeofenceSuccess]?

    public init(
        errors: [LocationClientTypes.BatchPutGeofenceError]? = nil,
        successes: [LocationClientTypes.BatchPutGeofenceSuccess]? = nil
    )
    {
        self.errors = errors
        self.successes = successes
    }
}

enum BatchPutGeofenceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.BatchPutGeofenceRequestEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutGeofenceRequestEntry(geofenceId: \(Swift.String(describing: geofenceId)), geometry: \(Swift.String(describing: geometry)), geofenceProperties: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes.BatchPutGeofenceRequestEntry {

    static func write(value: LocationClientTypes.BatchPutGeofenceRequestEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GeofenceId"].write(value.geofenceId)
        try writer["GeofenceProperties"].writeMap(value.geofenceProperties, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Geometry"].write(value.geometry, with: LocationClientTypes.GeofenceGeometry.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.BatchPutGeofenceRequestEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.BatchPutGeofenceRequestEntry()
        value.geofenceId = try reader["GeofenceId"].readIfPresent()
        value.geometry = try reader["Geometry"].readIfPresent(with: LocationClientTypes.GeofenceGeometry.read(from:))
        value.geofenceProperties = try reader["GeofenceProperties"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension LocationClientTypes {
    /// Contains geofence geometry details.
    public struct BatchPutGeofenceRequestEntry {
        /// The identifier for the geofence to be stored in a given geofence collection.
        /// This member is required.
        public var geofenceId: Swift.String?
        /// Associates one of more properties with the geofence. A property is a key-value pair stored with the geofence and added to any geofence event triggered with that geofence. Format: "key" : "value"
        public var geofenceProperties: [Swift.String:Swift.String]?
        /// Contains the details of the position of the geofence. Can be either a polygon or a circle. Including both will return a validation error. Each [ geofence polygon](https://docs.aws.amazon.com/location-geofences/latest/APIReference/API_GeofenceGeometry.html) can have a maximum of 1,000 vertices.
        /// This member is required.
        public var geometry: LocationClientTypes.GeofenceGeometry?

        public init(
            geofenceId: Swift.String? = nil,
            geofenceProperties: [Swift.String:Swift.String]? = nil,
            geometry: LocationClientTypes.GeofenceGeometry? = nil
        )
        {
            self.geofenceId = geofenceId
            self.geofenceProperties = geofenceProperties
            self.geometry = geometry
        }
    }

}

extension LocationClientTypes.BatchPutGeofenceSuccess {

    static func write(value: LocationClientTypes.BatchPutGeofenceSuccess?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreateTime"].writeTimestamp(value.createTime, format: .dateTime)
        try writer["GeofenceId"].write(value.geofenceId)
        try writer["UpdateTime"].writeTimestamp(value.updateTime, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.BatchPutGeofenceSuccess {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.BatchPutGeofenceSuccess()
        value.geofenceId = try reader["GeofenceId"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension LocationClientTypes {
    /// Contains a summary of each geofence that was successfully stored in a given geofence collection.
    public struct BatchPutGeofenceSuccess {
        /// The timestamp for when the geofence was stored in a geofence collection in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The geofence successfully stored in a geofence collection.
        /// This member is required.
        public var geofenceId: Swift.String?
        /// The timestamp for when the geofence was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            createTime: ClientRuntime.Date? = nil,
            geofenceId: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.updateTime = updateTime
        }
    }

}

extension LocationClientTypes.BatchUpdateDevicePositionError {

    static func write(value: LocationClientTypes.BatchUpdateDevicePositionError?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceId"].write(value.deviceId)
        try writer["Error"].write(value.error, with: LocationClientTypes.BatchItemError.write(value:to:))
        try writer["SampleTime"].writeTimestamp(value.sampleTime, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.BatchUpdateDevicePositionError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.BatchUpdateDevicePositionError()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.sampleTime = try reader["SampleTime"].readTimestampIfPresent(format: .dateTime)
        value.error = try reader["Error"].readIfPresent(with: LocationClientTypes.BatchItemError.read(from:))
        return value
    }
}

extension LocationClientTypes {
    /// Contains error details for each device that failed to update its position.
    public struct BatchUpdateDevicePositionError {
        /// The device associated with the failed location update.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains details related to the error code such as the error code and error message.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// The timestamp at which the device position was determined. Uses [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init(
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }
    }

}

extension BatchUpdateDevicePositionInput {

    static func urlPathProvider(_ value: BatchUpdateDevicePositionInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/positions"
    }
}

extension BatchUpdateDevicePositionInput {

    static func write(value: BatchUpdateDevicePositionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Updates"].writeList(value.updates, memberWritingClosure: LocationClientTypes.DevicePositionUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct BatchUpdateDevicePositionInput {
    /// The name of the tracker resource to update.
    /// This member is required.
    public var trackerName: Swift.String?
    /// Contains the position update details for each device, up to 10 devices.
    /// This member is required.
    public var updates: [LocationClientTypes.DevicePositionUpdate]?

    public init(
        trackerName: Swift.String? = nil,
        updates: [LocationClientTypes.DevicePositionUpdate]? = nil
    )
    {
        self.trackerName = trackerName
        self.updates = updates
    }
}

extension BatchUpdateDevicePositionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> BatchUpdateDevicePositionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateDevicePositionOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: LocationClientTypes.BatchUpdateDevicePositionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct BatchUpdateDevicePositionOutput {
    /// Contains error details for each device that failed to update its position.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchUpdateDevicePositionError]?

    public init(
        errors: [LocationClientTypes.BatchUpdateDevicePositionError]? = nil
    )
    {
        self.errors = errors
    }
}

enum BatchUpdateDevicePositionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.CalculateRouteCarModeOptions {

    static func write(value: LocationClientTypes.CalculateRouteCarModeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidFerries"].write(value.avoidFerries)
        try writer["AvoidTolls"].write(value.avoidTolls)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.CalculateRouteCarModeOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.CalculateRouteCarModeOptions()
        value.avoidFerries = try reader["AvoidFerries"].readIfPresent()
        value.avoidTolls = try reader["AvoidTolls"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// Contains details about additional route preferences for requests that specify TravelMode as Car.
    public struct CalculateRouteCarModeOptions {
        /// Avoids ferries when calculating routes. Default Value: false Valid Values: false | true
        public var avoidFerries: Swift.Bool?
        /// Avoids tolls when calculating routes. Default Value: false Valid Values: false | true
        public var avoidTolls: Swift.Bool?

        public init(
            avoidFerries: Swift.Bool? = nil,
            avoidTolls: Swift.Bool? = nil
        )
        {
            self.avoidFerries = avoidFerries
            self.avoidTolls = avoidTolls
        }
    }

}

extension CalculateRouteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRouteInput(arrivalTime: \(Swift.String(describing: arrivalTime)), calculatorName: \(Swift.String(describing: calculatorName)), carModeOptions: \(Swift.String(describing: carModeOptions)), departNow: \(Swift.String(describing: departNow)), departureTime: \(Swift.String(describing: departureTime)), distanceUnit: \(Swift.String(describing: distanceUnit)), includeLegGeometry: \(Swift.String(describing: includeLegGeometry)), optimizeFor: \(Swift.String(describing: optimizeFor)), travelMode: \(Swift.String(describing: travelMode)), truckModeOptions: \(Swift.String(describing: truckModeOptions)), waypointPositions: \(Swift.String(describing: waypointPositions)), departurePosition: \"CONTENT_REDACTED\", destinationPosition: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\")"}
}

extension CalculateRouteInput {

    static func queryItemProvider(_ value: CalculateRouteInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension CalculateRouteInput {

    static func urlPathProvider(_ value: CalculateRouteInput) -> Swift.String? {
        guard let calculatorName = value.calculatorName else {
            return nil
        }
        return "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())/calculate/route"
    }
}

extension CalculateRouteInput {

    static func write(value: CalculateRouteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArrivalTime"].writeTimestamp(value.arrivalTime, format: .dateTime)
        try writer["CarModeOptions"].write(value.carModeOptions, with: LocationClientTypes.CalculateRouteCarModeOptions.write(value:to:))
        try writer["DepartNow"].write(value.departNow)
        try writer["DeparturePosition"].writeList(value.departurePosition, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DepartureTime"].writeTimestamp(value.departureTime, format: .dateTime)
        try writer["DestinationPosition"].writeList(value.destinationPosition, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DistanceUnit"].write(value.distanceUnit)
        try writer["IncludeLegGeometry"].write(value.includeLegGeometry)
        try writer["OptimizeFor"].write(value.optimizeFor)
        try writer["TravelMode"].write(value.travelMode)
        try writer["TruckModeOptions"].write(value.truckModeOptions, with: LocationClientTypes.CalculateRouteTruckModeOptions.write(value:to:))
        try writer["WaypointPositions"].writeList(value.waypointPositions, memberWritingClosure: listWritingClosure(memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CalculateRouteInput {
    /// Specifies the desired time of arrival. Uses the given time to calculate the route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route. ArrivalTime is not supported Esri.
    public var arrivalTime: ClientRuntime.Date?
    /// The name of the route calculator resource that you want to use to calculate the route.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// Specifies route preferences when traveling by Car, such as avoiding routes that use ferries or tolls. Requirements: TravelMode must be specified as Car.
    public var carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions?
    /// Sets the time of departure as the current time. Uses the current time to calculate a route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route. Default Value: false Valid Values: false | true
    public var departNow: Swift.Bool?
    /// The start position for the route. Defined in [World Geodetic System (WGS 84)](https://earth-info.nga.mil/index.php?dir=wgs84&action=wgs84) format: [longitude, latitude].
    ///
    /// * For example, [-123.115, 49.285]
    ///
    ///
    /// If you specify a departure that's not located on a road, Amazon Location [moves the position to the nearest road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html). If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a 400 RoutesValidationException error. Valid Values: [-180 to 180,-90 to 90]
    /// This member is required.
    public var departurePosition: [Swift.Double]?
    /// Specifies the desired time of departure. Uses the given time to calculate the route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route.
    ///
    /// * In [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ. For example, 2020–07-2T12:15:20.000Z+01:00
    public var departureTime: ClientRuntime.Date?
    /// The finish position for the route. Defined in [World Geodetic System (WGS 84)](https://earth-info.nga.mil/index.php?dir=wgs84&action=wgs84) format: [longitude, latitude].
    ///
    /// * For example, [-122.339, 47.615]
    ///
    ///
    /// If you specify a destination that's not located on a road, Amazon Location [moves the position to the nearest road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html). Valid Values: [-180 to 180,-90 to 90]
    /// This member is required.
    public var destinationPosition: [Swift.Double]?
    /// Set the unit system to specify the distance. Default Value: Kilometers
    public var distanceUnit: LocationClientTypes.DistanceUnit?
    /// Set to include the geometry details in the result for each path between a pair of positions. Default Value: false Valid Values: false | true
    public var includeLegGeometry: Swift.Bool?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// Specifies the distance to optimize for when calculating a route.
    public var optimizeFor: LocationClientTypes.OptimizationMode?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. You can choose Car, Truck, Walking, Bicycle or Motorcycle as options for the TravelMode. Bicycle and Motorcycle are only valid when using Grab as a data provider, and only within Southeast Asia. Truck is not available for Grab. For more details on the using Grab for routing, including areas of coverage, see [GrabMaps](https://docs.aws.amazon.com/location/latest/developerguide/grab.html) in the Amazon Location Service Developer Guide. The TravelMode you specify also determines how you specify route preferences:
    ///
    /// * If traveling by Car use the CarModeOptions parameter.
    ///
    /// * If traveling by Truck use the TruckModeOptions parameter.
    ///
    ///
    /// Default Value: Car
    public var travelMode: LocationClientTypes.TravelMode?
    /// Specifies route preferences when traveling by Truck, such as avoiding routes that use ferries or tolls, and truck specifications to consider when choosing an optimal road. Requirements: TravelMode must be specified as Truck.
    public var truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions?
    /// Specifies an ordered list of up to 23 intermediate positions to include along a route between the departure position and destination position.
    ///
    /// * For example, from the DeparturePosition[-123.115, 49.285], the route follows the order that the waypoint positions are given [[-122.757, 49.0021],[-122.349, 47.620]]
    ///
    ///
    /// If you specify a waypoint position that's not located on a road, Amazon Location [moves the position to the nearest road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html). Specifying more than 23 waypoints returns a 400 ValidationException error. If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a 400 RoutesValidationException error. Valid Values: [-180 to 180,-90 to 90]
    public var waypointPositions: [[Swift.Double]]?

    public init(
        arrivalTime: ClientRuntime.Date? = nil,
        calculatorName: Swift.String? = nil,
        carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions? = nil,
        departNow: Swift.Bool? = nil,
        departurePosition: [Swift.Double]? = nil,
        departureTime: ClientRuntime.Date? = nil,
        destinationPosition: [Swift.Double]? = nil,
        distanceUnit: LocationClientTypes.DistanceUnit? = nil,
        includeLegGeometry: Swift.Bool? = nil,
        key: Swift.String? = nil,
        optimizeFor: LocationClientTypes.OptimizationMode? = nil,
        travelMode: LocationClientTypes.TravelMode? = nil,
        truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions? = nil,
        waypointPositions: [[Swift.Double]]? = nil
    )
    {
        self.arrivalTime = arrivalTime
        self.calculatorName = calculatorName
        self.carModeOptions = carModeOptions
        self.departNow = departNow
        self.departurePosition = departurePosition
        self.departureTime = departureTime
        self.destinationPosition = destinationPosition
        self.distanceUnit = distanceUnit
        self.includeLegGeometry = includeLegGeometry
        self.key = key
        self.optimizeFor = optimizeFor
        self.travelMode = travelMode
        self.truckModeOptions = truckModeOptions
        self.waypointPositions = waypointPositions
    }
}

extension CalculateRouteMatrixInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRouteMatrixInput(calculatorName: \(Swift.String(describing: calculatorName)), carModeOptions: \(Swift.String(describing: carModeOptions)), departNow: \(Swift.String(describing: departNow)), departurePositions: \(Swift.String(describing: departurePositions)), departureTime: \(Swift.String(describing: departureTime)), destinationPositions: \(Swift.String(describing: destinationPositions)), distanceUnit: \(Swift.String(describing: distanceUnit)), travelMode: \(Swift.String(describing: travelMode)), truckModeOptions: \(Swift.String(describing: truckModeOptions)), key: \"CONTENT_REDACTED\")"}
}

extension CalculateRouteMatrixInput {

    static func queryItemProvider(_ value: CalculateRouteMatrixInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension CalculateRouteMatrixInput {

    static func urlPathProvider(_ value: CalculateRouteMatrixInput) -> Swift.String? {
        guard let calculatorName = value.calculatorName else {
            return nil
        }
        return "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())/calculate/route-matrix"
    }
}

extension CalculateRouteMatrixInput {

    static func write(value: CalculateRouteMatrixInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CarModeOptions"].write(value.carModeOptions, with: LocationClientTypes.CalculateRouteCarModeOptions.write(value:to:))
        try writer["DepartNow"].write(value.departNow)
        try writer["DeparturePositions"].writeList(value.departurePositions, memberWritingClosure: listWritingClosure(memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["DepartureTime"].writeTimestamp(value.departureTime, format: .dateTime)
        try writer["DestinationPositions"].writeList(value.destinationPositions, memberWritingClosure: listWritingClosure(memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["DistanceUnit"].write(value.distanceUnit)
        try writer["TravelMode"].write(value.travelMode)
        try writer["TruckModeOptions"].write(value.truckModeOptions, with: LocationClientTypes.CalculateRouteTruckModeOptions.write(value:to:))
    }
}

public struct CalculateRouteMatrixInput {
    /// The name of the route calculator resource that you want to use to calculate the route matrix.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// Specifies route preferences when traveling by Car, such as avoiding routes that use ferries or tolls. Requirements: TravelMode must be specified as Car.
    public var carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions?
    /// Sets the time of departure as the current time. Uses the current time to calculate the route matrix. You can't set both DepartureTime and DepartNow. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix. Default Value: false Valid Values: false | true
    public var departNow: Swift.Bool?
    /// The list of departure (origin) positions for the route matrix. An array of points, each of which is itself a 2-value array defined in [WGS 84](https://earth-info.nga.mil/GandG/wgs84/index.html) format: [longitude, latitude]. For example, [-123.115, 49.285]. Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See [ Position restrictions](https://docs.aws.amazon.com/location/latest/developerguide/calculate-route-matrix.html#matrix-routing-position-limits) in the Amazon Location Service Developer Guide. For route calculators that use Esri as the data provider, if you specify a departure that's not located on a road, Amazon Location [ moves the position to the nearest road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html). The snapped value is available in the result in SnappedDeparturePositions. Valid Values: [-180 to 180,-90 to 90]
    /// This member is required.
    public var departurePositions: [[Swift.Double]]?
    /// Specifies the desired time of departure. Uses the given time to calculate the route matrix. You can't set both DepartureTime and DepartNow. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix. Setting a departure time in the past returns a 400 ValidationException error.
    ///
    /// * In [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ. For example, 2020–07-2T12:15:20.000Z+01:00
    public var departureTime: ClientRuntime.Date?
    /// The list of destination positions for the route matrix. An array of points, each of which is itself a 2-value array defined in [WGS 84](https://earth-info.nga.mil/GandG/wgs84/index.html) format: [longitude, latitude]. For example, [-122.339, 47.615] Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See [ Position restrictions](https://docs.aws.amazon.com/location/latest/developerguide/calculate-route-matrix.html#matrix-routing-position-limits) in the Amazon Location Service Developer Guide. For route calculators that use Esri as the data provider, if you specify a destination that's not located on a road, Amazon Location [ moves the position to the nearest road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html). The snapped value is available in the result in SnappedDestinationPositions. Valid Values: [-180 to 180,-90 to 90]
    /// This member is required.
    public var destinationPositions: [[Swift.Double]]?
    /// Set the unit system to specify the distance. Default Value: Kilometers
    public var distanceUnit: LocationClientTypes.DistanceUnit?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. The TravelMode you specify also determines how you specify route preferences:
    ///
    /// * If traveling by Car use the CarModeOptions parameter.
    ///
    /// * If traveling by Truck use the TruckModeOptions parameter.
    ///
    ///
    /// Bicycle or Motorcycle are only valid when using Grab as a data provider, and only within Southeast Asia. Truck is not available for Grab. For more information about using Grab as a data provider, see [GrabMaps](https://docs.aws.amazon.com/location/latest/developerguide/grab.html) in the Amazon Location Service Developer Guide. Default Value: Car
    public var travelMode: LocationClientTypes.TravelMode?
    /// Specifies route preferences when traveling by Truck, such as avoiding routes that use ferries or tolls, and truck specifications to consider when choosing an optimal road. Requirements: TravelMode must be specified as Truck.
    public var truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions?

    public init(
        calculatorName: Swift.String? = nil,
        carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions? = nil,
        departNow: Swift.Bool? = nil,
        departurePositions: [[Swift.Double]]? = nil,
        departureTime: ClientRuntime.Date? = nil,
        destinationPositions: [[Swift.Double]]? = nil,
        distanceUnit: LocationClientTypes.DistanceUnit? = nil,
        key: Swift.String? = nil,
        travelMode: LocationClientTypes.TravelMode? = nil,
        truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions? = nil
    )
    {
        self.calculatorName = calculatorName
        self.carModeOptions = carModeOptions
        self.departNow = departNow
        self.departurePositions = departurePositions
        self.departureTime = departureTime
        self.destinationPositions = destinationPositions
        self.distanceUnit = distanceUnit
        self.key = key
        self.travelMode = travelMode
        self.truckModeOptions = truckModeOptions
    }
}

extension CalculateRouteMatrixOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CalculateRouteMatrixOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CalculateRouteMatrixOutput()
        value.routeMatrix = try reader["RouteMatrix"].readListIfPresent(memberReadingClosure: listReadingClosure(memberReadingClosure: LocationClientTypes.RouteMatrixEntry.read(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.snappedDeparturePositions = try reader["SnappedDeparturePositions"].readListIfPresent(memberReadingClosure: listReadingClosure(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.snappedDestinationPositions = try reader["SnappedDestinationPositions"].readListIfPresent(memberReadingClosure: listReadingClosure(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.summary = try reader["Summary"].readIfPresent(with: LocationClientTypes.CalculateRouteMatrixSummary.read(from:))
        return value
    }
}

/// Returns the result of the route matrix calculation.
public struct CalculateRouteMatrixOutput {
    /// The calculated route matrix containing the results for all pairs of DeparturePositions to DestinationPositions. Each row corresponds to one entry in DeparturePositions. Each entry in the row corresponds to the route from that entry in DeparturePositions to an entry in DestinationPositions.
    /// This member is required.
    public var routeMatrix: [[LocationClientTypes.RouteMatrixEntry]]?
    /// For routes calculated using an Esri route calculator resource, departure positions are snapped to the closest road. For Esri route calculator resources, this returns the list of departure/origin positions used for calculation of the RouteMatrix.
    public var snappedDeparturePositions: [[Swift.Double]]?
    /// The list of destination positions for the route matrix used for calculation of the RouteMatrix.
    public var snappedDestinationPositions: [[Swift.Double]]?
    /// Contains information about the route matrix, DataSource, DistanceUnit, RouteCount and ErrorCount.
    /// This member is required.
    public var summary: LocationClientTypes.CalculateRouteMatrixSummary?

    public init(
        routeMatrix: [[LocationClientTypes.RouteMatrixEntry]]? = nil,
        snappedDeparturePositions: [[Swift.Double]]? = nil,
        snappedDestinationPositions: [[Swift.Double]]? = nil,
        summary: LocationClientTypes.CalculateRouteMatrixSummary? = nil
    )
    {
        self.routeMatrix = routeMatrix
        self.snappedDeparturePositions = snappedDeparturePositions
        self.snappedDestinationPositions = snappedDestinationPositions
        self.summary = summary
    }
}

enum CalculateRouteMatrixOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.CalculateRouteMatrixSummary {

    static func write(value: LocationClientTypes.CalculateRouteMatrixSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSource"].write(value.dataSource)
        try writer["DistanceUnit"].write(value.distanceUnit)
        try writer["ErrorCount"].write(value.errorCount)
        try writer["RouteCount"].write(value.routeCount)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.CalculateRouteMatrixSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.CalculateRouteMatrixSummary()
        value.dataSource = try reader["DataSource"].readIfPresent()
        value.routeCount = try reader["RouteCount"].readIfPresent()
        value.errorCount = try reader["ErrorCount"].readIfPresent()
        value.distanceUnit = try reader["DistanceUnit"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// A summary of the calculated route matrix.
    public struct CalculateRouteMatrixSummary {
        /// The data provider of traffic and road network data used to calculate the routes. Indicates one of the available providers:
        ///
        /// * Esri
        ///
        /// * Grab
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// The unit of measurement for route distances.
        /// This member is required.
        public var distanceUnit: LocationClientTypes.DistanceUnit?
        /// The count of error results in the route matrix. If this number is 0, all routes were calculated successfully.
        /// This member is required.
        public var errorCount: Swift.Int?
        /// The count of cells in the route matrix. Equal to the number of DeparturePositions multiplied by the number of DestinationPositions.
        /// This member is required.
        public var routeCount: Swift.Int?

        public init(
            dataSource: Swift.String? = nil,
            distanceUnit: LocationClientTypes.DistanceUnit? = nil,
            errorCount: Swift.Int? = nil,
            routeCount: Swift.Int? = nil
        )
        {
            self.dataSource = dataSource
            self.distanceUnit = distanceUnit
            self.errorCount = errorCount
            self.routeCount = routeCount
        }
    }

}

extension CalculateRouteOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CalculateRouteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CalculateRouteOutput()
        value.legs = try reader["Legs"].readListIfPresent(memberReadingClosure: LocationClientTypes.Leg.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.summary = try reader["Summary"].readIfPresent(with: LocationClientTypes.CalculateRouteSummary.read(from:))
        return value
    }
}

/// Returns the result of the route calculation. Metadata includes legs and route summary.
public struct CalculateRouteOutput {
    /// Contains details about each path between a pair of positions included along a route such as: StartPosition, EndPosition, Distance, DurationSeconds, Geometry, and Steps. The number of legs returned corresponds to one fewer than the total number of positions in the request. For example, a route with a departure position and destination position returns one leg with the positions [snapped to a nearby road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html):
    ///
    /// * The StartPosition is the departure position.
    ///
    /// * The EndPosition is the destination position.
    ///
    ///
    /// A route with a waypoint between the departure and destination position returns two legs with the positions snapped to a nearby road:
    ///
    /// * Leg 1: The StartPosition is the departure position . The EndPosition is the waypoint positon.
    ///
    /// * Leg 2: The StartPosition is the waypoint position. The EndPosition is the destination position.
    /// This member is required.
    public var legs: [LocationClientTypes.Leg]?
    /// Contains information about the whole route, such as: RouteBBox, DataSource, Distance, DistanceUnit, and DurationSeconds.
    /// This member is required.
    public var summary: LocationClientTypes.CalculateRouteSummary?

    public init(
        legs: [LocationClientTypes.Leg]? = nil,
        summary: LocationClientTypes.CalculateRouteSummary? = nil
    )
    {
        self.legs = legs
        self.summary = summary
    }
}

enum CalculateRouteOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.CalculateRouteSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRouteSummary(dataSource: \(Swift.String(describing: dataSource)), distance: \(Swift.String(describing: distance)), distanceUnit: \(Swift.String(describing: distanceUnit)), durationSeconds: \(Swift.String(describing: durationSeconds)), routeBBox: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes.CalculateRouteSummary {

    static func write(value: LocationClientTypes.CalculateRouteSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSource"].write(value.dataSource)
        try writer["Distance"].write(value.distance)
        try writer["DistanceUnit"].write(value.distanceUnit)
        try writer["DurationSeconds"].write(value.durationSeconds)
        try writer["RouteBBox"].writeList(value.routeBBox, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.CalculateRouteSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.CalculateRouteSummary()
        value.routeBBox = try reader["RouteBBox"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSource = try reader["DataSource"].readIfPresent()
        value.distance = try reader["Distance"].readIfPresent()
        value.durationSeconds = try reader["DurationSeconds"].readIfPresent()
        value.distanceUnit = try reader["DistanceUnit"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// A summary of the calculated route.
    public struct CalculateRouteSummary {
        /// The data provider of traffic and road network data used to calculate the route. Indicates one of the available providers:
        ///
        /// * Esri
        ///
        /// * Grab
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// The total distance covered by the route. The sum of the distance travelled between every stop on the route. If Esri is the data source for the route calculator, the route distance can’t be greater than 400 km. If the route exceeds 400 km, the response is a 400 RoutesValidationException error.
        /// This member is required.
        public var distance: Swift.Double?
        /// The unit of measurement for route distances.
        /// This member is required.
        public var distanceUnit: LocationClientTypes.DistanceUnit?
        /// The total travel time for the route measured in seconds. The sum of the travel time between every stop on the route.
        /// This member is required.
        public var durationSeconds: Swift.Double?
        /// Specifies a geographical box surrounding a route. Used to zoom into a route when displaying it in a map. For example, [min x, min y, max x, max y]. The first 2 bbox parameters describe the lower southwest corner:
        ///
        /// * The first bbox position is the X coordinate or longitude of the lower southwest corner.
        ///
        /// * The second bbox position is the Y coordinate or latitude of the lower southwest corner.
        ///
        ///
        /// The next 2 bbox parameters describe the upper northeast corner:
        ///
        /// * The third bbox position is the X coordinate, or longitude of the upper northeast corner.
        ///
        /// * The fourth bbox position is the Y coordinate, or latitude of the upper northeast corner.
        /// This member is required.
        public var routeBBox: [Swift.Double]?

        public init(
            dataSource: Swift.String? = nil,
            distance: Swift.Double? = nil,
            distanceUnit: LocationClientTypes.DistanceUnit? = nil,
            durationSeconds: Swift.Double? = nil,
            routeBBox: [Swift.Double]? = nil
        )
        {
            self.dataSource = dataSource
            self.distance = distance
            self.distanceUnit = distanceUnit
            self.durationSeconds = durationSeconds
            self.routeBBox = routeBBox
        }
    }

}

extension LocationClientTypes.CalculateRouteTruckModeOptions {

    static func write(value: LocationClientTypes.CalculateRouteTruckModeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidFerries"].write(value.avoidFerries)
        try writer["AvoidTolls"].write(value.avoidTolls)
        try writer["Dimensions"].write(value.dimensions, with: LocationClientTypes.TruckDimensions.write(value:to:))
        try writer["Weight"].write(value.weight, with: LocationClientTypes.TruckWeight.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.CalculateRouteTruckModeOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.CalculateRouteTruckModeOptions()
        value.avoidFerries = try reader["AvoidFerries"].readIfPresent()
        value.avoidTolls = try reader["AvoidTolls"].readIfPresent()
        value.dimensions = try reader["Dimensions"].readIfPresent(with: LocationClientTypes.TruckDimensions.read(from:))
        value.weight = try reader["Weight"].readIfPresent(with: LocationClientTypes.TruckWeight.read(from:))
        return value
    }
}

extension LocationClientTypes {
    /// Contains details about additional route preferences for requests that specify TravelMode as Truck.
    public struct CalculateRouteTruckModeOptions {
        /// Avoids ferries when calculating routes. Default Value: false Valid Values: false | true
        public var avoidFerries: Swift.Bool?
        /// Avoids tolls when calculating routes. Default Value: false Valid Values: false | true
        public var avoidTolls: Swift.Bool?
        /// Specifies the truck's dimension specifications including length, height, width, and unit of measurement. Used to avoid roads that can't support the truck's dimensions.
        public var dimensions: LocationClientTypes.TruckDimensions?
        /// Specifies the truck's weight specifications including total weight and unit of measurement. Used to avoid roads that can't support the truck's weight.
        public var weight: LocationClientTypes.TruckWeight?

        public init(
            avoidFerries: Swift.Bool? = nil,
            avoidTolls: Swift.Bool? = nil,
            dimensions: LocationClientTypes.TruckDimensions? = nil,
            weight: LocationClientTypes.TruckWeight? = nil
        )
        {
            self.avoidFerries = avoidFerries
            self.avoidTolls = avoidTolls
            self.dimensions = dimensions
            self.weight = weight
        }
    }

}

extension LocationClientTypes.Circle: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension LocationClientTypes.Circle {

    static func write(value: LocationClientTypes.Circle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Center"].writeList(value.center, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Radius"].write(value.radius)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.Circle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.Circle()
        value.center = try reader["Center"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.radius = try reader["Radius"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// A circle on the earth, as defined by a center point and a radius.
    public struct Circle {
        /// A single point geometry, specifying the center of the circle, using [WGS 84](https://gisgeography.com/wgs84-world-geodetic-system/) coordinates, in the form [longitude, latitude].
        /// This member is required.
        public var center: [Swift.Double]?
        /// The radius of the circle in meters. Must be greater than zero and no larger than 100,000 (100 kilometers).
        /// This member is required.
        public var radius: Swift.Double?

        public init(
            center: [Swift.Double]? = nil,
            radius: Swift.Double? = nil
        )
        {
            self.center = center
            self.radius = radius
        }
    }

}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request was unsuccessful because of a conflict.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CreateGeofenceCollectionInput {

    static func urlPathProvider(_ value: CreateGeofenceCollectionInput) -> Swift.String? {
        return "/geofencing/v0/collections"
    }
}

extension CreateGeofenceCollectionInput {

    static func write(value: CreateGeofenceCollectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CollectionName"].write(value.collectionName)
        try writer["Description"].write(value.description)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["PricingPlan"].write(value.pricingPlan)
        try writer["PricingPlanDataSource"].write(value.pricingPlanDataSource)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateGeofenceCollectionInput {
    /// A custom name for the geofence collection. Requirements:
    ///
    /// * Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique geofence collection name.
    ///
    /// * No spaces allowed. For example, ExampleGeofenceCollection.
    /// This member is required.
    public var collectionName: Swift.String?
    /// An optional description for the geofence collection.
    public var description: Swift.String?
    /// A key identifier for an [Amazon Web Services KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html). Enter a key ID, key ARN, alias name, or alias ARN.
    public var kmsKeyId: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// This parameter is no longer used.
    @available(*, deprecated, message: "Deprecated. No longer allowed. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?
    /// Applies one or more tags to the geofence collection. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource
    ///
    /// * Each resource tag must be unique with a maximum of one value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?

    public init(
        collectionName: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.collectionName = collectionName
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
    }
}

extension CreateGeofenceCollectionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateGeofenceCollectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGeofenceCollectionOutput()
        value.collectionArn = try reader["CollectionArn"].readIfPresent()
        value.collectionName = try reader["CollectionName"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct CreateGeofenceCollectionOutput {
    /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
    /// This member is required.
    public var collectionArn: Swift.String?
    /// The name for the geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The timestamp for when the geofence collection was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var createTime: ClientRuntime.Date?

    public init(
        collectionArn: Swift.String? = nil,
        collectionName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil
    )
    {
        self.collectionArn = collectionArn
        self.collectionName = collectionName
        self.createTime = createTime
    }
}

enum CreateGeofenceCollectionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateKeyInput {

    static func urlPathProvider(_ value: CreateKeyInput) -> Swift.String? {
        return "/metadata/v0/keys"
    }
}

extension CreateKeyInput {

    static func write(value: CreateKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["ExpireTime"].writeTimestamp(value.expireTime, format: .dateTime)
        try writer["KeyName"].write(value.keyName)
        try writer["NoExpiry"].write(value.noExpiry)
        try writer["Restrictions"].write(value.restrictions, with: LocationClientTypes.ApiKeyRestrictions.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateKeyInput {
    /// An optional description for the API key resource.
    public var description: Swift.String?
    /// The optional timestamp for when the API key resource will expire in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ. One of NoExpiry or ExpireTime must be set.
    public var expireTime: ClientRuntime.Date?
    /// A custom name for the API key resource. Requirements:
    ///
    /// * Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique API key name.
    ///
    /// * No spaces allowed. For example, ExampleAPIKey.
    /// This member is required.
    public var keyName: Swift.String?
    /// Optionally set to true to set no expiration time for the API key. One of NoExpiry or ExpireTime must be set.
    public var noExpiry: Swift.Bool?
    /// The API key restrictions for the API key resource.
    /// This member is required.
    public var restrictions: LocationClientTypes.ApiKeyRestrictions?
    /// Applies one or more tags to the map resource. A tag is a key-value pair that helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource
    ///
    /// * Each resource tag must be unique with a maximum of one value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        expireTime: ClientRuntime.Date? = nil,
        keyName: Swift.String? = nil,
        noExpiry: Swift.Bool? = nil,
        restrictions: LocationClientTypes.ApiKeyRestrictions? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.expireTime = expireTime
        self.keyName = keyName
        self.noExpiry = noExpiry
        self.restrictions = restrictions
        self.tags = tags
    }
}

extension CreateKeyOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateKeyOutput(createTime: \(Swift.String(describing: createTime)), keyArn: \(Swift.String(describing: keyArn)), keyName: \(Swift.String(describing: keyName)), key: \"CONTENT_REDACTED\")"}
}

extension CreateKeyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKeyOutput()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.key = try reader["Key"].readIfPresent()
        value.keyArn = try reader["KeyArn"].readIfPresent()
        value.keyName = try reader["KeyName"].readIfPresent()
        return value
    }
}

public struct CreateKeyOutput {
    /// The timestamp for when the API key resource was created in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The key value/string of an API key. This value is used when making API calls to authorize the call. For example, see [GetMapGlyphs](https://docs.aws.amazon.com/location/latest/APIReference/API_GetMapGlyphs.html).
    /// This member is required.
    public var key: Swift.String?
    /// The Amazon Resource Name (ARN) for the API key resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:key/ExampleKey
    /// This member is required.
    public var keyArn: Swift.String?
    /// The name of the API key resource.
    /// This member is required.
    public var keyName: Swift.String?

    public init(
        createTime: ClientRuntime.Date? = nil,
        key: Swift.String? = nil,
        keyArn: Swift.String? = nil,
        keyName: Swift.String? = nil
    )
    {
        self.createTime = createTime
        self.key = key
        self.keyArn = keyArn
        self.keyName = keyName
    }
}

enum CreateKeyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateMapInput {

    static func urlPathProvider(_ value: CreateMapInput) -> Swift.String? {
        return "/maps/v0/maps"
    }
}

extension CreateMapInput {

    static func write(value: CreateMapInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configuration"].write(value.configuration, with: LocationClientTypes.MapConfiguration.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["MapName"].write(value.mapName)
        try writer["PricingPlan"].write(value.pricingPlan)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateMapInput {
    /// Specifies the MapConfiguration, including the map style, for the map resource that you create. The map style defines the look of maps and the data provider for your map resource.
    /// This member is required.
    public var configuration: LocationClientTypes.MapConfiguration?
    /// An optional description for the map resource.
    public var description: Swift.String?
    /// The name for the map resource. Requirements:
    ///
    /// * Must contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique map resource name.
    ///
    /// * No spaces allowed. For example, ExampleMap.
    /// This member is required.
    public var mapName: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Applies one or more tags to the map resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource
    ///
    /// * Each resource tag must be unique with a maximum of one value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?

    public init(
        configuration: LocationClientTypes.MapConfiguration? = nil,
        description: Swift.String? = nil,
        mapName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.configuration = configuration
        self.description = description
        self.mapName = mapName
        self.pricingPlan = pricingPlan
        self.tags = tags
    }
}

extension CreateMapOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateMapOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMapOutput()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.mapArn = try reader["MapArn"].readIfPresent()
        value.mapName = try reader["MapName"].readIfPresent()
        return value
    }
}

public struct CreateMapOutput {
    /// The timestamp for when the map resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the map resource. Used to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:map/ExampleMap
    /// This member is required.
    public var mapArn: Swift.String?
    /// The name of the map resource.
    /// This member is required.
    public var mapName: Swift.String?

    public init(
        createTime: ClientRuntime.Date? = nil,
        mapArn: Swift.String? = nil,
        mapName: Swift.String? = nil
    )
    {
        self.createTime = createTime
        self.mapArn = mapArn
        self.mapName = mapName
    }
}

enum CreateMapOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreatePlaceIndexInput {

    static func urlPathProvider(_ value: CreatePlaceIndexInput) -> Swift.String? {
        return "/places/v0/indexes"
    }
}

extension CreatePlaceIndexInput {

    static func write(value: CreatePlaceIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSource"].write(value.dataSource)
        try writer["DataSourceConfiguration"].write(value.dataSourceConfiguration, with: LocationClientTypes.DataSourceConfiguration.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["IndexName"].write(value.indexName)
        try writer["PricingPlan"].write(value.pricingPlan)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreatePlaceIndexInput {
    /// Specifies the geospatial data provider for the new place index. This field is case-sensitive. Enter the valid values as shown. For example, entering HERE returns an error. Valid values include:
    ///
    /// * Esri – For additional information about [Esri](https://docs.aws.amazon.com/location/latest/developerguide/esri.html)'s coverage in your region of interest, see [Esri details on geocoding coverage](https://developers.arcgis.com/rest/geocode/api-reference/geocode-coverage.htm).
    ///
    /// * Grab – Grab provides place index functionality for Southeast Asia. For additional information about [GrabMaps](https://docs.aws.amazon.com/location/latest/developerguide/grab.html)' coverage, see [GrabMaps countries and areas covered](https://docs.aws.amazon.com/location/latest/developerguide/grab.html#grab-coverage-area).
    ///
    /// * Here – For additional information about [HERE Technologies](https://docs.aws.amazon.com/location/latest/developerguide/HERE.html)' coverage in your region of interest, see [HERE details on goecoding coverage](https://developer.here.com/documentation/geocoder/dev_guide/topics/coverage-geocoder.html). If you specify HERE Technologies (Here) as the data provider, you may not [store results](https://docs.aws.amazon.com/location-places/latest/APIReference/API_DataSourceConfiguration.html) for locations in Japan. For more information, see the [Amazon Web Services Service Terms](http://aws.amazon.com/service-terms/) for Amazon Location Service.
    ///
    ///
    /// For additional information , see [Data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html) on the Amazon Location Service Developer Guide.
    /// This member is required.
    public var dataSource: Swift.String?
    /// Specifies the data storage option requesting Places.
    public var dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    /// The optional description for the place index resource.
    public var description: Swift.String?
    /// The name of the place index resource. Requirements:
    ///
    /// * Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique place index resource name.
    ///
    /// * No spaces allowed. For example, ExamplePlaceIndex.
    /// This member is required.
    public var indexName: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Applies one or more tags to the place index resource. A tag is a key-value pair that helps you manage, identify, search, and filter your resources. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource.
    ///
    /// * Each tag key must be unique and must have exactly one associated value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?

    public init(
        dataSource: Swift.String? = nil,
        dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        indexName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dataSource = dataSource
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.indexName = indexName
        self.pricingPlan = pricingPlan
        self.tags = tags
    }
}

extension CreatePlaceIndexOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreatePlaceIndexOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePlaceIndexOutput()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.indexArn = try reader["IndexArn"].readIfPresent()
        value.indexName = try reader["IndexName"].readIfPresent()
        return value
    }
}

public struct CreatePlaceIndexOutput {
    /// The timestamp for when the place index resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the place index resource. Used to specify a resource across Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:place-index/ExamplePlaceIndex
    /// This member is required.
    public var indexArn: Swift.String?
    /// The name for the place index resource.
    /// This member is required.
    public var indexName: Swift.String?

    public init(
        createTime: ClientRuntime.Date? = nil,
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil
    )
    {
        self.createTime = createTime
        self.indexArn = indexArn
        self.indexName = indexName
    }
}

enum CreatePlaceIndexOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateRouteCalculatorInput {

    static func urlPathProvider(_ value: CreateRouteCalculatorInput) -> Swift.String? {
        return "/routes/v0/calculators"
    }
}

extension CreateRouteCalculatorInput {

    static func write(value: CreateRouteCalculatorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CalculatorName"].write(value.calculatorName)
        try writer["DataSource"].write(value.dataSource)
        try writer["Description"].write(value.description)
        try writer["PricingPlan"].write(value.pricingPlan)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateRouteCalculatorInput {
    /// The name of the route calculator resource. Requirements:
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9) , hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique Route calculator resource name.
    ///
    /// * No spaces allowed. For example, ExampleRouteCalculator.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// Specifies the data provider of traffic and road network data. This field is case-sensitive. Enter the valid values as shown. For example, entering HERE returns an error. Valid values include:
    ///
    /// * Esri – For additional information about [Esri](https://docs.aws.amazon.com/location/latest/developerguide/esri.html)'s coverage in your region of interest, see [Esri details on street networks and traffic coverage](https://doc.arcgis.com/en/arcgis-online/reference/network-coverage.htm). Route calculators that use Esri as a data source only calculate routes that are shorter than 400 km.
    ///
    /// * Grab – Grab provides routing functionality for Southeast Asia. For additional information about [GrabMaps](https://docs.aws.amazon.com/location/latest/developerguide/grab.html)' coverage, see [GrabMaps countries and areas covered](https://docs.aws.amazon.com/location/latest/developerguide/grab.html#grab-coverage-area).
    ///
    /// * Here – For additional information about [HERE Technologies](https://docs.aws.amazon.com/location/latest/developerguide/HERE.html)' coverage in your region of interest, see [HERE car routing coverage](https://developer.here.com/documentation/routing-api/dev_guide/topics/coverage/car-routing.html) and [HERE truck routing coverage](https://developer.here.com/documentation/routing-api/dev_guide/topics/coverage/truck-routing.html).
    ///
    ///
    /// For additional information , see [Data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html) on the Amazon Location Service Developer Guide.
    /// This member is required.
    public var dataSource: Swift.String?
    /// The optional description for the route calculator resource.
    public var description: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Applies one or more tags to the route calculator resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them.
    ///
    /// * For example: { "tag1" : "value1", "tag2" : "value2"}
    ///
    ///
    /// Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource
    ///
    /// * Each resource tag must be unique with a maximum of one value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?

    public init(
        calculatorName: Swift.String? = nil,
        dataSource: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.calculatorName = calculatorName
        self.dataSource = dataSource
        self.description = description
        self.pricingPlan = pricingPlan
        self.tags = tags
    }
}

extension CreateRouteCalculatorOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateRouteCalculatorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRouteCalculatorOutput()
        value.calculatorArn = try reader["CalculatorArn"].readIfPresent()
        value.calculatorName = try reader["CalculatorName"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct CreateRouteCalculatorOutput {
    /// The Amazon Resource Name (ARN) for the route calculator resource. Use the ARN when you specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:route-calculator/ExampleCalculator
    /// This member is required.
    public var calculatorArn: Swift.String?
    /// The name of the route calculator resource.
    ///
    /// * For example, ExampleRouteCalculator.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// The timestamp when the route calculator resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    ///
    /// * For example, 2020–07-2T12:15:20.000Z+01:00
    /// This member is required.
    public var createTime: ClientRuntime.Date?

    public init(
        calculatorArn: Swift.String? = nil,
        calculatorName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil
    )
    {
        self.calculatorArn = calculatorArn
        self.calculatorName = calculatorName
        self.createTime = createTime
    }
}

enum CreateRouteCalculatorOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateTrackerInput {

    static func urlPathProvider(_ value: CreateTrackerInput) -> Swift.String? {
        return "/tracking/v0/trackers"
    }
}

extension CreateTrackerInput {

    static func write(value: CreateTrackerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["EventBridgeEnabled"].write(value.eventBridgeEnabled)
        try writer["KmsKeyEnableGeospatialQueries"].write(value.kmsKeyEnableGeospatialQueries)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["PositionFiltering"].write(value.positionFiltering)
        try writer["PricingPlan"].write(value.pricingPlan)
        try writer["PricingPlanDataSource"].write(value.pricingPlanDataSource)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TrackerName"].write(value.trackerName)
    }
}

public struct CreateTrackerInput {
    /// An optional description for the tracker resource.
    public var description: Swift.String?
    /// Whether to enable position UPDATE events from this tracker to be sent to EventBridge. You do not need enable this feature to get ENTER and EXIT events for geofences with this tracker. Those events are always sent to EventBridge.
    public var eventBridgeEnabled: Swift.Bool?
    /// Enables GeospatialQueries for a tracker that uses a [Amazon Web Services KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html). This parameter is only used if you are using a KMS customer managed key. If you wish to encrypt your data using your own KMS customer managed key, then the Bounding Polygon Queries feature will be disabled by default. This is because by using this feature, a representation of your device positions will not be encrypted using the your KMS managed key. The exact device position, however; is still encrypted using your managed key. You can choose to opt-in to the Bounding Polygon Quseries feature. This is done by setting the KmsKeyEnableGeospatialQueries parameter to true when creating or updating a Tracker.
    public var kmsKeyEnableGeospatialQueries: Swift.Bool?
    /// A key identifier for an [Amazon Web Services KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html). Enter a key ID, key ARN, alias name, or alias ARN.
    public var kmsKeyId: Swift.String?
    /// Specifies the position filtering for the tracker resource. Valid values:
    ///
    /// * TimeBased - Location updates are evaluated against linked geofence collections, but not every location update is stored. If your update frequency is more often than 30 seconds, only one update per 30 seconds is stored for each unique device ID.
    ///
    /// * DistanceBased - If the device has moved less than 30 m (98.4 ft), location updates are ignored. Location updates within this area are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map.
    ///
    /// * AccuracyBased - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This can reduce the effects of GPS noise when displaying device trajectories on a map, and can help control your costs by reducing the number of geofence evaluations.
    ///
    ///
    /// This field is optional. If not specified, the default value is TimeBased.
    public var positionFiltering: LocationClientTypes.PositionFiltering?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// This parameter is no longer used.
    @available(*, deprecated, message: "Deprecated. No longer allowed. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?
    /// Applies one or more tags to the tracker resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource
    ///
    /// * Each resource tag must be unique with a maximum of one value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?
    /// The name for the tracker resource. Requirements:
    ///
    /// * Contain only alphanumeric characters (A-Z, a-z, 0-9) , hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique tracker resource name.
    ///
    /// * No spaces allowed. For example, ExampleTracker.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        description: Swift.String? = nil,
        eventBridgeEnabled: Swift.Bool? = nil,
        kmsKeyEnableGeospatialQueries: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        positionFiltering: LocationClientTypes.PositionFiltering? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.description = description
        self.eventBridgeEnabled = eventBridgeEnabled
        self.kmsKeyEnableGeospatialQueries = kmsKeyEnableGeospatialQueries
        self.kmsKeyId = kmsKeyId
        self.positionFiltering = positionFiltering
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
        self.trackerName = trackerName
    }
}

extension CreateTrackerOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateTrackerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTrackerOutput()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.trackerArn = try reader["TrackerArn"].readIfPresent()
        value.trackerName = try reader["TrackerName"].readIfPresent()
        return value
    }
}

public struct CreateTrackerOutput {
    /// The timestamp for when the tracker resource was created in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
    /// This member is required.
    public var trackerArn: Swift.String?
    /// The name of the tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        createTime: ClientRuntime.Date? = nil,
        trackerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.createTime = createTime
        self.trackerArn = trackerArn
        self.trackerName = trackerName
    }
}

enum CreateTrackerOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.DataSourceConfiguration {

    static func write(value: LocationClientTypes.DataSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IntendedUse"].write(value.intendedUse)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.DataSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.DataSourceConfiguration()
        value.intendedUse = try reader["IntendedUse"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// Specifies the data storage option chosen for requesting Places. When using Amazon Location Places:
    ///
    /// * If using HERE Technologies as a data provider, you can't store results for locations in Japan by setting IntendedUse to Storage. parameter.
    ///
    /// * Under the MobileAssetTracking or MobilAssetManagement pricing plan, you can't store results from your place index resources by setting IntendedUse to Storage. This returns a validation exception error.
    ///
    ///
    /// For more information, see the [AWS Service Terms](https://aws.amazon.com/service-terms/) for Amazon Location Service.
    public struct DataSourceConfiguration {
        /// Specifies how the results of an operation will be stored by the caller. Valid values include:
        ///
        /// * SingleUse specifies that the results won't be stored.
        ///
        /// * Storage specifies that the result can be cached or stored in a database.
        ///
        ///
        /// Default value: SingleUse
        public var intendedUse: LocationClientTypes.IntendedUse?

        public init(
            intendedUse: LocationClientTypes.IntendedUse? = nil
        )
        {
            self.intendedUse = intendedUse
        }
    }

}

extension DeleteGeofenceCollectionInput {

    static func urlPathProvider(_ value: DeleteGeofenceCollectionInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())"
    }
}

public struct DeleteGeofenceCollectionInput {
    /// The name of the geofence collection to be deleted.
    /// This member is required.
    public var collectionName: Swift.String?

    public init(
        collectionName: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
    }
}

extension DeleteGeofenceCollectionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteGeofenceCollectionOutput {
        return DeleteGeofenceCollectionOutput()
    }
}

public struct DeleteGeofenceCollectionOutput {

    public init() { }
}

enum DeleteGeofenceCollectionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteKeyInput {

    static func queryItemProvider(_ value: DeleteKeyInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let forceDelete = value.forceDelete {
            let forceDeleteQueryItem = ClientRuntime.SDKURLQueryItem(name: "forceDelete".urlPercentEncoding(), value: Swift.String(forceDelete).urlPercentEncoding())
            items.append(forceDeleteQueryItem)
        }
        return items
    }
}

extension DeleteKeyInput {

    static func urlPathProvider(_ value: DeleteKeyInput) -> Swift.String? {
        guard let keyName = value.keyName else {
            return nil
        }
        return "/metadata/v0/keys/\(keyName.urlPercentEncoding())"
    }
}

public struct DeleteKeyInput {
    /// ForceDelete bypasses an API key's expiry conditions and deletes the key. Set the parameter true to delete the key or to false to not preemptively delete the API key. Valid values: true, or false. Required: No This action is irreversible. Only use ForceDelete if you are certain the key is no longer in use.
    public var forceDelete: Swift.Bool?
    /// The name of the API key to delete.
    /// This member is required.
    public var keyName: Swift.String?

    public init(
        forceDelete: Swift.Bool? = nil,
        keyName: Swift.String? = nil
    )
    {
        self.forceDelete = forceDelete
        self.keyName = keyName
    }
}

extension DeleteKeyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteKeyOutput {
        return DeleteKeyOutput()
    }
}

public struct DeleteKeyOutput {

    public init() { }
}

enum DeleteKeyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteMapInput {

    static func urlPathProvider(_ value: DeleteMapInput) -> Swift.String? {
        guard let mapName = value.mapName else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())"
    }
}

public struct DeleteMapInput {
    /// The name of the map resource to be deleted.
    /// This member is required.
    public var mapName: Swift.String?

    public init(
        mapName: Swift.String? = nil
    )
    {
        self.mapName = mapName
    }
}

extension DeleteMapOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteMapOutput {
        return DeleteMapOutput()
    }
}

public struct DeleteMapOutput {

    public init() { }
}

enum DeleteMapOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeletePlaceIndexInput {

    static func urlPathProvider(_ value: DeletePlaceIndexInput) -> Swift.String? {
        guard let indexName = value.indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())"
    }
}

public struct DeletePlaceIndexInput {
    /// The name of the place index resource to be deleted.
    /// This member is required.
    public var indexName: Swift.String?

    public init(
        indexName: Swift.String? = nil
    )
    {
        self.indexName = indexName
    }
}

extension DeletePlaceIndexOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeletePlaceIndexOutput {
        return DeletePlaceIndexOutput()
    }
}

public struct DeletePlaceIndexOutput {

    public init() { }
}

enum DeletePlaceIndexOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteRouteCalculatorInput {

    static func urlPathProvider(_ value: DeleteRouteCalculatorInput) -> Swift.String? {
        guard let calculatorName = value.calculatorName else {
            return nil
        }
        return "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())"
    }
}

public struct DeleteRouteCalculatorInput {
    /// The name of the route calculator resource to be deleted.
    /// This member is required.
    public var calculatorName: Swift.String?

    public init(
        calculatorName: Swift.String? = nil
    )
    {
        self.calculatorName = calculatorName
    }
}

extension DeleteRouteCalculatorOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteRouteCalculatorOutput {
        return DeleteRouteCalculatorOutput()
    }
}

public struct DeleteRouteCalculatorOutput {

    public init() { }
}

enum DeleteRouteCalculatorOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteTrackerInput {

    static func urlPathProvider(_ value: DeleteTrackerInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())"
    }
}

public struct DeleteTrackerInput {
    /// The name of the tracker resource to be deleted.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        trackerName: Swift.String? = nil
    )
    {
        self.trackerName = trackerName
    }
}

extension DeleteTrackerOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteTrackerOutput {
        return DeleteTrackerOutput()
    }
}

public struct DeleteTrackerOutput {

    public init() { }
}

enum DeleteTrackerOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeGeofenceCollectionInput {

    static func urlPathProvider(_ value: DescribeGeofenceCollectionInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())"
    }
}

public struct DescribeGeofenceCollectionInput {
    /// The name of the geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?

    public init(
        collectionName: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
    }
}

extension DescribeGeofenceCollectionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeGeofenceCollectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeGeofenceCollectionOutput()
        value.collectionArn = try reader["CollectionArn"].readIfPresent()
        value.collectionName = try reader["CollectionName"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["Description"].readIfPresent()
        value.geofenceCount = try reader["GeofenceCount"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.pricingPlan = try reader["PricingPlan"].readIfPresent()
        value.pricingPlanDataSource = try reader["PricingPlanDataSource"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct DescribeGeofenceCollectionOutput {
    /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
    /// This member is required.
    public var collectionArn: Swift.String?
    /// The name of the geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The timestamp for when the geofence resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The optional description for the geofence collection.
    /// This member is required.
    public var description: Swift.String?
    /// The number of geofences in the geofence collection.
    public var geofenceCount: Swift.Int?
    /// A key identifier for an [Amazon Web Services KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html) assigned to the Amazon Location resource
    public var kmsKeyId: Swift.String?
    /// No longer used. Always returns RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// No longer used. Always returns an empty string.
    @available(*, deprecated, message: "Deprecated. Unused. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?
    /// Displays the key, value pairs of tags associated with this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp for when the geofence collection was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        collectionArn: Swift.String? = nil,
        collectionName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        geofenceCount: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.collectionArn = collectionArn
        self.collectionName = collectionName
        self.createTime = createTime
        self.description = description
        self.geofenceCount = geofenceCount
        self.kmsKeyId = kmsKeyId
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
        self.updateTime = updateTime
    }
}

enum DescribeGeofenceCollectionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeKeyInput {

    static func urlPathProvider(_ value: DescribeKeyInput) -> Swift.String? {
        guard let keyName = value.keyName else {
            return nil
        }
        return "/metadata/v0/keys/\(keyName.urlPercentEncoding())"
    }
}

public struct DescribeKeyInput {
    /// The name of the API key resource.
    /// This member is required.
    public var keyName: Swift.String?

    public init(
        keyName: Swift.String? = nil
    )
    {
        self.keyName = keyName
    }
}

extension DescribeKeyOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeKeyOutput(createTime: \(Swift.String(describing: createTime)), description: \(Swift.String(describing: description)), expireTime: \(Swift.String(describing: expireTime)), keyArn: \(Swift.String(describing: keyArn)), keyName: \(Swift.String(describing: keyName)), restrictions: \(Swift.String(describing: restrictions)), tags: \(Swift.String(describing: tags)), updateTime: \(Swift.String(describing: updateTime)), key: \"CONTENT_REDACTED\")"}
}

extension DescribeKeyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeKeyOutput()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["Description"].readIfPresent()
        value.expireTime = try reader["ExpireTime"].readTimestampIfPresent(format: .dateTime)
        value.key = try reader["Key"].readIfPresent()
        value.keyArn = try reader["KeyArn"].readIfPresent()
        value.keyName = try reader["KeyName"].readIfPresent()
        value.restrictions = try reader["Restrictions"].readIfPresent(with: LocationClientTypes.ApiKeyRestrictions.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct DescribeKeyOutput {
    /// The timestamp for when the API key resource was created in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The optional description for the API key resource.
    public var description: Swift.String?
    /// The timestamp for when the API key resource will expire in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var expireTime: ClientRuntime.Date?
    /// The key value/string of an API key.
    /// This member is required.
    public var key: Swift.String?
    /// The Amazon Resource Name (ARN) for the API key resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:key/ExampleKey
    /// This member is required.
    public var keyArn: Swift.String?
    /// The name of the API key resource.
    /// This member is required.
    public var keyName: Swift.String?
    /// API Restrictions on the allowed actions, resources, and referers for an API key resource.
    /// This member is required.
    public var restrictions: LocationClientTypes.ApiKeyRestrictions?
    /// Tags associated with the API key resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp for when the API key resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        createTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        expireTime: ClientRuntime.Date? = nil,
        key: Swift.String? = nil,
        keyArn: Swift.String? = nil,
        keyName: Swift.String? = nil,
        restrictions: LocationClientTypes.ApiKeyRestrictions? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.description = description
        self.expireTime = expireTime
        self.key = key
        self.keyArn = keyArn
        self.keyName = keyName
        self.restrictions = restrictions
        self.tags = tags
        self.updateTime = updateTime
    }
}

enum DescribeKeyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeMapInput {

    static func urlPathProvider(_ value: DescribeMapInput) -> Swift.String? {
        guard let mapName = value.mapName else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())"
    }
}

public struct DescribeMapInput {
    /// The name of the map resource.
    /// This member is required.
    public var mapName: Swift.String?

    public init(
        mapName: Swift.String? = nil
    )
    {
        self.mapName = mapName
    }
}

extension DescribeMapOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeMapOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMapOutput()
        value.configuration = try reader["Configuration"].readIfPresent(with: LocationClientTypes.MapConfiguration.read(from:))
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.dataSource = try reader["DataSource"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.mapArn = try reader["MapArn"].readIfPresent()
        value.mapName = try reader["MapName"].readIfPresent()
        value.pricingPlan = try reader["PricingPlan"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct DescribeMapOutput {
    /// Specifies the map tile style selected from a partner data provider.
    /// This member is required.
    public var configuration: LocationClientTypes.MapConfiguration?
    /// The timestamp for when the map resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// Specifies the data provider for the associated map tiles.
    /// This member is required.
    public var dataSource: Swift.String?
    /// The optional description for the map resource.
    /// This member is required.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) for the map resource. Used to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:map/ExampleMap
    /// This member is required.
    public var mapArn: Swift.String?
    /// The map style selected from an available provider.
    /// This member is required.
    public var mapName: Swift.String?
    /// No longer used. Always returns RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Tags associated with the map resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp for when the map resource was last update in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        configuration: LocationClientTypes.MapConfiguration? = nil,
        createTime: ClientRuntime.Date? = nil,
        dataSource: Swift.String? = nil,
        description: Swift.String? = nil,
        mapArn: Swift.String? = nil,
        mapName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.configuration = configuration
        self.createTime = createTime
        self.dataSource = dataSource
        self.description = description
        self.mapArn = mapArn
        self.mapName = mapName
        self.pricingPlan = pricingPlan
        self.tags = tags
        self.updateTime = updateTime
    }
}

enum DescribeMapOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribePlaceIndexInput {

    static func urlPathProvider(_ value: DescribePlaceIndexInput) -> Swift.String? {
        guard let indexName = value.indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())"
    }
}

public struct DescribePlaceIndexInput {
    /// The name of the place index resource.
    /// This member is required.
    public var indexName: Swift.String?

    public init(
        indexName: Swift.String? = nil
    )
    {
        self.indexName = indexName
    }
}

extension DescribePlaceIndexOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribePlaceIndexOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePlaceIndexOutput()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.dataSource = try reader["DataSource"].readIfPresent()
        value.dataSourceConfiguration = try reader["DataSourceConfiguration"].readIfPresent(with: LocationClientTypes.DataSourceConfiguration.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.indexArn = try reader["IndexArn"].readIfPresent()
        value.indexName = try reader["IndexName"].readIfPresent()
        value.pricingPlan = try reader["PricingPlan"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct DescribePlaceIndexOutput {
    /// The timestamp for when the place index resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The data provider of geospatial data. Values can be one of the following:
    ///
    /// * Esri
    ///
    /// * Grab
    ///
    /// * Here
    ///
    ///
    /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
    /// This member is required.
    public var dataSource: Swift.String?
    /// The specified data storage option for requesting Places.
    /// This member is required.
    public var dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    /// The optional description for the place index resource.
    /// This member is required.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) for the place index resource. Used to specify a resource across Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:place-index/ExamplePlaceIndex
    /// This member is required.
    public var indexArn: Swift.String?
    /// The name of the place index resource being described.
    /// This member is required.
    public var indexName: Swift.String?
    /// No longer used. Always returns RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Tags associated with place index resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp for when the place index resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        createTime: ClientRuntime.Date? = nil,
        dataSource: Swift.String? = nil,
        dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.dataSource = dataSource
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.indexArn = indexArn
        self.indexName = indexName
        self.pricingPlan = pricingPlan
        self.tags = tags
        self.updateTime = updateTime
    }
}

enum DescribePlaceIndexOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeRouteCalculatorInput {

    static func urlPathProvider(_ value: DescribeRouteCalculatorInput) -> Swift.String? {
        guard let calculatorName = value.calculatorName else {
            return nil
        }
        return "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())"
    }
}

public struct DescribeRouteCalculatorInput {
    /// The name of the route calculator resource.
    /// This member is required.
    public var calculatorName: Swift.String?

    public init(
        calculatorName: Swift.String? = nil
    )
    {
        self.calculatorName = calculatorName
    }
}

extension DescribeRouteCalculatorOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeRouteCalculatorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRouteCalculatorOutput()
        value.calculatorArn = try reader["CalculatorArn"].readIfPresent()
        value.calculatorName = try reader["CalculatorName"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.dataSource = try reader["DataSource"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.pricingPlan = try reader["PricingPlan"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct DescribeRouteCalculatorOutput {
    /// The Amazon Resource Name (ARN) for the Route calculator resource. Use the ARN when you specify a resource across Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:route-calculator/ExampleCalculator
    /// This member is required.
    public var calculatorArn: Swift.String?
    /// The name of the route calculator resource being described.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// The timestamp when the route calculator resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    ///
    /// * For example, 2020–07-2T12:15:20.000Z+01:00
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The data provider of traffic and road network data. Indicates one of the available providers:
    ///
    /// * Esri
    ///
    /// * Grab
    ///
    /// * Here
    ///
    ///
    /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
    /// This member is required.
    public var dataSource: Swift.String?
    /// The optional description of the route calculator resource.
    /// This member is required.
    public var description: Swift.String?
    /// Always returns RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Tags associated with route calculator resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp when the route calculator resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    ///
    /// * For example, 2020–07-2T12:15:20.000Z+01:00
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        calculatorArn: Swift.String? = nil,
        calculatorName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        dataSource: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.calculatorArn = calculatorArn
        self.calculatorName = calculatorName
        self.createTime = createTime
        self.dataSource = dataSource
        self.description = description
        self.pricingPlan = pricingPlan
        self.tags = tags
        self.updateTime = updateTime
    }
}

enum DescribeRouteCalculatorOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeTrackerInput {

    static func urlPathProvider(_ value: DescribeTrackerInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())"
    }
}

public struct DescribeTrackerInput {
    /// The name of the tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        trackerName: Swift.String? = nil
    )
    {
        self.trackerName = trackerName
    }
}

extension DescribeTrackerOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeTrackerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTrackerOutput()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["Description"].readIfPresent()
        value.eventBridgeEnabled = try reader["EventBridgeEnabled"].readIfPresent()
        value.kmsKeyEnableGeospatialQueries = try reader["KmsKeyEnableGeospatialQueries"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.positionFiltering = try reader["PositionFiltering"].readIfPresent()
        value.pricingPlan = try reader["PricingPlan"].readIfPresent()
        value.pricingPlanDataSource = try reader["PricingPlanDataSource"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.trackerArn = try reader["TrackerArn"].readIfPresent()
        value.trackerName = try reader["TrackerName"].readIfPresent()
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct DescribeTrackerOutput {
    /// The timestamp for when the tracker resource was created in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The optional description for the tracker resource.
    /// This member is required.
    public var description: Swift.String?
    /// Whether UPDATE events from this tracker in EventBridge are enabled. If set to true these events will be sent to EventBridge.
    public var eventBridgeEnabled: Swift.Bool?
    /// Enables GeospatialQueries for a tracker that uses a [Amazon Web Services KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html). This parameter is only used if you are using a KMS customer managed key. If you wish to encrypt your data using your own KMS customer managed key, then the Bounding Polygon Queries feature will be disabled by default. This is because by using this feature, a representation of your device positions will not be encrypted using the your KMS managed key. The exact device position, however; is still encrypted using your managed key. You can choose to opt-in to the Bounding Polygon Quseries feature. This is done by setting the KmsKeyEnableGeospatialQueries parameter to true when creating or updating a Tracker.
    public var kmsKeyEnableGeospatialQueries: Swift.Bool?
    /// A key identifier for an [Amazon Web Services KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html) assigned to the Amazon Location resource.
    public var kmsKeyId: Swift.String?
    /// The position filtering method of the tracker resource.
    public var positionFiltering: LocationClientTypes.PositionFiltering?
    /// Always returns RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// No longer used. Always returns an empty string.
    @available(*, deprecated, message: "Deprecated. Unused. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?
    /// The tags associated with the tracker resource.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
    /// This member is required.
    public var trackerArn: Swift.String?
    /// The name of the tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?
    /// The timestamp for when the tracker resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        createTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        eventBridgeEnabled: Swift.Bool? = nil,
        kmsKeyEnableGeospatialQueries: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        positionFiltering: LocationClientTypes.PositionFiltering? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.description = description
        self.eventBridgeEnabled = eventBridgeEnabled
        self.kmsKeyEnableGeospatialQueries = kmsKeyEnableGeospatialQueries
        self.kmsKeyId = kmsKeyId
        self.positionFiltering = positionFiltering
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
        self.trackerArn = trackerArn
        self.trackerName = trackerName
        self.updateTime = updateTime
    }
}

enum DescribeTrackerOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.DevicePosition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DevicePosition(accuracy: \(Swift.String(describing: accuracy)), deviceId: \(Swift.String(describing: deviceId)), receivedTime: \(Swift.String(describing: receivedTime)), sampleTime: \(Swift.String(describing: sampleTime)), position: \"CONTENT_REDACTED\", positionProperties: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes.DevicePosition {

    static func write(value: LocationClientTypes.DevicePosition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Accuracy"].write(value.accuracy, with: LocationClientTypes.PositionalAccuracy.write(value:to:))
        try writer["DeviceId"].write(value.deviceId)
        try writer["Position"].writeList(value.position, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PositionProperties"].writeMap(value.positionProperties, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ReceivedTime"].writeTimestamp(value.receivedTime, format: .dateTime)
        try writer["SampleTime"].writeTimestamp(value.sampleTime, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.DevicePosition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.DevicePosition()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.sampleTime = try reader["SampleTime"].readTimestampIfPresent(format: .dateTime)
        value.receivedTime = try reader["ReceivedTime"].readTimestampIfPresent(format: .dateTime)
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accuracy = try reader["Accuracy"].readIfPresent(with: LocationClientTypes.PositionalAccuracy.read(from:))
        value.positionProperties = try reader["PositionProperties"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension LocationClientTypes {
    /// Contains the device position details.
    public struct DevicePosition {
        /// The accuracy of the device position.
        public var accuracy: LocationClientTypes.PositionalAccuracy?
        /// The device whose position you retrieved.
        public var deviceId: Swift.String?
        /// The last known device position.
        /// This member is required.
        public var position: [Swift.Double]?
        /// The properties associated with the position.
        public var positionProperties: [Swift.String:Swift.String]?
        /// The timestamp for when the tracker resource received the device position in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var receivedTime: ClientRuntime.Date?
        /// The timestamp at which the device's position was determined. Uses [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init(
            accuracy: LocationClientTypes.PositionalAccuracy? = nil,
            deviceId: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            positionProperties: [Swift.String:Swift.String]? = nil,
            receivedTime: ClientRuntime.Date? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.receivedTime = receivedTime
            self.sampleTime = sampleTime
        }
    }

}

extension LocationClientTypes.DevicePositionUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DevicePositionUpdate(accuracy: \(Swift.String(describing: accuracy)), deviceId: \(Swift.String(describing: deviceId)), sampleTime: \(Swift.String(describing: sampleTime)), position: \"CONTENT_REDACTED\", positionProperties: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes.DevicePositionUpdate {

    static func write(value: LocationClientTypes.DevicePositionUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Accuracy"].write(value.accuracy, with: LocationClientTypes.PositionalAccuracy.write(value:to:))
        try writer["DeviceId"].write(value.deviceId)
        try writer["Position"].writeList(value.position, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PositionProperties"].writeMap(value.positionProperties, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["SampleTime"].writeTimestamp(value.sampleTime, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.DevicePositionUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.DevicePositionUpdate()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.sampleTime = try reader["SampleTime"].readTimestampIfPresent(format: .dateTime)
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accuracy = try reader["Accuracy"].readIfPresent(with: LocationClientTypes.PositionalAccuracy.read(from:))
        value.positionProperties = try reader["PositionProperties"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension LocationClientTypes {
    /// Contains the position update details for a device.
    public struct DevicePositionUpdate {
        /// The accuracy of the device position.
        public var accuracy: LocationClientTypes.PositionalAccuracy?
        /// The device associated to the position update.
        /// This member is required.
        public var deviceId: Swift.String?
        /// The latest device position defined in [WGS 84](https://earth-info.nga.mil/index.php?dir=wgs84&action=wgs84) format: [X or longitude, Y or latitude].
        /// This member is required.
        public var position: [Swift.Double]?
        /// Associates one of more properties with the position update. A property is a key-value pair stored with the position update and added to any geofence event the update may trigger. Format: "key" : "value"
        public var positionProperties: [Swift.String:Swift.String]?
        /// The timestamp at which the device's position was determined. Uses [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init(
            accuracy: LocationClientTypes.PositionalAccuracy? = nil,
            deviceId: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            positionProperties: [Swift.String:Swift.String]? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.sampleTime = sampleTime
        }
    }

}

extension LocationClientTypes {

    public enum DimensionUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case feet
        case meters
        case sdkUnknown(Swift.String)

        public static var allCases: [DimensionUnit] {
            return [
                .feet,
                .meters,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .feet: return "Feet"
            case .meters: return "Meters"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DisassociateTrackerConsumerInput {

    static func urlPathProvider(_ value: DisassociateTrackerConsumerInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        guard let consumerArn = value.consumerArn else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/consumers/\(consumerArn.urlPercentEncoding())"
    }
}

public struct DisassociateTrackerConsumerInput {
    /// The Amazon Resource Name (ARN) for the geofence collection to be disassociated from the tracker resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
    /// This member is required.
    public var consumerArn: Swift.String?
    /// The name of the tracker resource to be dissociated from the consumer.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        consumerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.consumerArn = consumerArn
        self.trackerName = trackerName
    }
}

extension DisassociateTrackerConsumerOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DisassociateTrackerConsumerOutput {
        return DisassociateTrackerConsumerOutput()
    }
}

public struct DisassociateTrackerConsumerOutput {

    public init() { }
}

enum DisassociateTrackerConsumerOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes {

    public enum DistanceUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case kilometers
        case miles
        case sdkUnknown(Swift.String)

        public static var allCases: [DistanceUnit] {
            return [
                .kilometers,
                .miles,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kilometers: return "Kilometers"
            case .miles: return "Miles"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LocationClientTypes.GeofenceGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeofenceGeometry(polygon: \(Swift.String(describing: polygon)), circle: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes.GeofenceGeometry {

    static func write(value: LocationClientTypes.GeofenceGeometry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Circle"].write(value.circle, with: LocationClientTypes.Circle.write(value:to:))
        try writer["Polygon"].writeList(value.polygon, memberWritingClosure: listWritingClosure(memberWritingClosure: listWritingClosure(memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.GeofenceGeometry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.GeofenceGeometry()
        value.polygon = try reader["Polygon"].readListIfPresent(memberReadingClosure: listReadingClosure(memberReadingClosure: listReadingClosure(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.circle = try reader["Circle"].readIfPresent(with: LocationClientTypes.Circle.read(from:))
        return value
    }
}

extension LocationClientTypes {
    /// Contains the geofence geometry details. A geofence geometry is made up of either a polygon or a circle. Can be either a polygon or a circle. Including both will return a validation error. Amazon Location doesn't currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian.
    public struct GeofenceGeometry {
        /// A circle on the earth, as defined by a center point and a radius.
        public var circle: LocationClientTypes.Circle?
        /// A polygon is a list of linear rings which are each made up of a list of vertices. Each vertex is a 2-dimensional point of the form: [longitude, latitude]. This is represented as an array of doubles of length 2 (so [double, double]). An array of 4 or more vertices, where the first and last vertex are the same (to form a closed boundary), is called a linear ring. The linear ring vertices must be listed in counter-clockwise order around the ring’s interior. The linear ring is represented as an array of vertices, or an array of arrays of doubles ([[double, double], ...]). A geofence consists of a single linear ring. To allow for future expansion, the Polygon parameter takes an array of linear rings, which is represented as an array of arrays of arrays of doubles ([[[double, double], ...], ...]). A linear ring for use in geofences can consist of between 4 and 1,000 vertices.
        public var polygon: [[[Swift.Double]]]?

        public init(
            circle: LocationClientTypes.Circle? = nil,
            polygon: [[[Swift.Double]]]? = nil
        )
        {
            self.circle = circle
            self.polygon = polygon
        }
    }

}

extension GetDevicePositionHistoryInput {

    static func urlPathProvider(_ value: GetDevicePositionHistoryInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())/list-positions"
    }
}

extension GetDevicePositionHistoryInput {

    static func write(value: GetDevicePositionHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTimeExclusive"].writeTimestamp(value.endTimeExclusive, format: .dateTime)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StartTimeInclusive"].writeTimestamp(value.startTimeInclusive, format: .dateTime)
    }
}

public struct GetDevicePositionHistoryInput {
    /// The device whose position history you want to retrieve.
    /// This member is required.
    public var deviceId: Swift.String?
    /// Specify the end time for the position history in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be the time that the request is made. Requirement:
    ///
    /// * The time specified for EndTimeExclusive must be after the time for StartTimeInclusive.
    public var endTimeExclusive: ClientRuntime.Date?
    /// An optional limit for the number of device positions returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?
    /// Specify the start time for the position history in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be 24 hours prior to the time that the request is made. Requirement:
    ///
    /// * The time specified for StartTimeInclusive must be before EndTimeExclusive.
    public var startTimeInclusive: ClientRuntime.Date?
    /// The tracker resource receiving the request for the device position history.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        endTimeExclusive: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTimeInclusive: ClientRuntime.Date? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.endTimeExclusive = endTimeExclusive
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeInclusive = startTimeInclusive
        self.trackerName = trackerName
    }
}

extension GetDevicePositionHistoryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetDevicePositionHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDevicePositionHistoryOutput()
        value.devicePositions = try reader["DevicePositions"].readListIfPresent(memberReadingClosure: LocationClientTypes.DevicePosition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct GetDevicePositionHistoryOutput {
    /// Contains the position history details for the requested device.
    /// This member is required.
    public var devicePositions: [LocationClientTypes.DevicePosition]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        devicePositions: [LocationClientTypes.DevicePosition]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devicePositions = devicePositions
        self.nextToken = nextToken
    }
}

enum GetDevicePositionHistoryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetDevicePositionInput {

    static func urlPathProvider(_ value: GetDevicePositionInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())/positions/latest"
    }
}

public struct GetDevicePositionInput {
    /// The device whose position you want to retrieve.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The tracker resource receiving the position update.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.trackerName = trackerName
    }
}

extension GetDevicePositionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicePositionOutput(accuracy: \(Swift.String(describing: accuracy)), deviceId: \(Swift.String(describing: deviceId)), receivedTime: \(Swift.String(describing: receivedTime)), sampleTime: \(Swift.String(describing: sampleTime)), position: \"CONTENT_REDACTED\", positionProperties: \"CONTENT_REDACTED\")"}
}

extension GetDevicePositionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetDevicePositionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDevicePositionOutput()
        value.accuracy = try reader["Accuracy"].readIfPresent(with: LocationClientTypes.PositionalAccuracy.read(from:))
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.positionProperties = try reader["PositionProperties"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.receivedTime = try reader["ReceivedTime"].readTimestampIfPresent(format: .dateTime)
        value.sampleTime = try reader["SampleTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct GetDevicePositionOutput {
    /// The accuracy of the device position.
    public var accuracy: LocationClientTypes.PositionalAccuracy?
    /// The device whose position you retrieved.
    public var deviceId: Swift.String?
    /// The last known device position.
    /// This member is required.
    public var position: [Swift.Double]?
    /// The properties associated with the position.
    public var positionProperties: [Swift.String:Swift.String]?
    /// The timestamp for when the tracker resource received the device position in [ ISO 8601 ](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var receivedTime: ClientRuntime.Date?
    /// The timestamp at which the device's position was determined. Uses [ ISO 8601 ](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var sampleTime: ClientRuntime.Date?

    public init(
        accuracy: LocationClientTypes.PositionalAccuracy? = nil,
        deviceId: Swift.String? = nil,
        position: [Swift.Double]? = nil,
        positionProperties: [Swift.String:Swift.String]? = nil,
        receivedTime: ClientRuntime.Date? = nil,
        sampleTime: ClientRuntime.Date? = nil
    )
    {
        self.accuracy = accuracy
        self.deviceId = deviceId
        self.position = position
        self.positionProperties = positionProperties
        self.receivedTime = receivedTime
        self.sampleTime = sampleTime
    }
}

enum GetDevicePositionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetGeofenceInput {

    static func urlPathProvider(_ value: GetGeofenceInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        guard let geofenceId = value.geofenceId else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/geofences/\(geofenceId.urlPercentEncoding())"
    }
}

public struct GetGeofenceInput {
    /// The geofence collection storing the target geofence.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The geofence you're retrieving details for.
    /// This member is required.
    public var geofenceId: Swift.String?

    public init(
        collectionName: Swift.String? = nil,
        geofenceId: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
        self.geofenceId = geofenceId
    }
}

extension GetGeofenceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGeofenceOutput(createTime: \(Swift.String(describing: createTime)), geofenceId: \(Swift.String(describing: geofenceId)), geometry: \(Swift.String(describing: geometry)), status: \(Swift.String(describing: status)), updateTime: \(Swift.String(describing: updateTime)), geofenceProperties: \"CONTENT_REDACTED\")"}
}

extension GetGeofenceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetGeofenceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGeofenceOutput()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.geofenceId = try reader["GeofenceId"].readIfPresent()
        value.geofenceProperties = try reader["GeofenceProperties"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.geometry = try reader["Geometry"].readIfPresent(with: LocationClientTypes.GeofenceGeometry.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct GetGeofenceOutput {
    /// The timestamp for when the geofence collection was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The geofence identifier.
    /// This member is required.
    public var geofenceId: Swift.String?
    /// User defined properties of the geofence. A property is a key-value pair stored with the geofence and added to any geofence event triggered with that geofence. Format: "key" : "value"
    public var geofenceProperties: [Swift.String:Swift.String]?
    /// Contains the geofence geometry details describing a polygon or a circle.
    /// This member is required.
    public var geometry: LocationClientTypes.GeofenceGeometry?
    /// Identifies the state of the geofence. A geofence will hold one of the following states:
    ///
    /// * ACTIVE — The geofence has been indexed by the system.
    ///
    /// * PENDING — The geofence is being processed by the system.
    ///
    /// * FAILED — The geofence failed to be indexed by the system.
    ///
    /// * DELETED — The geofence has been deleted from the system index.
    ///
    /// * DELETING — The geofence is being deleted from the system index.
    /// This member is required.
    public var status: Swift.String?
    /// The timestamp for when the geofence collection was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        createTime: ClientRuntime.Date? = nil,
        geofenceId: Swift.String? = nil,
        geofenceProperties: [Swift.String:Swift.String]? = nil,
        geometry: LocationClientTypes.GeofenceGeometry? = nil,
        status: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.geofenceId = geofenceId
        self.geofenceProperties = geofenceProperties
        self.geometry = geometry
        self.status = status
        self.updateTime = updateTime
    }
}

enum GetGeofenceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetMapGlyphsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapGlyphsInput(fontStack: \(Swift.String(describing: fontStack)), fontUnicodeRange: \(Swift.String(describing: fontUnicodeRange)), mapName: \(Swift.String(describing: mapName)), key: \"CONTENT_REDACTED\")"}
}

extension GetMapGlyphsInput {

    static func queryItemProvider(_ value: GetMapGlyphsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GetMapGlyphsInput {

    static func urlPathProvider(_ value: GetMapGlyphsInput) -> Swift.String? {
        guard let mapName = value.mapName else {
            return nil
        }
        guard let fontStack = value.fontStack else {
            return nil
        }
        guard let fontUnicodeRange = value.fontUnicodeRange else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())/glyphs/\(fontStack.urlPercentEncoding())/\(fontUnicodeRange.urlPercentEncoding())"
    }
}

public struct GetMapGlyphsInput {
    /// A comma-separated list of fonts to load glyphs from in order of preference. For example, Noto Sans Regular, Arial Unicode. Valid font stacks for [Esri](https://docs.aws.amazon.com/location/latest/developerguide/esri.html) styles:
    ///
    /// * VectorEsriDarkGrayCanvas – Ubuntu Medium Italic | Ubuntu Medium | Ubuntu Italic | Ubuntu Regular | Ubuntu Bold
    ///
    /// * VectorEsriLightGrayCanvas – Ubuntu Italic | Ubuntu Regular | Ubuntu Light | Ubuntu Bold
    ///
    /// * VectorEsriTopographic – Noto Sans Italic | Noto Sans Regular | Noto Sans Bold | Noto Serif Regular | Roboto Condensed Light Italic
    ///
    /// * VectorEsriStreets – Arial Regular | Arial Italic | Arial Bold
    ///
    /// * VectorEsriNavigation – Arial Regular | Arial Italic | Arial Bold | Arial Unicode MS Bold | Arial Unicode MS Regular
    ///
    ///
    /// Valid font stacks for [HERE Technologies](https://docs.aws.amazon.com/location/latest/developerguide/HERE.html) styles:
    ///
    /// * VectorHereContrast – Fira GO Regular | Fira GO Bold
    ///
    /// * VectorHereExplore, VectorHereExploreTruck, HybridHereExploreSatellite – Fira GO Italic | Fira GO Map | Fira GO Map Bold | Noto Sans CJK JP Bold | Noto Sans CJK JP Light | Noto Sans CJK JP Regular
    ///
    ///
    /// Valid font stacks for [GrabMaps](https://docs.aws.amazon.com/location/latest/developerguide/grab.html) styles:
    ///
    /// * VectorGrabStandardLight, VectorGrabStandardDark – Noto Sans Regular | Noto Sans Medium | Noto Sans Bold
    ///
    ///
    /// Valid font stacks for [Open Data](https://docs.aws.amazon.com/location/latest/developerguide/open-data.html) styles:
    ///
    /// * VectorOpenDataStandardLight, VectorOpenDataStandardDark, VectorOpenDataVisualizationLight, VectorOpenDataVisualizationDark – Amazon Ember Regular,Noto Sans Regular | Amazon Ember Bold,Noto Sans Bold | Amazon Ember Medium,Noto Sans Medium | Amazon Ember Regular Italic,Noto Sans Italic | Amazon Ember Condensed RC Regular,Noto Sans Regular | Amazon Ember Condensed RC Bold,Noto Sans Bold | Amazon Ember Regular,Noto Sans Regular,Noto Sans Arabic Regular | Amazon Ember Condensed RC Bold,Noto Sans Bold,Noto Sans Arabic Condensed Bold | Amazon Ember Bold,Noto Sans Bold,Noto Sans Arabic Bold | Amazon Ember Regular Italic,Noto Sans Italic,Noto Sans Arabic Regular | Amazon Ember Condensed RC Regular,Noto Sans Regular,Noto Sans Arabic Condensed Regular | Amazon Ember Medium,Noto Sans Medium,Noto Sans Arabic Medium
    ///
    ///
    /// The fonts used by the Open Data map styles are combined fonts that use Amazon Ember for most glyphs but Noto Sans for glyphs unsupported by Amazon Ember.
    /// This member is required.
    public var fontStack: Swift.String?
    /// A Unicode range of characters to download glyphs for. Each response will contain 256 characters. For example, 0–255 includes all characters from range U+0000 to 00FF. Must be aligned to multiples of 256.
    /// This member is required.
    public var fontUnicodeRange: Swift.String?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The map resource associated with the glyph ﬁle.
    /// This member is required.
    public var mapName: Swift.String?

    public init(
        fontStack: Swift.String? = nil,
        fontUnicodeRange: Swift.String? = nil,
        key: Swift.String? = nil,
        mapName: Swift.String? = nil
    )
    {
        self.fontStack = fontStack
        self.fontUnicodeRange = fontUnicodeRange
        self.key = key
        self.mapName = mapName
    }
}

extension GetMapGlyphsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetMapGlyphsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMapGlyphsOutput()
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            value.cacheControl = cacheControlHeaderValue
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.blob = data
        case .stream(let stream):
            value.blob = try stream.readToEnd()
        case .noStream:
            value.blob = nil
        }
        return value
    }
}

public struct GetMapGlyphsOutput {
    /// The glyph, as binary blob.
    public var blob: ClientRuntime.Data?
    /// The HTTP Cache-Control directive for the value.
    public var cacheControl: Swift.String?
    /// The map glyph content type. For example, application/octet-stream.
    public var contentType: Swift.String?

    public init(
        blob: ClientRuntime.Data? = nil,
        cacheControl: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.cacheControl = cacheControl
        self.contentType = contentType
    }
}

enum GetMapGlyphsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetMapSpritesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapSpritesInput(fileName: \(Swift.String(describing: fileName)), mapName: \(Swift.String(describing: mapName)), key: \"CONTENT_REDACTED\")"}
}

extension GetMapSpritesInput {

    static func queryItemProvider(_ value: GetMapSpritesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GetMapSpritesInput {

    static func urlPathProvider(_ value: GetMapSpritesInput) -> Swift.String? {
        guard let mapName = value.mapName else {
            return nil
        }
        guard let fileName = value.fileName else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())/sprites/\(fileName.urlPercentEncoding())"
    }
}

public struct GetMapSpritesInput {
    /// The name of the sprite ﬁle. Use the following ﬁle names for the sprite sheet:
    ///
    /// * sprites.png
    ///
    /// * sprites@2x.png for high pixel density displays
    ///
    ///
    /// For the JSON document containing image offsets. Use the following ﬁle names:
    ///
    /// * sprites.json
    ///
    /// * sprites@2x.json for high pixel density displays
    /// This member is required.
    public var fileName: Swift.String?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The map resource associated with the sprite ﬁle.
    /// This member is required.
    public var mapName: Swift.String?

    public init(
        fileName: Swift.String? = nil,
        key: Swift.String? = nil,
        mapName: Swift.String? = nil
    )
    {
        self.fileName = fileName
        self.key = key
        self.mapName = mapName
    }
}

extension GetMapSpritesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetMapSpritesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMapSpritesOutput()
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            value.cacheControl = cacheControlHeaderValue
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.blob = data
        case .stream(let stream):
            value.blob = try stream.readToEnd()
        case .noStream:
            value.blob = nil
        }
        return value
    }
}

public struct GetMapSpritesOutput {
    /// Contains the body of the sprite sheet or JSON offset ﬁle.
    public var blob: ClientRuntime.Data?
    /// The HTTP Cache-Control directive for the value.
    public var cacheControl: Swift.String?
    /// The content type of the sprite sheet and offsets. For example, the sprite sheet content type is image/png, and the sprite offset JSON document is application/json.
    public var contentType: Swift.String?

    public init(
        blob: ClientRuntime.Data? = nil,
        cacheControl: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.cacheControl = cacheControl
        self.contentType = contentType
    }
}

enum GetMapSpritesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetMapStyleDescriptorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapStyleDescriptorInput(mapName: \(Swift.String(describing: mapName)), key: \"CONTENT_REDACTED\")"}
}

extension GetMapStyleDescriptorInput {

    static func queryItemProvider(_ value: GetMapStyleDescriptorInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GetMapStyleDescriptorInput {

    static func urlPathProvider(_ value: GetMapStyleDescriptorInput) -> Swift.String? {
        guard let mapName = value.mapName else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())/style-descriptor"
    }
}

public struct GetMapStyleDescriptorInput {
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The map resource to retrieve the style descriptor from.
    /// This member is required.
    public var mapName: Swift.String?

    public init(
        key: Swift.String? = nil,
        mapName: Swift.String? = nil
    )
    {
        self.key = key
        self.mapName = mapName
    }
}

extension GetMapStyleDescriptorOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetMapStyleDescriptorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMapStyleDescriptorOutput()
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            value.cacheControl = cacheControlHeaderValue
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.blob = data
        case .stream(let stream):
            value.blob = try stream.readToEnd()
        case .noStream:
            value.blob = nil
        }
        return value
    }
}

public struct GetMapStyleDescriptorOutput {
    /// Contains the body of the style descriptor.
    public var blob: ClientRuntime.Data?
    /// The HTTP Cache-Control directive for the value.
    public var cacheControl: Swift.String?
    /// The style descriptor's content type. For example, application/json.
    public var contentType: Swift.String?

    public init(
        blob: ClientRuntime.Data? = nil,
        cacheControl: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.cacheControl = cacheControl
        self.contentType = contentType
    }
}

enum GetMapStyleDescriptorOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetMapTileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapTileInput(mapName: \(Swift.String(describing: mapName)), x: \(Swift.String(describing: x)), y: \(Swift.String(describing: y)), z: \(Swift.String(describing: z)), key: \"CONTENT_REDACTED\")"}
}

extension GetMapTileInput {

    static func queryItemProvider(_ value: GetMapTileInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GetMapTileInput {

    static func urlPathProvider(_ value: GetMapTileInput) -> Swift.String? {
        guard let mapName = value.mapName else {
            return nil
        }
        guard let z = value.z else {
            return nil
        }
        guard let x = value.x else {
            return nil
        }
        guard let y = value.y else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())/tiles/\(z.urlPercentEncoding())/\(x.urlPercentEncoding())/\(y.urlPercentEncoding())"
    }
}

public struct GetMapTileInput {
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The map resource to retrieve the map tiles from.
    /// This member is required.
    public var mapName: Swift.String?
    /// The X axis value for the map tile.
    /// This member is required.
    public var x: Swift.String?
    /// The Y axis value for the map tile.
    /// This member is required.
    public var y: Swift.String?
    /// The zoom value for the map tile.
    /// This member is required.
    public var z: Swift.String?

    public init(
        key: Swift.String? = nil,
        mapName: Swift.String? = nil,
        x: Swift.String? = nil,
        y: Swift.String? = nil,
        z: Swift.String? = nil
    )
    {
        self.key = key
        self.mapName = mapName
        self.x = x
        self.y = y
        self.z = z
    }
}

extension GetMapTileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetMapTileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMapTileOutput()
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            value.cacheControl = cacheControlHeaderValue
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.blob = data
        case .stream(let stream):
            value.blob = try stream.readToEnd()
        case .noStream:
            value.blob = nil
        }
        return value
    }
}

public struct GetMapTileOutput {
    /// Contains Mapbox Vector Tile (MVT) data.
    public var blob: ClientRuntime.Data?
    /// The HTTP Cache-Control directive for the value.
    public var cacheControl: Swift.String?
    /// The map tile's content type. For example, application/vnd.mapbox-vector-tile.
    public var contentType: Swift.String?

    public init(
        blob: ClientRuntime.Data? = nil,
        cacheControl: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.cacheControl = cacheControl
        self.contentType = contentType
    }
}

enum GetMapTileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetPlaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPlaceInput(indexName: \(Swift.String(describing: indexName)), language: \(Swift.String(describing: language)), placeId: \(Swift.String(describing: placeId)), key: \"CONTENT_REDACTED\")"}
}

extension GetPlaceInput {

    static func queryItemProvider(_ value: GetPlaceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let language = value.language {
            let languageQueryItem = ClientRuntime.SDKURLQueryItem(name: "language".urlPercentEncoding(), value: Swift.String(language).urlPercentEncoding())
            items.append(languageQueryItem)
        }
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GetPlaceInput {

    static func urlPathProvider(_ value: GetPlaceInput) -> Swift.String? {
        guard let indexName = value.indexName else {
            return nil
        }
        guard let placeId = value.placeId else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())/places/\(placeId.urlPercentEncoding())"
    }
}

public struct GetPlaceInput {
    /// The name of the place index resource that you want to use for the search.
    /// This member is required.
    public var indexName: Swift.String?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The preferred language used to return results. The value must be a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for a location around Athens, Greece, with the language parameter set to en. The city in the results will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the city in the results will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    public var language: Swift.String?
    /// The identifier of the place to find. While you can use PlaceID in subsequent requests, PlaceID is not intended to be a permanent identifier and the ID can change between consecutive API calls. Please see the following PlaceID behaviour for each data provider:
    ///
    /// * Esri: Place IDs will change every quarter at a minimum. The typical time period for these changes would be March, June, September, and December. Place IDs might also change between the typical quarterly change but that will be much less frequent.
    ///
    /// * HERE: We recommend that you cache data for no longer than a week to keep your data data fresh. You can assume that less than 1% ID shifts will release over release which is approximately 1 - 2 times per week.
    ///
    /// * Grab: Place IDs can expire or become invalid in the following situations.
    ///
    /// * Data operations: The POI may be removed from Grab POI database by Grab Map Ops based on the ground-truth, such as being closed in the real world, being detected as a duplicate POI, or having incorrect information. Grab will synchronize data to the Waypoint environment on weekly basis.
    ///
    /// * Interpolated POI: Interpolated POI is a temporary POI generated in real time when serving a request, and it will be marked as derived in the place.result_type field in the response. The information of interpolated POIs will be retained for at least 30 days, which means that within 30 days, you are able to obtain POI details by Place ID from Place Details API. After 30 days, the interpolated POIs(both Place ID and details) may expire and inaccessible from the Places Details API.
    /// This member is required.
    public var placeId: Swift.String?

    public init(
        indexName: Swift.String? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        placeId: Swift.String? = nil
    )
    {
        self.indexName = indexName
        self.key = key
        self.language = language
        self.placeId = placeId
    }
}

extension GetPlaceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetPlaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPlaceOutput()
        value.place = try reader["Place"].readIfPresent(with: LocationClientTypes.Place.read(from:))
        return value
    }
}

public struct GetPlaceOutput {
    /// Details about the result, such as its address and position.
    /// This member is required.
    public var place: LocationClientTypes.Place?

    public init(
        place: LocationClientTypes.Place? = nil
    )
    {
        self.place = place
    }
}

enum GetPlaceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes {

    public enum IntendedUse: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleuse
        /// Indicates that results of the operation may be stored locally.
        case storage
        case sdkUnknown(Swift.String)

        public static var allCases: [IntendedUse] {
            return [
                .singleuse,
                .storage,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .singleuse: return "SingleUse"
            case .storage: return "Storage"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request has failed to process because of an unknown server error, exception, or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LocationClientTypes.Leg: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Leg(distance: \(Swift.String(describing: distance)), durationSeconds: \(Swift.String(describing: durationSeconds)), geometry: \(Swift.String(describing: geometry)), steps: \(Swift.String(describing: steps)), endPosition: \"CONTENT_REDACTED\", startPosition: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes.Leg {

    static func write(value: LocationClientTypes.Leg?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Distance"].write(value.distance)
        try writer["DurationSeconds"].write(value.durationSeconds)
        try writer["EndPosition"].writeList(value.endPosition, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Geometry"].write(value.geometry, with: LocationClientTypes.LegGeometry.write(value:to:))
        try writer["StartPosition"].writeList(value.startPosition, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Steps"].writeList(value.steps, memberWritingClosure: LocationClientTypes.Step.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.Leg {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.Leg()
        value.startPosition = try reader["StartPosition"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.endPosition = try reader["EndPosition"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.distance = try reader["Distance"].readIfPresent()
        value.durationSeconds = try reader["DurationSeconds"].readIfPresent()
        value.geometry = try reader["Geometry"].readIfPresent(with: LocationClientTypes.LegGeometry.read(from:))
        value.steps = try reader["Steps"].readListIfPresent(memberReadingClosure: LocationClientTypes.Step.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LocationClientTypes {
    /// Contains the calculated route's details for each path between a pair of positions. The number of legs returned corresponds to one fewer than the total number of positions in the request. For example, a route with a departure position and destination position returns one leg with the positions [snapped to a nearby road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html):
    ///
    /// * The StartPosition is the departure position.
    ///
    /// * The EndPosition is the destination position.
    ///
    ///
    /// A route with a waypoint between the departure and destination position returns two legs with the positions snapped to a nearby road:
    ///
    /// * Leg 1: The StartPosition is the departure position . The EndPosition is the waypoint positon.
    ///
    /// * Leg 2: The StartPosition is the waypoint position. The EndPosition is the destination position.
    public struct Leg {
        /// The distance between the leg's StartPosition and EndPosition along a calculated route.
        ///
        /// * The default measurement is Kilometers unless the request specifies a DistanceUnit of Miles.
        /// This member is required.
        public var distance: Swift.Double?
        /// The estimated travel time between the leg's StartPosition and EndPosition. The travel mode and departure time that you specify in the request determines the calculated time.
        /// This member is required.
        public var durationSeconds: Swift.Double?
        /// The terminating position of the leg. Follows the format [longitude,latitude]. If the EndPosition isn't located on a road, it's [snapped to a nearby road](https://docs.aws.amazon.com/location/latest/developerguide/nap-to-nearby-road.html).
        /// This member is required.
        public var endPosition: [Swift.Double]?
        /// Contains the calculated route's path as a linestring geometry.
        public var geometry: LocationClientTypes.LegGeometry?
        /// The starting position of the leg. Follows the format [longitude,latitude]. If the StartPosition isn't located on a road, it's [snapped to a nearby road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html).
        /// This member is required.
        public var startPosition: [Swift.Double]?
        /// Contains a list of steps, which represent subsections of a leg. Each step provides instructions for how to move to the next step in the leg such as the step's start position, end position, travel distance, travel duration, and geometry offset.
        /// This member is required.
        public var steps: [LocationClientTypes.Step]?

        public init(
            distance: Swift.Double? = nil,
            durationSeconds: Swift.Double? = nil,
            endPosition: [Swift.Double]? = nil,
            geometry: LocationClientTypes.LegGeometry? = nil,
            startPosition: [Swift.Double]? = nil,
            steps: [LocationClientTypes.Step]? = nil
        )
        {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.endPosition = endPosition
            self.geometry = geometry
            self.startPosition = startPosition
            self.steps = steps
        }
    }

}

extension LocationClientTypes.LegGeometry {

    static func write(value: LocationClientTypes.LegGeometry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LineString"].writeList(value.lineString, memberWritingClosure: listWritingClosure(memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.LegGeometry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.LegGeometry()
        value.lineString = try reader["LineString"].readListIfPresent(memberReadingClosure: listReadingClosure(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LocationClientTypes {
    /// Contains the geometry details for each path between a pair of positions. Used in plotting a route leg on a map.
    public struct LegGeometry {
        /// An ordered list of positions used to plot a route on a map. The first position is closest to the start position for the leg, and the last position is the closest to the end position for the leg.
        ///
        /// * For example, [[-123.117, 49.284],[-123.115, 49.285],[-123.115, 49.285]]
        public var lineString: [[Swift.Double]]?

        public init(
            lineString: [[Swift.Double]]? = nil
        )
        {
            self.lineString = lineString
        }
    }

}

extension ListDevicePositionsInput {

    static func urlPathProvider(_ value: ListDevicePositionsInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/list-positions"
    }
}

extension ListDevicePositionsInput {

    static func write(value: ListDevicePositionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilterGeometry"].write(value.filterGeometry, with: LocationClientTypes.TrackingFilterGeometry.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListDevicePositionsInput {
    /// The geometry used to filter device positions.
    public var filterGeometry: LocationClientTypes.TrackingFilterGeometry?
    /// An optional limit for the number of entries returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?
    /// The tracker resource containing the requested devices.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        filterGeometry: LocationClientTypes.TrackingFilterGeometry? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.filterGeometry = filterGeometry
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trackerName = trackerName
    }
}

extension ListDevicePositionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDevicePositionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDevicePositionsOutput()
        value.entries = try reader["Entries"].readListIfPresent(memberReadingClosure: LocationClientTypes.ListDevicePositionsResponseEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListDevicePositionsOutput {
    /// Contains details about each device's last known position.
    /// This member is required.
    public var entries: [LocationClientTypes.ListDevicePositionsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListDevicePositionsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

enum ListDevicePositionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.ListDevicePositionsResponseEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevicePositionsResponseEntry(accuracy: \(Swift.String(describing: accuracy)), deviceId: \(Swift.String(describing: deviceId)), sampleTime: \(Swift.String(describing: sampleTime)), position: \"CONTENT_REDACTED\", positionProperties: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes.ListDevicePositionsResponseEntry {

    static func write(value: LocationClientTypes.ListDevicePositionsResponseEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Accuracy"].write(value.accuracy, with: LocationClientTypes.PositionalAccuracy.write(value:to:))
        try writer["DeviceId"].write(value.deviceId)
        try writer["Position"].writeList(value.position, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PositionProperties"].writeMap(value.positionProperties, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["SampleTime"].writeTimestamp(value.sampleTime, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.ListDevicePositionsResponseEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.ListDevicePositionsResponseEntry()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.sampleTime = try reader["SampleTime"].readTimestampIfPresent(format: .dateTime)
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accuracy = try reader["Accuracy"].readIfPresent(with: LocationClientTypes.PositionalAccuracy.read(from:))
        value.positionProperties = try reader["PositionProperties"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension LocationClientTypes {
    /// Contains the tracker resource details.
    public struct ListDevicePositionsResponseEntry {
        /// The accuracy of the device position.
        public var accuracy: LocationClientTypes.PositionalAccuracy?
        /// The ID of the device for this position.
        /// This member is required.
        public var deviceId: Swift.String?
        /// The last known device position. Empty if no positions currently stored.
        /// This member is required.
        public var position: [Swift.Double]?
        /// The properties associated with the position.
        public var positionProperties: [Swift.String:Swift.String]?
        /// The timestamp at which the device position was determined. Uses [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init(
            accuracy: LocationClientTypes.PositionalAccuracy? = nil,
            deviceId: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            positionProperties: [Swift.String:Swift.String]? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.sampleTime = sampleTime
        }
    }

}

extension ListGeofenceCollectionsInput {

    static func urlPathProvider(_ value: ListGeofenceCollectionsInput) -> Swift.String? {
        return "/geofencing/v0/list-collections"
    }
}

extension ListGeofenceCollectionsInput {

    static func write(value: ListGeofenceCollectionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListGeofenceCollectionsInput {
    /// An optional limit for the number of resources returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListGeofenceCollectionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListGeofenceCollectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGeofenceCollectionsOutput()
        value.entries = try reader["Entries"].readListIfPresent(memberReadingClosure: LocationClientTypes.ListGeofenceCollectionsResponseEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListGeofenceCollectionsOutput {
    /// Lists the geofence collections that exist in your Amazon Web Services account.
    /// This member is required.
    public var entries: [LocationClientTypes.ListGeofenceCollectionsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListGeofenceCollectionsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

enum ListGeofenceCollectionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.ListGeofenceCollectionsResponseEntry {

    static func write(value: LocationClientTypes.ListGeofenceCollectionsResponseEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CollectionName"].write(value.collectionName)
        try writer["CreateTime"].writeTimestamp(value.createTime, format: .dateTime)
        try writer["Description"].write(value.description)
        try writer["PricingPlan"].write(value.pricingPlan)
        try writer["PricingPlanDataSource"].write(value.pricingPlanDataSource)
        try writer["UpdateTime"].writeTimestamp(value.updateTime, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.ListGeofenceCollectionsResponseEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.ListGeofenceCollectionsResponseEntry()
        value.collectionName = try reader["CollectionName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.pricingPlan = try reader["PricingPlan"].readIfPresent()
        value.pricingPlanDataSource = try reader["PricingPlanDataSource"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension LocationClientTypes {
    /// Contains the geofence collection details.
    public struct ListGeofenceCollectionsResponseEntry {
        /// The name of the geofence collection.
        /// This member is required.
        public var collectionName: Swift.String?
        /// The timestamp for when the geofence collection was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description for the geofence collection
        /// This member is required.
        public var description: Swift.String?
        /// No longer used. Always returns RequestBasedUsage.
        @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// No longer used. Always returns an empty string.
        @available(*, deprecated, message: "Deprecated. Unused. API deprecated since 2022-02-01")
        public var pricingPlanDataSource: Swift.String?
        /// Specifies a timestamp for when the resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            collectionName: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            pricingPlanDataSource: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.updateTime = updateTime
        }
    }

}

extension LocationClientTypes.ListGeofenceResponseEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGeofenceResponseEntry(createTime: \(Swift.String(describing: createTime)), geofenceId: \(Swift.String(describing: geofenceId)), geometry: \(Swift.String(describing: geometry)), status: \(Swift.String(describing: status)), updateTime: \(Swift.String(describing: updateTime)), geofenceProperties: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes.ListGeofenceResponseEntry {

    static func write(value: LocationClientTypes.ListGeofenceResponseEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreateTime"].writeTimestamp(value.createTime, format: .dateTime)
        try writer["GeofenceId"].write(value.geofenceId)
        try writer["GeofenceProperties"].writeMap(value.geofenceProperties, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Geometry"].write(value.geometry, with: LocationClientTypes.GeofenceGeometry.write(value:to:))
        try writer["Status"].write(value.status)
        try writer["UpdateTime"].writeTimestamp(value.updateTime, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.ListGeofenceResponseEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.ListGeofenceResponseEntry()
        value.geofenceId = try reader["GeofenceId"].readIfPresent()
        value.geometry = try reader["Geometry"].readIfPresent(with: LocationClientTypes.GeofenceGeometry.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        value.geofenceProperties = try reader["GeofenceProperties"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension LocationClientTypes {
    /// Contains a list of geofences stored in a given geofence collection.
    public struct ListGeofenceResponseEntry {
        /// The timestamp for when the geofence was stored in a geofence collection in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The geofence identifier.
        /// This member is required.
        public var geofenceId: Swift.String?
        /// User defined properties of the geofence. A property is a key-value pair stored with the geofence and added to any geofence event triggered with that geofence. Format: "key" : "value"
        public var geofenceProperties: [Swift.String:Swift.String]?
        /// Contains the geofence geometry details describing a polygon or a circle.
        /// This member is required.
        public var geometry: LocationClientTypes.GeofenceGeometry?
        /// Identifies the state of the geofence. A geofence will hold one of the following states:
        ///
        /// * ACTIVE — The geofence has been indexed by the system.
        ///
        /// * PENDING — The geofence is being processed by the system.
        ///
        /// * FAILED — The geofence failed to be indexed by the system.
        ///
        /// * DELETED — The geofence has been deleted from the system index.
        ///
        /// * DELETING — The geofence is being deleted from the system index.
        /// This member is required.
        public var status: Swift.String?
        /// The timestamp for when the geofence was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            createTime: ClientRuntime.Date? = nil,
            geofenceId: Swift.String? = nil,
            geofenceProperties: [Swift.String:Swift.String]? = nil,
            geometry: LocationClientTypes.GeofenceGeometry? = nil,
            status: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.geofenceProperties = geofenceProperties
            self.geometry = geometry
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension ListGeofencesInput {

    static func urlPathProvider(_ value: ListGeofencesInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/list-geofences"
    }
}

extension ListGeofencesInput {

    static func write(value: ListGeofencesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListGeofencesInput {
    /// The name of the geofence collection storing the list of geofences.
    /// This member is required.
    public var collectionName: Swift.String?
    /// An optional limit for the number of geofences returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init(
        collectionName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListGeofencesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListGeofencesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGeofencesOutput()
        value.entries = try reader["Entries"].readListIfPresent(memberReadingClosure: LocationClientTypes.ListGeofenceResponseEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListGeofencesOutput {
    /// Contains a list of geofences stored in the geofence collection.
    /// This member is required.
    public var entries: [LocationClientTypes.ListGeofenceResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListGeofenceResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

enum ListGeofencesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListKeysInput {

    static func urlPathProvider(_ value: ListKeysInput) -> Swift.String? {
        return "/metadata/v0/list-keys"
    }
}

extension ListKeysInput {

    static func write(value: ListKeysInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: LocationClientTypes.ApiKeyFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListKeysInput {
    /// Optionally filter the list to only Active or Expired API keys.
    public var filter: LocationClientTypes.ApiKeyFilter?
    /// An optional limit for the number of resources returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init(
        filter: LocationClientTypes.ApiKeyFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListKeysOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKeysOutput()
        value.entries = try reader["Entries"].readListIfPresent(memberReadingClosure: LocationClientTypes.ListKeysResponseEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListKeysOutput {
    /// Contains API key resources in your Amazon Web Services account. Details include API key name, allowed referers and timestamp for when the API key will expire.
    /// This member is required.
    public var entries: [LocationClientTypes.ListKeysResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListKeysResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

enum ListKeysOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.ListKeysResponseEntry {

    static func write(value: LocationClientTypes.ListKeysResponseEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreateTime"].writeTimestamp(value.createTime, format: .dateTime)
        try writer["Description"].write(value.description)
        try writer["ExpireTime"].writeTimestamp(value.expireTime, format: .dateTime)
        try writer["KeyName"].write(value.keyName)
        try writer["Restrictions"].write(value.restrictions, with: LocationClientTypes.ApiKeyRestrictions.write(value:to:))
        try writer["UpdateTime"].writeTimestamp(value.updateTime, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.ListKeysResponseEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.ListKeysResponseEntry()
        value.keyName = try reader["KeyName"].readIfPresent()
        value.expireTime = try reader["ExpireTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["Description"].readIfPresent()
        value.restrictions = try reader["Restrictions"].readIfPresent(with: LocationClientTypes.ApiKeyRestrictions.read(from:))
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension LocationClientTypes {
    /// An API key resource listed in your Amazon Web Services account.
    public struct ListKeysResponseEntry {
        /// The timestamp of when the API key was created, in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The optional description for the API key resource.
        public var description: Swift.String?
        /// The timestamp for when the API key resource will expire, in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var expireTime: ClientRuntime.Date?
        /// The name of the API key resource.
        /// This member is required.
        public var keyName: Swift.String?
        /// API Restrictions on the allowed actions, resources, and referers for an API key resource.
        /// This member is required.
        public var restrictions: LocationClientTypes.ApiKeyRestrictions?
        /// The timestamp of when the API key was last updated, in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            expireTime: ClientRuntime.Date? = nil,
            keyName: Swift.String? = nil,
            restrictions: LocationClientTypes.ApiKeyRestrictions? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.description = description
            self.expireTime = expireTime
            self.keyName = keyName
            self.restrictions = restrictions
            self.updateTime = updateTime
        }
    }

}

extension ListMapsInput {

    static func urlPathProvider(_ value: ListMapsInput) -> Swift.String? {
        return "/maps/v0/list-maps"
    }
}

extension ListMapsInput {

    static func write(value: ListMapsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListMapsInput {
    /// An optional limit for the number of resources returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListMapsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListMapsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMapsOutput()
        value.entries = try reader["Entries"].readListIfPresent(memberReadingClosure: LocationClientTypes.ListMapsResponseEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListMapsOutput {
    /// Contains a list of maps in your Amazon Web Services account
    /// This member is required.
    public var entries: [LocationClientTypes.ListMapsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListMapsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

enum ListMapsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.ListMapsResponseEntry {

    static func write(value: LocationClientTypes.ListMapsResponseEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreateTime"].writeTimestamp(value.createTime, format: .dateTime)
        try writer["DataSource"].write(value.dataSource)
        try writer["Description"].write(value.description)
        try writer["MapName"].write(value.mapName)
        try writer["PricingPlan"].write(value.pricingPlan)
        try writer["UpdateTime"].writeTimestamp(value.updateTime, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.ListMapsResponseEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.ListMapsResponseEntry()
        value.mapName = try reader["MapName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.dataSource = try reader["DataSource"].readIfPresent()
        value.pricingPlan = try reader["PricingPlan"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension LocationClientTypes {
    /// Contains details of an existing map resource in your Amazon Web Services account.
    public struct ListMapsResponseEntry {
        /// The timestamp for when the map resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// Specifies the data provider for the associated map tiles.
        /// This member is required.
        public var dataSource: Swift.String?
        /// The description for the map resource.
        /// This member is required.
        public var description: Swift.String?
        /// The name of the associated map resource.
        /// This member is required.
        public var mapName: Swift.String?
        /// No longer used. Always returns RequestBasedUsage.
        @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// The timestamp for when the map resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            createTime: ClientRuntime.Date? = nil,
            dataSource: Swift.String? = nil,
            description: Swift.String? = nil,
            mapName: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapName = mapName
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }
    }

}

extension ListPlaceIndexesInput {

    static func urlPathProvider(_ value: ListPlaceIndexesInput) -> Swift.String? {
        return "/places/v0/list-indexes"
    }
}

extension ListPlaceIndexesInput {

    static func write(value: ListPlaceIndexesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListPlaceIndexesInput {
    /// An optional limit for the maximum number of results returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListPlaceIndexesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListPlaceIndexesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPlaceIndexesOutput()
        value.entries = try reader["Entries"].readListIfPresent(memberReadingClosure: LocationClientTypes.ListPlaceIndexesResponseEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListPlaceIndexesOutput {
    /// Lists the place index resources that exist in your Amazon Web Services account
    /// This member is required.
    public var entries: [LocationClientTypes.ListPlaceIndexesResponseEntry]?
    /// A pagination token indicating that there are additional pages available. You can use the token in a new request to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListPlaceIndexesResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

enum ListPlaceIndexesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.ListPlaceIndexesResponseEntry {

    static func write(value: LocationClientTypes.ListPlaceIndexesResponseEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreateTime"].writeTimestamp(value.createTime, format: .dateTime)
        try writer["DataSource"].write(value.dataSource)
        try writer["Description"].write(value.description)
        try writer["IndexName"].write(value.indexName)
        try writer["PricingPlan"].write(value.pricingPlan)
        try writer["UpdateTime"].writeTimestamp(value.updateTime, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.ListPlaceIndexesResponseEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.ListPlaceIndexesResponseEntry()
        value.indexName = try reader["IndexName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.dataSource = try reader["DataSource"].readIfPresent()
        value.pricingPlan = try reader["PricingPlan"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension LocationClientTypes {
    /// A place index resource listed in your Amazon Web Services account.
    public struct ListPlaceIndexesResponseEntry {
        /// The timestamp for when the place index resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The data provider of geospatial data. Values can be one of the following:
        ///
        /// * Esri
        ///
        /// * Grab
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// The optional description for the place index resource.
        /// This member is required.
        public var description: Swift.String?
        /// The name of the place index resource.
        /// This member is required.
        public var indexName: Swift.String?
        /// No longer used. Always returns RequestBasedUsage.
        @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// The timestamp for when the place index resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            createTime: ClientRuntime.Date? = nil,
            dataSource: Swift.String? = nil,
            description: Swift.String? = nil,
            indexName: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.indexName = indexName
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }
    }

}

extension ListRouteCalculatorsInput {

    static func urlPathProvider(_ value: ListRouteCalculatorsInput) -> Swift.String? {
        return "/routes/v0/list-calculators"
    }
}

extension ListRouteCalculatorsInput {

    static func write(value: ListRouteCalculatorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListRouteCalculatorsInput {
    /// An optional maximum number of results returned in a single call. Default Value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default Value: null
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListRouteCalculatorsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListRouteCalculatorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRouteCalculatorsOutput()
        value.entries = try reader["Entries"].readListIfPresent(memberReadingClosure: LocationClientTypes.ListRouteCalculatorsResponseEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListRouteCalculatorsOutput {
    /// Lists the route calculator resources that exist in your Amazon Web Services account
    /// This member is required.
    public var entries: [LocationClientTypes.ListRouteCalculatorsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a subsequent request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListRouteCalculatorsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

enum ListRouteCalculatorsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.ListRouteCalculatorsResponseEntry {

    static func write(value: LocationClientTypes.ListRouteCalculatorsResponseEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CalculatorName"].write(value.calculatorName)
        try writer["CreateTime"].writeTimestamp(value.createTime, format: .dateTime)
        try writer["DataSource"].write(value.dataSource)
        try writer["Description"].write(value.description)
        try writer["PricingPlan"].write(value.pricingPlan)
        try writer["UpdateTime"].writeTimestamp(value.updateTime, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.ListRouteCalculatorsResponseEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.ListRouteCalculatorsResponseEntry()
        value.calculatorName = try reader["CalculatorName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.dataSource = try reader["DataSource"].readIfPresent()
        value.pricingPlan = try reader["PricingPlan"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension LocationClientTypes {
    /// A route calculator resource listed in your Amazon Web Services account.
    public struct ListRouteCalculatorsResponseEntry {
        /// The name of the route calculator resource.
        /// This member is required.
        public var calculatorName: Swift.String?
        /// The timestamp when the route calculator resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        ///
        /// * For example, 2020–07-2T12:15:20.000Z+01:00
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The data provider of traffic and road network data. Indicates one of the available providers:
        ///
        /// * Esri
        ///
        /// * Grab
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// The optional description of the route calculator resource.
        /// This member is required.
        public var description: Swift.String?
        /// Always returns RequestBasedUsage.
        @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// The timestamp when the route calculator resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        ///
        /// * For example, 2020–07-2T12:15:20.000Z+01:00
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            calculatorName: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            dataSource: Swift.String? = nil,
            description: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.calculatorName = calculatorName
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }
    }

}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
    ///
    /// * Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// Tags that have been applied to the specified resource. Tags are mapped from the tag key to the tag value: "TagKey" : "TagValue".
    ///
    /// * Format example: {"tag1" : "value1", "tag2" : "value2"}
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTrackerConsumersInput {

    static func urlPathProvider(_ value: ListTrackerConsumersInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/list-consumers"
    }
}

extension ListTrackerConsumersInput {

    static func write(value: ListTrackerConsumersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListTrackerConsumersInput {
    /// An optional limit for the number of resources returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?
    /// The tracker resource whose associated geofence collections you want to list.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trackerName = trackerName
    }
}

extension ListTrackerConsumersOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTrackerConsumersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTrackerConsumersOutput()
        value.consumerArns = try reader["ConsumerArns"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListTrackerConsumersOutput {
    /// Contains the list of geofence collection ARNs associated to the tracker resource.
    /// This member is required.
    public var consumerArns: [Swift.String]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        consumerArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.consumerArns = consumerArns
        self.nextToken = nextToken
    }
}

enum ListTrackerConsumersOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTrackersInput {

    static func urlPathProvider(_ value: ListTrackersInput) -> Swift.String? {
        return "/tracking/v0/list-trackers"
    }
}

extension ListTrackersInput {

    static func write(value: ListTrackersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListTrackersInput {
    /// An optional limit for the number of resources returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListTrackersOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTrackersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTrackersOutput()
        value.entries = try reader["Entries"].readListIfPresent(memberReadingClosure: LocationClientTypes.ListTrackersResponseEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListTrackersOutput {
    /// Contains tracker resources in your Amazon Web Services account. Details include tracker name, description and timestamps for when the tracker was created and last updated.
    /// This member is required.
    public var entries: [LocationClientTypes.ListTrackersResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListTrackersResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

enum ListTrackersOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.ListTrackersResponseEntry {

    static func write(value: LocationClientTypes.ListTrackersResponseEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreateTime"].writeTimestamp(value.createTime, format: .dateTime)
        try writer["Description"].write(value.description)
        try writer["PricingPlan"].write(value.pricingPlan)
        try writer["PricingPlanDataSource"].write(value.pricingPlanDataSource)
        try writer["TrackerName"].write(value.trackerName)
        try writer["UpdateTime"].writeTimestamp(value.updateTime, format: .dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.ListTrackersResponseEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.ListTrackersResponseEntry()
        value.trackerName = try reader["TrackerName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.pricingPlan = try reader["PricingPlan"].readIfPresent()
        value.pricingPlanDataSource = try reader["PricingPlanDataSource"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension LocationClientTypes {
    /// Contains the tracker resource details.
    public struct ListTrackersResponseEntry {
        /// The timestamp for when the tracker resource was created in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description for the tracker resource.
        /// This member is required.
        public var description: Swift.String?
        /// Always returns RequestBasedUsage.
        @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// No longer used. Always returns an empty string.
        @available(*, deprecated, message: "Deprecated. Unused. API deprecated since 2022-02-01")
        public var pricingPlanDataSource: Swift.String?
        /// The name of the tracker resource.
        /// This member is required.
        public var trackerName: Swift.String?
        /// The timestamp at which the device's position was determined. Uses [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            pricingPlanDataSource: Swift.String? = nil,
            trackerName: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.trackerName = trackerName
            self.updateTime = updateTime
        }
    }

}

public enum LocationClientTypes {}

extension LocationClientTypes.MapConfiguration {

    static func write(value: LocationClientTypes.MapConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomLayers"].writeList(value.customLayers, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PoliticalView"].write(value.politicalView)
        try writer["Style"].write(value.style)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.MapConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.MapConfiguration()
        value.style = try reader["Style"].readIfPresent()
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        value.customLayers = try reader["CustomLayers"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LocationClientTypes {
    /// Specifies the map tile style selected from an available provider.
    public struct MapConfiguration {
        /// Specifies the custom layers for the style. Leave unset to not enable any custom layer, or, for styles that support custom layers, you can enable layer(s), such as POI layer for the VectorEsriNavigation style. Default is unset. Currenlty only VectorEsriNavigation supports CustomLayers. For more information, see [Custom Layers](https://docs.aws.amazon.com/location/latest/developerguide/map-concepts.html#map-custom-layers).
        public var customLayers: [Swift.String]?
        /// Specifies the political view for the style. Leave unset to not use a political view, or, for styles that support specific political views, you can choose a view, such as IND for the Indian view. Default is unset. Not all map resources or styles support political view styles. See [Political views](https://docs.aws.amazon.com/location/latest/developerguide/map-concepts.html#political-views) for more information.
        public var politicalView: Swift.String?
        /// Specifies the map style selected from an available data provider. Valid [Esri map styles](https://docs.aws.amazon.com/location/latest/developerguide/esri.html):
        ///
        /// * VectorEsriNavigation – The Esri Navigation map style, which provides a detailed basemap for the world symbolized with a custom navigation map style that's designed for use during the day in mobile devices. It also includes a richer set of places, such as shops, services, restaurants, attractions, and other points of interest. Enable the POI layer by setting it in CustomLayers to leverage the additional places data.
        ///
        /// * RasterEsriImagery – The Esri Imagery map style. A raster basemap that provides one meter or better satellite and aerial imagery in many parts of the world and lower resolution satellite imagery worldwide.
        ///
        /// * VectorEsriLightGrayCanvas – The Esri Light Gray Canvas map style, which provides a detailed vector basemap with a light gray, neutral background style with minimal colors, labels, and features that's designed to draw attention to your thematic content.
        ///
        /// * VectorEsriTopographic – The Esri Light map style, which provides a detailed vector basemap with a classic Esri map style.
        ///
        /// * VectorEsriStreets – The Esri Street Map style, which provides a detailed vector basemap for the world symbolized with a classic Esri street map style. The vector tile layer is similar in content and style to the World Street Map raster map.
        ///
        /// * VectorEsriDarkGrayCanvas – The Esri Dark Gray Canvas map style. A vector basemap with a dark gray, neutral background with minimal colors, labels, and features that's designed to draw attention to your thematic content.
        ///
        ///
        /// Valid [HERE Technologies map styles](https://docs.aws.amazon.com/location/latest/developerguide/HERE.html):
        ///
        /// * VectorHereExplore – A default HERE map style containing a neutral, global map and its features including roads, buildings, landmarks, and water features. It also now includes a fully designed map of Japan.
        ///
        /// * RasterHereExploreSatellite – A global map containing high resolution satellite imagery.
        ///
        /// * HybridHereExploreSatellite – A global map displaying the road network, street names, and city labels over satellite imagery. This style will automatically retrieve both raster and vector tiles, and your charges will be based on total tiles retrieved. Hybrid styles use both vector and raster tiles when rendering the map that you see. This means that more tiles are retrieved than when using either vector or raster tiles alone. Your charges will include all tiles retrieved.
        ///
        /// * VectorHereContrast – The HERE Contrast (Berlin) map style is a high contrast detailed base map of the world that blends 3D and 2D rendering. The VectorHereContrast style has been renamed from VectorHereBerlin. VectorHereBerlin has been deprecated, but will continue to work in applications that use it.
        ///
        /// * VectorHereExploreTruck – A global map containing truck restrictions and attributes (e.g. width / height / HAZMAT) symbolized with highlighted segments and icons on top of HERE Explore to support use cases within transport and logistics.
        ///
        ///
        /// Valid [GrabMaps map styles](https://docs.aws.amazon.com/location/latest/developerguide/grab.html):
        ///
        /// * VectorGrabStandardLight – The Grab Standard Light map style provides a basemap with detailed land use coloring, area names, roads, landmarks, and points of interest covering Southeast Asia.
        ///
        /// * VectorGrabStandardDark – The Grab Standard Dark map style provides a dark variation of the standard basemap covering Southeast Asia.
        ///
        ///
        /// Grab provides maps only for countries in Southeast Asia, and is only available in the Asia Pacific (Singapore) Region (ap-southeast-1). For more information, see [GrabMaps countries and area covered](https://docs.aws.amazon.com/location/latest/developerguide/grab.html#grab-coverage-area). Valid [Open Data map styles](https://docs.aws.amazon.com/location/latest/developerguide/open-data.html):
        ///
        /// * VectorOpenDataStandardLight – The Open Data Standard Light map style provides a detailed basemap for the world suitable for website and mobile application use. The map includes highways major roads, minor roads, railways, water features, cities, parks, landmarks, building footprints, and administrative boundaries.
        ///
        /// * VectorOpenDataStandardDark – Open Data Standard Dark is a dark-themed map style that provides a detailed basemap for the world suitable for website and mobile application use. The map includes highways major roads, minor roads, railways, water features, cities, parks, landmarks, building footprints, and administrative boundaries.
        ///
        /// * VectorOpenDataVisualizationLight – The Open Data Visualization Light map style is a light-themed style with muted colors and fewer features that aids in understanding overlaid data.
        ///
        /// * VectorOpenDataVisualizationDark – The Open Data Visualization Dark map style is a dark-themed style with muted colors and fewer features that aids in understanding overlaid data.
        /// This member is required.
        public var style: Swift.String?

        public init(
            customLayers: [Swift.String]? = nil,
            politicalView: Swift.String? = nil,
            style: Swift.String? = nil
        )
        {
            self.customLayers = customLayers
            self.politicalView = politicalView
            self.style = style
        }
    }

}

extension LocationClientTypes.MapConfigurationUpdate {

    static func write(value: LocationClientTypes.MapConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomLayers"].writeList(value.customLayers, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PoliticalView"].write(value.politicalView)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.MapConfigurationUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.MapConfigurationUpdate()
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        value.customLayers = try reader["CustomLayers"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LocationClientTypes {
    /// Specifies the political view for the style.
    public struct MapConfigurationUpdate {
        /// Specifies the custom layers for the style. Leave unset to not enable any custom layer, or, for styles that support custom layers, you can enable layer(s), such as POI layer for the VectorEsriNavigation style. Default is unset. Currenlty only VectorEsriNavigation supports CustomLayers. For more information, see [Custom Layers](https://docs.aws.amazon.com/location/latest/developerguide/map-concepts.html#map-custom-layers).
        public var customLayers: [Swift.String]?
        /// Specifies the political view for the style. Set to an empty string to not use a political view, or, for styles that support specific political views, you can choose a view, such as IND for the Indian view. Not all map resources or styles support political view styles. See [Political views](https://docs.aws.amazon.com/location/latest/developerguide/map-concepts.html#political-views) for more information.
        public var politicalView: Swift.String?

        public init(
            customLayers: [Swift.String]? = nil,
            politicalView: Swift.String? = nil
        )
        {
            self.customLayers = customLayers
            self.politicalView = politicalView
        }
    }

}

extension LocationClientTypes {

    public enum OptimizationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fastestroute
        case shortestroute
        case sdkUnknown(Swift.String)

        public static var allCases: [OptimizationMode] {
            return [
                .fastestroute,
                .shortestroute,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fastestroute: return "FastestRoute"
            case .shortestroute: return "ShortestRoute"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LocationClientTypes.Place {

    static func write(value: LocationClientTypes.Place?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressNumber"].write(value.addressNumber)
        try writer["Categories"].writeList(value.categories, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Country"].write(value.country)
        try writer["Geometry"].write(value.geometry, with: LocationClientTypes.PlaceGeometry.write(value:to:))
        try writer["Interpolated"].write(value.interpolated)
        try writer["Label"].write(value.label)
        try writer["Municipality"].write(value.municipality)
        try writer["Neighborhood"].write(value.neighborhood)
        try writer["PostalCode"].write(value.postalCode)
        try writer["Region"].write(value.region)
        try writer["Street"].write(value.street)
        try writer["SubMunicipality"].write(value.subMunicipality)
        try writer["SubRegion"].write(value.subRegion)
        try writer["SupplementalCategories"].writeList(value.supplementalCategories, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TimeZone"].write(value.timeZone, with: LocationClientTypes.TimeZone.write(value:to:))
        try writer["UnitNumber"].write(value.unitNumber)
        try writer["UnitType"].write(value.unitType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.Place {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.Place()
        value.label = try reader["Label"].readIfPresent()
        value.geometry = try reader["Geometry"].readIfPresent(with: LocationClientTypes.PlaceGeometry.read(from:))
        value.addressNumber = try reader["AddressNumber"].readIfPresent()
        value.street = try reader["Street"].readIfPresent()
        value.neighborhood = try reader["Neighborhood"].readIfPresent()
        value.municipality = try reader["Municipality"].readIfPresent()
        value.subRegion = try reader["SubRegion"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.country = try reader["Country"].readIfPresent()
        value.postalCode = try reader["PostalCode"].readIfPresent()
        value.interpolated = try reader["Interpolated"].readIfPresent()
        value.timeZone = try reader["TimeZone"].readIfPresent(with: LocationClientTypes.TimeZone.read(from:))
        value.unitType = try reader["UnitType"].readIfPresent()
        value.unitNumber = try reader["UnitNumber"].readIfPresent()
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.supplementalCategories = try reader["SupplementalCategories"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subMunicipality = try reader["SubMunicipality"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// Contains details about addresses or points of interest that match the search criteria. Not all details are included with all responses. Some details may only be returned by specific data partners.
    public struct Place {
        /// The numerical portion of an address, such as a building number.
        public var addressNumber: Swift.String?
        /// The Amazon Location categories that describe this Place. For more information about using categories, including a list of Amazon Location categories, see [Categories and filtering](https://docs.aws.amazon.com/location/latest/developerguide/category-filtering.html), in the Amazon Location Service Developer Guide.
        public var categories: [Swift.String]?
        /// A country/region specified using [ISO 3166](https://www.iso.org/iso-3166-country-codes.html) 3-digit country/region code. For example, CAN.
        public var country: Swift.String?
        /// Places uses a point geometry to specify a location or a Place.
        /// This member is required.
        public var geometry: LocationClientTypes.PlaceGeometry?
        /// True if the result is interpolated from other known places. False if the Place is a known place. Not returned when the partner does not provide the information. For example, returns False for an address location that is found in the partner data, but returns True if an address does not exist in the partner data and its location is calculated by interpolating between other known addresses.
        public var interpolated: Swift.Bool?
        /// The full name and address of the point of interest such as a city, region, or country. For example, 123 Any Street, Any Town, USA.
        public var label: Swift.String?
        /// A name for a local area, such as a city or town name. For example, Toronto.
        public var municipality: Swift.String?
        /// The name of a community district. For example, Downtown.
        public var neighborhood: Swift.String?
        /// A group of numbers and letters in a country-specific format, which accompanies the address for the purpose of identifying a location.
        public var postalCode: Swift.String?
        /// A name for an area or geographical division, such as a province or state name. For example, British Columbia.
        public var region: Swift.String?
        /// The name for a street or a road to identify a location. For example, Main Street.
        public var street: Swift.String?
        /// An area that's part of a larger municipality. For example, Blissville is a submunicipality in the Queen County in New York. This property is only returned for a place index that uses Esri as a data provider. The property is represented as a district. For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        public var subMunicipality: Swift.String?
        /// A county, or an area that's part of a larger region. For example, Metro Vancouver.
        public var subRegion: Swift.String?
        /// Categories from the data provider that describe the Place that are not mapped to any Amazon Location categories.
        public var supplementalCategories: [Swift.String]?
        /// The time zone in which the Place is located. Returned only when using HERE or Grab as the selected partner.
        public var timeZone: LocationClientTypes.TimeZone?
        /// For addresses with multiple units, the unit identifier. Can include numbers and letters, for example 3B or Unit 123. This property is returned only for a place index that uses Esri or Grab as a data provider. It is not returned for SearchPlaceIndexForPosition.
        public var unitNumber: Swift.String?
        /// For addresses with a UnitNumber, the type of unit. For example, Apartment. This property is returned only for a place index that uses Esri as a data provider.
        public var unitType: Swift.String?

        public init(
            addressNumber: Swift.String? = nil,
            categories: [Swift.String]? = nil,
            country: Swift.String? = nil,
            geometry: LocationClientTypes.PlaceGeometry? = nil,
            interpolated: Swift.Bool? = nil,
            label: Swift.String? = nil,
            municipality: Swift.String? = nil,
            neighborhood: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            region: Swift.String? = nil,
            street: Swift.String? = nil,
            subMunicipality: Swift.String? = nil,
            subRegion: Swift.String? = nil,
            supplementalCategories: [Swift.String]? = nil,
            timeZone: LocationClientTypes.TimeZone? = nil,
            unitNumber: Swift.String? = nil,
            unitType: Swift.String? = nil
        )
        {
            self.addressNumber = addressNumber
            self.categories = categories
            self.country = country
            self.geometry = geometry
            self.interpolated = interpolated
            self.label = label
            self.municipality = municipality
            self.neighborhood = neighborhood
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.subMunicipality = subMunicipality
            self.subRegion = subRegion
            self.supplementalCategories = supplementalCategories
            self.timeZone = timeZone
            self.unitNumber = unitNumber
            self.unitType = unitType
        }
    }

}

extension LocationClientTypes.PlaceGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlaceGeometry(point: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes.PlaceGeometry {

    static func write(value: LocationClientTypes.PlaceGeometry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Point"].writeList(value.point, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.PlaceGeometry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.PlaceGeometry()
        value.point = try reader["Point"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LocationClientTypes {
    /// Places uses a point geometry to specify a location or a Place.
    public struct PlaceGeometry {
        /// A single point geometry specifies a location for a Place using [WGS 84](https://gisgeography.com/wgs84-world-geodetic-system/) coordinates:
        ///
        /// * x — Specifies the x coordinate or longitude.
        ///
        /// * y — Specifies the y coordinate or latitude.
        public var point: [Swift.Double]?

        public init(
            point: [Swift.Double]? = nil
        )
        {
            self.point = point
        }
    }

}

extension LocationClientTypes {

    public enum PositionFiltering: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Filters device position updates according to their accuracy
        case accuracybased
        /// Filters device position updates according to the distance between them
        case distancebased
        /// Filters device position updates according to their sample time
        case timebased
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionFiltering] {
            return [
                .accuracybased,
                .distancebased,
                .timebased,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accuracybased: return "AccuracyBased"
            case .distancebased: return "DistanceBased"
            case .timebased: return "TimeBased"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LocationClientTypes.PositionalAccuracy {

    static func write(value: LocationClientTypes.PositionalAccuracy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Horizontal"].write(value.horizontal)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.PositionalAccuracy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.PositionalAccuracy()
        value.horizontal = try reader["Horizontal"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// Defines the level of certainty of the position.
    public struct PositionalAccuracy {
        /// Estimated maximum distance, in meters, between the measured position and the true position of a device, along the Earth's surface.
        /// This member is required.
        public var horizontal: Swift.Double?

        public init(
            horizontal: Swift.Double? = nil
        )
        {
            self.horizontal = horizontal
        }
    }

}

extension LocationClientTypes {

    public enum PricingPlan: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// This pricing plan must be picked for mobile asset management use cases
        case mobileassetmanagement
        /// This pricing plan must be picked for mobile asset tracking use cases.
        case mobileassettracking
        /// This pricing plan should be used for request based billing.
        case requestbasedusage
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingPlan] {
            return [
                .mobileassetmanagement,
                .mobileassettracking,
                .requestbasedusage,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mobileassetmanagement: return "MobileAssetManagement"
            case .mobileassettracking: return "MobileAssetTracking"
            case .requestbasedusage: return "RequestBasedUsage"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PutGeofenceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutGeofenceInput(collectionName: \(Swift.String(describing: collectionName)), geofenceId: \(Swift.String(describing: geofenceId)), geometry: \(Swift.String(describing: geometry)), geofenceProperties: \"CONTENT_REDACTED\")"}
}

extension PutGeofenceInput {

    static func urlPathProvider(_ value: PutGeofenceInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        guard let geofenceId = value.geofenceId else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/geofences/\(geofenceId.urlPercentEncoding())"
    }
}

extension PutGeofenceInput {

    static func write(value: PutGeofenceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GeofenceProperties"].writeMap(value.geofenceProperties, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Geometry"].write(value.geometry, with: LocationClientTypes.GeofenceGeometry.write(value:to:))
    }
}

public struct PutGeofenceInput {
    /// The geofence collection to store the geofence in.
    /// This member is required.
    public var collectionName: Swift.String?
    /// An identifier for the geofence. For example, ExampleGeofence-1.
    /// This member is required.
    public var geofenceId: Swift.String?
    /// Associates one of more properties with the geofence. A property is a key-value pair stored with the geofence and added to any geofence event triggered with that geofence. Format: "key" : "value"
    public var geofenceProperties: [Swift.String:Swift.String]?
    /// Contains the details to specify the position of the geofence. Can be either a polygon or a circle. Including both will return a validation error. Each [ geofence polygon](https://docs.aws.amazon.com/location-geofences/latest/APIReference/API_GeofenceGeometry.html) can have a maximum of 1,000 vertices.
    /// This member is required.
    public var geometry: LocationClientTypes.GeofenceGeometry?

    public init(
        collectionName: Swift.String? = nil,
        geofenceId: Swift.String? = nil,
        geofenceProperties: [Swift.String:Swift.String]? = nil,
        geometry: LocationClientTypes.GeofenceGeometry? = nil
    )
    {
        self.collectionName = collectionName
        self.geofenceId = geofenceId
        self.geofenceProperties = geofenceProperties
        self.geometry = geometry
    }
}

extension PutGeofenceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutGeofenceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutGeofenceOutput()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
        value.geofenceId = try reader["GeofenceId"].readIfPresent()
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct PutGeofenceOutput {
    /// The timestamp for when the geofence was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The geofence identifier entered in the request.
    /// This member is required.
    public var geofenceId: Swift.String?
    /// The timestamp for when the geofence was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        createTime: ClientRuntime.Date? = nil,
        geofenceId: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.geofenceId = geofenceId
        self.updateTime = updateTime
    }
}

enum PutGeofenceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The resource that you've entered was not found in your AWS account.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LocationClientTypes.RouteMatrixEntry {

    static func write(value: LocationClientTypes.RouteMatrixEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Distance"].write(value.distance)
        try writer["DurationSeconds"].write(value.durationSeconds)
        try writer["Error"].write(value.error, with: LocationClientTypes.RouteMatrixEntryError.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.RouteMatrixEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.RouteMatrixEntry()
        value.distance = try reader["Distance"].readIfPresent()
        value.durationSeconds = try reader["DurationSeconds"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: LocationClientTypes.RouteMatrixEntryError.read(from:))
        return value
    }
}

extension LocationClientTypes {
    /// The result for the calculated route of one DeparturePositionDestinationPosition pair.
    public struct RouteMatrixEntry {
        /// The total distance of travel for the route.
        public var distance: Swift.Double?
        /// The expected duration of travel for the route.
        public var durationSeconds: Swift.Double?
        /// An error corresponding to the calculation of a route between the DeparturePosition and DestinationPosition.
        public var error: LocationClientTypes.RouteMatrixEntryError?

        public init(
            distance: Swift.Double? = nil,
            durationSeconds: Swift.Double? = nil,
            error: LocationClientTypes.RouteMatrixEntryError? = nil
        )
        {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.error = error
        }
    }

}

extension LocationClientTypes.RouteMatrixEntryError {

    static func write(value: LocationClientTypes.RouteMatrixEntryError?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Code"].write(value.code)
        try writer["Message"].write(value.message)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.RouteMatrixEntryError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.RouteMatrixEntryError()
        value.code = try reader["Code"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// An error corresponding to the calculation of a route between the DeparturePosition and DestinationPosition. The error code can be one of the following:
    ///
    /// * RouteNotFound - Unable to find a valid route with the given parameters.
    ///
    ///
    ///
    ///
    /// * RouteTooLong - Route calculation went beyond the maximum size of a route and was terminated before completion.
    ///
    ///
    ///
    ///
    /// * PositionsNotFound - One or more of the input positions were not found on the route network.
    ///
    ///
    ///
    ///
    /// * DestinationPositionNotFound - The destination position was not found on the route network.
    ///
    ///
    ///
    ///
    /// * DeparturePositionNotFound - The departure position was not found on the route network.
    ///
    ///
    ///
    ///
    /// * OtherValidationError - The given inputs were not valid or a route was not found. More information is given in the error Message
    public struct RouteMatrixEntryError {
        /// The type of error which occurred for the route calculation.
        /// This member is required.
        public var code: LocationClientTypes.RouteMatrixErrorCode?
        /// A message about the error that occurred for the route calculation.
        public var message: Swift.String?

        public init(
            code: LocationClientTypes.RouteMatrixErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension LocationClientTypes {

    public enum RouteMatrixErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case departurepositionnotfound
        case destinationpositionnotfound
        case othervalidationerror
        case positionsnotfound
        case routenotfound
        case routetoolong
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteMatrixErrorCode] {
            return [
                .departurepositionnotfound,
                .destinationpositionnotfound,
                .othervalidationerror,
                .positionsnotfound,
                .routenotfound,
                .routetoolong,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .departurepositionnotfound: return "DeparturePositionNotFound"
            case .destinationpositionnotfound: return "DestinationPositionNotFound"
            case .othervalidationerror: return "OtherValidationError"
            case .positionsnotfound: return "PositionsNotFound"
            case .routenotfound: return "RouteNotFound"
            case .routetoolong: return "RouteTooLong"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LocationClientTypes.SearchForPositionResult {

    static func write(value: LocationClientTypes.SearchForPositionResult?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Distance"].write(value.distance)
        try writer["Place"].write(value.place, with: LocationClientTypes.Place.write(value:to:))
        try writer["PlaceId"].write(value.placeId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.SearchForPositionResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.SearchForPositionResult()
        value.place = try reader["Place"].readIfPresent(with: LocationClientTypes.Place.read(from:))
        value.distance = try reader["Distance"].readIfPresent()
        value.placeId = try reader["PlaceId"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// Contains a search result from a position search query that is run on a place index resource.
    public struct SearchForPositionResult {
        /// The distance in meters of a great-circle arc between the query position and the result. A great-circle arc is the shortest path on a sphere, in this case the Earth. This returns the shortest distance between two locations.
        /// This member is required.
        public var distance: Swift.Double?
        /// Details about the search result, such as its address and position.
        /// This member is required.
        public var place: LocationClientTypes.Place?
        /// The unique identifier of the place. You can use this with the GetPlace operation to find the place again later. For SearchPlaceIndexForPosition operations, the PlaceId is returned only by place indexes that use HERE or Grab as a data provider.
        public var placeId: Swift.String?

        public init(
            distance: Swift.Double? = nil,
            place: LocationClientTypes.Place? = nil,
            placeId: Swift.String? = nil
        )
        {
            self.distance = distance
            self.place = place
            self.placeId = placeId
        }
    }

}

extension LocationClientTypes.SearchForSuggestionsResult {

    static func write(value: LocationClientTypes.SearchForSuggestionsResult?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Categories"].writeList(value.categories, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PlaceId"].write(value.placeId)
        try writer["SupplementalCategories"].writeList(value.supplementalCategories, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Text"].write(value.text)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.SearchForSuggestionsResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.SearchForSuggestionsResult()
        value.text = try reader["Text"].readIfPresent()
        value.placeId = try reader["PlaceId"].readIfPresent()
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.supplementalCategories = try reader["SupplementalCategories"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LocationClientTypes {
    /// Contains a place suggestion resulting from a place suggestion query that is run on a place index resource.
    public struct SearchForSuggestionsResult {
        /// The Amazon Location categories that describe the Place. For more information about using categories, including a list of Amazon Location categories, see [Categories and filtering](https://docs.aws.amazon.com/location/latest/developerguide/category-filtering.html), in the Amazon Location Service Developer Guide.
        public var categories: [Swift.String]?
        /// The unique identifier of the Place. You can use this with the GetPlace operation to find the place again later, or to get full information for the Place. The GetPlace request must use the same PlaceIndex resource as the SearchPlaceIndexForSuggestions that generated the Place ID. For SearchPlaceIndexForSuggestions operations, the PlaceId is returned by place indexes that use Esri, Grab, or HERE as data providers. While you can use PlaceID in subsequent requests, PlaceID is not intended to be a permanent identifier and the ID can change between consecutive API calls. Please see the following PlaceID behaviour for each data provider:
        ///
        /// * Esri: Place IDs will change every quarter at a minimum. The typical time period for these changes would be March, June, September, and December. Place IDs might also change between the typical quarterly change but that will be much less frequent.
        ///
        /// * HERE: We recommend that you cache data for no longer than a week to keep your data data fresh. You can assume that less than 1% ID shifts will release over release which is approximately 1 - 2 times per week.
        ///
        /// * Grab: Place IDs can expire or become invalid in the following situations.
        ///
        /// * Data operations: The POI may be removed from Grab POI database by Grab Map Ops based on the ground-truth, such as being closed in the real world, being detected as a duplicate POI, or having incorrect information. Grab will synchronize data to the Waypoint environment on weekly basis.
        ///
        /// * Interpolated POI: Interpolated POI is a temporary POI generated in real time when serving a request, and it will be marked as derived in the place.result_type field in the response. The information of interpolated POIs will be retained for at least 30 days, which means that within 30 days, you are able to obtain POI details by Place ID from Place Details API. After 30 days, the interpolated POIs(both Place ID and details) may expire and inaccessible from the Places Details API.
        public var placeId: Swift.String?
        /// Categories from the data provider that describe the Place that are not mapped to any Amazon Location categories.
        public var supplementalCategories: [Swift.String]?
        /// The text of the place suggestion, typically formatted as an address string.
        /// This member is required.
        public var text: Swift.String?

        public init(
            categories: [Swift.String]? = nil,
            placeId: Swift.String? = nil,
            supplementalCategories: [Swift.String]? = nil,
            text: Swift.String? = nil
        )
        {
            self.categories = categories
            self.placeId = placeId
            self.supplementalCategories = supplementalCategories
            self.text = text
        }
    }

}

extension LocationClientTypes.SearchForTextResult {

    static func write(value: LocationClientTypes.SearchForTextResult?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Distance"].write(value.distance)
        try writer["Place"].write(value.place, with: LocationClientTypes.Place.write(value:to:))
        try writer["PlaceId"].write(value.placeId)
        try writer["Relevance"].write(value.relevance)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.SearchForTextResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.SearchForTextResult()
        value.place = try reader["Place"].readIfPresent(with: LocationClientTypes.Place.read(from:))
        value.distance = try reader["Distance"].readIfPresent()
        value.relevance = try reader["Relevance"].readIfPresent()
        value.placeId = try reader["PlaceId"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// Contains a search result from a text search query that is run on a place index resource.
    public struct SearchForTextResult {
        /// The distance in meters of a great-circle arc between the bias position specified and the result. Distance will be returned only if a bias position was specified in the query. A great-circle arc is the shortest path on a sphere, in this case the Earth. This returns the shortest distance between two locations.
        public var distance: Swift.Double?
        /// Details about the search result, such as its address and position.
        /// This member is required.
        public var place: LocationClientTypes.Place?
        /// The unique identifier of the place. You can use this with the GetPlace operation to find the place again later. For SearchPlaceIndexForText operations, the PlaceId is returned only by place indexes that use HERE or Grab as a data provider.
        public var placeId: Swift.String?
        /// The relative confidence in the match for a result among the results returned. For example, if more fields for an address match (including house number, street, city, country/region, and postal code), the relevance score is closer to 1. Returned only when the partner selected is Esri or Grab.
        public var relevance: Swift.Double?

        public init(
            distance: Swift.Double? = nil,
            place: LocationClientTypes.Place? = nil,
            placeId: Swift.String? = nil,
            relevance: Swift.Double? = nil
        )
        {
            self.distance = distance
            self.place = place
            self.placeId = placeId
            self.relevance = relevance
        }
    }

}

extension SearchPlaceIndexForPositionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForPositionInput(indexName: \(Swift.String(describing: indexName)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), key: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

extension SearchPlaceIndexForPositionInput {

    static func queryItemProvider(_ value: SearchPlaceIndexForPositionInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension SearchPlaceIndexForPositionInput {

    static func urlPathProvider(_ value: SearchPlaceIndexForPositionInput) -> Swift.String? {
        guard let indexName = value.indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())/search/position"
    }
}

extension SearchPlaceIndexForPositionInput {

    static func write(value: SearchPlaceIndexForPositionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["Position"].writeList(value.position, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct SearchPlaceIndexForPositionInput {
    /// The name of the place index resource you want to use for the search.
    /// This member is required.
    public var indexName: Swift.String?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The preferred language used to return results. The value must be a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for a location around Athens, Greece, with the language parameter set to en. The city in the results will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the city in the results will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    public var language: Swift.String?
    /// An optional parameter. The maximum number of results returned per request. Default value: 50
    public var maxResults: Swift.Int?
    /// Specifies the longitude and latitude of the position to query. This parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents a position with longitude -123.1174 and latitude 49.2847.
    /// This member is required.
    public var position: [Swift.Double]?

    public init(
        indexName: Swift.String? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        position: [Swift.Double]? = nil
    )
    {
        self.indexName = indexName
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.position = position
    }
}

extension SearchPlaceIndexForPositionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchPlaceIndexForPositionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchPlaceIndexForPositionOutput()
        value.results = try reader["Results"].readListIfPresent(memberReadingClosure: LocationClientTypes.SearchForPositionResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.summary = try reader["Summary"].readIfPresent(with: LocationClientTypes.SearchPlaceIndexForPositionSummary.read(from:))
        return value
    }
}

public struct SearchPlaceIndexForPositionOutput {
    /// Returns a list of Places closest to the specified position. Each result contains additional information about the Places returned.
    /// This member is required.
    public var results: [LocationClientTypes.SearchForPositionResult]?
    /// Contains a summary of the request. Echoes the input values for Position, Language, MaxResults, and the DataSource of the place index.
    /// This member is required.
    public var summary: LocationClientTypes.SearchPlaceIndexForPositionSummary?

    public init(
        results: [LocationClientTypes.SearchForPositionResult]? = nil,
        summary: LocationClientTypes.SearchPlaceIndexForPositionSummary? = nil
    )
    {
        self.results = results
        self.summary = summary
    }
}

enum SearchPlaceIndexForPositionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.SearchPlaceIndexForPositionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForPositionSummary(dataSource: \(Swift.String(describing: dataSource)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), position: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes.SearchPlaceIndexForPositionSummary {

    static func write(value: LocationClientTypes.SearchPlaceIndexForPositionSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSource"].write(value.dataSource)
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["Position"].writeList(value.position, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.SearchPlaceIndexForPositionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.SearchPlaceIndexForPositionSummary()
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxResults = try reader["MaxResults"].readIfPresent()
        value.dataSource = try reader["DataSource"].readIfPresent()
        value.language = try reader["Language"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// A summary of the request sent by using SearchPlaceIndexForPosition.
    public struct SearchPlaceIndexForPositionSummary {
        /// The geospatial data provider attached to the place index resource specified in the request. Values can be one of the following:
        ///
        /// * Esri
        ///
        /// * Grab
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// The preferred language used to return results. Matches the language in the request. The value is a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English.
        public var language: Swift.String?
        /// Contains the optional result count limit that is specified in the request. Default value: 50
        public var maxResults: Swift.Int?
        /// The position specified in the request.
        /// This member is required.
        public var position: [Swift.Double]?

        public init(
            dataSource: Swift.String? = nil,
            language: Swift.String? = nil,
            maxResults: Swift.Int? = nil,
            position: [Swift.Double]? = nil
        )
        {
            self.dataSource = dataSource
            self.language = language
            self.maxResults = maxResults
            self.position = position
        }
    }

}

extension SearchPlaceIndexForSuggestionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForSuggestionsInput(filterCategories: \(Swift.String(describing: filterCategories)), filterCountries: \(Swift.String(describing: filterCountries)), indexName: \(Swift.String(describing: indexName)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), biasPosition: \"CONTENT_REDACTED\", filterBBox: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension SearchPlaceIndexForSuggestionsInput {

    static func queryItemProvider(_ value: SearchPlaceIndexForSuggestionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension SearchPlaceIndexForSuggestionsInput {

    static func urlPathProvider(_ value: SearchPlaceIndexForSuggestionsInput) -> Swift.String? {
        guard let indexName = value.indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())/search/suggestions"
    }
}

extension SearchPlaceIndexForSuggestionsInput {

    static func write(value: SearchPlaceIndexForSuggestionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BiasPosition"].writeList(value.biasPosition, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterBBox"].writeList(value.filterBBox, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterCategories"].writeList(value.filterCategories, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterCountries"].writeList(value.filterCountries, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["Text"].write(value.text)
    }
}

public struct SearchPlaceIndexForSuggestionsInput {
    /// An optional parameter that indicates a preference for place suggestions that are closer to a specified position. If provided, this parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847. BiasPosition and FilterBBox are mutually exclusive. Specifying both options results in an error.
    public var biasPosition: [Swift.Double]?
    /// An optional parameter that limits the search results by returning only suggestions within a specified bounding box. If provided, this parameter must contain a total of four consecutive numbers in two pairs. The first pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the southwest corner of the bounding box; the second pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the northeast corner of the bounding box. For example, [-12.7935, -37.4835, -12.0684, -36.9542] represents a bounding box where the southwest corner has longitude -12.7935 and latitude -37.4835, and the northeast corner has longitude -12.0684 and latitude -36.9542. FilterBBox and BiasPosition are mutually exclusive. Specifying both options results in an error.
    public var filterBBox: [Swift.Double]?
    /// A list of one or more Amazon Location categories to filter the returned places. If you include more than one category, the results will include results that match any of the categories listed. For more information about using categories, including a list of Amazon Location categories, see [Categories and filtering](https://docs.aws.amazon.com/location/latest/developerguide/category-filtering.html), in the Amazon Location Service Developer Guide.
    public var filterCategories: [Swift.String]?
    /// An optional parameter that limits the search results by returning only suggestions within the provided list of countries.
    ///
    /// * Use the [ISO 3166](https://www.iso.org/iso-3166-country-codes.html) 3-digit country code. For example, Australia uses three upper-case characters: AUS.
    public var filterCountries: [Swift.String]?
    /// The name of the place index resource you want to use for the search.
    /// This member is required.
    public var indexName: Swift.String?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The preferred language used to return results. The value must be a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English. This setting affects the languages used in the results. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for Athens, Gr to get suggestions with the language parameter set to en. The results found will most likely be returned as Athens, Greece. If you set the language parameter to el, for Greek, then the result found will more likely be returned as Αθήνα, Ελλάδα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    public var language: Swift.String?
    /// An optional parameter. The maximum number of results returned per request. The default: 5
    public var maxResults: Swift.Int?
    /// The free-form partial text to use to generate place suggestions. For example, eiffel tow.
    /// This member is required.
    public var text: Swift.String?

    public init(
        biasPosition: [Swift.Double]? = nil,
        filterBBox: [Swift.Double]? = nil,
        filterCategories: [Swift.String]? = nil,
        filterCountries: [Swift.String]? = nil,
        indexName: Swift.String? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        text: Swift.String? = nil
    )
    {
        self.biasPosition = biasPosition
        self.filterBBox = filterBBox
        self.filterCategories = filterCategories
        self.filterCountries = filterCountries
        self.indexName = indexName
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.text = text
    }
}

extension SearchPlaceIndexForSuggestionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchPlaceIndexForSuggestionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchPlaceIndexForSuggestionsOutput()
        value.results = try reader["Results"].readListIfPresent(memberReadingClosure: LocationClientTypes.SearchForSuggestionsResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.summary = try reader["Summary"].readIfPresent(with: LocationClientTypes.SearchPlaceIndexForSuggestionsSummary.read(from:))
        return value
    }
}

public struct SearchPlaceIndexForSuggestionsOutput {
    /// A list of place suggestions that best match the search text.
    /// This member is required.
    public var results: [LocationClientTypes.SearchForSuggestionsResult]?
    /// Contains a summary of the request. Echoes the input values for BiasPosition, FilterBBox, FilterCountries, Language, MaxResults, and Text. Also includes the DataSource of the place index.
    /// This member is required.
    public var summary: LocationClientTypes.SearchPlaceIndexForSuggestionsSummary?

    public init(
        results: [LocationClientTypes.SearchForSuggestionsResult]? = nil,
        summary: LocationClientTypes.SearchPlaceIndexForSuggestionsSummary? = nil
    )
    {
        self.results = results
        self.summary = summary
    }
}

enum SearchPlaceIndexForSuggestionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.SearchPlaceIndexForSuggestionsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForSuggestionsSummary(dataSource: \(Swift.String(describing: dataSource)), filterCategories: \(Swift.String(describing: filterCategories)), filterCountries: \(Swift.String(describing: filterCountries)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), biasPosition: \"CONTENT_REDACTED\", filterBBox: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes.SearchPlaceIndexForSuggestionsSummary {

    static func write(value: LocationClientTypes.SearchPlaceIndexForSuggestionsSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BiasPosition"].writeList(value.biasPosition, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSource"].write(value.dataSource)
        try writer["FilterBBox"].writeList(value.filterBBox, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterCategories"].writeList(value.filterCategories, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterCountries"].writeList(value.filterCountries, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["Text"].write(value.text)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.SearchPlaceIndexForSuggestionsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.SearchPlaceIndexForSuggestionsSummary()
        value.text = try reader["Text"].readIfPresent()
        value.biasPosition = try reader["BiasPosition"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filterBBox = try reader["FilterBBox"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filterCountries = try reader["FilterCountries"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxResults = try reader["MaxResults"].readIfPresent()
        value.dataSource = try reader["DataSource"].readIfPresent()
        value.language = try reader["Language"].readIfPresent()
        value.filterCategories = try reader["FilterCategories"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LocationClientTypes {
    /// A summary of the request sent by using SearchPlaceIndexForSuggestions.
    public struct SearchPlaceIndexForSuggestionsSummary {
        /// Contains the coordinates for the optional bias position specified in the request. This parameter contains a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.
        public var biasPosition: [Swift.Double]?
        /// The geospatial data provider attached to the place index resource specified in the request. Values can be one of the following:
        ///
        /// * Esri
        ///
        /// * Grab
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// Contains the coordinates for the optional bounding box specified in the request.
        public var filterBBox: [Swift.Double]?
        /// The optional category filter specified in the request.
        public var filterCategories: [Swift.String]?
        /// Contains the optional country filter specified in the request.
        public var filterCountries: [Swift.String]?
        /// The preferred language used to return results. Matches the language in the request. The value is a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English.
        public var language: Swift.String?
        /// Contains the optional result count limit specified in the request.
        public var maxResults: Swift.Int?
        /// The free-form partial text input specified in the request.
        /// This member is required.
        public var text: Swift.String?

        public init(
            biasPosition: [Swift.Double]? = nil,
            dataSource: Swift.String? = nil,
            filterBBox: [Swift.Double]? = nil,
            filterCategories: [Swift.String]? = nil,
            filterCountries: [Swift.String]? = nil,
            language: Swift.String? = nil,
            maxResults: Swift.Int? = nil,
            text: Swift.String? = nil
        )
        {
            self.biasPosition = biasPosition
            self.dataSource = dataSource
            self.filterBBox = filterBBox
            self.filterCategories = filterCategories
            self.filterCountries = filterCountries
            self.language = language
            self.maxResults = maxResults
            self.text = text
        }
    }

}

extension SearchPlaceIndexForTextInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForTextInput(filterCategories: \(Swift.String(describing: filterCategories)), filterCountries: \(Swift.String(describing: filterCountries)), indexName: \(Swift.String(describing: indexName)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), biasPosition: \"CONTENT_REDACTED\", filterBBox: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension SearchPlaceIndexForTextInput {

    static func queryItemProvider(_ value: SearchPlaceIndexForTextInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension SearchPlaceIndexForTextInput {

    static func urlPathProvider(_ value: SearchPlaceIndexForTextInput) -> Swift.String? {
        guard let indexName = value.indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())/search/text"
    }
}

extension SearchPlaceIndexForTextInput {

    static func write(value: SearchPlaceIndexForTextInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BiasPosition"].writeList(value.biasPosition, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterBBox"].writeList(value.filterBBox, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterCategories"].writeList(value.filterCategories, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterCountries"].writeList(value.filterCountries, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["Text"].write(value.text)
    }
}

public struct SearchPlaceIndexForTextInput {
    /// An optional parameter that indicates a preference for places that are closer to a specified position. If provided, this parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847. BiasPosition and FilterBBox are mutually exclusive. Specifying both options results in an error.
    public var biasPosition: [Swift.Double]?
    /// An optional parameter that limits the search results by returning only places that are within the provided bounding box. If provided, this parameter must contain a total of four consecutive numbers in two pairs. The first pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the southwest corner of the bounding box; the second pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the northeast corner of the bounding box. For example, [-12.7935, -37.4835, -12.0684, -36.9542] represents a bounding box where the southwest corner has longitude -12.7935 and latitude -37.4835, and the northeast corner has longitude -12.0684 and latitude -36.9542. FilterBBox and BiasPosition are mutually exclusive. Specifying both options results in an error.
    public var filterBBox: [Swift.Double]?
    /// A list of one or more Amazon Location categories to filter the returned places. If you include more than one category, the results will include results that match any of the categories listed. For more information about using categories, including a list of Amazon Location categories, see [Categories and filtering](https://docs.aws.amazon.com/location/latest/developerguide/category-filtering.html), in the Amazon Location Service Developer Guide.
    public var filterCategories: [Swift.String]?
    /// An optional parameter that limits the search results by returning only places that are in a specified list of countries.
    ///
    /// * Valid values include [ISO 3166](https://www.iso.org/iso-3166-country-codes.html) 3-digit country codes. For example, Australia uses three upper-case characters: AUS.
    public var filterCountries: [Swift.String]?
    /// The name of the place index resource you want to use for the search.
    /// This member is required.
    public var indexName: Swift.String?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The preferred language used to return results. The value must be a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for Athens, Greece, with the language parameter set to en. The result found will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the result found will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    public var language: Swift.String?
    /// An optional parameter. The maximum number of results returned per request. The default: 50
    public var maxResults: Swift.Int?
    /// The address, name, city, or region to be used in the search in free-form text format. For example, 123 Any Street.
    /// This member is required.
    public var text: Swift.String?

    public init(
        biasPosition: [Swift.Double]? = nil,
        filterBBox: [Swift.Double]? = nil,
        filterCategories: [Swift.String]? = nil,
        filterCountries: [Swift.String]? = nil,
        indexName: Swift.String? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        text: Swift.String? = nil
    )
    {
        self.biasPosition = biasPosition
        self.filterBBox = filterBBox
        self.filterCategories = filterCategories
        self.filterCountries = filterCountries
        self.indexName = indexName
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.text = text
    }
}

extension SearchPlaceIndexForTextOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchPlaceIndexForTextOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchPlaceIndexForTextOutput()
        value.results = try reader["Results"].readListIfPresent(memberReadingClosure: LocationClientTypes.SearchForTextResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.summary = try reader["Summary"].readIfPresent(with: LocationClientTypes.SearchPlaceIndexForTextSummary.read(from:))
        return value
    }
}

public struct SearchPlaceIndexForTextOutput {
    /// A list of Places matching the input text. Each result contains additional information about the specific point of interest. Not all response properties are included with all responses. Some properties may only be returned by specific data partners.
    /// This member is required.
    public var results: [LocationClientTypes.SearchForTextResult]?
    /// Contains a summary of the request. Echoes the input values for BiasPosition, FilterBBox, FilterCountries, Language, MaxResults, and Text. Also includes the DataSource of the place index and the bounding box, ResultBBox, which surrounds the search results.
    /// This member is required.
    public var summary: LocationClientTypes.SearchPlaceIndexForTextSummary?

    public init(
        results: [LocationClientTypes.SearchForTextResult]? = nil,
        summary: LocationClientTypes.SearchPlaceIndexForTextSummary? = nil
    )
    {
        self.results = results
        self.summary = summary
    }
}

enum SearchPlaceIndexForTextOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LocationClientTypes.SearchPlaceIndexForTextSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForTextSummary(dataSource: \(Swift.String(describing: dataSource)), filterCategories: \(Swift.String(describing: filterCategories)), filterCountries: \(Swift.String(describing: filterCountries)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), biasPosition: \"CONTENT_REDACTED\", filterBBox: \"CONTENT_REDACTED\", resultBBox: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes.SearchPlaceIndexForTextSummary {

    static func write(value: LocationClientTypes.SearchPlaceIndexForTextSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BiasPosition"].writeList(value.biasPosition, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSource"].write(value.dataSource)
        try writer["FilterBBox"].writeList(value.filterBBox, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterCategories"].writeList(value.filterCategories, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterCountries"].writeList(value.filterCountries, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["ResultBBox"].writeList(value.resultBBox, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Text"].write(value.text)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.SearchPlaceIndexForTextSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.SearchPlaceIndexForTextSummary()
        value.text = try reader["Text"].readIfPresent()
        value.biasPosition = try reader["BiasPosition"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filterBBox = try reader["FilterBBox"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filterCountries = try reader["FilterCountries"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxResults = try reader["MaxResults"].readIfPresent()
        value.resultBBox = try reader["ResultBBox"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSource = try reader["DataSource"].readIfPresent()
        value.language = try reader["Language"].readIfPresent()
        value.filterCategories = try reader["FilterCategories"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LocationClientTypes {
    /// A summary of the request sent by using SearchPlaceIndexForText.
    public struct SearchPlaceIndexForTextSummary {
        /// Contains the coordinates for the optional bias position specified in the request. This parameter contains a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.
        public var biasPosition: [Swift.Double]?
        /// The geospatial data provider attached to the place index resource specified in the request. Values can be one of the following:
        ///
        /// * Esri
        ///
        /// * Grab
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// Contains the coordinates for the optional bounding box specified in the request.
        public var filterBBox: [Swift.Double]?
        /// The optional category filter specified in the request.
        public var filterCategories: [Swift.String]?
        /// Contains the optional country filter specified in the request.
        public var filterCountries: [Swift.String]?
        /// The preferred language used to return results. Matches the language in the request. The value is a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English.
        public var language: Swift.String?
        /// Contains the optional result count limit specified in the request.
        public var maxResults: Swift.Int?
        /// The bounding box that fully contains all search results. If you specified the optional FilterBBox parameter in the request, ResultBBox is contained within FilterBBox.
        public var resultBBox: [Swift.Double]?
        /// The search text specified in the request.
        /// This member is required.
        public var text: Swift.String?

        public init(
            biasPosition: [Swift.Double]? = nil,
            dataSource: Swift.String? = nil,
            filterBBox: [Swift.Double]? = nil,
            filterCategories: [Swift.String]? = nil,
            filterCountries: [Swift.String]? = nil,
            language: Swift.String? = nil,
            maxResults: Swift.Int? = nil,
            resultBBox: [Swift.Double]? = nil,
            text: Swift.String? = nil
        )
        {
            self.biasPosition = biasPosition
            self.dataSource = dataSource
            self.filterBBox = filterBBox
            self.filterCategories = filterCategories
            self.filterCountries = filterCountries
            self.language = language
            self.maxResults = maxResults
            self.resultBBox = resultBBox
            self.text = text
        }
    }

}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The operation was denied because the request would exceed the maximum [quota](https://docs.aws.amazon.com/location/latest/developerguide/location-quotas.html) set for Amazon Location Service.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message with the reason for the service quota exceeded exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LocationClientTypes {

    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// List all active API keys.
        case active
        /// List all expired API keys.
        case expired
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .active,
                .expired,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .expired: return "Expired"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LocationClientTypes.Step: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Step(distance: \(Swift.String(describing: distance)), durationSeconds: \(Swift.String(describing: durationSeconds)), geometryOffset: \(Swift.String(describing: geometryOffset)), endPosition: \"CONTENT_REDACTED\", startPosition: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes.Step {

    static func write(value: LocationClientTypes.Step?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Distance"].write(value.distance)
        try writer["DurationSeconds"].write(value.durationSeconds)
        try writer["EndPosition"].writeList(value.endPosition, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GeometryOffset"].write(value.geometryOffset)
        try writer["StartPosition"].writeList(value.startPosition, memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.Step {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.Step()
        value.startPosition = try reader["StartPosition"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.endPosition = try reader["EndPosition"].readListIfPresent(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.distance = try reader["Distance"].readIfPresent()
        value.durationSeconds = try reader["DurationSeconds"].readIfPresent()
        value.geometryOffset = try reader["GeometryOffset"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// Represents an element of a leg within a route. A step contains instructions for how to move to the next step in the leg.
    public struct Step {
        /// The travel distance between the step's StartPosition and EndPosition.
        /// This member is required.
        public var distance: Swift.Double?
        /// The estimated travel time, in seconds, from the step's StartPosition to the EndPosition. . The travel mode and departure time that you specify in the request determines the calculated time.
        /// This member is required.
        public var durationSeconds: Swift.Double?
        /// The end position of a step. If the position the last step in the leg, this position is the same as the end position of the leg.
        /// This member is required.
        public var endPosition: [Swift.Double]?
        /// Represents the start position, or index, in a sequence of steps within the leg's line string geometry. For example, the index of the first step in a leg geometry is 0. Included in the response for queries that set IncludeLegGeometry to True.
        public var geometryOffset: Swift.Int?
        /// The starting position of a step. If the position is the first step in the leg, this position is the same as the start position of the leg.
        /// This member is required.
        public var startPosition: [Swift.Double]?

        public init(
            distance: Swift.Double? = nil,
            durationSeconds: Swift.Double? = nil,
            endPosition: [Swift.Double]? = nil,
            geometryOffset: Swift.Int? = nil,
            startPosition: [Swift.Double]? = nil
        )
        {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.endPosition = endPosition
            self.geometryOffset = geometryOffset
            self.startPosition = startPosition
        }
    }

}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource whose tags you want to update.
    ///
    /// * Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Applies one or more tags to specific resource. A tag is a key-value pair that helps you manage, identify, search, and filter your resources. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource.
    ///
    /// * Each tag key must be unique and must have exactly one associated value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request was denied because of request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LocationClientTypes.TimeZone {

    static func write(value: LocationClientTypes.TimeZone?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Offset"].write(value.offset)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.TimeZone {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.TimeZone()
        value.name = try reader["Name"].readIfPresent()
        value.offset = try reader["Offset"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// Information about a time zone. Includes the name of the time zone and the offset from UTC in seconds.
    public struct TimeZone {
        /// The name of the time zone, following the [ IANA time zone standard](https://www.iana.org/time-zones). For example, America/Los_Angeles.
        /// This member is required.
        public var name: Swift.String?
        /// The time zone's offset, in seconds, from UTC.
        public var offset: Swift.Int?

        public init(
            name: Swift.String? = nil,
            offset: Swift.Int? = nil
        )
        {
            self.name = name
            self.offset = offset
        }
    }

}

extension LocationClientTypes.TrackingFilterGeometry {

    static func write(value: LocationClientTypes.TrackingFilterGeometry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Polygon"].writeList(value.polygon, memberWritingClosure: listWritingClosure(memberWritingClosure: listWritingClosure(memberWritingClosure: Swift.Double.write(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.TrackingFilterGeometry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.TrackingFilterGeometry()
        value.polygon = try reader["Polygon"].readListIfPresent(memberReadingClosure: listReadingClosure(memberReadingClosure: listReadingClosure(memberReadingClosure: Swift.Double.read(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LocationClientTypes {
    /// The geomerty used to filter device positions.
    public struct TrackingFilterGeometry {
        /// The set of arrays which define the polygon. A polygon can have between 4 and 1000 vertices.
        public var polygon: [[[Swift.Double]]]?

        public init(
            polygon: [[[Swift.Double]]]? = nil
        )
        {
            self.polygon = polygon
        }
    }

}

extension LocationClientTypes {

    public enum TravelMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bicycle
        case car
        case motorcycle
        case truck
        case walking
        case sdkUnknown(Swift.String)

        public static var allCases: [TravelMode] {
            return [
                .bicycle,
                .car,
                .motorcycle,
                .truck,
                .walking,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bicycle: return "Bicycle"
            case .car: return "Car"
            case .motorcycle: return "Motorcycle"
            case .truck: return "Truck"
            case .walking: return "Walking"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LocationClientTypes.TruckDimensions {

    static func write(value: LocationClientTypes.TruckDimensions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Height"].write(value.height)
        try writer["Length"].write(value.length)
        try writer["Unit"].write(value.unit)
        try writer["Width"].write(value.width)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.TruckDimensions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.TruckDimensions()
        value.length = try reader["Length"].readIfPresent()
        value.height = try reader["Height"].readIfPresent()
        value.width = try reader["Width"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// Contains details about the truck dimensions in the unit of measurement that you specify. Used to filter out roads that can't support or allow the specified dimensions for requests that specify TravelMode as Truck.
    public struct TruckDimensions {
        /// The height of the truck.
        ///
        /// * For example, 4.5.
        ///
        ///
        /// For routes calculated with a HERE resource, this value must be between 0 and 50 meters.
        public var height: Swift.Double?
        /// The length of the truck.
        ///
        /// * For example, 15.5.
        ///
        ///
        /// For routes calculated with a HERE resource, this value must be between 0 and 300 meters.
        public var length: Swift.Double?
        /// Specifies the unit of measurement for the truck dimensions. Default Value: Meters
        public var unit: LocationClientTypes.DimensionUnit?
        /// The width of the truck.
        ///
        /// * For example, 4.5.
        ///
        ///
        /// For routes calculated with a HERE resource, this value must be between 0 and 50 meters.
        public var width: Swift.Double?

        public init(
            height: Swift.Double? = nil,
            length: Swift.Double? = nil,
            unit: LocationClientTypes.DimensionUnit? = nil,
            width: Swift.Double? = nil
        )
        {
            self.height = height
            self.length = length
            self.unit = unit
            self.width = width
        }
    }

}

extension LocationClientTypes.TruckWeight {

    static func write(value: LocationClientTypes.TruckWeight?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Total"].write(value.total)
        try writer["Unit"].write(value.unit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.TruckWeight {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.TruckWeight()
        value.total = try reader["Total"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// Contains details about the truck's weight specifications. Used to avoid roads that can't support or allow the total weight for requests that specify TravelMode as Truck.
    public struct TruckWeight {
        /// The total weight of the truck.
        ///
        /// * For example, 3500.
        public var total: Swift.Double?
        /// The unit of measurement to use for the truck weight. Default Value: Kilograms
        public var unit: LocationClientTypes.VehicleWeightUnit?

        public init(
            total: Swift.Double? = nil,
            unit: LocationClientTypes.VehicleWeightUnit? = nil
        )
        {
            self.total = total
            self.unit = unit
        }
    }

}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource from which you want to remove tags.
    ///
    /// * Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateGeofenceCollectionInput {

    static func urlPathProvider(_ value: UpdateGeofenceCollectionInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())"
    }
}

extension UpdateGeofenceCollectionInput {

    static func write(value: UpdateGeofenceCollectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["PricingPlan"].write(value.pricingPlan)
        try writer["PricingPlanDataSource"].write(value.pricingPlanDataSource)
    }
}

public struct UpdateGeofenceCollectionInput {
    /// The name of the geofence collection to update.
    /// This member is required.
    public var collectionName: Swift.String?
    /// Updates the description for the geofence collection.
    public var description: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// This parameter is no longer used.
    @available(*, deprecated, message: "Deprecated. No longer allowed. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?

    public init(
        collectionName: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
        self.description = description
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
    }
}

extension UpdateGeofenceCollectionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateGeofenceCollectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGeofenceCollectionOutput()
        value.collectionArn = try reader["CollectionArn"].readIfPresent()
        value.collectionName = try reader["CollectionName"].readIfPresent()
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct UpdateGeofenceCollectionOutput {
    /// The Amazon Resource Name (ARN) of the updated geofence collection. Used to specify a resource across Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
    /// This member is required.
    public var collectionArn: Swift.String?
    /// The name of the updated geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The time when the geofence collection was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        collectionArn: Swift.String? = nil,
        collectionName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.collectionArn = collectionArn
        self.collectionName = collectionName
        self.updateTime = updateTime
    }
}

enum UpdateGeofenceCollectionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateKeyInput {

    static func urlPathProvider(_ value: UpdateKeyInput) -> Swift.String? {
        guard let keyName = value.keyName else {
            return nil
        }
        return "/metadata/v0/keys/\(keyName.urlPercentEncoding())"
    }
}

extension UpdateKeyInput {

    static func write(value: UpdateKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["ExpireTime"].writeTimestamp(value.expireTime, format: .dateTime)
        try writer["ForceUpdate"].write(value.forceUpdate)
        try writer["NoExpiry"].write(value.noExpiry)
        try writer["Restrictions"].write(value.restrictions, with: LocationClientTypes.ApiKeyRestrictions.write(value:to:))
    }
}

public struct UpdateKeyInput {
    /// Updates the description for the API key resource.
    public var description: Swift.String?
    /// Updates the timestamp for when the API key resource will expire in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    public var expireTime: ClientRuntime.Date?
    /// The boolean flag to be included for updating ExpireTime or Restrictions details. Must be set to true to update an API key resource that has been used in the past 7 days. False if force update is not preferred Default value: False
    public var forceUpdate: Swift.Bool?
    /// The name of the API key resource to update.
    /// This member is required.
    public var keyName: Swift.String?
    /// Whether the API key should expire. Set to true to set the API key to have no expiration time.
    public var noExpiry: Swift.Bool?
    /// Updates the API key restrictions for the API key resource.
    public var restrictions: LocationClientTypes.ApiKeyRestrictions?

    public init(
        description: Swift.String? = nil,
        expireTime: ClientRuntime.Date? = nil,
        forceUpdate: Swift.Bool? = nil,
        keyName: Swift.String? = nil,
        noExpiry: Swift.Bool? = nil,
        restrictions: LocationClientTypes.ApiKeyRestrictions? = nil
    )
    {
        self.description = description
        self.expireTime = expireTime
        self.forceUpdate = forceUpdate
        self.keyName = keyName
        self.noExpiry = noExpiry
        self.restrictions = restrictions
    }
}

extension UpdateKeyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateKeyOutput()
        value.keyArn = try reader["KeyArn"].readIfPresent()
        value.keyName = try reader["KeyName"].readIfPresent()
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct UpdateKeyOutput {
    /// The Amazon Resource Name (ARN) for the API key resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:key/ExampleKey
    /// This member is required.
    public var keyArn: Swift.String?
    /// The name of the API key resource.
    /// This member is required.
    public var keyName: Swift.String?
    /// The timestamp for when the API key resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        keyArn: Swift.String? = nil,
        keyName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.keyArn = keyArn
        self.keyName = keyName
        self.updateTime = updateTime
    }
}

enum UpdateKeyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateMapInput {

    static func urlPathProvider(_ value: UpdateMapInput) -> Swift.String? {
        guard let mapName = value.mapName else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())"
    }
}

extension UpdateMapInput {

    static func write(value: UpdateMapInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationUpdate"].write(value.configurationUpdate, with: LocationClientTypes.MapConfigurationUpdate.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["PricingPlan"].write(value.pricingPlan)
    }
}

public struct UpdateMapInput {
    /// Updates the parts of the map configuration that can be updated, including the political view.
    public var configurationUpdate: LocationClientTypes.MapConfigurationUpdate?
    /// Updates the description for the map resource.
    public var description: Swift.String?
    /// The name of the map resource to update.
    /// This member is required.
    public var mapName: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?

    public init(
        configurationUpdate: LocationClientTypes.MapConfigurationUpdate? = nil,
        description: Swift.String? = nil,
        mapName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil
    )
    {
        self.configurationUpdate = configurationUpdate
        self.description = description
        self.mapName = mapName
        self.pricingPlan = pricingPlan
    }
}

extension UpdateMapOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateMapOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMapOutput()
        value.mapArn = try reader["MapArn"].readIfPresent()
        value.mapName = try reader["MapName"].readIfPresent()
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct UpdateMapOutput {
    /// The Amazon Resource Name (ARN) of the updated map resource. Used to specify a resource across AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:map/ExampleMap
    /// This member is required.
    public var mapArn: Swift.String?
    /// The name of the updated map resource.
    /// This member is required.
    public var mapName: Swift.String?
    /// The timestamp for when the map resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        mapArn: Swift.String? = nil,
        mapName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.mapArn = mapArn
        self.mapName = mapName
        self.updateTime = updateTime
    }
}

enum UpdateMapOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdatePlaceIndexInput {

    static func urlPathProvider(_ value: UpdatePlaceIndexInput) -> Swift.String? {
        guard let indexName = value.indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())"
    }
}

extension UpdatePlaceIndexInput {

    static func write(value: UpdatePlaceIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSourceConfiguration"].write(value.dataSourceConfiguration, with: LocationClientTypes.DataSourceConfiguration.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["PricingPlan"].write(value.pricingPlan)
    }
}

public struct UpdatePlaceIndexInput {
    /// Updates the data storage option for the place index resource.
    public var dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    /// Updates the description for the place index resource.
    public var description: Swift.String?
    /// The name of the place index resource to update.
    /// This member is required.
    public var indexName: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?

    public init(
        dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        indexName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil
    )
    {
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.indexName = indexName
        self.pricingPlan = pricingPlan
    }
}

extension UpdatePlaceIndexOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdatePlaceIndexOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePlaceIndexOutput()
        value.indexArn = try reader["IndexArn"].readIfPresent()
        value.indexName = try reader["IndexName"].readIfPresent()
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct UpdatePlaceIndexOutput {
    /// The Amazon Resource Name (ARN) of the upated place index resource. Used to specify a resource across Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:place- index/ExamplePlaceIndex
    /// This member is required.
    public var indexArn: Swift.String?
    /// The name of the updated place index resource.
    /// This member is required.
    public var indexName: Swift.String?
    /// The timestamp for when the place index resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.indexArn = indexArn
        self.indexName = indexName
        self.updateTime = updateTime
    }
}

enum UpdatePlaceIndexOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateRouteCalculatorInput {

    static func urlPathProvider(_ value: UpdateRouteCalculatorInput) -> Swift.String? {
        guard let calculatorName = value.calculatorName else {
            return nil
        }
        return "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())"
    }
}

extension UpdateRouteCalculatorInput {

    static func write(value: UpdateRouteCalculatorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["PricingPlan"].write(value.pricingPlan)
    }
}

public struct UpdateRouteCalculatorInput {
    /// The name of the route calculator resource to update.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// Updates the description for the route calculator resource.
    public var description: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?

    public init(
        calculatorName: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil
    )
    {
        self.calculatorName = calculatorName
        self.description = description
        self.pricingPlan = pricingPlan
    }
}

extension UpdateRouteCalculatorOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateRouteCalculatorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRouteCalculatorOutput()
        value.calculatorArn = try reader["CalculatorArn"].readIfPresent()
        value.calculatorName = try reader["CalculatorName"].readIfPresent()
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct UpdateRouteCalculatorOutput {
    /// The Amazon Resource Name (ARN) of the updated route calculator resource. Used to specify a resource across AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:route- calculator/ExampleCalculator
    /// This member is required.
    public var calculatorArn: Swift.String?
    /// The name of the updated route calculator resource.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// The timestamp for when the route calculator was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        calculatorArn: Swift.String? = nil,
        calculatorName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.calculatorArn = calculatorArn
        self.calculatorName = calculatorName
        self.updateTime = updateTime
    }
}

enum UpdateRouteCalculatorOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateTrackerInput {

    static func urlPathProvider(_ value: UpdateTrackerInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())"
    }
}

extension UpdateTrackerInput {

    static func write(value: UpdateTrackerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["EventBridgeEnabled"].write(value.eventBridgeEnabled)
        try writer["KmsKeyEnableGeospatialQueries"].write(value.kmsKeyEnableGeospatialQueries)
        try writer["PositionFiltering"].write(value.positionFiltering)
        try writer["PricingPlan"].write(value.pricingPlan)
        try writer["PricingPlanDataSource"].write(value.pricingPlanDataSource)
    }
}

public struct UpdateTrackerInput {
    /// Updates the description for the tracker resource.
    public var description: Swift.String?
    /// Whether to enable position UPDATE events from this tracker to be sent to EventBridge. You do not need enable this feature to get ENTER and EXIT events for geofences with this tracker. Those events are always sent to EventBridge.
    public var eventBridgeEnabled: Swift.Bool?
    /// Enables GeospatialQueries for a tracker that uses a [Amazon Web Services KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html). This parameter is only used if you are using a KMS customer managed key.
    public var kmsKeyEnableGeospatialQueries: Swift.Bool?
    /// Updates the position filtering for the tracker resource. Valid values:
    ///
    /// * TimeBased - Location updates are evaluated against linked geofence collections, but not every location update is stored. If your update frequency is more often than 30 seconds, only one update per 30 seconds is stored for each unique device ID.
    ///
    /// * DistanceBased - If the device has moved less than 30 m (98.4 ft), location updates are ignored. Location updates within this distance are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map.
    ///
    /// * AccuracyBased - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This helps educe the effects of GPS noise when displaying device trajectories on a map, and can help control costs by reducing the number of geofence evaluations.
    public var positionFiltering: LocationClientTypes.PositionFiltering?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// This parameter is no longer used.
    @available(*, deprecated, message: "Deprecated. No longer allowed. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?
    /// The name of the tracker resource to update.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        description: Swift.String? = nil,
        eventBridgeEnabled: Swift.Bool? = nil,
        kmsKeyEnableGeospatialQueries: Swift.Bool? = nil,
        positionFiltering: LocationClientTypes.PositionFiltering? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.description = description
        self.eventBridgeEnabled = eventBridgeEnabled
        self.kmsKeyEnableGeospatialQueries = kmsKeyEnableGeospatialQueries
        self.positionFiltering = positionFiltering
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.trackerName = trackerName
    }
}

extension UpdateTrackerOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateTrackerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTrackerOutput()
        value.trackerArn = try reader["TrackerArn"].readIfPresent()
        value.trackerName = try reader["TrackerName"].readIfPresent()
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct UpdateTrackerOutput {
    /// The Amazon Resource Name (ARN) of the updated tracker resource. Used to specify a resource across AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
    /// This member is required.
    public var trackerArn: Swift.String?
    /// The name of the updated tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?
    /// The timestamp for when the tracker resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        trackerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.trackerArn = trackerArn
        self.trackerName = trackerName
        self.updateTime = updateTime
    }
}

enum UpdateTrackerOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: LocationClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The input failed to meet the constraints specified by the AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field where the invalid entry was detected.
        /// This member is required.
        public internal(set) var fieldList: [LocationClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// A message with the reason for the validation exception error.
        /// This member is required.
        public internal(set) var reason: LocationClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [LocationClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: LocationClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension LocationClientTypes.ValidationExceptionField {

    static func write(value: LocationClientTypes.ValidationExceptionField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["message"].write(value.message)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LocationClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LocationClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension LocationClientTypes {
    /// The input failed to meet the constraints specified by the AWS service in a specified field.
    public struct ValidationExceptionField {
        /// A message with the reason for the validation exception error.
        /// This member is required.
        public var message: Swift.String?
        /// The field name where the invalid entry was detected.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension LocationClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// The input cannot be parsed. For example a required JSON document, ARN identifier, date value, or numeric field cannot be parsed.
        case cannotparse
        /// The input is present and parsable, but it is otherwise invalid. For example, a required numeric argument is outside the allowed range.
        case fieldvalidationfailed
        /// The required input is missing.
        case missing
        /// The input is invalid but no more specific reason is applicable.
        case other
        /// No such operation is supported.
        case unknownoperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotparse,
                .fieldvalidationfailed,
                .missing,
                .other,
                .unknownoperation,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotparse: return "CannotParse"
            case .fieldvalidationfailed: return "FieldValidationFailed"
            case .missing: return "Missing"
            case .other: return "Other"
            case .unknownoperation: return "UnknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LocationClientTypes {

    public enum VehicleWeightUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case kilograms
        case pounds
        case sdkUnknown(Swift.String)

        public static var allCases: [VehicleWeightUnit] {
            return [
                .kilograms,
                .pounds,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kilograms: return "Kilograms"
            case .pounds: return "Pounds"
            case let .sdkUnknown(s): return s
            }
        }
    }
}
