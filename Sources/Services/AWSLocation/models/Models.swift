// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied because of insufficient access or permissions. Check with an administrator to verify your permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes.ApiKeyFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyStatus = "KeyStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyStatus = self.keyStatus {
            try encodeContainer.encode(keyStatus.rawValue, forKey: .keyStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyStatusDecoded = try containerValues.decodeIfPresent(LocationClientTypes.Status.self, forKey: .keyStatus)
        keyStatus = keyStatusDecoded
    }
}

extension LocationClientTypes {
    /// Options for filtering API keys.
    public struct ApiKeyFilter: Swift.Equatable {
        /// Filter on Active or Expired API keys.
        public var keyStatus: LocationClientTypes.Status?

        public init(
            keyStatus: LocationClientTypes.Status? = nil
        )
        {
            self.keyStatus = keyStatus
        }
    }

}

extension LocationClientTypes.ApiKeyRestrictions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowActions = "AllowActions"
        case allowReferers = "AllowReferers"
        case allowResources = "AllowResources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowActions = allowActions {
            var allowActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowActions)
            for apikeyaction0 in allowActions {
                try allowActionsContainer.encode(apikeyaction0)
            }
        }
        if let allowReferers = allowReferers {
            var allowReferersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowReferers)
            for refererpattern0 in allowReferers {
                try allowReferersContainer.encode(refererpattern0)
            }
        }
        if let allowResources = allowResources {
            var allowResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowResources)
            for geoarn0 in allowResources {
                try allowResourcesContainer.encode(geoarn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowActions)
        var allowActionsDecoded0:[Swift.String]? = nil
        if let allowActionsContainer = allowActionsContainer {
            allowActionsDecoded0 = [Swift.String]()
            for string0 in allowActionsContainer {
                if let string0 = string0 {
                    allowActionsDecoded0?.append(string0)
                }
            }
        }
        allowActions = allowActionsDecoded0
        let allowResourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowResources)
        var allowResourcesDecoded0:[Swift.String]? = nil
        if let allowResourcesContainer = allowResourcesContainer {
            allowResourcesDecoded0 = [Swift.String]()
            for string0 in allowResourcesContainer {
                if let string0 = string0 {
                    allowResourcesDecoded0?.append(string0)
                }
            }
        }
        allowResources = allowResourcesDecoded0
        let allowReferersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowReferers)
        var allowReferersDecoded0:[Swift.String]? = nil
        if let allowReferersContainer = allowReferersContainer {
            allowReferersDecoded0 = [Swift.String]()
            for string0 in allowReferersContainer {
                if let string0 = string0 {
                    allowReferersDecoded0?.append(string0)
                }
            }
        }
        allowReferers = allowReferersDecoded0
    }
}

extension LocationClientTypes {
    /// API Restrictions on the allowed actions, resources, and referers for an API key resource.
    public struct ApiKeyRestrictions: Swift.Equatable {
        /// A list of allowed actions that an API key resource grants permissions to perform. You must have at least one action for each type of resource. For example, if you have a place resource, you must include at least one place action. The following are valid values for the actions.
        ///
        /// * Map actions
        ///
        /// * geo:GetMap* - Allows all actions needed for map rendering.
        ///
        ///
        ///
        ///
        /// * Place actions
        ///
        /// * geo:SearchPlaceIndexForText - Allows geocoding.
        ///
        /// * geo:SearchPlaceIndexForPosition - Allows reverse geocoding.
        ///
        /// * geo:SearchPlaceIndexForSuggestions - Allows generating suggestions from text.
        ///
        /// * GetPlace - Allows finding a place by place ID.
        ///
        ///
        ///
        ///
        /// * Route actions
        ///
        /// * geo:CalculateRoute - Allows point to point routing.
        ///
        /// * geo:CalculateRouteMatrix - Allows calculating a matrix of routes.
        ///
        ///
        ///
        ///
        ///
        /// You must use these strings exactly. For example, to provide access to map rendering, the only valid action is geo:GetMap* as an input to the list. ["geo:GetMap*"] is valid but ["geo:GetMapTile"] is not. Similarly, you cannot use ["geo:SearchPlaceIndexFor*"] - you must list each of the Place actions separately.
        /// This member is required.
        public var allowActions: [Swift.String]?
        /// An optional list of allowed HTTP referers for which requests must originate from. Requests using this API key from other domains will not be allowed. Requirements:
        ///
        /// * Contain only alphanumeric characters (A–Z, a–z, 0–9) or any symbols in this list $\-._+!*`(),;/?:@=&
        ///
        /// * May contain a percent (%) if followed by 2 hexadecimal digits (A-F, a-f, 0-9); this is used for URL encoding purposes.
        ///
        /// * May contain wildcard characters question mark (?) and asterisk (*). Question mark (?) will replace any single character (including hexadecimal digits). Asterisk (*) will replace any multiple characters (including multiple hexadecimal digits).
        ///
        /// * No spaces allowed. For example, https://example.com.
        public var allowReferers: [Swift.String]?
        /// A list of allowed resource ARNs that a API key bearer can perform actions on.
        ///
        /// * The ARN must be the correct ARN for a map, place, or route ARN. You may include wildcards in the resource-id to match multiple resources of the same type.
        ///
        /// * The resources must be in the same partition, region, and account-id as the key that is being created.
        ///
        /// * Other than wildcards, you must include the full ARN, including the arn, partition, service, region, account-id and resource-id delimited by colons (:).
        ///
        /// * No spaces allowed, even with wildcards. For example, arn:aws:geo:region:account-id:map/ExampleMap*.
        ///
        ///
        /// For more information about ARN format, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
        /// This member is required.
        public var allowResources: [Swift.String]?

        public init(
            allowActions: [Swift.String]? = nil,
            allowReferers: [Swift.String]? = nil,
            allowResources: [Swift.String]? = nil
        )
        {
            self.allowActions = allowActions
            self.allowReferers = allowReferers
            self.allowResources = allowResources
        }
    }

}

extension AssociateTrackerConsumerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerArn = "ConsumerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerArn = self.consumerArn {
            try encodeContainer.encode(consumerArn, forKey: .consumerArn)
        }
    }
}

extension AssociateTrackerConsumerInput {

    static func urlPathProvider(_ value: AssociateTrackerConsumerInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/consumers"
    }
}

public struct AssociateTrackerConsumerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the geofence collection to be associated to tracker resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
    /// This member is required.
    public var consumerArn: Swift.String?
    /// The name of the tracker resource to be associated with a geofence collection.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        consumerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.consumerArn = consumerArn
        self.trackerName = trackerName
    }
}

struct AssociateTrackerConsumerInputBody: Swift.Equatable {
    let consumerArn: Swift.String?
}

extension AssociateTrackerConsumerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerArn = "ConsumerArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumerArn)
        consumerArn = consumerArnDecoded
    }
}

extension AssociateTrackerConsumerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateTrackerConsumerOutput: Swift.Equatable {

    public init() { }
}

enum AssociateTrackerConsumerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.BatchDeleteDevicePositionHistoryError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case error = "Error"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes {
    /// Contains the tracker resource details.
    public struct BatchDeleteDevicePositionHistoryError: Swift.Equatable {
        /// The ID of the device for this position.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains the batch request error details associated with the request.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?

        public init(
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
        }
    }

}

extension BatchDeleteDevicePositionHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceIds = deviceIds {
            var deviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceIds)
            for id0 in deviceIds {
                try deviceIdsContainer.encode(id0)
            }
        }
    }
}

extension BatchDeleteDevicePositionHistoryInput {

    static func urlPathProvider(_ value: BatchDeleteDevicePositionHistoryInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/delete-positions"
    }
}

public struct BatchDeleteDevicePositionHistoryInput: Swift.Equatable {
    /// Devices whose position history you want to delete.
    ///
    /// * For example, for two devices: “DeviceIds” : [DeviceId1,DeviceId2]
    /// This member is required.
    public var deviceIds: [Swift.String]?
    /// The name of the tracker resource to delete the device position history from.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        deviceIds: [Swift.String]? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceIds = deviceIds
        self.trackerName = trackerName
    }
}

struct BatchDeleteDevicePositionHistoryInputBody: Swift.Equatable {
    let deviceIds: [Swift.String]?
}

extension BatchDeleteDevicePositionHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceIds)
        var deviceIdsDecoded0:[Swift.String]? = nil
        if let deviceIdsContainer = deviceIdsContainer {
            deviceIdsDecoded0 = [Swift.String]()
            for string0 in deviceIdsContainer {
                if let string0 = string0 {
                    deviceIdsDecoded0?.append(string0)
                }
            }
        }
        deviceIds = deviceIdsDecoded0
    }
}

extension BatchDeleteDevicePositionHistoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDeleteDevicePositionHistoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteDevicePositionHistoryOutput: Swift.Equatable {
    /// Contains error details for each device history that failed to delete.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchDeleteDevicePositionHistoryError]?

    public init(
        errors: [LocationClientTypes.BatchDeleteDevicePositionHistoryError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteDevicePositionHistoryOutputBody: Swift.Equatable {
    let errors: [LocationClientTypes.BatchDeleteDevicePositionHistoryError]?
}

extension BatchDeleteDevicePositionHistoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchDeleteDevicePositionHistoryError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchDeleteDevicePositionHistoryError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchDeleteDevicePositionHistoryError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchDeleteDevicePositionHistoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.BatchDeleteGeofenceError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case geofenceId = "GeofenceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let geofenceId = self.geofenceId {
            try encodeContainer.encode(geofenceId, forKey: .geofenceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes {
    /// Contains error details for each geofence that failed to delete from the geofence collection.
    public struct BatchDeleteGeofenceError: Swift.Equatable {
        /// Contains details associated to the batch error.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// The geofence associated with the error message.
        /// This member is required.
        public var geofenceId: Swift.String?

        public init(
            error: LocationClientTypes.BatchItemError? = nil,
            geofenceId: Swift.String? = nil
        )
        {
            self.error = error
            self.geofenceId = geofenceId
        }
    }

}

extension BatchDeleteGeofenceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geofenceIds = "GeofenceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geofenceIds = geofenceIds {
            var geofenceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .geofenceIds)
            for id0 in geofenceIds {
                try geofenceIdsContainer.encode(id0)
            }
        }
    }
}

extension BatchDeleteGeofenceInput {

    static func urlPathProvider(_ value: BatchDeleteGeofenceInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/delete-geofences"
    }
}

public struct BatchDeleteGeofenceInput: Swift.Equatable {
    /// The geofence collection storing the geofences to be deleted.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The batch of geofences to be deleted.
    /// This member is required.
    public var geofenceIds: [Swift.String]?

    public init(
        collectionName: Swift.String? = nil,
        geofenceIds: [Swift.String]? = nil
    )
    {
        self.collectionName = collectionName
        self.geofenceIds = geofenceIds
    }
}

struct BatchDeleteGeofenceInputBody: Swift.Equatable {
    let geofenceIds: [Swift.String]?
}

extension BatchDeleteGeofenceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geofenceIds = "GeofenceIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .geofenceIds)
        var geofenceIdsDecoded0:[Swift.String]? = nil
        if let geofenceIdsContainer = geofenceIdsContainer {
            geofenceIdsDecoded0 = [Swift.String]()
            for string0 in geofenceIdsContainer {
                if let string0 = string0 {
                    geofenceIdsDecoded0?.append(string0)
                }
            }
        }
        geofenceIds = geofenceIdsDecoded0
    }
}

extension BatchDeleteGeofenceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDeleteGeofenceOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteGeofenceOutput: Swift.Equatable {
    /// Contains error details for each geofence that failed to delete.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchDeleteGeofenceError]?

    public init(
        errors: [LocationClientTypes.BatchDeleteGeofenceError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteGeofenceOutputBody: Swift.Equatable {
    let errors: [LocationClientTypes.BatchDeleteGeofenceError]?
}

extension BatchDeleteGeofenceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchDeleteGeofenceError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchDeleteGeofenceError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchDeleteGeofenceError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchDeleteGeofenceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.BatchEvaluateGeofencesError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case error = "Error"
        case sampleTime = "SampleTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let sampleTime = self.sampleTime {
            try encodeContainer.encodeTimestamp(sampleTime, format: .dateTime, forKey: .sampleTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes {
    /// Contains error details for each device that failed to evaluate its position against the geofences in a given geofence collection.
    public struct BatchEvaluateGeofencesError: Swift.Equatable {
        /// The device associated with the position evaluation error.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains details associated to the batch error.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// Specifies a timestamp for when the error occurred in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init(
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }
    }

}

extension BatchEvaluateGeofencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePositionUpdates = "DevicePositionUpdates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devicePositionUpdates = devicePositionUpdates {
            var devicePositionUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devicePositionUpdates)
            for devicepositionupdate0 in devicePositionUpdates {
                try devicePositionUpdatesContainer.encode(devicepositionupdate0)
            }
        }
    }
}

extension BatchEvaluateGeofencesInput {

    static func urlPathProvider(_ value: BatchEvaluateGeofencesInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/positions"
    }
}

public struct BatchEvaluateGeofencesInput: Swift.Equatable {
    /// The geofence collection used in evaluating the position of devices against its geofences.
    /// This member is required.
    public var collectionName: Swift.String?
    /// Contains device details for each device to be evaluated against the given geofence collection.
    /// This member is required.
    public var devicePositionUpdates: [LocationClientTypes.DevicePositionUpdate]?

    public init(
        collectionName: Swift.String? = nil,
        devicePositionUpdates: [LocationClientTypes.DevicePositionUpdate]? = nil
    )
    {
        self.collectionName = collectionName
        self.devicePositionUpdates = devicePositionUpdates
    }
}

struct BatchEvaluateGeofencesInputBody: Swift.Equatable {
    let devicePositionUpdates: [LocationClientTypes.DevicePositionUpdate]?
}

extension BatchEvaluateGeofencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePositionUpdates = "DevicePositionUpdates"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePositionUpdatesContainer = try containerValues.decodeIfPresent([LocationClientTypes.DevicePositionUpdate?].self, forKey: .devicePositionUpdates)
        var devicePositionUpdatesDecoded0:[LocationClientTypes.DevicePositionUpdate]? = nil
        if let devicePositionUpdatesContainer = devicePositionUpdatesContainer {
            devicePositionUpdatesDecoded0 = [LocationClientTypes.DevicePositionUpdate]()
            for structure0 in devicePositionUpdatesContainer {
                if let structure0 = structure0 {
                    devicePositionUpdatesDecoded0?.append(structure0)
                }
            }
        }
        devicePositionUpdates = devicePositionUpdatesDecoded0
    }
}

extension BatchEvaluateGeofencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchEvaluateGeofencesOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchEvaluateGeofencesOutput: Swift.Equatable {
    /// Contains error details for each device that failed to evaluate its position against the given geofence collection.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchEvaluateGeofencesError]?

    public init(
        errors: [LocationClientTypes.BatchEvaluateGeofencesError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchEvaluateGeofencesOutputBody: Swift.Equatable {
    let errors: [LocationClientTypes.BatchEvaluateGeofencesError]?
}

extension BatchEvaluateGeofencesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchEvaluateGeofencesError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchEvaluateGeofencesError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchEvaluateGeofencesError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchEvaluateGeofencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.BatchGetDevicePositionError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case error = "Error"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes {
    /// Contains error details for each device that didn't return a position.
    public struct BatchGetDevicePositionError: Swift.Equatable {
        /// The ID of the device that didn't return a position.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains details related to the error code.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?

        public init(
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
        }
    }

}

extension BatchGetDevicePositionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceIds = deviceIds {
            var deviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceIds)
            for id0 in deviceIds {
                try deviceIdsContainer.encode(id0)
            }
        }
    }
}

extension BatchGetDevicePositionInput {

    static func urlPathProvider(_ value: BatchGetDevicePositionInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/get-positions"
    }
}

public struct BatchGetDevicePositionInput: Swift.Equatable {
    /// Devices whose position you want to retrieve.
    ///
    /// * For example, for two devices: device-ids=DeviceId1&device-ids=DeviceId2
    /// This member is required.
    public var deviceIds: [Swift.String]?
    /// The tracker resource retrieving the device position.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        deviceIds: [Swift.String]? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceIds = deviceIds
        self.trackerName = trackerName
    }
}

struct BatchGetDevicePositionInputBody: Swift.Equatable {
    let deviceIds: [Swift.String]?
}

extension BatchGetDevicePositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceIds)
        var deviceIdsDecoded0:[Swift.String]? = nil
        if let deviceIdsContainer = deviceIdsContainer {
            deviceIdsDecoded0 = [Swift.String]()
            for string0 in deviceIdsContainer {
                if let string0 = string0 {
                    deviceIdsDecoded0?.append(string0)
                }
            }
        }
        deviceIds = deviceIdsDecoded0
    }
}

extension BatchGetDevicePositionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetDevicePositionOutputBody = try responseDecoder.decode(responseBody: data)
            self.devicePositions = output.devicePositions
            self.errors = output.errors
        } else {
            self.devicePositions = nil
            self.errors = nil
        }
    }
}

public struct BatchGetDevicePositionOutput: Swift.Equatable {
    /// Contains device position details such as the device ID, position, and timestamps for when the position was received and sampled.
    /// This member is required.
    public var devicePositions: [LocationClientTypes.DevicePosition]?
    /// Contains error details for each device that failed to send its position to the tracker resource.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchGetDevicePositionError]?

    public init(
        devicePositions: [LocationClientTypes.DevicePosition]? = nil,
        errors: [LocationClientTypes.BatchGetDevicePositionError]? = nil
    )
    {
        self.devicePositions = devicePositions
        self.errors = errors
    }
}

struct BatchGetDevicePositionOutputBody: Swift.Equatable {
    let errors: [LocationClientTypes.BatchGetDevicePositionError]?
    let devicePositions: [LocationClientTypes.DevicePosition]?
}

extension BatchGetDevicePositionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePositions = "DevicePositions"
        case errors = "Errors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchGetDevicePositionError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchGetDevicePositionError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchGetDevicePositionError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let devicePositionsContainer = try containerValues.decodeIfPresent([LocationClientTypes.DevicePosition?].self, forKey: .devicePositions)
        var devicePositionsDecoded0:[LocationClientTypes.DevicePosition]? = nil
        if let devicePositionsContainer = devicePositionsContainer {
            devicePositionsDecoded0 = [LocationClientTypes.DevicePosition]()
            for structure0 in devicePositionsContainer {
                if let structure0 = structure0 {
                    devicePositionsDecoded0?.append(structure0)
                }
            }
        }
        devicePositions = devicePositionsDecoded0
    }
}

enum BatchGetDevicePositionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.BatchItemError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes {
    /// Contains the batch request error details associated with the request.
    public struct BatchItemError: Swift.Equatable {
        /// The error code associated with the batch request error.
        public var code: LocationClientTypes.BatchItemErrorCode?
        /// A message with the reason for the batch request error.
        public var message: Swift.String?

        public init(
            code: LocationClientTypes.BatchItemErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension LocationClientTypes {
    public enum BatchItemErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Access to the resource was denied.
        case accessdeniederror
        /// The target resource already exists.
        case conflicterror
        /// Internal server error.
        case internalservererror
        /// The target resource does not exist.
        case resourcenotfounderror
        /// Too many requests.
        case throttlingerror
        /// Input fails to satisfy the constraints specified by the service.
        case validationerror
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchItemErrorCode] {
            return [
                .accessdeniederror,
                .conflicterror,
                .internalservererror,
                .resourcenotfounderror,
                .throttlingerror,
                .validationerror,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniederror: return "AccessDeniedError"
            case .conflicterror: return "ConflictError"
            case .internalservererror: return "InternalServerError"
            case .resourcenotfounderror: return "ResourceNotFoundError"
            case .throttlingerror: return "ThrottlingError"
            case .validationerror: return "ValidationError"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchItemErrorCode(rawValue: rawValue) ?? BatchItemErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes.BatchPutGeofenceError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case geofenceId = "GeofenceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let geofenceId = self.geofenceId {
            try encodeContainer.encode(geofenceId, forKey: .geofenceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes {
    /// Contains error details for each geofence that failed to be stored in a given geofence collection.
    public struct BatchPutGeofenceError: Swift.Equatable {
        /// Contains details associated to the batch error.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// The geofence associated with the error message.
        /// This member is required.
        public var geofenceId: Swift.String?

        public init(
            error: LocationClientTypes.BatchItemError? = nil,
            geofenceId: Swift.String? = nil
        )
        {
            self.error = error
            self.geofenceId = geofenceId
        }
    }

}

extension BatchPutGeofenceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for batchputgeofencerequestentry0 in entries {
                try entriesContainer.encode(batchputgeofencerequestentry0)
            }
        }
    }
}

extension BatchPutGeofenceInput {

    static func urlPathProvider(_ value: BatchPutGeofenceInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/put-geofences"
    }
}

public struct BatchPutGeofenceInput: Swift.Equatable {
    /// The geofence collection storing the geofences.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The batch of geofences to be stored in a geofence collection.
    /// This member is required.
    public var entries: [LocationClientTypes.BatchPutGeofenceRequestEntry]?

    public init(
        collectionName: Swift.String? = nil,
        entries: [LocationClientTypes.BatchPutGeofenceRequestEntry]? = nil
    )
    {
        self.collectionName = collectionName
        self.entries = entries
    }
}

struct BatchPutGeofenceInputBody: Swift.Equatable {
    let entries: [LocationClientTypes.BatchPutGeofenceRequestEntry]?
}

extension BatchPutGeofenceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchPutGeofenceRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.BatchPutGeofenceRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.BatchPutGeofenceRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchPutGeofenceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchPutGeofenceOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.successes = output.successes
        } else {
            self.errors = nil
            self.successes = nil
        }
    }
}

public struct BatchPutGeofenceOutput: Swift.Equatable {
    /// Contains additional error details for each geofence that failed to be stored in a geofence collection.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchPutGeofenceError]?
    /// Contains each geofence that was successfully stored in a geofence collection.
    /// This member is required.
    public var successes: [LocationClientTypes.BatchPutGeofenceSuccess]?

    public init(
        errors: [LocationClientTypes.BatchPutGeofenceError]? = nil,
        successes: [LocationClientTypes.BatchPutGeofenceSuccess]? = nil
    )
    {
        self.errors = errors
        self.successes = successes
    }
}

struct BatchPutGeofenceOutputBody: Swift.Equatable {
    let successes: [LocationClientTypes.BatchPutGeofenceSuccess]?
    let errors: [LocationClientTypes.BatchPutGeofenceError]?
}

extension BatchPutGeofenceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
        case successes = "Successes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successesContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchPutGeofenceSuccess?].self, forKey: .successes)
        var successesDecoded0:[LocationClientTypes.BatchPutGeofenceSuccess]? = nil
        if let successesContainer = successesContainer {
            successesDecoded0 = [LocationClientTypes.BatchPutGeofenceSuccess]()
            for structure0 in successesContainer {
                if let structure0 = structure0 {
                    successesDecoded0?.append(structure0)
                }
            }
        }
        successes = successesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchPutGeofenceError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchPutGeofenceError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchPutGeofenceError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchPutGeofenceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.BatchPutGeofenceRequestEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geofenceId = "GeofenceId"
        case geofenceProperties = "GeofenceProperties"
        case geometry = "Geometry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geofenceId = self.geofenceId {
            try encodeContainer.encode(geofenceId, forKey: .geofenceId)
        }
        if let geofenceProperties = geofenceProperties {
            var geofencePropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .geofenceProperties)
            for (dictKey0, propertyMap0) in geofenceProperties {
                try geofencePropertiesContainer.encode(propertyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let geometry = self.geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.GeofenceGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let geofencePropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .geofenceProperties)
        var geofencePropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let geofencePropertiesContainer = geofencePropertiesContainer {
            geofencePropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in geofencePropertiesContainer {
                if let string0 = string0 {
                    geofencePropertiesDecoded0?[key0] = string0
                }
            }
        }
        geofenceProperties = geofencePropertiesDecoded0
    }
}

extension LocationClientTypes.BatchPutGeofenceRequestEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutGeofenceRequestEntry(geofenceId: \(Swift.String(describing: geofenceId)), geometry: \(Swift.String(describing: geometry)), geofenceProperties: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Contains geofence geometry details.
    public struct BatchPutGeofenceRequestEntry: Swift.Equatable {
        /// The identifier for the geofence to be stored in a given geofence collection.
        /// This member is required.
        public var geofenceId: Swift.String?
        /// Associates one of more properties with the geofence. A property is a key-value pair stored with the geofence and added to any geofence event triggered with that geofence. Format: "key" : "value"
        public var geofenceProperties: [Swift.String:Swift.String]?
        /// Contains the details of the position of the geofence. Can be either a polygon or a circle. Including both will return a validation error. Each [ geofence polygon](https://docs.aws.amazon.com/location-geofences/latest/APIReference/API_GeofenceGeometry.html) can have a maximum of 1,000 vertices.
        /// This member is required.
        public var geometry: LocationClientTypes.GeofenceGeometry?

        public init(
            geofenceId: Swift.String? = nil,
            geofenceProperties: [Swift.String:Swift.String]? = nil,
            geometry: LocationClientTypes.GeofenceGeometry? = nil
        )
        {
            self.geofenceId = geofenceId
            self.geofenceProperties = geofenceProperties
            self.geometry = geometry
        }
    }

}

extension LocationClientTypes.BatchPutGeofenceSuccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case geofenceId = "GeofenceId"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let geofenceId = self.geofenceId {
            try encodeContainer.encode(geofenceId, forKey: .geofenceId)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes {
    /// Contains a summary of each geofence that was successfully stored in a given geofence collection.
    public struct BatchPutGeofenceSuccess: Swift.Equatable {
        /// The timestamp for when the geofence was stored in a geofence collection in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The geofence successfully stored in a geofence collection.
        /// This member is required.
        public var geofenceId: Swift.String?
        /// The timestamp for when the geofence was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            createTime: ClientRuntime.Date? = nil,
            geofenceId: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.updateTime = updateTime
        }
    }

}

extension LocationClientTypes.BatchUpdateDevicePositionError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case error = "Error"
        case sampleTime = "SampleTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let sampleTime = self.sampleTime {
            try encodeContainer.encodeTimestamp(sampleTime, format: .dateTime, forKey: .sampleTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes {
    /// Contains error details for each device that failed to update its position.
    public struct BatchUpdateDevicePositionError: Swift.Equatable {
        /// The device associated with the failed location update.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains details related to the error code such as the error code and error message.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// The timestamp at which the device position was determined. Uses [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init(
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }
    }

}

extension BatchUpdateDevicePositionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updates = "Updates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updates = updates {
            var updatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updates)
            for devicepositionupdate0 in updates {
                try updatesContainer.encode(devicepositionupdate0)
            }
        }
    }
}

extension BatchUpdateDevicePositionInput {

    static func urlPathProvider(_ value: BatchUpdateDevicePositionInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/positions"
    }
}

public struct BatchUpdateDevicePositionInput: Swift.Equatable {
    /// The name of the tracker resource to update.
    /// This member is required.
    public var trackerName: Swift.String?
    /// Contains the position update details for each device, up to 10 devices.
    /// This member is required.
    public var updates: [LocationClientTypes.DevicePositionUpdate]?

    public init(
        trackerName: Swift.String? = nil,
        updates: [LocationClientTypes.DevicePositionUpdate]? = nil
    )
    {
        self.trackerName = trackerName
        self.updates = updates
    }
}

struct BatchUpdateDevicePositionInputBody: Swift.Equatable {
    let updates: [LocationClientTypes.DevicePositionUpdate]?
}

extension BatchUpdateDevicePositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updates = "Updates"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatesContainer = try containerValues.decodeIfPresent([LocationClientTypes.DevicePositionUpdate?].self, forKey: .updates)
        var updatesDecoded0:[LocationClientTypes.DevicePositionUpdate]? = nil
        if let updatesContainer = updatesContainer {
            updatesDecoded0 = [LocationClientTypes.DevicePositionUpdate]()
            for structure0 in updatesContainer {
                if let structure0 = structure0 {
                    updatesDecoded0?.append(structure0)
                }
            }
        }
        updates = updatesDecoded0
    }
}

extension BatchUpdateDevicePositionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchUpdateDevicePositionOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchUpdateDevicePositionOutput: Swift.Equatable {
    /// Contains error details for each device that failed to update its position.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchUpdateDevicePositionError]?

    public init(
        errors: [LocationClientTypes.BatchUpdateDevicePositionError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchUpdateDevicePositionOutputBody: Swift.Equatable {
    let errors: [LocationClientTypes.BatchUpdateDevicePositionError]?
}

extension BatchUpdateDevicePositionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchUpdateDevicePositionError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchUpdateDevicePositionError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchUpdateDevicePositionError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchUpdateDevicePositionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.CalculateRouteCarModeOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avoidFerries = "AvoidFerries"
        case avoidTolls = "AvoidTolls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let avoidFerries = self.avoidFerries {
            try encodeContainer.encode(avoidFerries, forKey: .avoidFerries)
        }
        if let avoidTolls = self.avoidTolls {
            try encodeContainer.encode(avoidTolls, forKey: .avoidTolls)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let avoidFerriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .avoidFerries)
        avoidFerries = avoidFerriesDecoded
        let avoidTollsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .avoidTolls)
        avoidTolls = avoidTollsDecoded
    }
}

extension LocationClientTypes {
    /// Contains details about additional route preferences for requests that specify TravelMode as Car.
    public struct CalculateRouteCarModeOptions: Swift.Equatable {
        /// Avoids ferries when calculating routes. Default Value: false Valid Values: false | true
        public var avoidFerries: Swift.Bool?
        /// Avoids tolls when calculating routes. Default Value: false Valid Values: false | true
        public var avoidTolls: Swift.Bool?

        public init(
            avoidFerries: Swift.Bool? = nil,
            avoidTolls: Swift.Bool? = nil
        )
        {
            self.avoidFerries = avoidFerries
            self.avoidTolls = avoidTolls
        }
    }

}

extension CalculateRouteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRouteInput(arrivalTime: \(Swift.String(describing: arrivalTime)), calculatorName: \(Swift.String(describing: calculatorName)), carModeOptions: \(Swift.String(describing: carModeOptions)), departNow: \(Swift.String(describing: departNow)), departureTime: \(Swift.String(describing: departureTime)), distanceUnit: \(Swift.String(describing: distanceUnit)), includeLegGeometry: \(Swift.String(describing: includeLegGeometry)), optimizeFor: \(Swift.String(describing: optimizeFor)), travelMode: \(Swift.String(describing: travelMode)), truckModeOptions: \(Swift.String(describing: truckModeOptions)), waypointPositions: \(Swift.String(describing: waypointPositions)), departurePosition: \"CONTENT_REDACTED\", destinationPosition: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\")"}
}

extension CalculateRouteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrivalTime = "ArrivalTime"
        case carModeOptions = "CarModeOptions"
        case departNow = "DepartNow"
        case departurePosition = "DeparturePosition"
        case departureTime = "DepartureTime"
        case destinationPosition = "DestinationPosition"
        case distanceUnit = "DistanceUnit"
        case includeLegGeometry = "IncludeLegGeometry"
        case optimizeFor = "OptimizeFor"
        case travelMode = "TravelMode"
        case truckModeOptions = "TruckModeOptions"
        case waypointPositions = "WaypointPositions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arrivalTime = self.arrivalTime {
            try encodeContainer.encodeTimestamp(arrivalTime, format: .dateTime, forKey: .arrivalTime)
        }
        if let carModeOptions = self.carModeOptions {
            try encodeContainer.encode(carModeOptions, forKey: .carModeOptions)
        }
        if let departNow = self.departNow {
            try encodeContainer.encode(departNow, forKey: .departNow)
        }
        if let departurePosition = departurePosition {
            var departurePositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .departurePosition)
            for double0 in departurePosition {
                try departurePositionContainer.encode(double0)
            }
        }
        if let departureTime = self.departureTime {
            try encodeContainer.encodeTimestamp(departureTime, format: .dateTime, forKey: .departureTime)
        }
        if let destinationPosition = destinationPosition {
            var destinationPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPosition)
            for double0 in destinationPosition {
                try destinationPositionContainer.encode(double0)
            }
        }
        if let distanceUnit = self.distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let includeLegGeometry = self.includeLegGeometry {
            try encodeContainer.encode(includeLegGeometry, forKey: .includeLegGeometry)
        }
        if let optimizeFor = self.optimizeFor {
            try encodeContainer.encode(optimizeFor.rawValue, forKey: .optimizeFor)
        }
        if let travelMode = self.travelMode {
            try encodeContainer.encode(travelMode.rawValue, forKey: .travelMode)
        }
        if let truckModeOptions = self.truckModeOptions {
            try encodeContainer.encode(truckModeOptions, forKey: .truckModeOptions)
        }
        if let waypointPositions = waypointPositions {
            var waypointPositionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .waypointPositions)
            for position0 in waypointPositions {
                var position0Container = waypointPositionsContainer.nestedUnkeyedContainer()
                for double1 in position0 {
                    try position0Container.encode(double1)
                }
            }
        }
    }
}

extension CalculateRouteInput {

    static func queryItemProvider(_ value: CalculateRouteInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension CalculateRouteInput {

    static func urlPathProvider(_ value: CalculateRouteInput) -> Swift.String? {
        guard let calculatorName = value.calculatorName else {
            return nil
        }
        return "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())/calculate/route"
    }
}

public struct CalculateRouteInput: Swift.Equatable {
    /// Specifies the desired time of arrival. Uses the given time to calculate the route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route. ArrivalTime is not supported Esri.
    public var arrivalTime: ClientRuntime.Date?
    /// The name of the route calculator resource that you want to use to calculate the route.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// Specifies route preferences when traveling by Car, such as avoiding routes that use ferries or tolls. Requirements: TravelMode must be specified as Car.
    public var carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions?
    /// Sets the time of departure as the current time. Uses the current time to calculate a route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route. Default Value: false Valid Values: false | true
    public var departNow: Swift.Bool?
    /// The start position for the route. Defined in [World Geodetic System (WGS 84)](https://earth-info.nga.mil/index.php?dir=wgs84&action=wgs84) format: [longitude, latitude].
    ///
    /// * For example, [-123.115, 49.285]
    ///
    ///
    /// If you specify a departure that's not located on a road, Amazon Location [moves the position to the nearest road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html). If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a 400 RoutesValidationException error. Valid Values: [-180 to 180,-90 to 90]
    /// This member is required.
    public var departurePosition: [Swift.Double]?
    /// Specifies the desired time of departure. Uses the given time to calculate the route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route.
    ///
    /// * In [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ. For example, 2020–07-2T12:15:20.000Z+01:00
    public var departureTime: ClientRuntime.Date?
    /// The finish position for the route. Defined in [World Geodetic System (WGS 84)](https://earth-info.nga.mil/index.php?dir=wgs84&action=wgs84) format: [longitude, latitude].
    ///
    /// * For example, [-122.339, 47.615]
    ///
    ///
    /// If you specify a destination that's not located on a road, Amazon Location [moves the position to the nearest road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html). Valid Values: [-180 to 180,-90 to 90]
    /// This member is required.
    public var destinationPosition: [Swift.Double]?
    /// Set the unit system to specify the distance. Default Value: Kilometers
    public var distanceUnit: LocationClientTypes.DistanceUnit?
    /// Set to include the geometry details in the result for each path between a pair of positions. Default Value: false Valid Values: false | true
    public var includeLegGeometry: Swift.Bool?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// Specifies the distance to optimize for when calculating a route.
    public var optimizeFor: LocationClientTypes.OptimizationMode?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. You can choose Car, Truck, Walking, Bicycle or Motorcycle as options for the TravelMode. Bicycle and Motorcycle are only valid when using Grab as a data provider, and only within Southeast Asia. Truck is not available for Grab. For more details on the using Grab for routing, including areas of coverage, see [GrabMaps](https://docs.aws.amazon.com/location/latest/developerguide/grab.html) in the Amazon Location Service Developer Guide. The TravelMode you specify also determines how you specify route preferences:
    ///
    /// * If traveling by Car use the CarModeOptions parameter.
    ///
    /// * If traveling by Truck use the TruckModeOptions parameter.
    ///
    ///
    /// Default Value: Car
    public var travelMode: LocationClientTypes.TravelMode?
    /// Specifies route preferences when traveling by Truck, such as avoiding routes that use ferries or tolls, and truck specifications to consider when choosing an optimal road. Requirements: TravelMode must be specified as Truck.
    public var truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions?
    /// Specifies an ordered list of up to 23 intermediate positions to include along a route between the departure position and destination position.
    ///
    /// * For example, from the DeparturePosition[-123.115, 49.285], the route follows the order that the waypoint positions are given [[-122.757, 49.0021],[-122.349, 47.620]]
    ///
    ///
    /// If you specify a waypoint position that's not located on a road, Amazon Location [moves the position to the nearest road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html). Specifying more than 23 waypoints returns a 400 ValidationException error. If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a 400 RoutesValidationException error. Valid Values: [-180 to 180,-90 to 90]
    public var waypointPositions: [[Swift.Double]]?

    public init(
        arrivalTime: ClientRuntime.Date? = nil,
        calculatorName: Swift.String? = nil,
        carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions? = nil,
        departNow: Swift.Bool? = nil,
        departurePosition: [Swift.Double]? = nil,
        departureTime: ClientRuntime.Date? = nil,
        destinationPosition: [Swift.Double]? = nil,
        distanceUnit: LocationClientTypes.DistanceUnit? = nil,
        includeLegGeometry: Swift.Bool? = nil,
        key: Swift.String? = nil,
        optimizeFor: LocationClientTypes.OptimizationMode? = nil,
        travelMode: LocationClientTypes.TravelMode? = nil,
        truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions? = nil,
        waypointPositions: [[Swift.Double]]? = nil
    )
    {
        self.arrivalTime = arrivalTime
        self.calculatorName = calculatorName
        self.carModeOptions = carModeOptions
        self.departNow = departNow
        self.departurePosition = departurePosition
        self.departureTime = departureTime
        self.destinationPosition = destinationPosition
        self.distanceUnit = distanceUnit
        self.includeLegGeometry = includeLegGeometry
        self.key = key
        self.optimizeFor = optimizeFor
        self.travelMode = travelMode
        self.truckModeOptions = truckModeOptions
        self.waypointPositions = waypointPositions
    }
}

struct CalculateRouteInputBody: Swift.Equatable {
    let departurePosition: [Swift.Double]?
    let destinationPosition: [Swift.Double]?
    let waypointPositions: [[Swift.Double]]?
    let travelMode: LocationClientTypes.TravelMode?
    let departureTime: ClientRuntime.Date?
    let departNow: Swift.Bool?
    let distanceUnit: LocationClientTypes.DistanceUnit?
    let includeLegGeometry: Swift.Bool?
    let carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions?
    let truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions?
    let arrivalTime: ClientRuntime.Date?
    let optimizeFor: LocationClientTypes.OptimizationMode?
}

extension CalculateRouteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrivalTime = "ArrivalTime"
        case carModeOptions = "CarModeOptions"
        case departNow = "DepartNow"
        case departurePosition = "DeparturePosition"
        case departureTime = "DepartureTime"
        case destinationPosition = "DestinationPosition"
        case distanceUnit = "DistanceUnit"
        case includeLegGeometry = "IncludeLegGeometry"
        case optimizeFor = "OptimizeFor"
        case travelMode = "TravelMode"
        case truckModeOptions = "TruckModeOptions"
        case waypointPositions = "WaypointPositions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let departurePositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .departurePosition)
        var departurePositionDecoded0:[Swift.Double]? = nil
        if let departurePositionContainer = departurePositionContainer {
            departurePositionDecoded0 = [Swift.Double]()
            for double0 in departurePositionContainer {
                if let double0 = double0 {
                    departurePositionDecoded0?.append(double0)
                }
            }
        }
        departurePosition = departurePositionDecoded0
        let destinationPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .destinationPosition)
        var destinationPositionDecoded0:[Swift.Double]? = nil
        if let destinationPositionContainer = destinationPositionContainer {
            destinationPositionDecoded0 = [Swift.Double]()
            for double0 in destinationPositionContainer {
                if let double0 = double0 {
                    destinationPositionDecoded0?.append(double0)
                }
            }
        }
        destinationPosition = destinationPositionDecoded0
        let waypointPositionsContainer = try containerValues.decodeIfPresent([[Swift.Double?]?].self, forKey: .waypointPositions)
        var waypointPositionsDecoded0:[[Swift.Double]]? = nil
        if let waypointPositionsContainer = waypointPositionsContainer {
            waypointPositionsDecoded0 = [[Swift.Double]]()
            for list0 in waypointPositionsContainer {
                var list0Decoded0: [Swift.Double]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.Double]()
                    for double1 in list0 {
                        if let double1 = double1 {
                            list0Decoded0?.append(double1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    waypointPositionsDecoded0?.append(list0Decoded0)
                }
            }
        }
        waypointPositions = waypointPositionsDecoded0
        let travelModeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.TravelMode.self, forKey: .travelMode)
        travelMode = travelModeDecoded
        let departureTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .departureTime)
        departureTime = departureTimeDecoded
        let departNowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .departNow)
        departNow = departNowDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let includeLegGeometryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeLegGeometry)
        includeLegGeometry = includeLegGeometryDecoded
        let carModeOptionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.CalculateRouteCarModeOptions.self, forKey: .carModeOptions)
        carModeOptions = carModeOptionsDecoded
        let truckModeOptionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.CalculateRouteTruckModeOptions.self, forKey: .truckModeOptions)
        truckModeOptions = truckModeOptionsDecoded
        let arrivalTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .arrivalTime)
        arrivalTime = arrivalTimeDecoded
        let optimizeForDecoded = try containerValues.decodeIfPresent(LocationClientTypes.OptimizationMode.self, forKey: .optimizeFor)
        optimizeFor = optimizeForDecoded
    }
}

extension CalculateRouteMatrixInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRouteMatrixInput(calculatorName: \(Swift.String(describing: calculatorName)), carModeOptions: \(Swift.String(describing: carModeOptions)), departNow: \(Swift.String(describing: departNow)), departurePositions: \(Swift.String(describing: departurePositions)), departureTime: \(Swift.String(describing: departureTime)), destinationPositions: \(Swift.String(describing: destinationPositions)), distanceUnit: \(Swift.String(describing: distanceUnit)), travelMode: \(Swift.String(describing: travelMode)), truckModeOptions: \(Swift.String(describing: truckModeOptions)), key: \"CONTENT_REDACTED\")"}
}

extension CalculateRouteMatrixInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case carModeOptions = "CarModeOptions"
        case departNow = "DepartNow"
        case departurePositions = "DeparturePositions"
        case departureTime = "DepartureTime"
        case destinationPositions = "DestinationPositions"
        case distanceUnit = "DistanceUnit"
        case travelMode = "TravelMode"
        case truckModeOptions = "TruckModeOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let carModeOptions = self.carModeOptions {
            try encodeContainer.encode(carModeOptions, forKey: .carModeOptions)
        }
        if let departNow = self.departNow {
            try encodeContainer.encode(departNow, forKey: .departNow)
        }
        if let departurePositions = departurePositions {
            var departurePositionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .departurePositions)
            for position0 in departurePositions {
                var position0Container = departurePositionsContainer.nestedUnkeyedContainer()
                for double1 in position0 {
                    try position0Container.encode(double1)
                }
            }
        }
        if let departureTime = self.departureTime {
            try encodeContainer.encodeTimestamp(departureTime, format: .dateTime, forKey: .departureTime)
        }
        if let destinationPositions = destinationPositions {
            var destinationPositionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPositions)
            for position0 in destinationPositions {
                var position0Container = destinationPositionsContainer.nestedUnkeyedContainer()
                for double1 in position0 {
                    try position0Container.encode(double1)
                }
            }
        }
        if let distanceUnit = self.distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let travelMode = self.travelMode {
            try encodeContainer.encode(travelMode.rawValue, forKey: .travelMode)
        }
        if let truckModeOptions = self.truckModeOptions {
            try encodeContainer.encode(truckModeOptions, forKey: .truckModeOptions)
        }
    }
}

extension CalculateRouteMatrixInput {

    static func queryItemProvider(_ value: CalculateRouteMatrixInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension CalculateRouteMatrixInput {

    static func urlPathProvider(_ value: CalculateRouteMatrixInput) -> Swift.String? {
        guard let calculatorName = value.calculatorName else {
            return nil
        }
        return "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())/calculate/route-matrix"
    }
}

public struct CalculateRouteMatrixInput: Swift.Equatable {
    /// The name of the route calculator resource that you want to use to calculate the route matrix.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// Specifies route preferences when traveling by Car, such as avoiding routes that use ferries or tolls. Requirements: TravelMode must be specified as Car.
    public var carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions?
    /// Sets the time of departure as the current time. Uses the current time to calculate the route matrix. You can't set both DepartureTime and DepartNow. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix. Default Value: false Valid Values: false | true
    public var departNow: Swift.Bool?
    /// The list of departure (origin) positions for the route matrix. An array of points, each of which is itself a 2-value array defined in [WGS 84](https://earth-info.nga.mil/GandG/wgs84/index.html) format: [longitude, latitude]. For example, [-123.115, 49.285]. Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See [ Position restrictions](https://docs.aws.amazon.com/location/latest/developerguide/calculate-route-matrix.html#matrix-routing-position-limits) in the Amazon Location Service Developer Guide. For route calculators that use Esri as the data provider, if you specify a departure that's not located on a road, Amazon Location [ moves the position to the nearest road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html). The snapped value is available in the result in SnappedDeparturePositions. Valid Values: [-180 to 180,-90 to 90]
    /// This member is required.
    public var departurePositions: [[Swift.Double]]?
    /// Specifies the desired time of departure. Uses the given time to calculate the route matrix. You can't set both DepartureTime and DepartNow. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix. Setting a departure time in the past returns a 400 ValidationException error.
    ///
    /// * In [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ. For example, 2020–07-2T12:15:20.000Z+01:00
    public var departureTime: ClientRuntime.Date?
    /// The list of destination positions for the route matrix. An array of points, each of which is itself a 2-value array defined in [WGS 84](https://earth-info.nga.mil/GandG/wgs84/index.html) format: [longitude, latitude]. For example, [-122.339, 47.615] Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See [ Position restrictions](https://docs.aws.amazon.com/location/latest/developerguide/calculate-route-matrix.html#matrix-routing-position-limits) in the Amazon Location Service Developer Guide. For route calculators that use Esri as the data provider, if you specify a destination that's not located on a road, Amazon Location [ moves the position to the nearest road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html). The snapped value is available in the result in SnappedDestinationPositions. Valid Values: [-180 to 180,-90 to 90]
    /// This member is required.
    public var destinationPositions: [[Swift.Double]]?
    /// Set the unit system to specify the distance. Default Value: Kilometers
    public var distanceUnit: LocationClientTypes.DistanceUnit?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. The TravelMode you specify also determines how you specify route preferences:
    ///
    /// * If traveling by Car use the CarModeOptions parameter.
    ///
    /// * If traveling by Truck use the TruckModeOptions parameter.
    ///
    ///
    /// Bicycle or Motorcycle are only valid when using Grab as a data provider, and only within Southeast Asia. Truck is not available for Grab. For more information about using Grab as a data provider, see [GrabMaps](https://docs.aws.amazon.com/location/latest/developerguide/grab.html) in the Amazon Location Service Developer Guide. Default Value: Car
    public var travelMode: LocationClientTypes.TravelMode?
    /// Specifies route preferences when traveling by Truck, such as avoiding routes that use ferries or tolls, and truck specifications to consider when choosing an optimal road. Requirements: TravelMode must be specified as Truck.
    public var truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions?

    public init(
        calculatorName: Swift.String? = nil,
        carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions? = nil,
        departNow: Swift.Bool? = nil,
        departurePositions: [[Swift.Double]]? = nil,
        departureTime: ClientRuntime.Date? = nil,
        destinationPositions: [[Swift.Double]]? = nil,
        distanceUnit: LocationClientTypes.DistanceUnit? = nil,
        key: Swift.String? = nil,
        travelMode: LocationClientTypes.TravelMode? = nil,
        truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions? = nil
    )
    {
        self.calculatorName = calculatorName
        self.carModeOptions = carModeOptions
        self.departNow = departNow
        self.departurePositions = departurePositions
        self.departureTime = departureTime
        self.destinationPositions = destinationPositions
        self.distanceUnit = distanceUnit
        self.key = key
        self.travelMode = travelMode
        self.truckModeOptions = truckModeOptions
    }
}

struct CalculateRouteMatrixInputBody: Swift.Equatable {
    let departurePositions: [[Swift.Double]]?
    let destinationPositions: [[Swift.Double]]?
    let travelMode: LocationClientTypes.TravelMode?
    let departureTime: ClientRuntime.Date?
    let departNow: Swift.Bool?
    let distanceUnit: LocationClientTypes.DistanceUnit?
    let carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions?
    let truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions?
}

extension CalculateRouteMatrixInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case carModeOptions = "CarModeOptions"
        case departNow = "DepartNow"
        case departurePositions = "DeparturePositions"
        case departureTime = "DepartureTime"
        case destinationPositions = "DestinationPositions"
        case distanceUnit = "DistanceUnit"
        case travelMode = "TravelMode"
        case truckModeOptions = "TruckModeOptions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let departurePositionsContainer = try containerValues.decodeIfPresent([[Swift.Double?]?].self, forKey: .departurePositions)
        var departurePositionsDecoded0:[[Swift.Double]]? = nil
        if let departurePositionsContainer = departurePositionsContainer {
            departurePositionsDecoded0 = [[Swift.Double]]()
            for list0 in departurePositionsContainer {
                var list0Decoded0: [Swift.Double]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.Double]()
                    for double1 in list0 {
                        if let double1 = double1 {
                            list0Decoded0?.append(double1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    departurePositionsDecoded0?.append(list0Decoded0)
                }
            }
        }
        departurePositions = departurePositionsDecoded0
        let destinationPositionsContainer = try containerValues.decodeIfPresent([[Swift.Double?]?].self, forKey: .destinationPositions)
        var destinationPositionsDecoded0:[[Swift.Double]]? = nil
        if let destinationPositionsContainer = destinationPositionsContainer {
            destinationPositionsDecoded0 = [[Swift.Double]]()
            for list0 in destinationPositionsContainer {
                var list0Decoded0: [Swift.Double]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.Double]()
                    for double1 in list0 {
                        if let double1 = double1 {
                            list0Decoded0?.append(double1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    destinationPositionsDecoded0?.append(list0Decoded0)
                }
            }
        }
        destinationPositions = destinationPositionsDecoded0
        let travelModeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.TravelMode.self, forKey: .travelMode)
        travelMode = travelModeDecoded
        let departureTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .departureTime)
        departureTime = departureTimeDecoded
        let departNowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .departNow)
        departNow = departNowDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let carModeOptionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.CalculateRouteCarModeOptions.self, forKey: .carModeOptions)
        carModeOptions = carModeOptionsDecoded
        let truckModeOptionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.CalculateRouteTruckModeOptions.self, forKey: .truckModeOptions)
        truckModeOptions = truckModeOptionsDecoded
    }
}

extension CalculateRouteMatrixOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CalculateRouteMatrixOutputBody = try responseDecoder.decode(responseBody: data)
            self.routeMatrix = output.routeMatrix
            self.snappedDeparturePositions = output.snappedDeparturePositions
            self.snappedDestinationPositions = output.snappedDestinationPositions
            self.summary = output.summary
        } else {
            self.routeMatrix = nil
            self.snappedDeparturePositions = nil
            self.snappedDestinationPositions = nil
            self.summary = nil
        }
    }
}

/// Returns the result of the route matrix calculation.
public struct CalculateRouteMatrixOutput: Swift.Equatable {
    /// The calculated route matrix containing the results for all pairs of DeparturePositions to DestinationPositions. Each row corresponds to one entry in DeparturePositions. Each entry in the row corresponds to the route from that entry in DeparturePositions to an entry in DestinationPositions.
    /// This member is required.
    public var routeMatrix: [[LocationClientTypes.RouteMatrixEntry]]?
    /// For routes calculated using an Esri route calculator resource, departure positions are snapped to the closest road. For Esri route calculator resources, this returns the list of departure/origin positions used for calculation of the RouteMatrix.
    public var snappedDeparturePositions: [[Swift.Double]]?
    /// The list of destination positions for the route matrix used for calculation of the RouteMatrix.
    public var snappedDestinationPositions: [[Swift.Double]]?
    /// Contains information about the route matrix, DataSource, DistanceUnit, RouteCount and ErrorCount.
    /// This member is required.
    public var summary: LocationClientTypes.CalculateRouteMatrixSummary?

    public init(
        routeMatrix: [[LocationClientTypes.RouteMatrixEntry]]? = nil,
        snappedDeparturePositions: [[Swift.Double]]? = nil,
        snappedDestinationPositions: [[Swift.Double]]? = nil,
        summary: LocationClientTypes.CalculateRouteMatrixSummary? = nil
    )
    {
        self.routeMatrix = routeMatrix
        self.snappedDeparturePositions = snappedDeparturePositions
        self.snappedDestinationPositions = snappedDestinationPositions
        self.summary = summary
    }
}

struct CalculateRouteMatrixOutputBody: Swift.Equatable {
    let routeMatrix: [[LocationClientTypes.RouteMatrixEntry]]?
    let snappedDeparturePositions: [[Swift.Double]]?
    let snappedDestinationPositions: [[Swift.Double]]?
    let summary: LocationClientTypes.CalculateRouteMatrixSummary?
}

extension CalculateRouteMatrixOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routeMatrix = "RouteMatrix"
        case snappedDeparturePositions = "SnappedDeparturePositions"
        case snappedDestinationPositions = "SnappedDestinationPositions"
        case summary = "Summary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeMatrixContainer = try containerValues.decodeIfPresent([[LocationClientTypes.RouteMatrixEntry?]?].self, forKey: .routeMatrix)
        var routeMatrixDecoded0:[[LocationClientTypes.RouteMatrixEntry]]? = nil
        if let routeMatrixContainer = routeMatrixContainer {
            routeMatrixDecoded0 = [[LocationClientTypes.RouteMatrixEntry]]()
            for list0 in routeMatrixContainer {
                var list0Decoded0: [LocationClientTypes.RouteMatrixEntry]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [LocationClientTypes.RouteMatrixEntry]()
                    for structure1 in list0 {
                        if let structure1 = structure1 {
                            list0Decoded0?.append(structure1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    routeMatrixDecoded0?.append(list0Decoded0)
                }
            }
        }
        routeMatrix = routeMatrixDecoded0
        let snappedDeparturePositionsContainer = try containerValues.decodeIfPresent([[Swift.Double?]?].self, forKey: .snappedDeparturePositions)
        var snappedDeparturePositionsDecoded0:[[Swift.Double]]? = nil
        if let snappedDeparturePositionsContainer = snappedDeparturePositionsContainer {
            snappedDeparturePositionsDecoded0 = [[Swift.Double]]()
            for list0 in snappedDeparturePositionsContainer {
                var list0Decoded0: [Swift.Double]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.Double]()
                    for double1 in list0 {
                        if let double1 = double1 {
                            list0Decoded0?.append(double1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    snappedDeparturePositionsDecoded0?.append(list0Decoded0)
                }
            }
        }
        snappedDeparturePositions = snappedDeparturePositionsDecoded0
        let snappedDestinationPositionsContainer = try containerValues.decodeIfPresent([[Swift.Double?]?].self, forKey: .snappedDestinationPositions)
        var snappedDestinationPositionsDecoded0:[[Swift.Double]]? = nil
        if let snappedDestinationPositionsContainer = snappedDestinationPositionsContainer {
            snappedDestinationPositionsDecoded0 = [[Swift.Double]]()
            for list0 in snappedDestinationPositionsContainer {
                var list0Decoded0: [Swift.Double]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.Double]()
                    for double1 in list0 {
                        if let double1 = double1 {
                            list0Decoded0?.append(double1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    snappedDestinationPositionsDecoded0?.append(list0Decoded0)
                }
            }
        }
        snappedDestinationPositions = snappedDestinationPositionsDecoded0
        let summaryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.CalculateRouteMatrixSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

enum CalculateRouteMatrixOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.CalculateRouteMatrixSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case distanceUnit = "DistanceUnit"
        case errorCount = "ErrorCount"
        case routeCount = "RouteCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let distanceUnit = self.distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let errorCount = self.errorCount {
            try encodeContainer.encode(errorCount, forKey: .errorCount)
        }
        if let routeCount = self.routeCount {
            try encodeContainer.encode(routeCount, forKey: .routeCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let routeCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .routeCount)
        routeCount = routeCountDecoded
        let errorCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorCount)
        errorCount = errorCountDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
    }
}

extension LocationClientTypes {
    /// A summary of the calculated route matrix.
    public struct CalculateRouteMatrixSummary: Swift.Equatable {
        /// The data provider of traffic and road network data used to calculate the routes. Indicates one of the available providers:
        ///
        /// * Esri
        ///
        /// * Grab
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// The unit of measurement for route distances.
        /// This member is required.
        public var distanceUnit: LocationClientTypes.DistanceUnit?
        /// The count of error results in the route matrix. If this number is 0, all routes were calculated successfully.
        /// This member is required.
        public var errorCount: Swift.Int?
        /// The count of cells in the route matrix. Equal to the number of DeparturePositions multiplied by the number of DestinationPositions.
        /// This member is required.
        public var routeCount: Swift.Int?

        public init(
            dataSource: Swift.String? = nil,
            distanceUnit: LocationClientTypes.DistanceUnit? = nil,
            errorCount: Swift.Int? = nil,
            routeCount: Swift.Int? = nil
        )
        {
            self.dataSource = dataSource
            self.distanceUnit = distanceUnit
            self.errorCount = errorCount
            self.routeCount = routeCount
        }
    }

}

extension CalculateRouteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CalculateRouteOutputBody = try responseDecoder.decode(responseBody: data)
            self.legs = output.legs
            self.summary = output.summary
        } else {
            self.legs = nil
            self.summary = nil
        }
    }
}

/// Returns the result of the route calculation. Metadata includes legs and route summary.
public struct CalculateRouteOutput: Swift.Equatable {
    /// Contains details about each path between a pair of positions included along a route such as: StartPosition, EndPosition, Distance, DurationSeconds, Geometry, and Steps. The number of legs returned corresponds to one fewer than the total number of positions in the request. For example, a route with a departure position and destination position returns one leg with the positions [snapped to a nearby road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html):
    ///
    /// * The StartPosition is the departure position.
    ///
    /// * The EndPosition is the destination position.
    ///
    ///
    /// A route with a waypoint between the departure and destination position returns two legs with the positions snapped to a nearby road:
    ///
    /// * Leg 1: The StartPosition is the departure position . The EndPosition is the waypoint positon.
    ///
    /// * Leg 2: The StartPosition is the waypoint position. The EndPosition is the destination position.
    /// This member is required.
    public var legs: [LocationClientTypes.Leg]?
    /// Contains information about the whole route, such as: RouteBBox, DataSource, Distance, DistanceUnit, and DurationSeconds.
    /// This member is required.
    public var summary: LocationClientTypes.CalculateRouteSummary?

    public init(
        legs: [LocationClientTypes.Leg]? = nil,
        summary: LocationClientTypes.CalculateRouteSummary? = nil
    )
    {
        self.legs = legs
        self.summary = summary
    }
}

struct CalculateRouteOutputBody: Swift.Equatable {
    let legs: [LocationClientTypes.Leg]?
    let summary: LocationClientTypes.CalculateRouteSummary?
}

extension CalculateRouteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case legs = "Legs"
        case summary = "Summary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let legsContainer = try containerValues.decodeIfPresent([LocationClientTypes.Leg?].self, forKey: .legs)
        var legsDecoded0:[LocationClientTypes.Leg]? = nil
        if let legsContainer = legsContainer {
            legsDecoded0 = [LocationClientTypes.Leg]()
            for structure0 in legsContainer {
                if let structure0 = structure0 {
                    legsDecoded0?.append(structure0)
                }
            }
        }
        legs = legsDecoded0
        let summaryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.CalculateRouteSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

enum CalculateRouteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.CalculateRouteSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case distance = "Distance"
        case distanceUnit = "DistanceUnit"
        case durationSeconds = "DurationSeconds"
        case routeBBox = "RouteBBox"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let distance = self.distance {
            try encodeContainer.encode(distance, forKey: .distance)
        }
        if let distanceUnit = self.distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let routeBBox = routeBBox {
            var routeBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routeBBox)
            for double0 in routeBBox {
                try routeBBoxContainer.encode(double0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .routeBBox)
        var routeBBoxDecoded0:[Swift.Double]? = nil
        if let routeBBoxContainer = routeBBoxContainer {
            routeBBoxDecoded0 = [Swift.Double]()
            for double0 in routeBBoxContainer {
                if let double0 = double0 {
                    routeBBoxDecoded0?.append(double0)
                }
            }
        }
        routeBBox = routeBBoxDecoded0
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let distanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .distance)
        distance = distanceDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
    }
}

extension LocationClientTypes.CalculateRouteSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRouteSummary(dataSource: \(Swift.String(describing: dataSource)), distance: \(Swift.String(describing: distance)), distanceUnit: \(Swift.String(describing: distanceUnit)), durationSeconds: \(Swift.String(describing: durationSeconds)), routeBBox: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// A summary of the calculated route.
    public struct CalculateRouteSummary: Swift.Equatable {
        /// The data provider of traffic and road network data used to calculate the route. Indicates one of the available providers:
        ///
        /// * Esri
        ///
        /// * Grab
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// The total distance covered by the route. The sum of the distance travelled between every stop on the route. If Esri is the data source for the route calculator, the route distance can’t be greater than 400 km. If the route exceeds 400 km, the response is a 400 RoutesValidationException error.
        /// This member is required.
        public var distance: Swift.Double?
        /// The unit of measurement for route distances.
        /// This member is required.
        public var distanceUnit: LocationClientTypes.DistanceUnit?
        /// The total travel time for the route measured in seconds. The sum of the travel time between every stop on the route.
        /// This member is required.
        public var durationSeconds: Swift.Double?
        /// Specifies a geographical box surrounding a route. Used to zoom into a route when displaying it in a map. For example, [min x, min y, max x, max y]. The first 2 bbox parameters describe the lower southwest corner:
        ///
        /// * The first bbox position is the X coordinate or longitude of the lower southwest corner.
        ///
        /// * The second bbox position is the Y coordinate or latitude of the lower southwest corner.
        ///
        ///
        /// The next 2 bbox parameters describe the upper northeast corner:
        ///
        /// * The third bbox position is the X coordinate, or longitude of the upper northeast corner.
        ///
        /// * The fourth bbox position is the Y coordinate, or latitude of the upper northeast corner.
        /// This member is required.
        public var routeBBox: [Swift.Double]?

        public init(
            dataSource: Swift.String? = nil,
            distance: Swift.Double? = nil,
            distanceUnit: LocationClientTypes.DistanceUnit? = nil,
            durationSeconds: Swift.Double? = nil,
            routeBBox: [Swift.Double]? = nil
        )
        {
            self.dataSource = dataSource
            self.distance = distance
            self.distanceUnit = distanceUnit
            self.durationSeconds = durationSeconds
            self.routeBBox = routeBBox
        }
    }

}

extension LocationClientTypes.CalculateRouteTruckModeOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avoidFerries = "AvoidFerries"
        case avoidTolls = "AvoidTolls"
        case dimensions = "Dimensions"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let avoidFerries = self.avoidFerries {
            try encodeContainer.encode(avoidFerries, forKey: .avoidFerries)
        }
        if let avoidTolls = self.avoidTolls {
            try encodeContainer.encode(avoidTolls, forKey: .avoidTolls)
        }
        if let dimensions = self.dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
        if let weight = self.weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let avoidFerriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .avoidFerries)
        avoidFerries = avoidFerriesDecoded
        let avoidTollsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .avoidTolls)
        avoidTolls = avoidTollsDecoded
        let dimensionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.TruckDimensions.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let weightDecoded = try containerValues.decodeIfPresent(LocationClientTypes.TruckWeight.self, forKey: .weight)
        weight = weightDecoded
    }
}

extension LocationClientTypes {
    /// Contains details about additional route preferences for requests that specify TravelMode as Truck.
    public struct CalculateRouteTruckModeOptions: Swift.Equatable {
        /// Avoids ferries when calculating routes. Default Value: false Valid Values: false | true
        public var avoidFerries: Swift.Bool?
        /// Avoids tolls when calculating routes. Default Value: false Valid Values: false | true
        public var avoidTolls: Swift.Bool?
        /// Specifies the truck's dimension specifications including length, height, width, and unit of measurement. Used to avoid roads that can't support the truck's dimensions.
        public var dimensions: LocationClientTypes.TruckDimensions?
        /// Specifies the truck's weight specifications including total weight and unit of measurement. Used to avoid roads that can't support the truck's weight.
        public var weight: LocationClientTypes.TruckWeight?

        public init(
            avoidFerries: Swift.Bool? = nil,
            avoidTolls: Swift.Bool? = nil,
            dimensions: LocationClientTypes.TruckDimensions? = nil,
            weight: LocationClientTypes.TruckWeight? = nil
        )
        {
            self.avoidFerries = avoidFerries
            self.avoidTolls = avoidTolls
            self.dimensions = dimensions
            self.weight = weight
        }
    }

}

extension LocationClientTypes.Circle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case center = "Center"
        case radius = "Radius"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let center = center {
            var centerContainer = encodeContainer.nestedUnkeyedContainer(forKey: .center)
            for double0 in center {
                try centerContainer.encode(double0)
            }
        }
        if let radius = self.radius {
            try encodeContainer.encode(radius, forKey: .radius)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let centerContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .center)
        var centerDecoded0:[Swift.Double]? = nil
        if let centerContainer = centerContainer {
            centerDecoded0 = [Swift.Double]()
            for double0 in centerContainer {
                if let double0 = double0 {
                    centerDecoded0?.append(double0)
                }
            }
        }
        center = centerDecoded0
        let radiusDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .radius)
        radius = radiusDecoded
    }
}

extension LocationClientTypes.Circle: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension LocationClientTypes {
    /// A circle on the earth, as defined by a center point and a radius.
    public struct Circle: Swift.Equatable {
        /// A single point geometry, specifying the center of the circle, using [WGS 84](https://gisgeography.com/wgs84-world-geodetic-system/) coordinates, in the form [longitude, latitude].
        /// This member is required.
        public var center: [Swift.Double]?
        /// The radius of the circle in meters. Must be greater than zero and no larger than 100,000 (100 kilometers).
        /// This member is required.
        public var radius: Swift.Double?

        public init(
            center: [Swift.Double]? = nil,
            radius: Swift.Double? = nil
        )
        {
            self.center = center
            self.radius = radius
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was unsuccessful because of a conflict.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateGeofenceCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionName = "CollectionName"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectionName = self.collectionName {
            try encodeContainer.encode(collectionName, forKey: .collectionName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = self.pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateGeofenceCollectionInput {

    static func urlPathProvider(_ value: CreateGeofenceCollectionInput) -> Swift.String? {
        return "/geofencing/v0/collections"
    }
}

public struct CreateGeofenceCollectionInput: Swift.Equatable {
    /// A custom name for the geofence collection. Requirements:
    ///
    /// * Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique geofence collection name.
    ///
    /// * No spaces allowed. For example, ExampleGeofenceCollection.
    /// This member is required.
    public var collectionName: Swift.String?
    /// An optional description for the geofence collection.
    public var description: Swift.String?
    /// A key identifier for an [Amazon Web Services KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html). Enter a key ID, key ARN, alias name, or alias ARN.
    public var kmsKeyId: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// This parameter is no longer used.
    @available(*, deprecated, message: "Deprecated. No longer allowed. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?
    /// Applies one or more tags to the geofence collection. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource
    ///
    /// * Each resource tag must be unique with a maximum of one value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?

    public init(
        collectionName: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.collectionName = collectionName
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
    }
}

struct CreateGeofenceCollectionInputBody: Swift.Equatable {
    let collectionName: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let pricingPlanDataSource: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let kmsKeyId: Swift.String?
}

extension CreateGeofenceCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionName = "CollectionName"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension CreateGeofenceCollectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGeofenceCollectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.collectionArn = output.collectionArn
            self.collectionName = output.collectionName
            self.createTime = output.createTime
        } else {
            self.collectionArn = nil
            self.collectionName = nil
            self.createTime = nil
        }
    }
}

public struct CreateGeofenceCollectionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
    /// This member is required.
    public var collectionArn: Swift.String?
    /// The name for the geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The timestamp for when the geofence collection was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var createTime: ClientRuntime.Date?

    public init(
        collectionArn: Swift.String? = nil,
        collectionName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil
    )
    {
        self.collectionArn = collectionArn
        self.collectionName = collectionName
        self.createTime = createTime
    }
}

struct CreateGeofenceCollectionOutputBody: Swift.Equatable {
    let collectionName: Swift.String?
    let collectionArn: Swift.String?
    let createTime: ClientRuntime.Date?
}

extension CreateGeofenceCollectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionArn = "CollectionArn"
        case collectionName = "CollectionName"
        case createTime = "CreateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let collectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionArn)
        collectionArn = collectionArnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

enum CreateGeofenceCollectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case expireTime = "ExpireTime"
        case keyName = "KeyName"
        case noExpiry = "NoExpiry"
        case restrictions = "Restrictions"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expireTime = self.expireTime {
            try encodeContainer.encodeTimestamp(expireTime, format: .dateTime, forKey: .expireTime)
        }
        if let keyName = self.keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let noExpiry = self.noExpiry {
            try encodeContainer.encode(noExpiry, forKey: .noExpiry)
        }
        if let restrictions = self.restrictions {
            try encodeContainer.encode(restrictions, forKey: .restrictions)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateKeyInput {

    static func urlPathProvider(_ value: CreateKeyInput) -> Swift.String? {
        return "/metadata/v0/keys"
    }
}

public struct CreateKeyInput: Swift.Equatable {
    /// An optional description for the API key resource.
    public var description: Swift.String?
    /// The optional timestamp for when the API key resource will expire in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ. One of NoExpiry or ExpireTime must be set.
    public var expireTime: ClientRuntime.Date?
    /// A custom name for the API key resource. Requirements:
    ///
    /// * Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique API key name.
    ///
    /// * No spaces allowed. For example, ExampleAPIKey.
    /// This member is required.
    public var keyName: Swift.String?
    /// Optionally set to true to set no expiration time for the API key. One of NoExpiry or ExpireTime must be set.
    public var noExpiry: Swift.Bool?
    /// The API key restrictions for the API key resource.
    /// This member is required.
    public var restrictions: LocationClientTypes.ApiKeyRestrictions?
    /// Applies one or more tags to the map resource. A tag is a key-value pair that helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource
    ///
    /// * Each resource tag must be unique with a maximum of one value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        expireTime: ClientRuntime.Date? = nil,
        keyName: Swift.String? = nil,
        noExpiry: Swift.Bool? = nil,
        restrictions: LocationClientTypes.ApiKeyRestrictions? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.expireTime = expireTime
        self.keyName = keyName
        self.noExpiry = noExpiry
        self.restrictions = restrictions
        self.tags = tags
    }
}

struct CreateKeyInputBody: Swift.Equatable {
    let keyName: Swift.String?
    let restrictions: LocationClientTypes.ApiKeyRestrictions?
    let description: Swift.String?
    let expireTime: ClientRuntime.Date?
    let noExpiry: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension CreateKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case expireTime = "ExpireTime"
        case keyName = "KeyName"
        case noExpiry = "NoExpiry"
        case restrictions = "Restrictions"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.ApiKeyRestrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expireTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expireTime)
        expireTime = expireTimeDecoded
        let noExpiryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .noExpiry)
        noExpiry = noExpiryDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateKeyOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateKeyOutput(createTime: \(Swift.String(describing: createTime)), keyArn: \(Swift.String(describing: keyArn)), keyName: \(Swift.String(describing: keyName)), key: \"CONTENT_REDACTED\")"}
}

extension CreateKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.key = output.key
            self.keyArn = output.keyArn
            self.keyName = output.keyName
        } else {
            self.createTime = nil
            self.key = nil
            self.keyArn = nil
            self.keyName = nil
        }
    }
}

public struct CreateKeyOutput: Swift.Equatable {
    /// The timestamp for when the API key resource was created in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The key value/string of an API key. This value is used when making API calls to authorize the call. For example, see [GetMapGlyphs](https://docs.aws.amazon.com/location/latest/APIReference/API_GetMapGlyphs.html).
    /// This member is required.
    public var key: Swift.String?
    /// The Amazon Resource Name (ARN) for the API key resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:key/ExampleKey
    /// This member is required.
    public var keyArn: Swift.String?
    /// The name of the API key resource.
    /// This member is required.
    public var keyName: Swift.String?

    public init(
        createTime: ClientRuntime.Date? = nil,
        key: Swift.String? = nil,
        keyArn: Swift.String? = nil,
        keyName: Swift.String? = nil
    )
    {
        self.createTime = createTime
        self.key = key
        self.keyArn = keyArn
        self.keyName = keyName
    }
}

struct CreateKeyOutputBody: Swift.Equatable {
    let key: Swift.String?
    let keyArn: Swift.String?
    let keyName: Swift.String?
    let createTime: ClientRuntime.Date?
}

extension CreateKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case key = "Key"
        case keyArn = "KeyArn"
        case keyName = "KeyName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

enum CreateKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMapInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case mapName = "MapName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mapName = self.mapName {
            try encodeContainer.encode(mapName, forKey: .mapName)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateMapInput {

    static func urlPathProvider(_ value: CreateMapInput) -> Swift.String? {
        return "/maps/v0/maps"
    }
}

public struct CreateMapInput: Swift.Equatable {
    /// Specifies the MapConfiguration, including the map style, for the map resource that you create. The map style defines the look of maps and the data provider for your map resource.
    /// This member is required.
    public var configuration: LocationClientTypes.MapConfiguration?
    /// An optional description for the map resource.
    public var description: Swift.String?
    /// The name for the map resource. Requirements:
    ///
    /// * Must contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique map resource name.
    ///
    /// * No spaces allowed. For example, ExampleMap.
    /// This member is required.
    public var mapName: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Applies one or more tags to the map resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource
    ///
    /// * Each resource tag must be unique with a maximum of one value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?

    public init(
        configuration: LocationClientTypes.MapConfiguration? = nil,
        description: Swift.String? = nil,
        mapName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.configuration = configuration
        self.description = description
        self.mapName = mapName
        self.pricingPlan = pricingPlan
        self.tags = tags
    }
}

struct CreateMapInputBody: Swift.Equatable {
    let mapName: Swift.String?
    let configuration: LocationClientTypes.MapConfiguration?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateMapInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case mapName = "MapName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapName)
        mapName = mapNameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(LocationClientTypes.MapConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMapOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMapOutputBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.mapArn = output.mapArn
            self.mapName = output.mapName
        } else {
            self.createTime = nil
            self.mapArn = nil
            self.mapName = nil
        }
    }
}

public struct CreateMapOutput: Swift.Equatable {
    /// The timestamp for when the map resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the map resource. Used to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:map/ExampleMap
    /// This member is required.
    public var mapArn: Swift.String?
    /// The name of the map resource.
    /// This member is required.
    public var mapName: Swift.String?

    public init(
        createTime: ClientRuntime.Date? = nil,
        mapArn: Swift.String? = nil,
        mapName: Swift.String? = nil
    )
    {
        self.createTime = createTime
        self.mapArn = mapArn
        self.mapName = mapName
    }
}

struct CreateMapOutputBody: Swift.Equatable {
    let mapName: Swift.String?
    let mapArn: Swift.String?
    let createTime: ClientRuntime.Date?
}

extension CreateMapOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case mapArn = "MapArn"
        case mapName = "MapName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapName)
        mapName = mapNameDecoded
        let mapArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapArn)
        mapArn = mapArnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

enum CreateMapOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePlaceIndexInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case dataSourceConfiguration = "DataSourceConfiguration"
        case description = "Description"
        case indexName = "IndexName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let dataSourceConfiguration = self.dataSourceConfiguration {
            try encodeContainer.encode(dataSourceConfiguration, forKey: .dataSourceConfiguration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePlaceIndexInput {

    static func urlPathProvider(_ value: CreatePlaceIndexInput) -> Swift.String? {
        return "/places/v0/indexes"
    }
}

public struct CreatePlaceIndexInput: Swift.Equatable {
    /// Specifies the geospatial data provider for the new place index. This field is case-sensitive. Enter the valid values as shown. For example, entering HERE returns an error. Valid values include:
    ///
    /// * Esri – For additional information about [Esri](https://docs.aws.amazon.com/location/latest/developerguide/esri.html)'s coverage in your region of interest, see [Esri details on geocoding coverage](https://developers.arcgis.com/rest/geocode/api-reference/geocode-coverage.htm).
    ///
    /// * Grab – Grab provides place index functionality for Southeast Asia. For additional information about [GrabMaps](https://docs.aws.amazon.com/location/latest/developerguide/grab.html)' coverage, see [GrabMaps countries and areas covered](https://docs.aws.amazon.com/location/latest/developerguide/grab.html#grab-coverage-area).
    ///
    /// * Here – For additional information about [HERE Technologies](https://docs.aws.amazon.com/location/latest/developerguide/HERE.html)' coverage in your region of interest, see [HERE details on goecoding coverage](https://developer.here.com/documentation/geocoder/dev_guide/topics/coverage-geocoder.html). If you specify HERE Technologies (Here) as the data provider, you may not [store results](https://docs.aws.amazon.com/location-places/latest/APIReference/API_DataSourceConfiguration.html) for locations in Japan. For more information, see the [Amazon Web Services Service Terms](http://aws.amazon.com/service-terms/) for Amazon Location Service.
    ///
    ///
    /// For additional information , see [Data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html) on the Amazon Location Service Developer Guide.
    /// This member is required.
    public var dataSource: Swift.String?
    /// Specifies the data storage option requesting Places.
    public var dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    /// The optional description for the place index resource.
    public var description: Swift.String?
    /// The name of the place index resource. Requirements:
    ///
    /// * Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique place index resource name.
    ///
    /// * No spaces allowed. For example, ExamplePlaceIndex.
    /// This member is required.
    public var indexName: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Applies one or more tags to the place index resource. A tag is a key-value pair that helps you manage, identify, search, and filter your resources. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource.
    ///
    /// * Each tag key must be unique and must have exactly one associated value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?

    public init(
        dataSource: Swift.String? = nil,
        dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        indexName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dataSource = dataSource
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.indexName = indexName
        self.pricingPlan = pricingPlan
        self.tags = tags
    }
}

struct CreatePlaceIndexInputBody: Swift.Equatable {
    let indexName: Swift.String?
    let dataSource: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
    let dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    let tags: [Swift.String:Swift.String]?
}

extension CreatePlaceIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case dataSourceConfiguration = "DataSourceConfiguration"
        case description = "Description"
        case indexName = "IndexName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePlaceIndexOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePlaceIndexOutputBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.indexArn = output.indexArn
            self.indexName = output.indexName
        } else {
            self.createTime = nil
            self.indexArn = nil
            self.indexName = nil
        }
    }
}

public struct CreatePlaceIndexOutput: Swift.Equatable {
    /// The timestamp for when the place index resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the place index resource. Used to specify a resource across Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:place-index/ExamplePlaceIndex
    /// This member is required.
    public var indexArn: Swift.String?
    /// The name for the place index resource.
    /// This member is required.
    public var indexName: Swift.String?

    public init(
        createTime: ClientRuntime.Date? = nil,
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil
    )
    {
        self.createTime = createTime
        self.indexArn = indexArn
        self.indexName = indexName
    }
}

struct CreatePlaceIndexOutputBody: Swift.Equatable {
    let indexName: Swift.String?
    let indexArn: Swift.String?
    let createTime: ClientRuntime.Date?
}

extension CreatePlaceIndexOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case indexArn = "IndexArn"
        case indexName = "IndexName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let indexArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexArn)
        indexArn = indexArnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

enum CreatePlaceIndexOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRouteCalculatorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorName = "CalculatorName"
        case dataSource = "DataSource"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculatorName = self.calculatorName {
            try encodeContainer.encode(calculatorName, forKey: .calculatorName)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRouteCalculatorInput {

    static func urlPathProvider(_ value: CreateRouteCalculatorInput) -> Swift.String? {
        return "/routes/v0/calculators"
    }
}

public struct CreateRouteCalculatorInput: Swift.Equatable {
    /// The name of the route calculator resource. Requirements:
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9) , hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique Route calculator resource name.
    ///
    /// * No spaces allowed. For example, ExampleRouteCalculator.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// Specifies the data provider of traffic and road network data. This field is case-sensitive. Enter the valid values as shown. For example, entering HERE returns an error. Valid values include:
    ///
    /// * Esri – For additional information about [Esri](https://docs.aws.amazon.com/location/latest/developerguide/esri.html)'s coverage in your region of interest, see [Esri details on street networks and traffic coverage](https://doc.arcgis.com/en/arcgis-online/reference/network-coverage.htm). Route calculators that use Esri as a data source only calculate routes that are shorter than 400 km.
    ///
    /// * Grab – Grab provides routing functionality for Southeast Asia. For additional information about [GrabMaps](https://docs.aws.amazon.com/location/latest/developerguide/grab.html)' coverage, see [GrabMaps countries and areas covered](https://docs.aws.amazon.com/location/latest/developerguide/grab.html#grab-coverage-area).
    ///
    /// * Here – For additional information about [HERE Technologies](https://docs.aws.amazon.com/location/latest/developerguide/HERE.html)' coverage in your region of interest, see [HERE car routing coverage](https://developer.here.com/documentation/routing-api/dev_guide/topics/coverage/car-routing.html) and [HERE truck routing coverage](https://developer.here.com/documentation/routing-api/dev_guide/topics/coverage/truck-routing.html).
    ///
    ///
    /// For additional information , see [Data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html) on the Amazon Location Service Developer Guide.
    /// This member is required.
    public var dataSource: Swift.String?
    /// The optional description for the route calculator resource.
    public var description: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Applies one or more tags to the route calculator resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them.
    ///
    /// * For example: { "tag1" : "value1", "tag2" : "value2"}
    ///
    ///
    /// Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource
    ///
    /// * Each resource tag must be unique with a maximum of one value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?

    public init(
        calculatorName: Swift.String? = nil,
        dataSource: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.calculatorName = calculatorName
        self.dataSource = dataSource
        self.description = description
        self.pricingPlan = pricingPlan
        self.tags = tags
    }
}

struct CreateRouteCalculatorInputBody: Swift.Equatable {
    let calculatorName: Swift.String?
    let dataSource: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRouteCalculatorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorName = "CalculatorName"
        case dataSource = "DataSource"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorName)
        calculatorName = calculatorNameDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRouteCalculatorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRouteCalculatorOutputBody = try responseDecoder.decode(responseBody: data)
            self.calculatorArn = output.calculatorArn
            self.calculatorName = output.calculatorName
            self.createTime = output.createTime
        } else {
            self.calculatorArn = nil
            self.calculatorName = nil
            self.createTime = nil
        }
    }
}

public struct CreateRouteCalculatorOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the route calculator resource. Use the ARN when you specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:route-calculator/ExampleCalculator
    /// This member is required.
    public var calculatorArn: Swift.String?
    /// The name of the route calculator resource.
    ///
    /// * For example, ExampleRouteCalculator.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// The timestamp when the route calculator resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    ///
    /// * For example, 2020–07-2T12:15:20.000Z+01:00
    /// This member is required.
    public var createTime: ClientRuntime.Date?

    public init(
        calculatorArn: Swift.String? = nil,
        calculatorName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil
    )
    {
        self.calculatorArn = calculatorArn
        self.calculatorName = calculatorName
        self.createTime = createTime
    }
}

struct CreateRouteCalculatorOutputBody: Swift.Equatable {
    let calculatorName: Swift.String?
    let calculatorArn: Swift.String?
    let createTime: ClientRuntime.Date?
}

extension CreateRouteCalculatorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorArn = "CalculatorArn"
        case calculatorName = "CalculatorName"
        case createTime = "CreateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorName)
        calculatorName = calculatorNameDecoded
        let calculatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorArn)
        calculatorArn = calculatorArnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

enum CreateRouteCalculatorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTrackerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventBridgeEnabled = "EventBridgeEnabled"
        case kmsKeyEnableGeospatialQueries = "KmsKeyEnableGeospatialQueries"
        case kmsKeyId = "KmsKeyId"
        case positionFiltering = "PositionFiltering"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
        case trackerName = "TrackerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventBridgeEnabled = self.eventBridgeEnabled {
            try encodeContainer.encode(eventBridgeEnabled, forKey: .eventBridgeEnabled)
        }
        if let kmsKeyEnableGeospatialQueries = self.kmsKeyEnableGeospatialQueries {
            try encodeContainer.encode(kmsKeyEnableGeospatialQueries, forKey: .kmsKeyEnableGeospatialQueries)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let positionFiltering = self.positionFiltering {
            try encodeContainer.encode(positionFiltering.rawValue, forKey: .positionFiltering)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = self.pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let trackerName = self.trackerName {
            try encodeContainer.encode(trackerName, forKey: .trackerName)
        }
    }
}

extension CreateTrackerInput {

    static func urlPathProvider(_ value: CreateTrackerInput) -> Swift.String? {
        return "/tracking/v0/trackers"
    }
}

public struct CreateTrackerInput: Swift.Equatable {
    /// An optional description for the tracker resource.
    public var description: Swift.String?
    /// Whether to enable position UPDATE events from this tracker to be sent to EventBridge. You do not need enable this feature to get ENTER and EXIT events for geofences with this tracker. Those events are always sent to EventBridge.
    public var eventBridgeEnabled: Swift.Bool?
    /// Enables GeospatialQueries for a tracker that uses a [Amazon Web Services KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html). This parameter is only used if you are using a KMS customer managed key. If you wish to encrypt your data using your own KMS customer managed key, then the Bounding Polygon Queries feature will be disabled by default. This is because by using this feature, a representation of your device positions will not be encrypted using the your KMS managed key. The exact device position, however; is still encrypted using your managed key. You can choose to opt-in to the Bounding Polygon Quseries feature. This is done by setting the KmsKeyEnableGeospatialQueries parameter to true when creating or updating a Tracker.
    public var kmsKeyEnableGeospatialQueries: Swift.Bool?
    /// A key identifier for an [Amazon Web Services KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html). Enter a key ID, key ARN, alias name, or alias ARN.
    public var kmsKeyId: Swift.String?
    /// Specifies the position filtering for the tracker resource. Valid values:
    ///
    /// * TimeBased - Location updates are evaluated against linked geofence collections, but not every location update is stored. If your update frequency is more often than 30 seconds, only one update per 30 seconds is stored for each unique device ID.
    ///
    /// * DistanceBased - If the device has moved less than 30 m (98.4 ft), location updates are ignored. Location updates within this area are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map.
    ///
    /// * AccuracyBased - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This can reduce the effects of GPS noise when displaying device trajectories on a map, and can help control your costs by reducing the number of geofence evaluations.
    ///
    ///
    /// This field is optional. If not specified, the default value is TimeBased.
    public var positionFiltering: LocationClientTypes.PositionFiltering?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// This parameter is no longer used.
    @available(*, deprecated, message: "Deprecated. No longer allowed. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?
    /// Applies one or more tags to the tracker resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource
    ///
    /// * Each resource tag must be unique with a maximum of one value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    public var tags: [Swift.String:Swift.String]?
    /// The name for the tracker resource. Requirements:
    ///
    /// * Contain only alphanumeric characters (A-Z, a-z, 0-9) , hyphens (-), periods (.), and underscores (_).
    ///
    /// * Must be a unique tracker resource name.
    ///
    /// * No spaces allowed. For example, ExampleTracker.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        description: Swift.String? = nil,
        eventBridgeEnabled: Swift.Bool? = nil,
        kmsKeyEnableGeospatialQueries: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        positionFiltering: LocationClientTypes.PositionFiltering? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.description = description
        self.eventBridgeEnabled = eventBridgeEnabled
        self.kmsKeyEnableGeospatialQueries = kmsKeyEnableGeospatialQueries
        self.kmsKeyId = kmsKeyId
        self.positionFiltering = positionFiltering
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
        self.trackerName = trackerName
    }
}

struct CreateTrackerInputBody: Swift.Equatable {
    let trackerName: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let kmsKeyId: Swift.String?
    let pricingPlanDataSource: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let positionFiltering: LocationClientTypes.PositionFiltering?
    let eventBridgeEnabled: Swift.Bool?
    let kmsKeyEnableGeospatialQueries: Swift.Bool?
}

extension CreateTrackerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventBridgeEnabled = "EventBridgeEnabled"
        case kmsKeyEnableGeospatialQueries = "KmsKeyEnableGeospatialQueries"
        case kmsKeyId = "KmsKeyId"
        case positionFiltering = "PositionFiltering"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
        case trackerName = "TrackerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let positionFilteringDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PositionFiltering.self, forKey: .positionFiltering)
        positionFiltering = positionFilteringDecoded
        let eventBridgeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .eventBridgeEnabled)
        eventBridgeEnabled = eventBridgeEnabledDecoded
        let kmsKeyEnableGeospatialQueriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kmsKeyEnableGeospatialQueries)
        kmsKeyEnableGeospatialQueries = kmsKeyEnableGeospatialQueriesDecoded
    }
}

extension CreateTrackerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTrackerOutputBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.trackerArn = output.trackerArn
            self.trackerName = output.trackerName
        } else {
            self.createTime = nil
            self.trackerArn = nil
            self.trackerName = nil
        }
    }
}

public struct CreateTrackerOutput: Swift.Equatable {
    /// The timestamp for when the tracker resource was created in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
    /// This member is required.
    public var trackerArn: Swift.String?
    /// The name of the tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        createTime: ClientRuntime.Date? = nil,
        trackerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.createTime = createTime
        self.trackerArn = trackerArn
        self.trackerName = trackerName
    }
}

struct CreateTrackerOutputBody: Swift.Equatable {
    let trackerName: Swift.String?
    let trackerArn: Swift.String?
    let createTime: ClientRuntime.Date?
}

extension CreateTrackerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case trackerArn = "TrackerArn"
        case trackerName = "TrackerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let trackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerArn)
        trackerArn = trackerArnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

enum CreateTrackerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.DataSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intendedUse = "IntendedUse"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intendedUse = self.intendedUse {
            try encodeContainer.encode(intendedUse.rawValue, forKey: .intendedUse)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intendedUseDecoded = try containerValues.decodeIfPresent(LocationClientTypes.IntendedUse.self, forKey: .intendedUse)
        intendedUse = intendedUseDecoded
    }
}

extension LocationClientTypes {
    /// Specifies the data storage option chosen for requesting Places. When using Amazon Location Places:
    ///
    /// * If using HERE Technologies as a data provider, you can't store results for locations in Japan by setting IntendedUse to Storage. parameter.
    ///
    /// * Under the MobileAssetTracking or MobilAssetManagement pricing plan, you can't store results from your place index resources by setting IntendedUse to Storage. This returns a validation exception error.
    ///
    ///
    /// For more information, see the [AWS Service Terms](https://aws.amazon.com/service-terms/) for Amazon Location Service.
    public struct DataSourceConfiguration: Swift.Equatable {
        /// Specifies how the results of an operation will be stored by the caller. Valid values include:
        ///
        /// * SingleUse specifies that the results won't be stored.
        ///
        /// * Storage specifies that the result can be cached or stored in a database.
        ///
        ///
        /// Default value: SingleUse
        public var intendedUse: LocationClientTypes.IntendedUse?

        public init(
            intendedUse: LocationClientTypes.IntendedUse? = nil
        )
        {
            self.intendedUse = intendedUse
        }
    }

}

extension DeleteGeofenceCollectionInput {

    static func urlPathProvider(_ value: DeleteGeofenceCollectionInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())"
    }
}

public struct DeleteGeofenceCollectionInput: Swift.Equatable {
    /// The name of the geofence collection to be deleted.
    /// This member is required.
    public var collectionName: Swift.String?

    public init(
        collectionName: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
    }
}

struct DeleteGeofenceCollectionInputBody: Swift.Equatable {
}

extension DeleteGeofenceCollectionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGeofenceCollectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGeofenceCollectionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGeofenceCollectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteKeyInput {

    static func queryItemProvider(_ value: DeleteKeyInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let forceDelete = value.forceDelete {
            let forceDeleteQueryItem = ClientRuntime.SDKURLQueryItem(name: "forceDelete".urlPercentEncoding(), value: Swift.String(forceDelete).urlPercentEncoding())
            items.append(forceDeleteQueryItem)
        }
        return items
    }
}

extension DeleteKeyInput {

    static func urlPathProvider(_ value: DeleteKeyInput) -> Swift.String? {
        guard let keyName = value.keyName else {
            return nil
        }
        return "/metadata/v0/keys/\(keyName.urlPercentEncoding())"
    }
}

public struct DeleteKeyInput: Swift.Equatable {
    /// ForceDelete bypasses an API key's expiry conditions and deletes the key. Set the parameter true to delete the key or to false to not preemptively delete the API key. Valid values: true, or false. Required: No This action is irreversible. Only use ForceDelete if you are certain the key is no longer in use.
    public var forceDelete: Swift.Bool?
    /// The name of the API key to delete.
    /// This member is required.
    public var keyName: Swift.String?

    public init(
        forceDelete: Swift.Bool? = nil,
        keyName: Swift.String? = nil
    )
    {
        self.forceDelete = forceDelete
        self.keyName = keyName
    }
}

struct DeleteKeyInputBody: Swift.Equatable {
}

extension DeleteKeyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteKeyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMapInput {

    static func urlPathProvider(_ value: DeleteMapInput) -> Swift.String? {
        guard let mapName = value.mapName else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())"
    }
}

public struct DeleteMapInput: Swift.Equatable {
    /// The name of the map resource to be deleted.
    /// This member is required.
    public var mapName: Swift.String?

    public init(
        mapName: Swift.String? = nil
    )
    {
        self.mapName = mapName
    }
}

struct DeleteMapInputBody: Swift.Equatable {
}

extension DeleteMapInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMapOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMapOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMapOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePlaceIndexInput {

    static func urlPathProvider(_ value: DeletePlaceIndexInput) -> Swift.String? {
        guard let indexName = value.indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())"
    }
}

public struct DeletePlaceIndexInput: Swift.Equatable {
    /// The name of the place index resource to be deleted.
    /// This member is required.
    public var indexName: Swift.String?

    public init(
        indexName: Swift.String? = nil
    )
    {
        self.indexName = indexName
    }
}

struct DeletePlaceIndexInputBody: Swift.Equatable {
}

extension DeletePlaceIndexInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePlaceIndexOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePlaceIndexOutput: Swift.Equatable {

    public init() { }
}

enum DeletePlaceIndexOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRouteCalculatorInput {

    static func urlPathProvider(_ value: DeleteRouteCalculatorInput) -> Swift.String? {
        guard let calculatorName = value.calculatorName else {
            return nil
        }
        return "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())"
    }
}

public struct DeleteRouteCalculatorInput: Swift.Equatable {
    /// The name of the route calculator resource to be deleted.
    /// This member is required.
    public var calculatorName: Swift.String?

    public init(
        calculatorName: Swift.String? = nil
    )
    {
        self.calculatorName = calculatorName
    }
}

struct DeleteRouteCalculatorInputBody: Swift.Equatable {
}

extension DeleteRouteCalculatorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRouteCalculatorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRouteCalculatorOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRouteCalculatorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTrackerInput {

    static func urlPathProvider(_ value: DeleteTrackerInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())"
    }
}

public struct DeleteTrackerInput: Swift.Equatable {
    /// The name of the tracker resource to be deleted.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        trackerName: Swift.String? = nil
    )
    {
        self.trackerName = trackerName
    }
}

struct DeleteTrackerInputBody: Swift.Equatable {
}

extension DeleteTrackerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTrackerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTrackerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTrackerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeGeofenceCollectionInput {

    static func urlPathProvider(_ value: DescribeGeofenceCollectionInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())"
    }
}

public struct DescribeGeofenceCollectionInput: Swift.Equatable {
    /// The name of the geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?

    public init(
        collectionName: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
    }
}

struct DescribeGeofenceCollectionInputBody: Swift.Equatable {
}

extension DescribeGeofenceCollectionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGeofenceCollectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeGeofenceCollectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.collectionArn = output.collectionArn
            self.collectionName = output.collectionName
            self.createTime = output.createTime
            self.description = output.description
            self.geofenceCount = output.geofenceCount
            self.kmsKeyId = output.kmsKeyId
            self.pricingPlan = output.pricingPlan
            self.pricingPlanDataSource = output.pricingPlanDataSource
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.collectionArn = nil
            self.collectionName = nil
            self.createTime = nil
            self.description = nil
            self.geofenceCount = nil
            self.kmsKeyId = nil
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct DescribeGeofenceCollectionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
    /// This member is required.
    public var collectionArn: Swift.String?
    /// The name of the geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The timestamp for when the geofence resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The optional description for the geofence collection.
    /// This member is required.
    public var description: Swift.String?
    /// The number of geofences in the geofence collection.
    public var geofenceCount: Swift.Int?
    /// A key identifier for an [Amazon Web Services KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html) assigned to the Amazon Location resource
    public var kmsKeyId: Swift.String?
    /// No longer used. Always returns RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// No longer used. Always returns an empty string.
    @available(*, deprecated, message: "Deprecated. Unused. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?
    /// Displays the key, value pairs of tags associated with this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp for when the geofence collection was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        collectionArn: Swift.String? = nil,
        collectionName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        geofenceCount: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.collectionArn = collectionArn
        self.collectionName = collectionName
        self.createTime = createTime
        self.description = description
        self.geofenceCount = geofenceCount
        self.kmsKeyId = kmsKeyId
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct DescribeGeofenceCollectionOutputBody: Swift.Equatable {
    let collectionName: Swift.String?
    let collectionArn: Swift.String?
    let description: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let pricingPlanDataSource: Swift.String?
    let kmsKeyId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let geofenceCount: Swift.Int?
}

extension DescribeGeofenceCollectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionArn = "CollectionArn"
        case collectionName = "CollectionName"
        case createTime = "CreateTime"
        case description = "Description"
        case geofenceCount = "GeofenceCount"
        case kmsKeyId = "KmsKeyId"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
        case updateTime = "UpdateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let collectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionArn)
        collectionArn = collectionArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let geofenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .geofenceCount)
        geofenceCount = geofenceCountDecoded
    }
}

enum DescribeGeofenceCollectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeKeyInput {

    static func urlPathProvider(_ value: DescribeKeyInput) -> Swift.String? {
        guard let keyName = value.keyName else {
            return nil
        }
        return "/metadata/v0/keys/\(keyName.urlPercentEncoding())"
    }
}

public struct DescribeKeyInput: Swift.Equatable {
    /// The name of the API key resource.
    /// This member is required.
    public var keyName: Swift.String?

    public init(
        keyName: Swift.String? = nil
    )
    {
        self.keyName = keyName
    }
}

struct DescribeKeyInputBody: Swift.Equatable {
}

extension DescribeKeyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeKeyOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeKeyOutput(createTime: \(Swift.String(describing: createTime)), description: \(Swift.String(describing: description)), expireTime: \(Swift.String(describing: expireTime)), keyArn: \(Swift.String(describing: keyArn)), keyName: \(Swift.String(describing: keyName)), restrictions: \(Swift.String(describing: restrictions)), tags: \(Swift.String(describing: tags)), updateTime: \(Swift.String(describing: updateTime)), key: \"CONTENT_REDACTED\")"}
}

extension DescribeKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.description = output.description
            self.expireTime = output.expireTime
            self.key = output.key
            self.keyArn = output.keyArn
            self.keyName = output.keyName
            self.restrictions = output.restrictions
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.createTime = nil
            self.description = nil
            self.expireTime = nil
            self.key = nil
            self.keyArn = nil
            self.keyName = nil
            self.restrictions = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct DescribeKeyOutput: Swift.Equatable {
    /// The timestamp for when the API key resource was created in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The optional description for the API key resource.
    public var description: Swift.String?
    /// The timestamp for when the API key resource will expire in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var expireTime: ClientRuntime.Date?
    /// The key value/string of an API key.
    /// This member is required.
    public var key: Swift.String?
    /// The Amazon Resource Name (ARN) for the API key resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:key/ExampleKey
    /// This member is required.
    public var keyArn: Swift.String?
    /// The name of the API key resource.
    /// This member is required.
    public var keyName: Swift.String?
    /// API Restrictions on the allowed actions, resources, and referers for an API key resource.
    /// This member is required.
    public var restrictions: LocationClientTypes.ApiKeyRestrictions?
    /// Tags associated with the API key resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp for when the API key resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        createTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        expireTime: ClientRuntime.Date? = nil,
        key: Swift.String? = nil,
        keyArn: Swift.String? = nil,
        keyName: Swift.String? = nil,
        restrictions: LocationClientTypes.ApiKeyRestrictions? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.description = description
        self.expireTime = expireTime
        self.key = key
        self.keyArn = keyArn
        self.keyName = keyName
        self.restrictions = restrictions
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct DescribeKeyOutputBody: Swift.Equatable {
    let key: Swift.String?
    let keyArn: Swift.String?
    let keyName: Swift.String?
    let restrictions: LocationClientTypes.ApiKeyRestrictions?
    let createTime: ClientRuntime.Date?
    let expireTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case description = "Description"
        case expireTime = "ExpireTime"
        case key = "Key"
        case keyArn = "KeyArn"
        case keyName = "KeyName"
        case restrictions = "Restrictions"
        case tags = "Tags"
        case updateTime = "UpdateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.ApiKeyRestrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let expireTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expireTime)
        expireTime = expireTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMapInput {

    static func urlPathProvider(_ value: DescribeMapInput) -> Swift.String? {
        guard let mapName = value.mapName else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())"
    }
}

public struct DescribeMapInput: Swift.Equatable {
    /// The name of the map resource.
    /// This member is required.
    public var mapName: Swift.String?

    public init(
        mapName: Swift.String? = nil
    )
    {
        self.mapName = mapName
    }
}

struct DescribeMapInputBody: Swift.Equatable {
}

extension DescribeMapInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeMapOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMapOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuration = output.configuration
            self.createTime = output.createTime
            self.dataSource = output.dataSource
            self.description = output.description
            self.mapArn = output.mapArn
            self.mapName = output.mapName
            self.pricingPlan = output.pricingPlan
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.configuration = nil
            self.createTime = nil
            self.dataSource = nil
            self.description = nil
            self.mapArn = nil
            self.mapName = nil
            self.pricingPlan = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct DescribeMapOutput: Swift.Equatable {
    /// Specifies the map tile style selected from a partner data provider.
    /// This member is required.
    public var configuration: LocationClientTypes.MapConfiguration?
    /// The timestamp for when the map resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// Specifies the data provider for the associated map tiles.
    /// This member is required.
    public var dataSource: Swift.String?
    /// The optional description for the map resource.
    /// This member is required.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) for the map resource. Used to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:map/ExampleMap
    /// This member is required.
    public var mapArn: Swift.String?
    /// The map style selected from an available provider.
    /// This member is required.
    public var mapName: Swift.String?
    /// No longer used. Always returns RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Tags associated with the map resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp for when the map resource was last update in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        configuration: LocationClientTypes.MapConfiguration? = nil,
        createTime: ClientRuntime.Date? = nil,
        dataSource: Swift.String? = nil,
        description: Swift.String? = nil,
        mapArn: Swift.String? = nil,
        mapName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.configuration = configuration
        self.createTime = createTime
        self.dataSource = dataSource
        self.description = description
        self.mapArn = mapArn
        self.mapName = mapName
        self.pricingPlan = pricingPlan
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct DescribeMapOutputBody: Swift.Equatable {
    let mapName: Swift.String?
    let mapArn: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let dataSource: Swift.String?
    let configuration: LocationClientTypes.MapConfiguration?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
}

extension DescribeMapOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case description = "Description"
        case mapArn = "MapArn"
        case mapName = "MapName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
        case updateTime = "UpdateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapName)
        mapName = mapNameDecoded
        let mapArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapArn)
        mapArn = mapArnDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(LocationClientTypes.MapConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

enum DescribeMapOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePlaceIndexInput {

    static func urlPathProvider(_ value: DescribePlaceIndexInput) -> Swift.String? {
        guard let indexName = value.indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())"
    }
}

public struct DescribePlaceIndexInput: Swift.Equatable {
    /// The name of the place index resource.
    /// This member is required.
    public var indexName: Swift.String?

    public init(
        indexName: Swift.String? = nil
    )
    {
        self.indexName = indexName
    }
}

struct DescribePlaceIndexInputBody: Swift.Equatable {
}

extension DescribePlaceIndexInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribePlaceIndexOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePlaceIndexOutputBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.dataSource = output.dataSource
            self.dataSourceConfiguration = output.dataSourceConfiguration
            self.description = output.description
            self.indexArn = output.indexArn
            self.indexName = output.indexName
            self.pricingPlan = output.pricingPlan
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.createTime = nil
            self.dataSource = nil
            self.dataSourceConfiguration = nil
            self.description = nil
            self.indexArn = nil
            self.indexName = nil
            self.pricingPlan = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct DescribePlaceIndexOutput: Swift.Equatable {
    /// The timestamp for when the place index resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The data provider of geospatial data. Values can be one of the following:
    ///
    /// * Esri
    ///
    /// * Grab
    ///
    /// * Here
    ///
    ///
    /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
    /// This member is required.
    public var dataSource: Swift.String?
    /// The specified data storage option for requesting Places.
    /// This member is required.
    public var dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    /// The optional description for the place index resource.
    /// This member is required.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) for the place index resource. Used to specify a resource across Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:place-index/ExamplePlaceIndex
    /// This member is required.
    public var indexArn: Swift.String?
    /// The name of the place index resource being described.
    /// This member is required.
    public var indexName: Swift.String?
    /// No longer used. Always returns RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Tags associated with place index resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp for when the place index resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        createTime: ClientRuntime.Date? = nil,
        dataSource: Swift.String? = nil,
        dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.dataSource = dataSource
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.indexArn = indexArn
        self.indexName = indexName
        self.pricingPlan = pricingPlan
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct DescribePlaceIndexOutputBody: Swift.Equatable {
    let indexName: Swift.String?
    let indexArn: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let dataSource: Swift.String?
    let dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    let tags: [Swift.String:Swift.String]?
}

extension DescribePlaceIndexOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case dataSourceConfiguration = "DataSourceConfiguration"
        case description = "Description"
        case indexArn = "IndexArn"
        case indexName = "IndexName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
        case updateTime = "UpdateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let indexArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexArn)
        indexArn = indexArnDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribePlaceIndexOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRouteCalculatorInput {

    static func urlPathProvider(_ value: DescribeRouteCalculatorInput) -> Swift.String? {
        guard let calculatorName = value.calculatorName else {
            return nil
        }
        return "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())"
    }
}

public struct DescribeRouteCalculatorInput: Swift.Equatable {
    /// The name of the route calculator resource.
    /// This member is required.
    public var calculatorName: Swift.String?

    public init(
        calculatorName: Swift.String? = nil
    )
    {
        self.calculatorName = calculatorName
    }
}

struct DescribeRouteCalculatorInputBody: Swift.Equatable {
}

extension DescribeRouteCalculatorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRouteCalculatorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRouteCalculatorOutputBody = try responseDecoder.decode(responseBody: data)
            self.calculatorArn = output.calculatorArn
            self.calculatorName = output.calculatorName
            self.createTime = output.createTime
            self.dataSource = output.dataSource
            self.description = output.description
            self.pricingPlan = output.pricingPlan
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.calculatorArn = nil
            self.calculatorName = nil
            self.createTime = nil
            self.dataSource = nil
            self.description = nil
            self.pricingPlan = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct DescribeRouteCalculatorOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the Route calculator resource. Use the ARN when you specify a resource across Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:route-calculator/ExampleCalculator
    /// This member is required.
    public var calculatorArn: Swift.String?
    /// The name of the route calculator resource being described.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// The timestamp when the route calculator resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    ///
    /// * For example, 2020–07-2T12:15:20.000Z+01:00
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The data provider of traffic and road network data. Indicates one of the available providers:
    ///
    /// * Esri
    ///
    /// * Grab
    ///
    /// * Here
    ///
    ///
    /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
    /// This member is required.
    public var dataSource: Swift.String?
    /// The optional description of the route calculator resource.
    /// This member is required.
    public var description: Swift.String?
    /// Always returns RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Tags associated with route calculator resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp when the route calculator resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    ///
    /// * For example, 2020–07-2T12:15:20.000Z+01:00
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        calculatorArn: Swift.String? = nil,
        calculatorName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        dataSource: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.calculatorArn = calculatorArn
        self.calculatorName = calculatorName
        self.createTime = createTime
        self.dataSource = dataSource
        self.description = description
        self.pricingPlan = pricingPlan
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct DescribeRouteCalculatorOutputBody: Swift.Equatable {
    let calculatorName: Swift.String?
    let calculatorArn: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let dataSource: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeRouteCalculatorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorArn = "CalculatorArn"
        case calculatorName = "CalculatorName"
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
        case updateTime = "UpdateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorName)
        calculatorName = calculatorNameDecoded
        let calculatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorArn)
        calculatorArn = calculatorArnDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeRouteCalculatorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTrackerInput {

    static func urlPathProvider(_ value: DescribeTrackerInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())"
    }
}

public struct DescribeTrackerInput: Swift.Equatable {
    /// The name of the tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        trackerName: Swift.String? = nil
    )
    {
        self.trackerName = trackerName
    }
}

struct DescribeTrackerInputBody: Swift.Equatable {
}

extension DescribeTrackerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTrackerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTrackerOutputBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.description = output.description
            self.eventBridgeEnabled = output.eventBridgeEnabled
            self.kmsKeyEnableGeospatialQueries = output.kmsKeyEnableGeospatialQueries
            self.kmsKeyId = output.kmsKeyId
            self.positionFiltering = output.positionFiltering
            self.pricingPlan = output.pricingPlan
            self.pricingPlanDataSource = output.pricingPlanDataSource
            self.tags = output.tags
            self.trackerArn = output.trackerArn
            self.trackerName = output.trackerName
            self.updateTime = output.updateTime
        } else {
            self.createTime = nil
            self.description = nil
            self.eventBridgeEnabled = nil
            self.kmsKeyEnableGeospatialQueries = nil
            self.kmsKeyId = nil
            self.positionFiltering = nil
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.tags = nil
            self.trackerArn = nil
            self.trackerName = nil
            self.updateTime = nil
        }
    }
}

public struct DescribeTrackerOutput: Swift.Equatable {
    /// The timestamp for when the tracker resource was created in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The optional description for the tracker resource.
    /// This member is required.
    public var description: Swift.String?
    /// Whether UPDATE events from this tracker in EventBridge are enabled. If set to true these events will be sent to EventBridge.
    public var eventBridgeEnabled: Swift.Bool?
    /// Enables GeospatialQueries for a tracker that uses a [Amazon Web Services KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html). This parameter is only used if you are using a KMS customer managed key. If you wish to encrypt your data using your own KMS customer managed key, then the Bounding Polygon Queries feature will be disabled by default. This is because by using this feature, a representation of your device positions will not be encrypted using the your KMS managed key. The exact device position, however; is still encrypted using your managed key. You can choose to opt-in to the Bounding Polygon Quseries feature. This is done by setting the KmsKeyEnableGeospatialQueries parameter to true when creating or updating a Tracker.
    public var kmsKeyEnableGeospatialQueries: Swift.Bool?
    /// A key identifier for an [Amazon Web Services KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html) assigned to the Amazon Location resource.
    public var kmsKeyId: Swift.String?
    /// The position filtering method of the tracker resource.
    public var positionFiltering: LocationClientTypes.PositionFiltering?
    /// Always returns RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// No longer used. Always returns an empty string.
    @available(*, deprecated, message: "Deprecated. Unused. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?
    /// The tags associated with the tracker resource.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
    /// This member is required.
    public var trackerArn: Swift.String?
    /// The name of the tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?
    /// The timestamp for when the tracker resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        createTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        eventBridgeEnabled: Swift.Bool? = nil,
        kmsKeyEnableGeospatialQueries: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        positionFiltering: LocationClientTypes.PositionFiltering? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.description = description
        self.eventBridgeEnabled = eventBridgeEnabled
        self.kmsKeyEnableGeospatialQueries = kmsKeyEnableGeospatialQueries
        self.kmsKeyId = kmsKeyId
        self.positionFiltering = positionFiltering
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
        self.trackerArn = trackerArn
        self.trackerName = trackerName
        self.updateTime = updateTime
    }
}

struct DescribeTrackerOutputBody: Swift.Equatable {
    let trackerName: Swift.String?
    let trackerArn: Swift.String?
    let description: Swift.String?
    let pricingPlan: LocationClientTypes.PricingPlan?
    let pricingPlanDataSource: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let kmsKeyId: Swift.String?
    let positionFiltering: LocationClientTypes.PositionFiltering?
    let eventBridgeEnabled: Swift.Bool?
    let kmsKeyEnableGeospatialQueries: Swift.Bool?
}

extension DescribeTrackerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case description = "Description"
        case eventBridgeEnabled = "EventBridgeEnabled"
        case kmsKeyEnableGeospatialQueries = "KmsKeyEnableGeospatialQueries"
        case kmsKeyId = "KmsKeyId"
        case positionFiltering = "PositionFiltering"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
        case trackerArn = "TrackerArn"
        case trackerName = "TrackerName"
        case updateTime = "UpdateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let trackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerArn)
        trackerArn = trackerArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let positionFilteringDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PositionFiltering.self, forKey: .positionFiltering)
        positionFiltering = positionFilteringDecoded
        let eventBridgeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .eventBridgeEnabled)
        eventBridgeEnabled = eventBridgeEnabledDecoded
        let kmsKeyEnableGeospatialQueriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kmsKeyEnableGeospatialQueries)
        kmsKeyEnableGeospatialQueries = kmsKeyEnableGeospatialQueriesDecoded
    }
}

enum DescribeTrackerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.DevicePosition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accuracy = "Accuracy"
        case deviceId = "DeviceId"
        case position = "Position"
        case positionProperties = "PositionProperties"
        case receivedTime = "ReceivedTime"
        case sampleTime = "SampleTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accuracy = self.accuracy {
            try encodeContainer.encode(accuracy, forKey: .accuracy)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for double0 in position {
                try positionContainer.encode(double0)
            }
        }
        if let positionProperties = positionProperties {
            var positionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .positionProperties)
            for (dictKey0, propertyMap0) in positionProperties {
                try positionPropertiesContainer.encode(propertyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let receivedTime = self.receivedTime {
            try encodeContainer.encodeTimestamp(receivedTime, format: .dateTime, forKey: .receivedTime)
        }
        if let sampleTime = self.sampleTime {
            try encodeContainer.encodeTimestamp(sampleTime, format: .dateTime, forKey: .sampleTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let receivedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .receivedTime)
        receivedTime = receivedTimeDecoded
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
        let accuracyDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PositionalAccuracy.self, forKey: .accuracy)
        accuracy = accuracyDecoded
        let positionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .positionProperties)
        var positionPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let positionPropertiesContainer = positionPropertiesContainer {
            positionPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in positionPropertiesContainer {
                if let string0 = string0 {
                    positionPropertiesDecoded0?[key0] = string0
                }
            }
        }
        positionProperties = positionPropertiesDecoded0
    }
}

extension LocationClientTypes.DevicePosition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DevicePosition(accuracy: \(Swift.String(describing: accuracy)), deviceId: \(Swift.String(describing: deviceId)), receivedTime: \(Swift.String(describing: receivedTime)), sampleTime: \(Swift.String(describing: sampleTime)), position: \"CONTENT_REDACTED\", positionProperties: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Contains the device position details.
    public struct DevicePosition: Swift.Equatable {
        /// The accuracy of the device position.
        public var accuracy: LocationClientTypes.PositionalAccuracy?
        /// The device whose position you retrieved.
        public var deviceId: Swift.String?
        /// The last known device position.
        /// This member is required.
        public var position: [Swift.Double]?
        /// The properties associated with the position.
        public var positionProperties: [Swift.String:Swift.String]?
        /// The timestamp for when the tracker resource received the device position in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var receivedTime: ClientRuntime.Date?
        /// The timestamp at which the device's position was determined. Uses [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init(
            accuracy: LocationClientTypes.PositionalAccuracy? = nil,
            deviceId: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            positionProperties: [Swift.String:Swift.String]? = nil,
            receivedTime: ClientRuntime.Date? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.receivedTime = receivedTime
            self.sampleTime = sampleTime
        }
    }

}

extension LocationClientTypes.DevicePositionUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accuracy = "Accuracy"
        case deviceId = "DeviceId"
        case position = "Position"
        case positionProperties = "PositionProperties"
        case sampleTime = "SampleTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accuracy = self.accuracy {
            try encodeContainer.encode(accuracy, forKey: .accuracy)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for double0 in position {
                try positionContainer.encode(double0)
            }
        }
        if let positionProperties = positionProperties {
            var positionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .positionProperties)
            for (dictKey0, propertyMap0) in positionProperties {
                try positionPropertiesContainer.encode(propertyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sampleTime = self.sampleTime {
            try encodeContainer.encodeTimestamp(sampleTime, format: .dateTime, forKey: .sampleTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
        let accuracyDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PositionalAccuracy.self, forKey: .accuracy)
        accuracy = accuracyDecoded
        let positionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .positionProperties)
        var positionPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let positionPropertiesContainer = positionPropertiesContainer {
            positionPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in positionPropertiesContainer {
                if let string0 = string0 {
                    positionPropertiesDecoded0?[key0] = string0
                }
            }
        }
        positionProperties = positionPropertiesDecoded0
    }
}

extension LocationClientTypes.DevicePositionUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DevicePositionUpdate(accuracy: \(Swift.String(describing: accuracy)), deviceId: \(Swift.String(describing: deviceId)), sampleTime: \(Swift.String(describing: sampleTime)), position: \"CONTENT_REDACTED\", positionProperties: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Contains the position update details for a device.
    public struct DevicePositionUpdate: Swift.Equatable {
        /// The accuracy of the device position.
        public var accuracy: LocationClientTypes.PositionalAccuracy?
        /// The device associated to the position update.
        /// This member is required.
        public var deviceId: Swift.String?
        /// The latest device position defined in [WGS 84](https://earth-info.nga.mil/index.php?dir=wgs84&action=wgs84) format: [X or longitude, Y or latitude].
        /// This member is required.
        public var position: [Swift.Double]?
        /// Associates one of more properties with the position update. A property is a key-value pair stored with the position update and added to any geofence event the update may trigger. Format: "key" : "value"
        public var positionProperties: [Swift.String:Swift.String]?
        /// The timestamp at which the device's position was determined. Uses [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init(
            accuracy: LocationClientTypes.PositionalAccuracy? = nil,
            deviceId: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            positionProperties: [Swift.String:Swift.String]? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.sampleTime = sampleTime
        }
    }

}

extension LocationClientTypes {
    public enum DimensionUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case feet
        case meters
        case sdkUnknown(Swift.String)

        public static var allCases: [DimensionUnit] {
            return [
                .feet,
                .meters,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .feet: return "Feet"
            case .meters: return "Meters"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DimensionUnit(rawValue: rawValue) ?? DimensionUnit.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateTrackerConsumerInput {

    static func urlPathProvider(_ value: DisassociateTrackerConsumerInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        guard let consumerArn = value.consumerArn else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/consumers/\(consumerArn.urlPercentEncoding())"
    }
}

public struct DisassociateTrackerConsumerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the geofence collection to be disassociated from the tracker resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
    /// This member is required.
    public var consumerArn: Swift.String?
    /// The name of the tracker resource to be dissociated from the consumer.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        consumerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.consumerArn = consumerArn
        self.trackerName = trackerName
    }
}

struct DisassociateTrackerConsumerInputBody: Swift.Equatable {
}

extension DisassociateTrackerConsumerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateTrackerConsumerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateTrackerConsumerOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateTrackerConsumerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes {
    public enum DistanceUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kilometers
        case miles
        case sdkUnknown(Swift.String)

        public static var allCases: [DistanceUnit] {
            return [
                .kilometers,
                .miles,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kilometers: return "Kilometers"
            case .miles: return "Miles"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DistanceUnit(rawValue: rawValue) ?? DistanceUnit.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes.GeofenceGeometry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case circle = "Circle"
        case polygon = "Polygon"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let circle = self.circle {
            try encodeContainer.encode(circle, forKey: .circle)
        }
        if let polygon = polygon {
            var polygonContainer = encodeContainer.nestedUnkeyedContainer(forKey: .polygon)
            for linearring0 in polygon {
                var linearring0Container = polygonContainer.nestedUnkeyedContainer()
                for position1 in linearring0 {
                    var position1Container = linearring0Container.nestedUnkeyedContainer()
                    for double2 in position1 {
                        try position1Container.encode(double2)
                    }
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let polygonContainer = try containerValues.decodeIfPresent([[[Swift.Double?]?]?].self, forKey: .polygon)
        var polygonDecoded0:[[[Swift.Double]]]? = nil
        if let polygonContainer = polygonContainer {
            polygonDecoded0 = [[[Swift.Double]]]()
            for list0 in polygonContainer {
                var list0Decoded0: [[Swift.Double]]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [[Swift.Double]]()
                    for list1 in list0 {
                        var list1Decoded1: [Swift.Double]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [Swift.Double]()
                            for double2 in list1 {
                                if let double2 = double2 {
                                    list1Decoded1?.append(double2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            list0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    polygonDecoded0?.append(list0Decoded0)
                }
            }
        }
        polygon = polygonDecoded0
        let circleDecoded = try containerValues.decodeIfPresent(LocationClientTypes.Circle.self, forKey: .circle)
        circle = circleDecoded
    }
}

extension LocationClientTypes.GeofenceGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeofenceGeometry(polygon: \(Swift.String(describing: polygon)), circle: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Contains the geofence geometry details. A geofence geometry is made up of either a polygon or a circle. Can be either a polygon or a circle. Including both will return a validation error. Amazon Location doesn't currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian.
    public struct GeofenceGeometry: Swift.Equatable {
        /// A circle on the earth, as defined by a center point and a radius.
        public var circle: LocationClientTypes.Circle?
        /// A polygon is a list of linear rings which are each made up of a list of vertices. Each vertex is a 2-dimensional point of the form: [longitude, latitude]. This is represented as an array of doubles of length 2 (so [double, double]). An array of 4 or more vertices, where the first and last vertex are the same (to form a closed boundary), is called a linear ring. The linear ring vertices must be listed in counter-clockwise order around the ring’s interior. The linear ring is represented as an array of vertices, or an array of arrays of doubles ([[double, double], ...]). A geofence consists of a single linear ring. To allow for future expansion, the Polygon parameter takes an array of linear rings, which is represented as an array of arrays of arrays of doubles ([[[double, double], ...], ...]). A linear ring for use in geofences can consist of between 4 and 1,000 vertices.
        public var polygon: [[[Swift.Double]]]?

        public init(
            circle: LocationClientTypes.Circle? = nil,
            polygon: [[[Swift.Double]]]? = nil
        )
        {
            self.circle = circle
            self.polygon = polygon
        }
    }

}

extension GetDevicePositionHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTimeExclusive = "EndTimeExclusive"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeInclusive = "StartTimeInclusive"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTimeExclusive = self.endTimeExclusive {
            try encodeContainer.encodeTimestamp(endTimeExclusive, format: .dateTime, forKey: .endTimeExclusive)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTimeInclusive = self.startTimeInclusive {
            try encodeContainer.encodeTimestamp(startTimeInclusive, format: .dateTime, forKey: .startTimeInclusive)
        }
    }
}

extension GetDevicePositionHistoryInput {

    static func urlPathProvider(_ value: GetDevicePositionHistoryInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())/list-positions"
    }
}

public struct GetDevicePositionHistoryInput: Swift.Equatable {
    /// The device whose position history you want to retrieve.
    /// This member is required.
    public var deviceId: Swift.String?
    /// Specify the end time for the position history in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be the time that the request is made. Requirement:
    ///
    /// * The time specified for EndTimeExclusive must be after the time for StartTimeInclusive.
    public var endTimeExclusive: ClientRuntime.Date?
    /// An optional limit for the number of device positions returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?
    /// Specify the start time for the position history in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be 24 hours prior to the time that the request is made. Requirement:
    ///
    /// * The time specified for StartTimeInclusive must be before EndTimeExclusive.
    public var startTimeInclusive: ClientRuntime.Date?
    /// The tracker resource receiving the request for the device position history.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        endTimeExclusive: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTimeInclusive: ClientRuntime.Date? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.endTimeExclusive = endTimeExclusive
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeInclusive = startTimeInclusive
        self.trackerName = trackerName
    }
}

struct GetDevicePositionHistoryInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let startTimeInclusive: ClientRuntime.Date?
    let endTimeExclusive: ClientRuntime.Date?
    let maxResults: Swift.Int?
}

extension GetDevicePositionHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTimeExclusive = "EndTimeExclusive"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeInclusive = "StartTimeInclusive"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let startTimeInclusiveDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTimeInclusive)
        startTimeInclusive = startTimeInclusiveDecoded
        let endTimeExclusiveDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTimeExclusive)
        endTimeExclusive = endTimeExclusiveDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetDevicePositionHistoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDevicePositionHistoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.devicePositions = output.devicePositions
            self.nextToken = output.nextToken
        } else {
            self.devicePositions = nil
            self.nextToken = nil
        }
    }
}

public struct GetDevicePositionHistoryOutput: Swift.Equatable {
    /// Contains the position history details for the requested device.
    /// This member is required.
    public var devicePositions: [LocationClientTypes.DevicePosition]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        devicePositions: [LocationClientTypes.DevicePosition]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devicePositions = devicePositions
        self.nextToken = nextToken
    }
}

struct GetDevicePositionHistoryOutputBody: Swift.Equatable {
    let devicePositions: [LocationClientTypes.DevicePosition]?
    let nextToken: Swift.String?
}

extension GetDevicePositionHistoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePositions = "DevicePositions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePositionsContainer = try containerValues.decodeIfPresent([LocationClientTypes.DevicePosition?].self, forKey: .devicePositions)
        var devicePositionsDecoded0:[LocationClientTypes.DevicePosition]? = nil
        if let devicePositionsContainer = devicePositionsContainer {
            devicePositionsDecoded0 = [LocationClientTypes.DevicePosition]()
            for structure0 in devicePositionsContainer {
                if let structure0 = structure0 {
                    devicePositionsDecoded0?.append(structure0)
                }
            }
        }
        devicePositions = devicePositionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetDevicePositionHistoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDevicePositionInput {

    static func urlPathProvider(_ value: GetDevicePositionInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())/positions/latest"
    }
}

public struct GetDevicePositionInput: Swift.Equatable {
    /// The device whose position you want to retrieve.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The tracker resource receiving the position update.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.trackerName = trackerName
    }
}

struct GetDevicePositionInputBody: Swift.Equatable {
}

extension GetDevicePositionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDevicePositionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicePositionOutput(accuracy: \(Swift.String(describing: accuracy)), deviceId: \(Swift.String(describing: deviceId)), receivedTime: \(Swift.String(describing: receivedTime)), sampleTime: \(Swift.String(describing: sampleTime)), position: \"CONTENT_REDACTED\", positionProperties: \"CONTENT_REDACTED\")"}
}

extension GetDevicePositionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDevicePositionOutputBody = try responseDecoder.decode(responseBody: data)
            self.accuracy = output.accuracy
            self.deviceId = output.deviceId
            self.position = output.position
            self.positionProperties = output.positionProperties
            self.receivedTime = output.receivedTime
            self.sampleTime = output.sampleTime
        } else {
            self.accuracy = nil
            self.deviceId = nil
            self.position = nil
            self.positionProperties = nil
            self.receivedTime = nil
            self.sampleTime = nil
        }
    }
}

public struct GetDevicePositionOutput: Swift.Equatable {
    /// The accuracy of the device position.
    public var accuracy: LocationClientTypes.PositionalAccuracy?
    /// The device whose position you retrieved.
    public var deviceId: Swift.String?
    /// The last known device position.
    /// This member is required.
    public var position: [Swift.Double]?
    /// The properties associated with the position.
    public var positionProperties: [Swift.String:Swift.String]?
    /// The timestamp for when the tracker resource received the device position in [ ISO 8601 ](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var receivedTime: ClientRuntime.Date?
    /// The timestamp at which the device's position was determined. Uses [ ISO 8601 ](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var sampleTime: ClientRuntime.Date?

    public init(
        accuracy: LocationClientTypes.PositionalAccuracy? = nil,
        deviceId: Swift.String? = nil,
        position: [Swift.Double]? = nil,
        positionProperties: [Swift.String:Swift.String]? = nil,
        receivedTime: ClientRuntime.Date? = nil,
        sampleTime: ClientRuntime.Date? = nil
    )
    {
        self.accuracy = accuracy
        self.deviceId = deviceId
        self.position = position
        self.positionProperties = positionProperties
        self.receivedTime = receivedTime
        self.sampleTime = sampleTime
    }
}

struct GetDevicePositionOutputBody: Swift.Equatable {
    let deviceId: Swift.String?
    let sampleTime: ClientRuntime.Date?
    let receivedTime: ClientRuntime.Date?
    let position: [Swift.Double]?
    let accuracy: LocationClientTypes.PositionalAccuracy?
    let positionProperties: [Swift.String:Swift.String]?
}

extension GetDevicePositionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accuracy = "Accuracy"
        case deviceId = "DeviceId"
        case position = "Position"
        case positionProperties = "PositionProperties"
        case receivedTime = "ReceivedTime"
        case sampleTime = "SampleTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let receivedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .receivedTime)
        receivedTime = receivedTimeDecoded
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
        let accuracyDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PositionalAccuracy.self, forKey: .accuracy)
        accuracy = accuracyDecoded
        let positionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .positionProperties)
        var positionPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let positionPropertiesContainer = positionPropertiesContainer {
            positionPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in positionPropertiesContainer {
                if let string0 = string0 {
                    positionPropertiesDecoded0?[key0] = string0
                }
            }
        }
        positionProperties = positionPropertiesDecoded0
    }
}

enum GetDevicePositionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGeofenceInput {

    static func urlPathProvider(_ value: GetGeofenceInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        guard let geofenceId = value.geofenceId else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/geofences/\(geofenceId.urlPercentEncoding())"
    }
}

public struct GetGeofenceInput: Swift.Equatable {
    /// The geofence collection storing the target geofence.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The geofence you're retrieving details for.
    /// This member is required.
    public var geofenceId: Swift.String?

    public init(
        collectionName: Swift.String? = nil,
        geofenceId: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
        self.geofenceId = geofenceId
    }
}

struct GetGeofenceInputBody: Swift.Equatable {
}

extension GetGeofenceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGeofenceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGeofenceOutput(createTime: \(Swift.String(describing: createTime)), geofenceId: \(Swift.String(describing: geofenceId)), geometry: \(Swift.String(describing: geometry)), status: \(Swift.String(describing: status)), updateTime: \(Swift.String(describing: updateTime)), geofenceProperties: \"CONTENT_REDACTED\")"}
}

extension GetGeofenceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGeofenceOutputBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.geofenceId = output.geofenceId
            self.geofenceProperties = output.geofenceProperties
            self.geometry = output.geometry
            self.status = output.status
            self.updateTime = output.updateTime
        } else {
            self.createTime = nil
            self.geofenceId = nil
            self.geofenceProperties = nil
            self.geometry = nil
            self.status = nil
            self.updateTime = nil
        }
    }
}

public struct GetGeofenceOutput: Swift.Equatable {
    /// The timestamp for when the geofence collection was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The geofence identifier.
    /// This member is required.
    public var geofenceId: Swift.String?
    /// User defined properties of the geofence. A property is a key-value pair stored with the geofence and added to any geofence event triggered with that geofence. Format: "key" : "value"
    public var geofenceProperties: [Swift.String:Swift.String]?
    /// Contains the geofence geometry details describing a polygon or a circle.
    /// This member is required.
    public var geometry: LocationClientTypes.GeofenceGeometry?
    /// Identifies the state of the geofence. A geofence will hold one of the following states:
    ///
    /// * ACTIVE — The geofence has been indexed by the system.
    ///
    /// * PENDING — The geofence is being processed by the system.
    ///
    /// * FAILED — The geofence failed to be indexed by the system.
    ///
    /// * DELETED — The geofence has been deleted from the system index.
    ///
    /// * DELETING — The geofence is being deleted from the system index.
    /// This member is required.
    public var status: Swift.String?
    /// The timestamp for when the geofence collection was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        createTime: ClientRuntime.Date? = nil,
        geofenceId: Swift.String? = nil,
        geofenceProperties: [Swift.String:Swift.String]? = nil,
        geometry: LocationClientTypes.GeofenceGeometry? = nil,
        status: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.geofenceId = geofenceId
        self.geofenceProperties = geofenceProperties
        self.geometry = geometry
        self.status = status
        self.updateTime = updateTime
    }
}

struct GetGeofenceOutputBody: Swift.Equatable {
    let geofenceId: Swift.String?
    let geometry: LocationClientTypes.GeofenceGeometry?
    let status: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let geofenceProperties: [Swift.String:Swift.String]?
}

extension GetGeofenceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case geofenceId = "GeofenceId"
        case geofenceProperties = "GeofenceProperties"
        case geometry = "Geometry"
        case status = "Status"
        case updateTime = "UpdateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.GeofenceGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let geofencePropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .geofenceProperties)
        var geofencePropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let geofencePropertiesContainer = geofencePropertiesContainer {
            geofencePropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in geofencePropertiesContainer {
                if let string0 = string0 {
                    geofencePropertiesDecoded0?[key0] = string0
                }
            }
        }
        geofenceProperties = geofencePropertiesDecoded0
    }
}

enum GetGeofenceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMapGlyphsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapGlyphsInput(fontStack: \(Swift.String(describing: fontStack)), fontUnicodeRange: \(Swift.String(describing: fontUnicodeRange)), mapName: \(Swift.String(describing: mapName)), key: \"CONTENT_REDACTED\")"}
}

extension GetMapGlyphsInput {

    static func queryItemProvider(_ value: GetMapGlyphsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GetMapGlyphsInput {

    static func urlPathProvider(_ value: GetMapGlyphsInput) -> Swift.String? {
        guard let mapName = value.mapName else {
            return nil
        }
        guard let fontStack = value.fontStack else {
            return nil
        }
        guard let fontUnicodeRange = value.fontUnicodeRange else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())/glyphs/\(fontStack.urlPercentEncoding())/\(fontUnicodeRange.urlPercentEncoding())"
    }
}

public struct GetMapGlyphsInput: Swift.Equatable {
    /// A comma-separated list of fonts to load glyphs from in order of preference. For example, Noto Sans Regular, Arial Unicode. Valid font stacks for [Esri](https://docs.aws.amazon.com/location/latest/developerguide/esri.html) styles:
    ///
    /// * VectorEsriDarkGrayCanvas – Ubuntu Medium Italic | Ubuntu Medium | Ubuntu Italic | Ubuntu Regular | Ubuntu Bold
    ///
    /// * VectorEsriLightGrayCanvas – Ubuntu Italic | Ubuntu Regular | Ubuntu Light | Ubuntu Bold
    ///
    /// * VectorEsriTopographic – Noto Sans Italic | Noto Sans Regular | Noto Sans Bold | Noto Serif Regular | Roboto Condensed Light Italic
    ///
    /// * VectorEsriStreets – Arial Regular | Arial Italic | Arial Bold
    ///
    /// * VectorEsriNavigation – Arial Regular | Arial Italic | Arial Bold | Arial Unicode MS Bold | Arial Unicode MS Regular
    ///
    ///
    /// Valid font stacks for [HERE Technologies](https://docs.aws.amazon.com/location/latest/developerguide/HERE.html) styles:
    ///
    /// * VectorHereContrast – Fira GO Regular | Fira GO Bold
    ///
    /// * VectorHereExplore, VectorHereExploreTruck, HybridHereExploreSatellite – Fira GO Italic | Fira GO Map | Fira GO Map Bold | Noto Sans CJK JP Bold | Noto Sans CJK JP Light | Noto Sans CJK JP Regular
    ///
    ///
    /// Valid font stacks for [GrabMaps](https://docs.aws.amazon.com/location/latest/developerguide/grab.html) styles:
    ///
    /// * VectorGrabStandardLight, VectorGrabStandardDark – Noto Sans Regular | Noto Sans Medium | Noto Sans Bold
    ///
    ///
    /// Valid font stacks for [Open Data](https://docs.aws.amazon.com/location/latest/developerguide/open-data.html) styles:
    ///
    /// * VectorOpenDataStandardLight, VectorOpenDataStandardDark, VectorOpenDataVisualizationLight, VectorOpenDataVisualizationDark – Amazon Ember Regular,Noto Sans Regular | Amazon Ember Bold,Noto Sans Bold | Amazon Ember Medium,Noto Sans Medium | Amazon Ember Regular Italic,Noto Sans Italic | Amazon Ember Condensed RC Regular,Noto Sans Regular | Amazon Ember Condensed RC Bold,Noto Sans Bold | Amazon Ember Regular,Noto Sans Regular,Noto Sans Arabic Regular | Amazon Ember Condensed RC Bold,Noto Sans Bold,Noto Sans Arabic Condensed Bold | Amazon Ember Bold,Noto Sans Bold,Noto Sans Arabic Bold | Amazon Ember Regular Italic,Noto Sans Italic,Noto Sans Arabic Regular | Amazon Ember Condensed RC Regular,Noto Sans Regular,Noto Sans Arabic Condensed Regular | Amazon Ember Medium,Noto Sans Medium,Noto Sans Arabic Medium
    ///
    ///
    /// The fonts used by the Open Data map styles are combined fonts that use Amazon Ember for most glyphs but Noto Sans for glyphs unsupported by Amazon Ember.
    /// This member is required.
    public var fontStack: Swift.String?
    /// A Unicode range of characters to download glyphs for. Each response will contain 256 characters. For example, 0–255 includes all characters from range U+0000 to 00FF. Must be aligned to multiples of 256.
    /// This member is required.
    public var fontUnicodeRange: Swift.String?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The map resource associated with the glyph ﬁle.
    /// This member is required.
    public var mapName: Swift.String?

    public init(
        fontStack: Swift.String? = nil,
        fontUnicodeRange: Swift.String? = nil,
        key: Swift.String? = nil,
        mapName: Swift.String? = nil
    )
    {
        self.fontStack = fontStack
        self.fontUnicodeRange = fontUnicodeRange
        self.key = key
        self.mapName = mapName
    }
}

struct GetMapGlyphsInputBody: Swift.Equatable {
}

extension GetMapGlyphsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMapGlyphsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            self.cacheControl = cacheControlHeaderValue
        } else {
            self.cacheControl = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.blob = data
        case .stream(let stream):
            self.blob = try stream.readToEnd()
        case .noStream:
            self.blob = nil
        }
    }
}

public struct GetMapGlyphsOutput: Swift.Equatable {
    /// The glyph, as binary blob.
    public var blob: ClientRuntime.Data?
    /// The HTTP Cache-Control directive for the value.
    public var cacheControl: Swift.String?
    /// The map glyph content type. For example, application/octet-stream.
    public var contentType: Swift.String?

    public init(
        blob: ClientRuntime.Data? = nil,
        cacheControl: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.cacheControl = cacheControl
        self.contentType = contentType
    }
}

struct GetMapGlyphsOutputBody: Swift.Equatable {
    let blob: ClientRuntime.Data?
}

extension GetMapGlyphsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blob = "Blob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .blob)
        blob = blobDecoded
    }
}

enum GetMapGlyphsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMapSpritesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapSpritesInput(fileName: \(Swift.String(describing: fileName)), mapName: \(Swift.String(describing: mapName)), key: \"CONTENT_REDACTED\")"}
}

extension GetMapSpritesInput {

    static func queryItemProvider(_ value: GetMapSpritesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GetMapSpritesInput {

    static func urlPathProvider(_ value: GetMapSpritesInput) -> Swift.String? {
        guard let mapName = value.mapName else {
            return nil
        }
        guard let fileName = value.fileName else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())/sprites/\(fileName.urlPercentEncoding())"
    }
}

public struct GetMapSpritesInput: Swift.Equatable {
    /// The name of the sprite ﬁle. Use the following ﬁle names for the sprite sheet:
    ///
    /// * sprites.png
    ///
    /// * sprites@2x.png for high pixel density displays
    ///
    ///
    /// For the JSON document containing image offsets. Use the following ﬁle names:
    ///
    /// * sprites.json
    ///
    /// * sprites@2x.json for high pixel density displays
    /// This member is required.
    public var fileName: Swift.String?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The map resource associated with the sprite ﬁle.
    /// This member is required.
    public var mapName: Swift.String?

    public init(
        fileName: Swift.String? = nil,
        key: Swift.String? = nil,
        mapName: Swift.String? = nil
    )
    {
        self.fileName = fileName
        self.key = key
        self.mapName = mapName
    }
}

struct GetMapSpritesInputBody: Swift.Equatable {
}

extension GetMapSpritesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMapSpritesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            self.cacheControl = cacheControlHeaderValue
        } else {
            self.cacheControl = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.blob = data
        case .stream(let stream):
            self.blob = try stream.readToEnd()
        case .noStream:
            self.blob = nil
        }
    }
}

public struct GetMapSpritesOutput: Swift.Equatable {
    /// Contains the body of the sprite sheet or JSON offset ﬁle.
    public var blob: ClientRuntime.Data?
    /// The HTTP Cache-Control directive for the value.
    public var cacheControl: Swift.String?
    /// The content type of the sprite sheet and offsets. For example, the sprite sheet content type is image/png, and the sprite offset JSON document is application/json.
    public var contentType: Swift.String?

    public init(
        blob: ClientRuntime.Data? = nil,
        cacheControl: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.cacheControl = cacheControl
        self.contentType = contentType
    }
}

struct GetMapSpritesOutputBody: Swift.Equatable {
    let blob: ClientRuntime.Data?
}

extension GetMapSpritesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blob = "Blob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .blob)
        blob = blobDecoded
    }
}

enum GetMapSpritesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMapStyleDescriptorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapStyleDescriptorInput(mapName: \(Swift.String(describing: mapName)), key: \"CONTENT_REDACTED\")"}
}

extension GetMapStyleDescriptorInput {

    static func queryItemProvider(_ value: GetMapStyleDescriptorInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GetMapStyleDescriptorInput {

    static func urlPathProvider(_ value: GetMapStyleDescriptorInput) -> Swift.String? {
        guard let mapName = value.mapName else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())/style-descriptor"
    }
}

public struct GetMapStyleDescriptorInput: Swift.Equatable {
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The map resource to retrieve the style descriptor from.
    /// This member is required.
    public var mapName: Swift.String?

    public init(
        key: Swift.String? = nil,
        mapName: Swift.String? = nil
    )
    {
        self.key = key
        self.mapName = mapName
    }
}

struct GetMapStyleDescriptorInputBody: Swift.Equatable {
}

extension GetMapStyleDescriptorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMapStyleDescriptorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            self.cacheControl = cacheControlHeaderValue
        } else {
            self.cacheControl = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.blob = data
        case .stream(let stream):
            self.blob = try stream.readToEnd()
        case .noStream:
            self.blob = nil
        }
    }
}

public struct GetMapStyleDescriptorOutput: Swift.Equatable {
    /// Contains the body of the style descriptor.
    public var blob: ClientRuntime.Data?
    /// The HTTP Cache-Control directive for the value.
    public var cacheControl: Swift.String?
    /// The style descriptor's content type. For example, application/json.
    public var contentType: Swift.String?

    public init(
        blob: ClientRuntime.Data? = nil,
        cacheControl: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.cacheControl = cacheControl
        self.contentType = contentType
    }
}

struct GetMapStyleDescriptorOutputBody: Swift.Equatable {
    let blob: ClientRuntime.Data?
}

extension GetMapStyleDescriptorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blob = "Blob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .blob)
        blob = blobDecoded
    }
}

enum GetMapStyleDescriptorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMapTileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapTileInput(mapName: \(Swift.String(describing: mapName)), x: \(Swift.String(describing: x)), y: \(Swift.String(describing: y)), z: \(Swift.String(describing: z)), key: \"CONTENT_REDACTED\")"}
}

extension GetMapTileInput {

    static func queryItemProvider(_ value: GetMapTileInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GetMapTileInput {

    static func urlPathProvider(_ value: GetMapTileInput) -> Swift.String? {
        guard let mapName = value.mapName else {
            return nil
        }
        guard let z = value.z else {
            return nil
        }
        guard let x = value.x else {
            return nil
        }
        guard let y = value.y else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())/tiles/\(z.urlPercentEncoding())/\(x.urlPercentEncoding())/\(y.urlPercentEncoding())"
    }
}

public struct GetMapTileInput: Swift.Equatable {
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The map resource to retrieve the map tiles from.
    /// This member is required.
    public var mapName: Swift.String?
    /// The X axis value for the map tile.
    /// This member is required.
    public var x: Swift.String?
    /// The Y axis value for the map tile.
    /// This member is required.
    public var y: Swift.String?
    /// The zoom value for the map tile.
    /// This member is required.
    public var z: Swift.String?

    public init(
        key: Swift.String? = nil,
        mapName: Swift.String? = nil,
        x: Swift.String? = nil,
        y: Swift.String? = nil,
        z: Swift.String? = nil
    )
    {
        self.key = key
        self.mapName = mapName
        self.x = x
        self.y = y
        self.z = z
    }
}

struct GetMapTileInputBody: Swift.Equatable {
}

extension GetMapTileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMapTileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            self.cacheControl = cacheControlHeaderValue
        } else {
            self.cacheControl = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.blob = data
        case .stream(let stream):
            self.blob = try stream.readToEnd()
        case .noStream:
            self.blob = nil
        }
    }
}

public struct GetMapTileOutput: Swift.Equatable {
    /// Contains Mapbox Vector Tile (MVT) data.
    public var blob: ClientRuntime.Data?
    /// The HTTP Cache-Control directive for the value.
    public var cacheControl: Swift.String?
    /// The map tile's content type. For example, application/vnd.mapbox-vector-tile.
    public var contentType: Swift.String?

    public init(
        blob: ClientRuntime.Data? = nil,
        cacheControl: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.cacheControl = cacheControl
        self.contentType = contentType
    }
}

struct GetMapTileOutputBody: Swift.Equatable {
    let blob: ClientRuntime.Data?
}

extension GetMapTileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blob = "Blob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .blob)
        blob = blobDecoded
    }
}

enum GetMapTileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPlaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPlaceInput(indexName: \(Swift.String(describing: indexName)), language: \(Swift.String(describing: language)), placeId: \(Swift.String(describing: placeId)), key: \"CONTENT_REDACTED\")"}
}

extension GetPlaceInput {

    static func queryItemProvider(_ value: GetPlaceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let language = value.language {
            let languageQueryItem = ClientRuntime.SDKURLQueryItem(name: "language".urlPercentEncoding(), value: Swift.String(language).urlPercentEncoding())
            items.append(languageQueryItem)
        }
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GetPlaceInput {

    static func urlPathProvider(_ value: GetPlaceInput) -> Swift.String? {
        guard let indexName = value.indexName else {
            return nil
        }
        guard let placeId = value.placeId else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())/places/\(placeId.urlPercentEncoding())"
    }
}

public struct GetPlaceInput: Swift.Equatable {
    /// The name of the place index resource that you want to use for the search.
    /// This member is required.
    public var indexName: Swift.String?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The preferred language used to return results. The value must be a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for a location around Athens, Greece, with the language parameter set to en. The city in the results will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the city in the results will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    public var language: Swift.String?
    /// The identifier of the place to find. While you can use PlaceID in subsequent requests, PlaceID is not intended to be a permanent identifier and the ID can change between consecutive API calls. Please see the following PlaceID behaviour for each data provider:
    ///
    /// * Esri: Place IDs will change every quarter at a minimum. The typical time period for these changes would be March, June, September, and December. Place IDs might also change between the typical quarterly change but that will be much less frequent.
    ///
    /// * HERE: We recommend that you cache data for no longer than a week to keep your data data fresh. You can assume that less than 1% ID shifts will release over release which is approximately 1 - 2 times per week.
    ///
    /// * Grab: Place IDs can expire or become invalid in the following situations.
    ///
    /// * Data operations: The POI may be removed from Grab POI database by Grab Map Ops based on the ground-truth, such as being closed in the real world, being detected as a duplicate POI, or having incorrect information. Grab will synchronize data to the Waypoint environment on weekly basis.
    ///
    /// * Interpolated POI: Interpolated POI is a temporary POI generated in real time when serving a request, and it will be marked as derived in the place.result_type field in the response. The information of interpolated POIs will be retained for at least 30 days, which means that within 30 days, you are able to obtain POI details by Place ID from Place Details API. After 30 days, the interpolated POIs(both Place ID and details) may expire and inaccessible from the Places Details API.
    /// This member is required.
    public var placeId: Swift.String?

    public init(
        indexName: Swift.String? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        placeId: Swift.String? = nil
    )
    {
        self.indexName = indexName
        self.key = key
        self.language = language
        self.placeId = placeId
    }
}

struct GetPlaceInputBody: Swift.Equatable {
}

extension GetPlaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPlaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPlaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.place = output.place
        } else {
            self.place = nil
        }
    }
}

public struct GetPlaceOutput: Swift.Equatable {
    /// Details about the result, such as its address and position.
    /// This member is required.
    public var place: LocationClientTypes.Place?

    public init(
        place: LocationClientTypes.Place? = nil
    )
    {
        self.place = place
    }
}

struct GetPlaceOutputBody: Swift.Equatable {
    let place: LocationClientTypes.Place?
}

extension GetPlaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case place = "Place"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.Place.self, forKey: .place)
        place = placeDecoded
    }
}

enum GetPlaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes {
    public enum IntendedUse: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleuse
        /// Indicates that results of the operation may be stored locally.
        case storage
        case sdkUnknown(Swift.String)

        public static var allCases: [IntendedUse] {
            return [
                .singleuse,
                .storage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .singleuse: return "SingleUse"
            case .storage: return "Storage"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntendedUse(rawValue: rawValue) ?? IntendedUse.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has failed to process because of an unknown server error, exception, or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes.Leg: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distance = "Distance"
        case durationSeconds = "DurationSeconds"
        case endPosition = "EndPosition"
        case geometry = "Geometry"
        case startPosition = "StartPosition"
        case steps = "Steps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distance = self.distance {
            try encodeContainer.encode(distance, forKey: .distance)
        }
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let endPosition = endPosition {
            var endPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endPosition)
            for double0 in endPosition {
                try endPositionContainer.encode(double0)
            }
        }
        if let geometry = self.geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
        if let startPosition = startPosition {
            var startPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startPosition)
            for double0 in startPosition {
                try startPositionContainer.encode(double0)
            }
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for step0 in steps {
                try stepsContainer.encode(step0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .startPosition)
        var startPositionDecoded0:[Swift.Double]? = nil
        if let startPositionContainer = startPositionContainer {
            startPositionDecoded0 = [Swift.Double]()
            for double0 in startPositionContainer {
                if let double0 = double0 {
                    startPositionDecoded0?.append(double0)
                }
            }
        }
        startPosition = startPositionDecoded0
        let endPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .endPosition)
        var endPositionDecoded0:[Swift.Double]? = nil
        if let endPositionContainer = endPositionContainer {
            endPositionDecoded0 = [Swift.Double]()
            for double0 in endPositionContainer {
                if let double0 = double0 {
                    endPositionDecoded0?.append(double0)
                }
            }
        }
        endPosition = endPositionDecoded0
        let distanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .distance)
        distance = distanceDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.LegGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let stepsContainer = try containerValues.decodeIfPresent([LocationClientTypes.Step?].self, forKey: .steps)
        var stepsDecoded0:[LocationClientTypes.Step]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [LocationClientTypes.Step]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension LocationClientTypes.Leg: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Leg(distance: \(Swift.String(describing: distance)), durationSeconds: \(Swift.String(describing: durationSeconds)), geometry: \(Swift.String(describing: geometry)), steps: \(Swift.String(describing: steps)), endPosition: \"CONTENT_REDACTED\", startPosition: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Contains the calculated route's details for each path between a pair of positions. The number of legs returned corresponds to one fewer than the total number of positions in the request. For example, a route with a departure position and destination position returns one leg with the positions [snapped to a nearby road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html):
    ///
    /// * The StartPosition is the departure position.
    ///
    /// * The EndPosition is the destination position.
    ///
    ///
    /// A route with a waypoint between the departure and destination position returns two legs with the positions snapped to a nearby road:
    ///
    /// * Leg 1: The StartPosition is the departure position . The EndPosition is the waypoint positon.
    ///
    /// * Leg 2: The StartPosition is the waypoint position. The EndPosition is the destination position.
    public struct Leg: Swift.Equatable {
        /// The distance between the leg's StartPosition and EndPosition along a calculated route.
        ///
        /// * The default measurement is Kilometers unless the request specifies a DistanceUnit of Miles.
        /// This member is required.
        public var distance: Swift.Double?
        /// The estimated travel time between the leg's StartPosition and EndPosition. The travel mode and departure time that you specify in the request determines the calculated time.
        /// This member is required.
        public var durationSeconds: Swift.Double?
        /// The terminating position of the leg. Follows the format [longitude,latitude]. If the EndPosition isn't located on a road, it's [snapped to a nearby road](https://docs.aws.amazon.com/location/latest/developerguide/nap-to-nearby-road.html).
        /// This member is required.
        public var endPosition: [Swift.Double]?
        /// Contains the calculated route's path as a linestring geometry.
        public var geometry: LocationClientTypes.LegGeometry?
        /// The starting position of the leg. Follows the format [longitude,latitude]. If the StartPosition isn't located on a road, it's [snapped to a nearby road](https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html).
        /// This member is required.
        public var startPosition: [Swift.Double]?
        /// Contains a list of steps, which represent subsections of a leg. Each step provides instructions for how to move to the next step in the leg such as the step's start position, end position, travel distance, travel duration, and geometry offset.
        /// This member is required.
        public var steps: [LocationClientTypes.Step]?

        public init(
            distance: Swift.Double? = nil,
            durationSeconds: Swift.Double? = nil,
            endPosition: [Swift.Double]? = nil,
            geometry: LocationClientTypes.LegGeometry? = nil,
            startPosition: [Swift.Double]? = nil,
            steps: [LocationClientTypes.Step]? = nil
        )
        {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.endPosition = endPosition
            self.geometry = geometry
            self.startPosition = startPosition
            self.steps = steps
        }
    }

}

extension LocationClientTypes.LegGeometry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lineString = "LineString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lineString = lineString {
            var lineStringContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineString)
            for position0 in lineString {
                var position0Container = lineStringContainer.nestedUnkeyedContainer()
                for double1 in position0 {
                    try position0Container.encode(double1)
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineStringContainer = try containerValues.decodeIfPresent([[Swift.Double?]?].self, forKey: .lineString)
        var lineStringDecoded0:[[Swift.Double]]? = nil
        if let lineStringContainer = lineStringContainer {
            lineStringDecoded0 = [[Swift.Double]]()
            for list0 in lineStringContainer {
                var list0Decoded0: [Swift.Double]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.Double]()
                    for double1 in list0 {
                        if let double1 = double1 {
                            list0Decoded0?.append(double1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    lineStringDecoded0?.append(list0Decoded0)
                }
            }
        }
        lineString = lineStringDecoded0
    }
}

extension LocationClientTypes {
    /// Contains the geometry details for each path between a pair of positions. Used in plotting a route leg on a map.
    public struct LegGeometry: Swift.Equatable {
        /// An ordered list of positions used to plot a route on a map. The first position is closest to the start position for the leg, and the last position is the closest to the end position for the leg.
        ///
        /// * For example, [[-123.117, 49.284],[-123.115, 49.285],[-123.115, 49.285]]
        public var lineString: [[Swift.Double]]?

        public init(
            lineString: [[Swift.Double]]? = nil
        )
        {
            self.lineString = lineString
        }
    }

}

extension ListDevicePositionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterGeometry = "FilterGeometry"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterGeometry = self.filterGeometry {
            try encodeContainer.encode(filterGeometry, forKey: .filterGeometry)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDevicePositionsInput {

    static func urlPathProvider(_ value: ListDevicePositionsInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/list-positions"
    }
}

public struct ListDevicePositionsInput: Swift.Equatable {
    /// The geometry used to filter device positions.
    public var filterGeometry: LocationClientTypes.TrackingFilterGeometry?
    /// An optional limit for the number of entries returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?
    /// The tracker resource containing the requested devices.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        filterGeometry: LocationClientTypes.TrackingFilterGeometry? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.filterGeometry = filterGeometry
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trackerName = trackerName
    }
}

struct ListDevicePositionsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filterGeometry: LocationClientTypes.TrackingFilterGeometry?
}

extension ListDevicePositionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterGeometry = "FilterGeometry"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterGeometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.TrackingFilterGeometry.self, forKey: .filterGeometry)
        filterGeometry = filterGeometryDecoded
    }
}

extension ListDevicePositionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDevicePositionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevicePositionsOutput: Swift.Equatable {
    /// Contains details about each device's last known position.
    /// This member is required.
    public var entries: [LocationClientTypes.ListDevicePositionsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListDevicePositionsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListDevicePositionsOutputBody: Swift.Equatable {
    let entries: [LocationClientTypes.ListDevicePositionsResponseEntry]?
    let nextToken: Swift.String?
}

extension ListDevicePositionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListDevicePositionsResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListDevicePositionsResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListDevicePositionsResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDevicePositionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.ListDevicePositionsResponseEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accuracy = "Accuracy"
        case deviceId = "DeviceId"
        case position = "Position"
        case positionProperties = "PositionProperties"
        case sampleTime = "SampleTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accuracy = self.accuracy {
            try encodeContainer.encode(accuracy, forKey: .accuracy)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for double0 in position {
                try positionContainer.encode(double0)
            }
        }
        if let positionProperties = positionProperties {
            var positionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .positionProperties)
            for (dictKey0, propertyMap0) in positionProperties {
                try positionPropertiesContainer.encode(propertyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sampleTime = self.sampleTime {
            try encodeContainer.encodeTimestamp(sampleTime, format: .dateTime, forKey: .sampleTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
        let accuracyDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PositionalAccuracy.self, forKey: .accuracy)
        accuracy = accuracyDecoded
        let positionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .positionProperties)
        var positionPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let positionPropertiesContainer = positionPropertiesContainer {
            positionPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in positionPropertiesContainer {
                if let string0 = string0 {
                    positionPropertiesDecoded0?[key0] = string0
                }
            }
        }
        positionProperties = positionPropertiesDecoded0
    }
}

extension LocationClientTypes.ListDevicePositionsResponseEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevicePositionsResponseEntry(accuracy: \(Swift.String(describing: accuracy)), deviceId: \(Swift.String(describing: deviceId)), sampleTime: \(Swift.String(describing: sampleTime)), position: \"CONTENT_REDACTED\", positionProperties: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Contains the tracker resource details.
    public struct ListDevicePositionsResponseEntry: Swift.Equatable {
        /// The accuracy of the device position.
        public var accuracy: LocationClientTypes.PositionalAccuracy?
        /// The ID of the device for this position.
        /// This member is required.
        public var deviceId: Swift.String?
        /// The last known device position. Empty if no positions currently stored.
        /// This member is required.
        public var position: [Swift.Double]?
        /// The properties associated with the position.
        public var positionProperties: [Swift.String:Swift.String]?
        /// The timestamp at which the device position was determined. Uses [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init(
            accuracy: LocationClientTypes.PositionalAccuracy? = nil,
            deviceId: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            positionProperties: [Swift.String:Swift.String]? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.sampleTime = sampleTime
        }
    }

}

extension ListGeofenceCollectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGeofenceCollectionsInput {

    static func urlPathProvider(_ value: ListGeofenceCollectionsInput) -> Swift.String? {
        return "/geofencing/v0/list-collections"
    }
}

public struct ListGeofenceCollectionsInput: Swift.Equatable {
    /// An optional limit for the number of resources returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGeofenceCollectionsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListGeofenceCollectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGeofenceCollectionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGeofenceCollectionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListGeofenceCollectionsOutput: Swift.Equatable {
    /// Lists the geofence collections that exist in your Amazon Web Services account.
    /// This member is required.
    public var entries: [LocationClientTypes.ListGeofenceCollectionsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListGeofenceCollectionsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListGeofenceCollectionsOutputBody: Swift.Equatable {
    let entries: [LocationClientTypes.ListGeofenceCollectionsResponseEntry]?
    let nextToken: Swift.String?
}

extension ListGeofenceCollectionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListGeofenceCollectionsResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListGeofenceCollectionsResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListGeofenceCollectionsResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGeofenceCollectionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.ListGeofenceCollectionsResponseEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionName = "CollectionName"
        case createTime = "CreateTime"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectionName = self.collectionName {
            try encodeContainer.encode(collectionName, forKey: .collectionName)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = self.pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes {
    /// Contains the geofence collection details.
    public struct ListGeofenceCollectionsResponseEntry: Swift.Equatable {
        /// The name of the geofence collection.
        /// This member is required.
        public var collectionName: Swift.String?
        /// The timestamp for when the geofence collection was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description for the geofence collection
        /// This member is required.
        public var description: Swift.String?
        /// No longer used. Always returns RequestBasedUsage.
        @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// No longer used. Always returns an empty string.
        @available(*, deprecated, message: "Deprecated. Unused. API deprecated since 2022-02-01")
        public var pricingPlanDataSource: Swift.String?
        /// Specifies a timestamp for when the resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            collectionName: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            pricingPlanDataSource: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.updateTime = updateTime
        }
    }

}

extension LocationClientTypes.ListGeofenceResponseEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case geofenceId = "GeofenceId"
        case geofenceProperties = "GeofenceProperties"
        case geometry = "Geometry"
        case status = "Status"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let geofenceId = self.geofenceId {
            try encodeContainer.encode(geofenceId, forKey: .geofenceId)
        }
        if let geofenceProperties = geofenceProperties {
            var geofencePropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .geofenceProperties)
            for (dictKey0, propertyMap0) in geofenceProperties {
                try geofencePropertiesContainer.encode(propertyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let geometry = self.geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.GeofenceGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let geofencePropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .geofenceProperties)
        var geofencePropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let geofencePropertiesContainer = geofencePropertiesContainer {
            geofencePropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in geofencePropertiesContainer {
                if let string0 = string0 {
                    geofencePropertiesDecoded0?[key0] = string0
                }
            }
        }
        geofenceProperties = geofencePropertiesDecoded0
    }
}

extension LocationClientTypes.ListGeofenceResponseEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGeofenceResponseEntry(createTime: \(Swift.String(describing: createTime)), geofenceId: \(Swift.String(describing: geofenceId)), geometry: \(Swift.String(describing: geometry)), status: \(Swift.String(describing: status)), updateTime: \(Swift.String(describing: updateTime)), geofenceProperties: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Contains a list of geofences stored in a given geofence collection.
    public struct ListGeofenceResponseEntry: Swift.Equatable {
        /// The timestamp for when the geofence was stored in a geofence collection in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The geofence identifier.
        /// This member is required.
        public var geofenceId: Swift.String?
        /// User defined properties of the geofence. A property is a key-value pair stored with the geofence and added to any geofence event triggered with that geofence. Format: "key" : "value"
        public var geofenceProperties: [Swift.String:Swift.String]?
        /// Contains the geofence geometry details describing a polygon or a circle.
        /// This member is required.
        public var geometry: LocationClientTypes.GeofenceGeometry?
        /// Identifies the state of the geofence. A geofence will hold one of the following states:
        ///
        /// * ACTIVE — The geofence has been indexed by the system.
        ///
        /// * PENDING — The geofence is being processed by the system.
        ///
        /// * FAILED — The geofence failed to be indexed by the system.
        ///
        /// * DELETED — The geofence has been deleted from the system index.
        ///
        /// * DELETING — The geofence is being deleted from the system index.
        /// This member is required.
        public var status: Swift.String?
        /// The timestamp for when the geofence was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            createTime: ClientRuntime.Date? = nil,
            geofenceId: Swift.String? = nil,
            geofenceProperties: [Swift.String:Swift.String]? = nil,
            geometry: LocationClientTypes.GeofenceGeometry? = nil,
            status: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.geofenceProperties = geofenceProperties
            self.geometry = geometry
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension ListGeofencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGeofencesInput {

    static func urlPathProvider(_ value: ListGeofencesInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/list-geofences"
    }
}

public struct ListGeofencesInput: Swift.Equatable {
    /// The name of the geofence collection storing the list of geofences.
    /// This member is required.
    public var collectionName: Swift.String?
    /// An optional limit for the number of geofences returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init(
        collectionName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGeofencesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListGeofencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGeofencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGeofencesOutputBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListGeofencesOutput: Swift.Equatable {
    /// Contains a list of geofences stored in the geofence collection.
    /// This member is required.
    public var entries: [LocationClientTypes.ListGeofenceResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListGeofenceResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListGeofencesOutputBody: Swift.Equatable {
    let entries: [LocationClientTypes.ListGeofenceResponseEntry]?
    let nextToken: Swift.String?
}

extension ListGeofencesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListGeofenceResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListGeofenceResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListGeofenceResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGeofencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListKeysInput {

    static func urlPathProvider(_ value: ListKeysInput) -> Swift.String? {
        return "/metadata/v0/list-keys"
    }
}

public struct ListKeysInput: Swift.Equatable {
    /// Optionally filter the list to only Active or Expired API keys.
    public var filter: LocationClientTypes.ApiKeyFilter?
    /// An optional limit for the number of resources returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init(
        filter: LocationClientTypes.ApiKeyFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKeysInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filter: LocationClientTypes.ApiKeyFilter?
}

extension ListKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterDecoded = try containerValues.decodeIfPresent(LocationClientTypes.ApiKeyFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListKeysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKeysOutputBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListKeysOutput: Swift.Equatable {
    /// Contains API key resources in your Amazon Web Services account. Details include API key name, allowed referers and timestamp for when the API key will expire.
    /// This member is required.
    public var entries: [LocationClientTypes.ListKeysResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListKeysResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListKeysOutputBody: Swift.Equatable {
    let entries: [LocationClientTypes.ListKeysResponseEntry]?
    let nextToken: Swift.String?
}

extension ListKeysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListKeysResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListKeysResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListKeysResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListKeysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.ListKeysResponseEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case description = "Description"
        case expireTime = "ExpireTime"
        case keyName = "KeyName"
        case restrictions = "Restrictions"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expireTime = self.expireTime {
            try encodeContainer.encodeTimestamp(expireTime, format: .dateTime, forKey: .expireTime)
        }
        if let keyName = self.keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let restrictions = self.restrictions {
            try encodeContainer.encode(restrictions, forKey: .restrictions)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let expireTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expireTime)
        expireTime = expireTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.ApiKeyRestrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes {
    /// An API key resource listed in your Amazon Web Services account.
    public struct ListKeysResponseEntry: Swift.Equatable {
        /// The timestamp of when the API key was created, in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The optional description for the API key resource.
        public var description: Swift.String?
        /// The timestamp for when the API key resource will expire, in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var expireTime: ClientRuntime.Date?
        /// The name of the API key resource.
        /// This member is required.
        public var keyName: Swift.String?
        /// API Restrictions on the allowed actions, resources, and referers for an API key resource.
        /// This member is required.
        public var restrictions: LocationClientTypes.ApiKeyRestrictions?
        /// The timestamp of when the API key was last updated, in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            expireTime: ClientRuntime.Date? = nil,
            keyName: Swift.String? = nil,
            restrictions: LocationClientTypes.ApiKeyRestrictions? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.description = description
            self.expireTime = expireTime
            self.keyName = keyName
            self.restrictions = restrictions
            self.updateTime = updateTime
        }
    }

}

extension ListMapsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMapsInput {

    static func urlPathProvider(_ value: ListMapsInput) -> Swift.String? {
        return "/maps/v0/list-maps"
    }
}

public struct ListMapsInput: Swift.Equatable {
    /// An optional limit for the number of resources returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMapsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListMapsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMapsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMapsOutputBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListMapsOutput: Swift.Equatable {
    /// Contains a list of maps in your Amazon Web Services account
    /// This member is required.
    public var entries: [LocationClientTypes.ListMapsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListMapsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListMapsOutputBody: Swift.Equatable {
    let entries: [LocationClientTypes.ListMapsResponseEntry]?
    let nextToken: Swift.String?
}

extension ListMapsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListMapsResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListMapsResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListMapsResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMapsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.ListMapsResponseEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case description = "Description"
        case mapName = "MapName"
        case pricingPlan = "PricingPlan"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mapName = self.mapName {
            try encodeContainer.encode(mapName, forKey: .mapName)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapName)
        mapName = mapNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes {
    /// Contains details of an existing map resource in your Amazon Web Services account.
    public struct ListMapsResponseEntry: Swift.Equatable {
        /// The timestamp for when the map resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// Specifies the data provider for the associated map tiles.
        /// This member is required.
        public var dataSource: Swift.String?
        /// The description for the map resource.
        /// This member is required.
        public var description: Swift.String?
        /// The name of the associated map resource.
        /// This member is required.
        public var mapName: Swift.String?
        /// No longer used. Always returns RequestBasedUsage.
        @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// The timestamp for when the map resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            createTime: ClientRuntime.Date? = nil,
            dataSource: Swift.String? = nil,
            description: Swift.String? = nil,
            mapName: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapName = mapName
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }
    }

}

extension ListPlaceIndexesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPlaceIndexesInput {

    static func urlPathProvider(_ value: ListPlaceIndexesInput) -> Swift.String? {
        return "/places/v0/list-indexes"
    }
}

public struct ListPlaceIndexesInput: Swift.Equatable {
    /// An optional limit for the maximum number of results returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPlaceIndexesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListPlaceIndexesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPlaceIndexesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPlaceIndexesOutputBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListPlaceIndexesOutput: Swift.Equatable {
    /// Lists the place index resources that exist in your Amazon Web Services account
    /// This member is required.
    public var entries: [LocationClientTypes.ListPlaceIndexesResponseEntry]?
    /// A pagination token indicating that there are additional pages available. You can use the token in a new request to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListPlaceIndexesResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListPlaceIndexesOutputBody: Swift.Equatable {
    let entries: [LocationClientTypes.ListPlaceIndexesResponseEntry]?
    let nextToken: Swift.String?
}

extension ListPlaceIndexesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListPlaceIndexesResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListPlaceIndexesResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListPlaceIndexesResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPlaceIndexesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.ListPlaceIndexesResponseEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case description = "Description"
        case indexName = "IndexName"
        case pricingPlan = "PricingPlan"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes {
    /// A place index resource listed in your Amazon Web Services account.
    public struct ListPlaceIndexesResponseEntry: Swift.Equatable {
        /// The timestamp for when the place index resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The data provider of geospatial data. Values can be one of the following:
        ///
        /// * Esri
        ///
        /// * Grab
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// The optional description for the place index resource.
        /// This member is required.
        public var description: Swift.String?
        /// The name of the place index resource.
        /// This member is required.
        public var indexName: Swift.String?
        /// No longer used. Always returns RequestBasedUsage.
        @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// The timestamp for when the place index resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            createTime: ClientRuntime.Date? = nil,
            dataSource: Swift.String? = nil,
            description: Swift.String? = nil,
            indexName: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.indexName = indexName
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }
    }

}

extension ListRouteCalculatorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRouteCalculatorsInput {

    static func urlPathProvider(_ value: ListRouteCalculatorsInput) -> Swift.String? {
        return "/routes/v0/list-calculators"
    }
}

public struct ListRouteCalculatorsInput: Swift.Equatable {
    /// An optional maximum number of results returned in a single call. Default Value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default Value: null
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRouteCalculatorsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListRouteCalculatorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRouteCalculatorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRouteCalculatorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListRouteCalculatorsOutput: Swift.Equatable {
    /// Lists the route calculator resources that exist in your Amazon Web Services account
    /// This member is required.
    public var entries: [LocationClientTypes.ListRouteCalculatorsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a subsequent request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListRouteCalculatorsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListRouteCalculatorsOutputBody: Swift.Equatable {
    let entries: [LocationClientTypes.ListRouteCalculatorsResponseEntry]?
    let nextToken: Swift.String?
}

extension ListRouteCalculatorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListRouteCalculatorsResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListRouteCalculatorsResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListRouteCalculatorsResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRouteCalculatorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.ListRouteCalculatorsResponseEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorName = "CalculatorName"
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculatorName = self.calculatorName {
            try encodeContainer.encode(calculatorName, forKey: .calculatorName)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorName)
        calculatorName = calculatorNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes {
    /// A route calculator resource listed in your Amazon Web Services account.
    public struct ListRouteCalculatorsResponseEntry: Swift.Equatable {
        /// The name of the route calculator resource.
        /// This member is required.
        public var calculatorName: Swift.String?
        /// The timestamp when the route calculator resource was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        ///
        /// * For example, 2020–07-2T12:15:20.000Z+01:00
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The data provider of traffic and road network data. Indicates one of the available providers:
        ///
        /// * Esri
        ///
        /// * Grab
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// The optional description of the route calculator resource.
        /// This member is required.
        public var description: Swift.String?
        /// Always returns RequestBasedUsage.
        @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// The timestamp when the route calculator resource was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        ///
        /// * For example, 2020–07-2T12:15:20.000Z+01:00
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            calculatorName: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            dataSource: Swift.String? = nil,
            description: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.calculatorName = calculatorName
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }
    }

}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
    ///
    /// * Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Tags that have been applied to the specified resource. Tags are mapped from the tag key to the tag value: "TagKey" : "TagValue".
    ///
    /// * Format example: {"tag1" : "value1", "tag2" : "value2"}
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTrackerConsumersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTrackerConsumersInput {

    static func urlPathProvider(_ value: ListTrackerConsumersInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/list-consumers"
    }
}

public struct ListTrackerConsumersInput: Swift.Equatable {
    /// An optional limit for the number of resources returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?
    /// The tracker resource whose associated geofence collections you want to list.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trackerName = trackerName
    }
}

struct ListTrackerConsumersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTrackerConsumersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrackerConsumersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTrackerConsumersOutputBody = try responseDecoder.decode(responseBody: data)
            self.consumerArns = output.consumerArns
            self.nextToken = output.nextToken
        } else {
            self.consumerArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListTrackerConsumersOutput: Swift.Equatable {
    /// Contains the list of geofence collection ARNs associated to the tracker resource.
    /// This member is required.
    public var consumerArns: [Swift.String]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        consumerArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.consumerArns = consumerArns
        self.nextToken = nextToken
    }
}

struct ListTrackerConsumersOutputBody: Swift.Equatable {
    let consumerArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListTrackerConsumersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerArns = "ConsumerArns"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .consumerArns)
        var consumerArnsDecoded0:[Swift.String]? = nil
        if let consumerArnsContainer = consumerArnsContainer {
            consumerArnsDecoded0 = [Swift.String]()
            for string0 in consumerArnsContainer {
                if let string0 = string0 {
                    consumerArnsDecoded0?.append(string0)
                }
            }
        }
        consumerArns = consumerArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTrackerConsumersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTrackersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTrackersInput {

    static func urlPathProvider(_ value: ListTrackersInput) -> Swift.String? {
        return "/tracking/v0/list-trackers"
    }
}

public struct ListTrackersInput: Swift.Equatable {
    /// An optional limit for the number of resources returned in a single call. Default value: 100
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTrackersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTrackersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrackersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTrackersOutputBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListTrackersOutput: Swift.Equatable {
    /// Contains tracker resources in your Amazon Web Services account. Details include tracker name, description and timestamps for when the tracker was created and last updated.
    /// This member is required.
    public var entries: [LocationClientTypes.ListTrackersResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        entries: [LocationClientTypes.ListTrackersResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListTrackersOutputBody: Swift.Equatable {
    let entries: [LocationClientTypes.ListTrackersResponseEntry]?
    let nextToken: Swift.String?
}

extension ListTrackersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListTrackersResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListTrackersResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListTrackersResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTrackersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.ListTrackersResponseEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case trackerName = "TrackerName"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = self.pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
        if let trackerName = self.trackerName {
            try encodeContainer.encode(trackerName, forKey: .trackerName)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes {
    /// Contains the tracker resource details.
    public struct ListTrackersResponseEntry: Swift.Equatable {
        /// The timestamp for when the tracker resource was created in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description for the tracker resource.
        /// This member is required.
        public var description: Swift.String?
        /// Always returns RequestBasedUsage.
        @available(*, deprecated, message: "Deprecated. Always returns RequestBasedUsage. API deprecated since 2022-02-01")
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// No longer used. Always returns an empty string.
        @available(*, deprecated, message: "Deprecated. Unused. API deprecated since 2022-02-01")
        public var pricingPlanDataSource: Swift.String?
        /// The name of the tracker resource.
        /// This member is required.
        public var trackerName: Swift.String?
        /// The timestamp at which the device's position was determined. Uses [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            pricingPlanDataSource: Swift.String? = nil,
            trackerName: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.trackerName = trackerName
            self.updateTime = updateTime
        }
    }

}

public enum LocationClientTypes {}

extension LocationClientTypes.MapConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customLayers = "CustomLayers"
        case politicalView = "PoliticalView"
        case style = "Style"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customLayers = customLayers {
            var customLayersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customLayers)
            for customlayer0 in customLayers {
                try customLayersContainer.encode(customlayer0)
            }
        }
        if let politicalView = self.politicalView {
            try encodeContainer.encode(politicalView, forKey: .politicalView)
        }
        if let style = self.style {
            try encodeContainer.encode(style, forKey: .style)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let styleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .style)
        style = styleDecoded
        let politicalViewDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .politicalView)
        politicalView = politicalViewDecoded
        let customLayersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .customLayers)
        var customLayersDecoded0:[Swift.String]? = nil
        if let customLayersContainer = customLayersContainer {
            customLayersDecoded0 = [Swift.String]()
            for string0 in customLayersContainer {
                if let string0 = string0 {
                    customLayersDecoded0?.append(string0)
                }
            }
        }
        customLayers = customLayersDecoded0
    }
}

extension LocationClientTypes {
    /// Specifies the map tile style selected from an available provider.
    public struct MapConfiguration: Swift.Equatable {
        /// Specifies the custom layers for the style. Leave unset to not enable any custom layer, or, for styles that support custom layers, you can enable layer(s), such as POI layer for the VectorEsriNavigation style. Default is unset. Currenlty only VectorEsriNavigation supports CustomLayers. For more information, see [Custom Layers](https://docs.aws.amazon.com/location/latest/developerguide/map-concepts.html#map-custom-layers).
        public var customLayers: [Swift.String]?
        /// Specifies the political view for the style. Leave unset to not use a political view, or, for styles that support specific political views, you can choose a view, such as IND for the Indian view. Default is unset. Not all map resources or styles support political view styles. See [Political views](https://docs.aws.amazon.com/location/latest/developerguide/map-concepts.html#political-views) for more information.
        public var politicalView: Swift.String?
        /// Specifies the map style selected from an available data provider. Valid [Esri map styles](https://docs.aws.amazon.com/location/latest/developerguide/esri.html):
        ///
        /// * VectorEsriNavigation – The Esri Navigation map style, which provides a detailed basemap for the world symbolized with a custom navigation map style that's designed for use during the day in mobile devices. It also includes a richer set of places, such as shops, services, restaurants, attractions, and other points of interest. Enable the POI layer by setting it in CustomLayers to leverage the additional places data.
        ///
        /// * RasterEsriImagery – The Esri Imagery map style. A raster basemap that provides one meter or better satellite and aerial imagery in many parts of the world and lower resolution satellite imagery worldwide.
        ///
        /// * VectorEsriLightGrayCanvas – The Esri Light Gray Canvas map style, which provides a detailed vector basemap with a light gray, neutral background style with minimal colors, labels, and features that's designed to draw attention to your thematic content.
        ///
        /// * VectorEsriTopographic – The Esri Light map style, which provides a detailed vector basemap with a classic Esri map style.
        ///
        /// * VectorEsriStreets – The Esri Street Map style, which provides a detailed vector basemap for the world symbolized with a classic Esri street map style. The vector tile layer is similar in content and style to the World Street Map raster map.
        ///
        /// * VectorEsriDarkGrayCanvas – The Esri Dark Gray Canvas map style. A vector basemap with a dark gray, neutral background with minimal colors, labels, and features that's designed to draw attention to your thematic content.
        ///
        ///
        /// Valid [HERE Technologies map styles](https://docs.aws.amazon.com/location/latest/developerguide/HERE.html):
        ///
        /// * VectorHereExplore – A default HERE map style containing a neutral, global map and its features including roads, buildings, landmarks, and water features. It also now includes a fully designed map of Japan.
        ///
        /// * RasterHereExploreSatellite – A global map containing high resolution satellite imagery.
        ///
        /// * HybridHereExploreSatellite – A global map displaying the road network, street names, and city labels over satellite imagery. This style will automatically retrieve both raster and vector tiles, and your charges will be based on total tiles retrieved. Hybrid styles use both vector and raster tiles when rendering the map that you see. This means that more tiles are retrieved than when using either vector or raster tiles alone. Your charges will include all tiles retrieved.
        ///
        /// * VectorHereContrast – The HERE Contrast (Berlin) map style is a high contrast detailed base map of the world that blends 3D and 2D rendering. The VectorHereContrast style has been renamed from VectorHereBerlin. VectorHereBerlin has been deprecated, but will continue to work in applications that use it.
        ///
        /// * VectorHereExploreTruck – A global map containing truck restrictions and attributes (e.g. width / height / HAZMAT) symbolized with highlighted segments and icons on top of HERE Explore to support use cases within transport and logistics.
        ///
        ///
        /// Valid [GrabMaps map styles](https://docs.aws.amazon.com/location/latest/developerguide/grab.html):
        ///
        /// * VectorGrabStandardLight – The Grab Standard Light map style provides a basemap with detailed land use coloring, area names, roads, landmarks, and points of interest covering Southeast Asia.
        ///
        /// * VectorGrabStandardDark – The Grab Standard Dark map style provides a dark variation of the standard basemap covering Southeast Asia.
        ///
        ///
        /// Grab provides maps only for countries in Southeast Asia, and is only available in the Asia Pacific (Singapore) Region (ap-southeast-1). For more information, see [GrabMaps countries and area covered](https://docs.aws.amazon.com/location/latest/developerguide/grab.html#grab-coverage-area). Valid [Open Data map styles](https://docs.aws.amazon.com/location/latest/developerguide/open-data.html):
        ///
        /// * VectorOpenDataStandardLight – The Open Data Standard Light map style provides a detailed basemap for the world suitable for website and mobile application use. The map includes highways major roads, minor roads, railways, water features, cities, parks, landmarks, building footprints, and administrative boundaries.
        ///
        /// * VectorOpenDataStandardDark – Open Data Standard Dark is a dark-themed map style that provides a detailed basemap for the world suitable for website and mobile application use. The map includes highways major roads, minor roads, railways, water features, cities, parks, landmarks, building footprints, and administrative boundaries.
        ///
        /// * VectorOpenDataVisualizationLight – The Open Data Visualization Light map style is a light-themed style with muted colors and fewer features that aids in understanding overlaid data.
        ///
        /// * VectorOpenDataVisualizationDark – The Open Data Visualization Dark map style is a dark-themed style with muted colors and fewer features that aids in understanding overlaid data.
        /// This member is required.
        public var style: Swift.String?

        public init(
            customLayers: [Swift.String]? = nil,
            politicalView: Swift.String? = nil,
            style: Swift.String? = nil
        )
        {
            self.customLayers = customLayers
            self.politicalView = politicalView
            self.style = style
        }
    }

}

extension LocationClientTypes.MapConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customLayers = "CustomLayers"
        case politicalView = "PoliticalView"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customLayers = customLayers {
            var customLayersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customLayers)
            for customlayer0 in customLayers {
                try customLayersContainer.encode(customlayer0)
            }
        }
        if let politicalView = self.politicalView {
            try encodeContainer.encode(politicalView, forKey: .politicalView)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let politicalViewDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .politicalView)
        politicalView = politicalViewDecoded
        let customLayersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .customLayers)
        var customLayersDecoded0:[Swift.String]? = nil
        if let customLayersContainer = customLayersContainer {
            customLayersDecoded0 = [Swift.String]()
            for string0 in customLayersContainer {
                if let string0 = string0 {
                    customLayersDecoded0?.append(string0)
                }
            }
        }
        customLayers = customLayersDecoded0
    }
}

extension LocationClientTypes {
    /// Specifies the political view for the style.
    public struct MapConfigurationUpdate: Swift.Equatable {
        /// Specifies the custom layers for the style. Leave unset to not enable any custom layer, or, for styles that support custom layers, you can enable layer(s), such as POI layer for the VectorEsriNavigation style. Default is unset. Currenlty only VectorEsriNavigation supports CustomLayers. For more information, see [Custom Layers](https://docs.aws.amazon.com/location/latest/developerguide/map-concepts.html#map-custom-layers).
        public var customLayers: [Swift.String]?
        /// Specifies the political view for the style. Set to an empty string to not use a political view, or, for styles that support specific political views, you can choose a view, such as IND for the Indian view. Not all map resources or styles support political view styles. See [Political views](https://docs.aws.amazon.com/location/latest/developerguide/map-concepts.html#political-views) for more information.
        public var politicalView: Swift.String?

        public init(
            customLayers: [Swift.String]? = nil,
            politicalView: Swift.String? = nil
        )
        {
            self.customLayers = customLayers
            self.politicalView = politicalView
        }
    }

}

extension LocationClientTypes {
    public enum OptimizationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fastestroute
        case shortestroute
        case sdkUnknown(Swift.String)

        public static var allCases: [OptimizationMode] {
            return [
                .fastestroute,
                .shortestroute,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fastestroute: return "FastestRoute"
            case .shortestroute: return "ShortestRoute"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OptimizationMode(rawValue: rawValue) ?? OptimizationMode.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes.Place: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressNumber = "AddressNumber"
        case categories = "Categories"
        case country = "Country"
        case geometry = "Geometry"
        case interpolated = "Interpolated"
        case label = "Label"
        case municipality = "Municipality"
        case neighborhood = "Neighborhood"
        case postalCode = "PostalCode"
        case region = "Region"
        case street = "Street"
        case subMunicipality = "SubMunicipality"
        case subRegion = "SubRegion"
        case supplementalCategories = "SupplementalCategories"
        case timeZone = "TimeZone"
        case unitNumber = "UnitNumber"
        case unitType = "UnitType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressNumber = self.addressNumber {
            try encodeContainer.encode(addressNumber, forKey: .addressNumber)
        }
        if let categories = categories {
            var categoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categories)
            for placecategory0 in categories {
                try categoriesContainer.encode(placecategory0)
            }
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let geometry = self.geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
        if let interpolated = self.interpolated {
            try encodeContainer.encode(interpolated, forKey: .interpolated)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let municipality = self.municipality {
            try encodeContainer.encode(municipality, forKey: .municipality)
        }
        if let neighborhood = self.neighborhood {
            try encodeContainer.encode(neighborhood, forKey: .neighborhood)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let street = self.street {
            try encodeContainer.encode(street, forKey: .street)
        }
        if let subMunicipality = self.subMunicipality {
            try encodeContainer.encode(subMunicipality, forKey: .subMunicipality)
        }
        if let subRegion = self.subRegion {
            try encodeContainer.encode(subRegion, forKey: .subRegion)
        }
        if let supplementalCategories = supplementalCategories {
            var supplementalCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supplementalCategories)
            for placesupplementalcategory0 in supplementalCategories {
                try supplementalCategoriesContainer.encode(placesupplementalcategory0)
            }
        }
        if let timeZone = self.timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
        if let unitNumber = self.unitNumber {
            try encodeContainer.encode(unitNumber, forKey: .unitNumber)
        }
        if let unitType = self.unitType {
            try encodeContainer.encode(unitType, forKey: .unitType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PlaceGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let addressNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressNumber)
        addressNumber = addressNumberDecoded
        let streetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street)
        street = streetDecoded
        let neighborhoodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .neighborhood)
        neighborhood = neighborhoodDecoded
        let municipalityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .municipality)
        municipality = municipalityDecoded
        let subRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subRegion)
        subRegion = subRegionDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let interpolatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .interpolated)
        interpolated = interpolatedDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(LocationClientTypes.TimeZone.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let unitTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unitType)
        unitType = unitTypeDecoded
        let unitNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unitNumber)
        unitNumber = unitNumberDecoded
        let categoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .categories)
        var categoriesDecoded0:[Swift.String]? = nil
        if let categoriesContainer = categoriesContainer {
            categoriesDecoded0 = [Swift.String]()
            for string0 in categoriesContainer {
                if let string0 = string0 {
                    categoriesDecoded0?.append(string0)
                }
            }
        }
        categories = categoriesDecoded0
        let supplementalCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supplementalCategories)
        var supplementalCategoriesDecoded0:[Swift.String]? = nil
        if let supplementalCategoriesContainer = supplementalCategoriesContainer {
            supplementalCategoriesDecoded0 = [Swift.String]()
            for string0 in supplementalCategoriesContainer {
                if let string0 = string0 {
                    supplementalCategoriesDecoded0?.append(string0)
                }
            }
        }
        supplementalCategories = supplementalCategoriesDecoded0
        let subMunicipalityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subMunicipality)
        subMunicipality = subMunicipalityDecoded
    }
}

extension LocationClientTypes {
    /// Contains details about addresses or points of interest that match the search criteria. Not all details are included with all responses. Some details may only be returned by specific data partners.
    public struct Place: Swift.Equatable {
        /// The numerical portion of an address, such as a building number.
        public var addressNumber: Swift.String?
        /// The Amazon Location categories that describe this Place. For more information about using categories, including a list of Amazon Location categories, see [Categories and filtering](https://docs.aws.amazon.com/location/latest/developerguide/category-filtering.html), in the Amazon Location Service Developer Guide.
        public var categories: [Swift.String]?
        /// A country/region specified using [ISO 3166](https://www.iso.org/iso-3166-country-codes.html) 3-digit country/region code. For example, CAN.
        public var country: Swift.String?
        /// Places uses a point geometry to specify a location or a Place.
        /// This member is required.
        public var geometry: LocationClientTypes.PlaceGeometry?
        /// True if the result is interpolated from other known places. False if the Place is a known place. Not returned when the partner does not provide the information. For example, returns False for an address location that is found in the partner data, but returns True if an address does not exist in the partner data and its location is calculated by interpolating between other known addresses.
        public var interpolated: Swift.Bool?
        /// The full name and address of the point of interest such as a city, region, or country. For example, 123 Any Street, Any Town, USA.
        public var label: Swift.String?
        /// A name for a local area, such as a city or town name. For example, Toronto.
        public var municipality: Swift.String?
        /// The name of a community district. For example, Downtown.
        public var neighborhood: Swift.String?
        /// A group of numbers and letters in a country-specific format, which accompanies the address for the purpose of identifying a location.
        public var postalCode: Swift.String?
        /// A name for an area or geographical division, such as a province or state name. For example, British Columbia.
        public var region: Swift.String?
        /// The name for a street or a road to identify a location. For example, Main Street.
        public var street: Swift.String?
        /// An area that's part of a larger municipality. For example, Blissville is a submunicipality in the Queen County in New York. This property is only returned for a place index that uses Esri as a data provider. The property is represented as a district. For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        public var subMunicipality: Swift.String?
        /// A county, or an area that's part of a larger region. For example, Metro Vancouver.
        public var subRegion: Swift.String?
        /// Categories from the data provider that describe the Place that are not mapped to any Amazon Location categories.
        public var supplementalCategories: [Swift.String]?
        /// The time zone in which the Place is located. Returned only when using HERE or Grab as the selected partner.
        public var timeZone: LocationClientTypes.TimeZone?
        /// For addresses with multiple units, the unit identifier. Can include numbers and letters, for example 3B or Unit 123. This property is returned only for a place index that uses Esri or Grab as a data provider. It is not returned for SearchPlaceIndexForPosition.
        public var unitNumber: Swift.String?
        /// For addresses with a UnitNumber, the type of unit. For example, Apartment. This property is returned only for a place index that uses Esri as a data provider.
        public var unitType: Swift.String?

        public init(
            addressNumber: Swift.String? = nil,
            categories: [Swift.String]? = nil,
            country: Swift.String? = nil,
            geometry: LocationClientTypes.PlaceGeometry? = nil,
            interpolated: Swift.Bool? = nil,
            label: Swift.String? = nil,
            municipality: Swift.String? = nil,
            neighborhood: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            region: Swift.String? = nil,
            street: Swift.String? = nil,
            subMunicipality: Swift.String? = nil,
            subRegion: Swift.String? = nil,
            supplementalCategories: [Swift.String]? = nil,
            timeZone: LocationClientTypes.TimeZone? = nil,
            unitNumber: Swift.String? = nil,
            unitType: Swift.String? = nil
        )
        {
            self.addressNumber = addressNumber
            self.categories = categories
            self.country = country
            self.geometry = geometry
            self.interpolated = interpolated
            self.label = label
            self.municipality = municipality
            self.neighborhood = neighborhood
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.subMunicipality = subMunicipality
            self.subRegion = subRegion
            self.supplementalCategories = supplementalCategories
            self.timeZone = timeZone
            self.unitNumber = unitNumber
            self.unitType = unitType
        }
    }

}

extension LocationClientTypes.PlaceGeometry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case point = "Point"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let point = point {
            var pointContainer = encodeContainer.nestedUnkeyedContainer(forKey: .point)
            for double0 in point {
                try pointContainer.encode(double0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pointContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .point)
        var pointDecoded0:[Swift.Double]? = nil
        if let pointContainer = pointContainer {
            pointDecoded0 = [Swift.Double]()
            for double0 in pointContainer {
                if let double0 = double0 {
                    pointDecoded0?.append(double0)
                }
            }
        }
        point = pointDecoded0
    }
}

extension LocationClientTypes.PlaceGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlaceGeometry(point: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Places uses a point geometry to specify a location or a Place.
    public struct PlaceGeometry: Swift.Equatable {
        /// A single point geometry specifies a location for a Place using [WGS 84](https://gisgeography.com/wgs84-world-geodetic-system/) coordinates:
        ///
        /// * x — Specifies the x coordinate or longitude.
        ///
        /// * y — Specifies the y coordinate or latitude.
        public var point: [Swift.Double]?

        public init(
            point: [Swift.Double]? = nil
        )
        {
            self.point = point
        }
    }

}

extension LocationClientTypes {
    public enum PositionFiltering: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Filters device position updates according to their accuracy
        case accuracybased
        /// Filters device position updates according to the distance between them
        case distancebased
        /// Filters device position updates according to their sample time
        case timebased
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionFiltering] {
            return [
                .accuracybased,
                .distancebased,
                .timebased,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accuracybased: return "AccuracyBased"
            case .distancebased: return "DistanceBased"
            case .timebased: return "TimeBased"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PositionFiltering(rawValue: rawValue) ?? PositionFiltering.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes.PositionalAccuracy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case horizontal = "Horizontal"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let horizontal = self.horizontal {
            try encodeContainer.encode(horizontal, forKey: .horizontal)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let horizontalDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .horizontal)
        horizontal = horizontalDecoded
    }
}

extension LocationClientTypes {
    /// Defines the level of certainty of the position.
    public struct PositionalAccuracy: Swift.Equatable {
        /// Estimated maximum distance, in meters, between the measured position and the true position of a device, along the Earth's surface.
        /// This member is required.
        public var horizontal: Swift.Double?

        public init(
            horizontal: Swift.Double? = nil
        )
        {
            self.horizontal = horizontal
        }
    }

}

extension LocationClientTypes {
    public enum PricingPlan: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// This pricing plan must be picked for mobile asset management use cases
        case mobileassetmanagement
        /// This pricing plan must be picked for mobile asset tracking use cases.
        case mobileassettracking
        /// This pricing plan should be used for request based billing.
        case requestbasedusage
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingPlan] {
            return [
                .mobileassetmanagement,
                .mobileassettracking,
                .requestbasedusage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mobileassetmanagement: return "MobileAssetManagement"
            case .mobileassettracking: return "MobileAssetTracking"
            case .requestbasedusage: return "RequestBasedUsage"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PricingPlan(rawValue: rawValue) ?? PricingPlan.sdkUnknown(rawValue)
        }
    }
}

extension PutGeofenceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutGeofenceInput(collectionName: \(Swift.String(describing: collectionName)), geofenceId: \(Swift.String(describing: geofenceId)), geometry: \(Swift.String(describing: geometry)), geofenceProperties: \"CONTENT_REDACTED\")"}
}

extension PutGeofenceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geofenceProperties = "GeofenceProperties"
        case geometry = "Geometry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geofenceProperties = geofenceProperties {
            var geofencePropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .geofenceProperties)
            for (dictKey0, propertyMap0) in geofenceProperties {
                try geofencePropertiesContainer.encode(propertyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let geometry = self.geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
    }
}

extension PutGeofenceInput {

    static func urlPathProvider(_ value: PutGeofenceInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        guard let geofenceId = value.geofenceId else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/geofences/\(geofenceId.urlPercentEncoding())"
    }
}

public struct PutGeofenceInput: Swift.Equatable {
    /// The geofence collection to store the geofence in.
    /// This member is required.
    public var collectionName: Swift.String?
    /// An identifier for the geofence. For example, ExampleGeofence-1.
    /// This member is required.
    public var geofenceId: Swift.String?
    /// Associates one of more properties with the geofence. A property is a key-value pair stored with the geofence and added to any geofence event triggered with that geofence. Format: "key" : "value"
    public var geofenceProperties: [Swift.String:Swift.String]?
    /// Contains the details to specify the position of the geofence. Can be either a polygon or a circle. Including both will return a validation error. Each [ geofence polygon](https://docs.aws.amazon.com/location-geofences/latest/APIReference/API_GeofenceGeometry.html) can have a maximum of 1,000 vertices.
    /// This member is required.
    public var geometry: LocationClientTypes.GeofenceGeometry?

    public init(
        collectionName: Swift.String? = nil,
        geofenceId: Swift.String? = nil,
        geofenceProperties: [Swift.String:Swift.String]? = nil,
        geometry: LocationClientTypes.GeofenceGeometry? = nil
    )
    {
        self.collectionName = collectionName
        self.geofenceId = geofenceId
        self.geofenceProperties = geofenceProperties
        self.geometry = geometry
    }
}

struct PutGeofenceInputBody: Swift.Equatable {
    let geometry: LocationClientTypes.GeofenceGeometry?
    let geofenceProperties: [Swift.String:Swift.String]?
}

extension PutGeofenceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geofenceProperties = "GeofenceProperties"
        case geometry = "Geometry"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.GeofenceGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let geofencePropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .geofenceProperties)
        var geofencePropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let geofencePropertiesContainer = geofencePropertiesContainer {
            geofencePropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in geofencePropertiesContainer {
                if let string0 = string0 {
                    geofencePropertiesDecoded0?[key0] = string0
                }
            }
        }
        geofenceProperties = geofencePropertiesDecoded0
    }
}

extension PutGeofenceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutGeofenceOutputBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.geofenceId = output.geofenceId
            self.updateTime = output.updateTime
        } else {
            self.createTime = nil
            self.geofenceId = nil
            self.updateTime = nil
        }
    }
}

public struct PutGeofenceOutput: Swift.Equatable {
    /// The timestamp for when the geofence was created in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The geofence identifier entered in the request.
    /// This member is required.
    public var geofenceId: Swift.String?
    /// The timestamp for when the geofence was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        createTime: ClientRuntime.Date? = nil,
        geofenceId: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.geofenceId = geofenceId
        self.updateTime = updateTime
    }
}

struct PutGeofenceOutputBody: Swift.Equatable {
    let geofenceId: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
}

extension PutGeofenceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case geofenceId = "GeofenceId"
        case updateTime = "UpdateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

enum PutGeofenceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource that you've entered was not found in your AWS account.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes.RouteMatrixEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distance = "Distance"
        case durationSeconds = "DurationSeconds"
        case error = "Error"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distance = self.distance {
            try encodeContainer.encode(distance, forKey: .distance)
        }
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .distance)
        distance = distanceDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.RouteMatrixEntryError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes {
    /// The result for the calculated route of one DeparturePositionDestinationPosition pair.
    public struct RouteMatrixEntry: Swift.Equatable {
        /// The total distance of travel for the route.
        public var distance: Swift.Double?
        /// The expected duration of travel for the route.
        public var durationSeconds: Swift.Double?
        /// An error corresponding to the calculation of a route between the DeparturePosition and DestinationPosition.
        public var error: LocationClientTypes.RouteMatrixEntryError?

        public init(
            distance: Swift.Double? = nil,
            durationSeconds: Swift.Double? = nil,
            error: LocationClientTypes.RouteMatrixEntryError? = nil
        )
        {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.error = error
        }
    }

}

extension LocationClientTypes.RouteMatrixEntryError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.RouteMatrixErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes {
    /// An error corresponding to the calculation of a route between the DeparturePosition and DestinationPosition. The error code can be one of the following:
    ///
    /// * RouteNotFound - Unable to find a valid route with the given parameters.
    ///
    ///
    ///
    ///
    /// * RouteTooLong - Route calculation went beyond the maximum size of a route and was terminated before completion.
    ///
    ///
    ///
    ///
    /// * PositionsNotFound - One or more of the input positions were not found on the route network.
    ///
    ///
    ///
    ///
    /// * DestinationPositionNotFound - The destination position was not found on the route network.
    ///
    ///
    ///
    ///
    /// * DeparturePositionNotFound - The departure position was not found on the route network.
    ///
    ///
    ///
    ///
    /// * OtherValidationError - The given inputs were not valid or a route was not found. More information is given in the error Message
    public struct RouteMatrixEntryError: Swift.Equatable {
        /// The type of error which occurred for the route calculation.
        /// This member is required.
        public var code: LocationClientTypes.RouteMatrixErrorCode?
        /// A message about the error that occurred for the route calculation.
        public var message: Swift.String?

        public init(
            code: LocationClientTypes.RouteMatrixErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension LocationClientTypes {
    public enum RouteMatrixErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case departurepositionnotfound
        case destinationpositionnotfound
        case othervalidationerror
        case positionsnotfound
        case routenotfound
        case routetoolong
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteMatrixErrorCode] {
            return [
                .departurepositionnotfound,
                .destinationpositionnotfound,
                .othervalidationerror,
                .positionsnotfound,
                .routenotfound,
                .routetoolong,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .departurepositionnotfound: return "DeparturePositionNotFound"
            case .destinationpositionnotfound: return "DestinationPositionNotFound"
            case .othervalidationerror: return "OtherValidationError"
            case .positionsnotfound: return "PositionsNotFound"
            case .routenotfound: return "RouteNotFound"
            case .routetoolong: return "RouteTooLong"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteMatrixErrorCode(rawValue: rawValue) ?? RouteMatrixErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes.SearchForPositionResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distance = "Distance"
        case place = "Place"
        case placeId = "PlaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distance = self.distance {
            try encodeContainer.encode(distance, forKey: .distance)
        }
        if let place = self.place {
            try encodeContainer.encode(place, forKey: .place)
        }
        if let placeId = self.placeId {
            try encodeContainer.encode(placeId, forKey: .placeId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.Place.self, forKey: .place)
        place = placeDecoded
        let distanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .distance)
        distance = distanceDecoded
        let placeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placeId)
        placeId = placeIdDecoded
    }
}

extension LocationClientTypes {
    /// Contains a search result from a position search query that is run on a place index resource.
    public struct SearchForPositionResult: Swift.Equatable {
        /// The distance in meters of a great-circle arc between the query position and the result. A great-circle arc is the shortest path on a sphere, in this case the Earth. This returns the shortest distance between two locations.
        /// This member is required.
        public var distance: Swift.Double?
        /// Details about the search result, such as its address and position.
        /// This member is required.
        public var place: LocationClientTypes.Place?
        /// The unique identifier of the place. You can use this with the GetPlace operation to find the place again later. For SearchPlaceIndexForPosition operations, the PlaceId is returned only by place indexes that use HERE or Grab as a data provider.
        public var placeId: Swift.String?

        public init(
            distance: Swift.Double? = nil,
            place: LocationClientTypes.Place? = nil,
            placeId: Swift.String? = nil
        )
        {
            self.distance = distance
            self.place = place
            self.placeId = placeId
        }
    }

}

extension LocationClientTypes.SearchForSuggestionsResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categories = "Categories"
        case placeId = "PlaceId"
        case supplementalCategories = "SupplementalCategories"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categories = categories {
            var categoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categories)
            for placecategory0 in categories {
                try categoriesContainer.encode(placecategory0)
            }
        }
        if let placeId = self.placeId {
            try encodeContainer.encode(placeId, forKey: .placeId)
        }
        if let supplementalCategories = supplementalCategories {
            var supplementalCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supplementalCategories)
            for placesupplementalcategory0 in supplementalCategories {
                try supplementalCategoriesContainer.encode(placesupplementalcategory0)
            }
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let placeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placeId)
        placeId = placeIdDecoded
        let categoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .categories)
        var categoriesDecoded0:[Swift.String]? = nil
        if let categoriesContainer = categoriesContainer {
            categoriesDecoded0 = [Swift.String]()
            for string0 in categoriesContainer {
                if let string0 = string0 {
                    categoriesDecoded0?.append(string0)
                }
            }
        }
        categories = categoriesDecoded0
        let supplementalCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supplementalCategories)
        var supplementalCategoriesDecoded0:[Swift.String]? = nil
        if let supplementalCategoriesContainer = supplementalCategoriesContainer {
            supplementalCategoriesDecoded0 = [Swift.String]()
            for string0 in supplementalCategoriesContainer {
                if let string0 = string0 {
                    supplementalCategoriesDecoded0?.append(string0)
                }
            }
        }
        supplementalCategories = supplementalCategoriesDecoded0
    }
}

extension LocationClientTypes {
    /// Contains a place suggestion resulting from a place suggestion query that is run on a place index resource.
    public struct SearchForSuggestionsResult: Swift.Equatable {
        /// The Amazon Location categories that describe the Place. For more information about using categories, including a list of Amazon Location categories, see [Categories and filtering](https://docs.aws.amazon.com/location/latest/developerguide/category-filtering.html), in the Amazon Location Service Developer Guide.
        public var categories: [Swift.String]?
        /// The unique identifier of the Place. You can use this with the GetPlace operation to find the place again later, or to get full information for the Place. The GetPlace request must use the same PlaceIndex resource as the SearchPlaceIndexForSuggestions that generated the Place ID. For SearchPlaceIndexForSuggestions operations, the PlaceId is returned by place indexes that use Esri, Grab, or HERE as data providers. While you can use PlaceID in subsequent requests, PlaceID is not intended to be a permanent identifier and the ID can change between consecutive API calls. Please see the following PlaceID behaviour for each data provider:
        ///
        /// * Esri: Place IDs will change every quarter at a minimum. The typical time period for these changes would be March, June, September, and December. Place IDs might also change between the typical quarterly change but that will be much less frequent.
        ///
        /// * HERE: We recommend that you cache data for no longer than a week to keep your data data fresh. You can assume that less than 1% ID shifts will release over release which is approximately 1 - 2 times per week.
        ///
        /// * Grab: Place IDs can expire or become invalid in the following situations.
        ///
        /// * Data operations: The POI may be removed from Grab POI database by Grab Map Ops based on the ground-truth, such as being closed in the real world, being detected as a duplicate POI, or having incorrect information. Grab will synchronize data to the Waypoint environment on weekly basis.
        ///
        /// * Interpolated POI: Interpolated POI is a temporary POI generated in real time when serving a request, and it will be marked as derived in the place.result_type field in the response. The information of interpolated POIs will be retained for at least 30 days, which means that within 30 days, you are able to obtain POI details by Place ID from Place Details API. After 30 days, the interpolated POIs(both Place ID and details) may expire and inaccessible from the Places Details API.
        public var placeId: Swift.String?
        /// Categories from the data provider that describe the Place that are not mapped to any Amazon Location categories.
        public var supplementalCategories: [Swift.String]?
        /// The text of the place suggestion, typically formatted as an address string.
        /// This member is required.
        public var text: Swift.String?

        public init(
            categories: [Swift.String]? = nil,
            placeId: Swift.String? = nil,
            supplementalCategories: [Swift.String]? = nil,
            text: Swift.String? = nil
        )
        {
            self.categories = categories
            self.placeId = placeId
            self.supplementalCategories = supplementalCategories
            self.text = text
        }
    }

}

extension LocationClientTypes.SearchForTextResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distance = "Distance"
        case place = "Place"
        case placeId = "PlaceId"
        case relevance = "Relevance"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distance = self.distance {
            try encodeContainer.encode(distance, forKey: .distance)
        }
        if let place = self.place {
            try encodeContainer.encode(place, forKey: .place)
        }
        if let placeId = self.placeId {
            try encodeContainer.encode(placeId, forKey: .placeId)
        }
        if let relevance = self.relevance {
            try encodeContainer.encode(relevance, forKey: .relevance)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.Place.self, forKey: .place)
        place = placeDecoded
        let distanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .distance)
        distance = distanceDecoded
        let relevanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .relevance)
        relevance = relevanceDecoded
        let placeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placeId)
        placeId = placeIdDecoded
    }
}

extension LocationClientTypes {
    /// Contains a search result from a text search query that is run on a place index resource.
    public struct SearchForTextResult: Swift.Equatable {
        /// The distance in meters of a great-circle arc between the bias position specified and the result. Distance will be returned only if a bias position was specified in the query. A great-circle arc is the shortest path on a sphere, in this case the Earth. This returns the shortest distance between two locations.
        public var distance: Swift.Double?
        /// Details about the search result, such as its address and position.
        /// This member is required.
        public var place: LocationClientTypes.Place?
        /// The unique identifier of the place. You can use this with the GetPlace operation to find the place again later. For SearchPlaceIndexForText operations, the PlaceId is returned only by place indexes that use HERE or Grab as a data provider.
        public var placeId: Swift.String?
        /// The relative confidence in the match for a result among the results returned. For example, if more fields for an address match (including house number, street, city, country/region, and postal code), the relevance score is closer to 1. Returned only when the partner selected is Esri or Grab.
        public var relevance: Swift.Double?

        public init(
            distance: Swift.Double? = nil,
            place: LocationClientTypes.Place? = nil,
            placeId: Swift.String? = nil,
            relevance: Swift.Double? = nil
        )
        {
            self.distance = distance
            self.place = place
            self.placeId = placeId
            self.relevance = relevance
        }
    }

}

extension SearchPlaceIndexForPositionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForPositionInput(indexName: \(Swift.String(describing: indexName)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), key: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

extension SearchPlaceIndexForPositionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language = "Language"
        case maxResults = "MaxResults"
        case position = "Position"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for double0 in position {
                try positionContainer.encode(double0)
            }
        }
    }
}

extension SearchPlaceIndexForPositionInput {

    static func queryItemProvider(_ value: SearchPlaceIndexForPositionInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension SearchPlaceIndexForPositionInput {

    static func urlPathProvider(_ value: SearchPlaceIndexForPositionInput) -> Swift.String? {
        guard let indexName = value.indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())/search/position"
    }
}

public struct SearchPlaceIndexForPositionInput: Swift.Equatable {
    /// The name of the place index resource you want to use for the search.
    /// This member is required.
    public var indexName: Swift.String?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The preferred language used to return results. The value must be a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for a location around Athens, Greece, with the language parameter set to en. The city in the results will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the city in the results will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    public var language: Swift.String?
    /// An optional parameter. The maximum number of results returned per request. Default value: 50
    public var maxResults: Swift.Int?
    /// Specifies the longitude and latitude of the position to query. This parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents a position with longitude -123.1174 and latitude 49.2847.
    /// This member is required.
    public var position: [Swift.Double]?

    public init(
        indexName: Swift.String? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        position: [Swift.Double]? = nil
    )
    {
        self.indexName = indexName
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.position = position
    }
}

struct SearchPlaceIndexForPositionInputBody: Swift.Equatable {
    let position: [Swift.Double]?
    let maxResults: Swift.Int?
    let language: Swift.String?
}

extension SearchPlaceIndexForPositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language = "Language"
        case maxResults = "MaxResults"
        case position = "Position"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension SearchPlaceIndexForPositionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchPlaceIndexForPositionOutputBody = try responseDecoder.decode(responseBody: data)
            self.results = output.results
            self.summary = output.summary
        } else {
            self.results = nil
            self.summary = nil
        }
    }
}

public struct SearchPlaceIndexForPositionOutput: Swift.Equatable {
    /// Returns a list of Places closest to the specified position. Each result contains additional information about the Places returned.
    /// This member is required.
    public var results: [LocationClientTypes.SearchForPositionResult]?
    /// Contains a summary of the request. Echoes the input values for Position, Language, MaxResults, and the DataSource of the place index.
    /// This member is required.
    public var summary: LocationClientTypes.SearchPlaceIndexForPositionSummary?

    public init(
        results: [LocationClientTypes.SearchForPositionResult]? = nil,
        summary: LocationClientTypes.SearchPlaceIndexForPositionSummary? = nil
    )
    {
        self.results = results
        self.summary = summary
    }
}

struct SearchPlaceIndexForPositionOutputBody: Swift.Equatable {
    let summary: LocationClientTypes.SearchPlaceIndexForPositionSummary?
    let results: [LocationClientTypes.SearchForPositionResult]?
}

extension SearchPlaceIndexForPositionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
        case summary = "Summary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.SearchPlaceIndexForPositionSummary.self, forKey: .summary)
        summary = summaryDecoded
        let resultsContainer = try containerValues.decodeIfPresent([LocationClientTypes.SearchForPositionResult?].self, forKey: .results)
        var resultsDecoded0:[LocationClientTypes.SearchForPositionResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [LocationClientTypes.SearchForPositionResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

enum SearchPlaceIndexForPositionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.SearchPlaceIndexForPositionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case language = "Language"
        case maxResults = "MaxResults"
        case position = "Position"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for double0 in position {
                try positionContainer.encode(double0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension LocationClientTypes.SearchPlaceIndexForPositionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForPositionSummary(dataSource: \(Swift.String(describing: dataSource)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), position: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// A summary of the request sent by using SearchPlaceIndexForPosition.
    public struct SearchPlaceIndexForPositionSummary: Swift.Equatable {
        /// The geospatial data provider attached to the place index resource specified in the request. Values can be one of the following:
        ///
        /// * Esri
        ///
        /// * Grab
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// The preferred language used to return results. Matches the language in the request. The value is a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English.
        public var language: Swift.String?
        /// Contains the optional result count limit that is specified in the request. Default value: 50
        public var maxResults: Swift.Int?
        /// The position specified in the request.
        /// This member is required.
        public var position: [Swift.Double]?

        public init(
            dataSource: Swift.String? = nil,
            language: Swift.String? = nil,
            maxResults: Swift.Int? = nil,
            position: [Swift.Double]? = nil
        )
        {
            self.dataSource = dataSource
            self.language = language
            self.maxResults = maxResults
            self.position = position
        }
    }

}

extension SearchPlaceIndexForSuggestionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForSuggestionsInput(filterCategories: \(Swift.String(describing: filterCategories)), filterCountries: \(Swift.String(describing: filterCountries)), indexName: \(Swift.String(describing: indexName)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), biasPosition: \"CONTENT_REDACTED\", filterBBox: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension SearchPlaceIndexForSuggestionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case biasPosition = "BiasPosition"
        case filterBBox = "FilterBBox"
        case filterCategories = "FilterCategories"
        case filterCountries = "FilterCountries"
        case language = "Language"
        case maxResults = "MaxResults"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let biasPosition = biasPosition {
            var biasPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .biasPosition)
            for double0 in biasPosition {
                try biasPositionContainer.encode(double0)
            }
        }
        if let filterBBox = filterBBox {
            var filterBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterBBox)
            for double0 in filterBBox {
                try filterBBoxContainer.encode(double0)
            }
        }
        if let filterCategories = filterCategories {
            var filterCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCategories)
            for placecategory0 in filterCategories {
                try filterCategoriesContainer.encode(placecategory0)
            }
        }
        if let filterCountries = filterCountries {
            var filterCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCountries)
            for countrycode0 in filterCountries {
                try filterCountriesContainer.encode(countrycode0)
            }
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension SearchPlaceIndexForSuggestionsInput {

    static func queryItemProvider(_ value: SearchPlaceIndexForSuggestionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension SearchPlaceIndexForSuggestionsInput {

    static func urlPathProvider(_ value: SearchPlaceIndexForSuggestionsInput) -> Swift.String? {
        guard let indexName = value.indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())/search/suggestions"
    }
}

public struct SearchPlaceIndexForSuggestionsInput: Swift.Equatable {
    /// An optional parameter that indicates a preference for place suggestions that are closer to a specified position. If provided, this parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847. BiasPosition and FilterBBox are mutually exclusive. Specifying both options results in an error.
    public var biasPosition: [Swift.Double]?
    /// An optional parameter that limits the search results by returning only suggestions within a specified bounding box. If provided, this parameter must contain a total of four consecutive numbers in two pairs. The first pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the southwest corner of the bounding box; the second pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the northeast corner of the bounding box. For example, [-12.7935, -37.4835, -12.0684, -36.9542] represents a bounding box where the southwest corner has longitude -12.7935 and latitude -37.4835, and the northeast corner has longitude -12.0684 and latitude -36.9542. FilterBBox and BiasPosition are mutually exclusive. Specifying both options results in an error.
    public var filterBBox: [Swift.Double]?
    /// A list of one or more Amazon Location categories to filter the returned places. If you include more than one category, the results will include results that match any of the categories listed. For more information about using categories, including a list of Amazon Location categories, see [Categories and filtering](https://docs.aws.amazon.com/location/latest/developerguide/category-filtering.html), in the Amazon Location Service Developer Guide.
    public var filterCategories: [Swift.String]?
    /// An optional parameter that limits the search results by returning only suggestions within the provided list of countries.
    ///
    /// * Use the [ISO 3166](https://www.iso.org/iso-3166-country-codes.html) 3-digit country code. For example, Australia uses three upper-case characters: AUS.
    public var filterCountries: [Swift.String]?
    /// The name of the place index resource you want to use for the search.
    /// This member is required.
    public var indexName: Swift.String?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The preferred language used to return results. The value must be a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English. This setting affects the languages used in the results. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for Athens, Gr to get suggestions with the language parameter set to en. The results found will most likely be returned as Athens, Greece. If you set the language parameter to el, for Greek, then the result found will more likely be returned as Αθήνα, Ελλάδα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    public var language: Swift.String?
    /// An optional parameter. The maximum number of results returned per request. The default: 5
    public var maxResults: Swift.Int?
    /// The free-form partial text to use to generate place suggestions. For example, eiffel tow.
    /// This member is required.
    public var text: Swift.String?

    public init(
        biasPosition: [Swift.Double]? = nil,
        filterBBox: [Swift.Double]? = nil,
        filterCategories: [Swift.String]? = nil,
        filterCountries: [Swift.String]? = nil,
        indexName: Swift.String? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        text: Swift.String? = nil
    )
    {
        self.biasPosition = biasPosition
        self.filterBBox = filterBBox
        self.filterCategories = filterCategories
        self.filterCountries = filterCountries
        self.indexName = indexName
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.text = text
    }
}

struct SearchPlaceIndexForSuggestionsInputBody: Swift.Equatable {
    let text: Swift.String?
    let biasPosition: [Swift.Double]?
    let filterBBox: [Swift.Double]?
    let filterCountries: [Swift.String]?
    let maxResults: Swift.Int?
    let language: Swift.String?
    let filterCategories: [Swift.String]?
}

extension SearchPlaceIndexForSuggestionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case biasPosition = "BiasPosition"
        case filterBBox = "FilterBBox"
        case filterCategories = "FilterCategories"
        case filterCountries = "FilterCountries"
        case language = "Language"
        case maxResults = "MaxResults"
        case text = "Text"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let biasPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .biasPosition)
        var biasPositionDecoded0:[Swift.Double]? = nil
        if let biasPositionContainer = biasPositionContainer {
            biasPositionDecoded0 = [Swift.Double]()
            for double0 in biasPositionContainer {
                if let double0 = double0 {
                    biasPositionDecoded0?.append(double0)
                }
            }
        }
        biasPosition = biasPositionDecoded0
        let filterBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .filterBBox)
        var filterBBoxDecoded0:[Swift.Double]? = nil
        if let filterBBoxContainer = filterBBoxContainer {
            filterBBoxDecoded0 = [Swift.Double]()
            for double0 in filterBBoxContainer {
                if let double0 = double0 {
                    filterBBoxDecoded0?.append(double0)
                }
            }
        }
        filterBBox = filterBBoxDecoded0
        let filterCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterCountries)
        var filterCountriesDecoded0:[Swift.String]? = nil
        if let filterCountriesContainer = filterCountriesContainer {
            filterCountriesDecoded0 = [Swift.String]()
            for string0 in filterCountriesContainer {
                if let string0 = string0 {
                    filterCountriesDecoded0?.append(string0)
                }
            }
        }
        filterCountries = filterCountriesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let filterCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterCategories)
        var filterCategoriesDecoded0:[Swift.String]? = nil
        if let filterCategoriesContainer = filterCategoriesContainer {
            filterCategoriesDecoded0 = [Swift.String]()
            for string0 in filterCategoriesContainer {
                if let string0 = string0 {
                    filterCategoriesDecoded0?.append(string0)
                }
            }
        }
        filterCategories = filterCategoriesDecoded0
    }
}

extension SearchPlaceIndexForSuggestionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchPlaceIndexForSuggestionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.results = output.results
            self.summary = output.summary
        } else {
            self.results = nil
            self.summary = nil
        }
    }
}

public struct SearchPlaceIndexForSuggestionsOutput: Swift.Equatable {
    /// A list of place suggestions that best match the search text.
    /// This member is required.
    public var results: [LocationClientTypes.SearchForSuggestionsResult]?
    /// Contains a summary of the request. Echoes the input values for BiasPosition, FilterBBox, FilterCountries, Language, MaxResults, and Text. Also includes the DataSource of the place index.
    /// This member is required.
    public var summary: LocationClientTypes.SearchPlaceIndexForSuggestionsSummary?

    public init(
        results: [LocationClientTypes.SearchForSuggestionsResult]? = nil,
        summary: LocationClientTypes.SearchPlaceIndexForSuggestionsSummary? = nil
    )
    {
        self.results = results
        self.summary = summary
    }
}

struct SearchPlaceIndexForSuggestionsOutputBody: Swift.Equatable {
    let summary: LocationClientTypes.SearchPlaceIndexForSuggestionsSummary?
    let results: [LocationClientTypes.SearchForSuggestionsResult]?
}

extension SearchPlaceIndexForSuggestionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
        case summary = "Summary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.SearchPlaceIndexForSuggestionsSummary.self, forKey: .summary)
        summary = summaryDecoded
        let resultsContainer = try containerValues.decodeIfPresent([LocationClientTypes.SearchForSuggestionsResult?].self, forKey: .results)
        var resultsDecoded0:[LocationClientTypes.SearchForSuggestionsResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [LocationClientTypes.SearchForSuggestionsResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

enum SearchPlaceIndexForSuggestionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.SearchPlaceIndexForSuggestionsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case biasPosition = "BiasPosition"
        case dataSource = "DataSource"
        case filterBBox = "FilterBBox"
        case filterCategories = "FilterCategories"
        case filterCountries = "FilterCountries"
        case language = "Language"
        case maxResults = "MaxResults"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let biasPosition = biasPosition {
            var biasPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .biasPosition)
            for double0 in biasPosition {
                try biasPositionContainer.encode(double0)
            }
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let filterBBox = filterBBox {
            var filterBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterBBox)
            for double0 in filterBBox {
                try filterBBoxContainer.encode(double0)
            }
        }
        if let filterCategories = filterCategories {
            var filterCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCategories)
            for placecategory0 in filterCategories {
                try filterCategoriesContainer.encode(placecategory0)
            }
        }
        if let filterCountries = filterCountries {
            var filterCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCountries)
            for countrycode0 in filterCountries {
                try filterCountriesContainer.encode(countrycode0)
            }
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let biasPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .biasPosition)
        var biasPositionDecoded0:[Swift.Double]? = nil
        if let biasPositionContainer = biasPositionContainer {
            biasPositionDecoded0 = [Swift.Double]()
            for double0 in biasPositionContainer {
                if let double0 = double0 {
                    biasPositionDecoded0?.append(double0)
                }
            }
        }
        biasPosition = biasPositionDecoded0
        let filterBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .filterBBox)
        var filterBBoxDecoded0:[Swift.Double]? = nil
        if let filterBBoxContainer = filterBBoxContainer {
            filterBBoxDecoded0 = [Swift.Double]()
            for double0 in filterBBoxContainer {
                if let double0 = double0 {
                    filterBBoxDecoded0?.append(double0)
                }
            }
        }
        filterBBox = filterBBoxDecoded0
        let filterCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterCountries)
        var filterCountriesDecoded0:[Swift.String]? = nil
        if let filterCountriesContainer = filterCountriesContainer {
            filterCountriesDecoded0 = [Swift.String]()
            for string0 in filterCountriesContainer {
                if let string0 = string0 {
                    filterCountriesDecoded0?.append(string0)
                }
            }
        }
        filterCountries = filterCountriesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let filterCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterCategories)
        var filterCategoriesDecoded0:[Swift.String]? = nil
        if let filterCategoriesContainer = filterCategoriesContainer {
            filterCategoriesDecoded0 = [Swift.String]()
            for string0 in filterCategoriesContainer {
                if let string0 = string0 {
                    filterCategoriesDecoded0?.append(string0)
                }
            }
        }
        filterCategories = filterCategoriesDecoded0
    }
}

extension LocationClientTypes.SearchPlaceIndexForSuggestionsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForSuggestionsSummary(dataSource: \(Swift.String(describing: dataSource)), filterCategories: \(Swift.String(describing: filterCategories)), filterCountries: \(Swift.String(describing: filterCountries)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), biasPosition: \"CONTENT_REDACTED\", filterBBox: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// A summary of the request sent by using SearchPlaceIndexForSuggestions.
    public struct SearchPlaceIndexForSuggestionsSummary: Swift.Equatable {
        /// Contains the coordinates for the optional bias position specified in the request. This parameter contains a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.
        public var biasPosition: [Swift.Double]?
        /// The geospatial data provider attached to the place index resource specified in the request. Values can be one of the following:
        ///
        /// * Esri
        ///
        /// * Grab
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// Contains the coordinates for the optional bounding box specified in the request.
        public var filterBBox: [Swift.Double]?
        /// The optional category filter specified in the request.
        public var filterCategories: [Swift.String]?
        /// Contains the optional country filter specified in the request.
        public var filterCountries: [Swift.String]?
        /// The preferred language used to return results. Matches the language in the request. The value is a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English.
        public var language: Swift.String?
        /// Contains the optional result count limit specified in the request.
        public var maxResults: Swift.Int?
        /// The free-form partial text input specified in the request.
        /// This member is required.
        public var text: Swift.String?

        public init(
            biasPosition: [Swift.Double]? = nil,
            dataSource: Swift.String? = nil,
            filterBBox: [Swift.Double]? = nil,
            filterCategories: [Swift.String]? = nil,
            filterCountries: [Swift.String]? = nil,
            language: Swift.String? = nil,
            maxResults: Swift.Int? = nil,
            text: Swift.String? = nil
        )
        {
            self.biasPosition = biasPosition
            self.dataSource = dataSource
            self.filterBBox = filterBBox
            self.filterCategories = filterCategories
            self.filterCountries = filterCountries
            self.language = language
            self.maxResults = maxResults
            self.text = text
        }
    }

}

extension SearchPlaceIndexForTextInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForTextInput(filterCategories: \(Swift.String(describing: filterCategories)), filterCountries: \(Swift.String(describing: filterCountries)), indexName: \(Swift.String(describing: indexName)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), biasPosition: \"CONTENT_REDACTED\", filterBBox: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension SearchPlaceIndexForTextInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case biasPosition = "BiasPosition"
        case filterBBox = "FilterBBox"
        case filterCategories = "FilterCategories"
        case filterCountries = "FilterCountries"
        case language = "Language"
        case maxResults = "MaxResults"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let biasPosition = biasPosition {
            var biasPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .biasPosition)
            for double0 in biasPosition {
                try biasPositionContainer.encode(double0)
            }
        }
        if let filterBBox = filterBBox {
            var filterBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterBBox)
            for double0 in filterBBox {
                try filterBBoxContainer.encode(double0)
            }
        }
        if let filterCategories = filterCategories {
            var filterCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCategories)
            for placecategory0 in filterCategories {
                try filterCategoriesContainer.encode(placecategory0)
            }
        }
        if let filterCountries = filterCountries {
            var filterCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCountries)
            for countrycode0 in filterCountries {
                try filterCountriesContainer.encode(countrycode0)
            }
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension SearchPlaceIndexForTextInput {

    static func queryItemProvider(_ value: SearchPlaceIndexForTextInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let key = value.key {
            let keyQueryItem = ClientRuntime.SDKURLQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension SearchPlaceIndexForTextInput {

    static func urlPathProvider(_ value: SearchPlaceIndexForTextInput) -> Swift.String? {
        guard let indexName = value.indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())/search/text"
    }
}

public struct SearchPlaceIndexForTextInput: Swift.Equatable {
    /// An optional parameter that indicates a preference for places that are closer to a specified position. If provided, this parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847. BiasPosition and FilterBBox are mutually exclusive. Specifying both options results in an error.
    public var biasPosition: [Swift.Double]?
    /// An optional parameter that limits the search results by returning only places that are within the provided bounding box. If provided, this parameter must contain a total of four consecutive numbers in two pairs. The first pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the southwest corner of the bounding box; the second pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the northeast corner of the bounding box. For example, [-12.7935, -37.4835, -12.0684, -36.9542] represents a bounding box where the southwest corner has longitude -12.7935 and latitude -37.4835, and the northeast corner has longitude -12.0684 and latitude -36.9542. FilterBBox and BiasPosition are mutually exclusive. Specifying both options results in an error.
    public var filterBBox: [Swift.Double]?
    /// A list of one or more Amazon Location categories to filter the returned places. If you include more than one category, the results will include results that match any of the categories listed. For more information about using categories, including a list of Amazon Location categories, see [Categories and filtering](https://docs.aws.amazon.com/location/latest/developerguide/category-filtering.html), in the Amazon Location Service Developer Guide.
    public var filterCategories: [Swift.String]?
    /// An optional parameter that limits the search results by returning only places that are in a specified list of countries.
    ///
    /// * Valid values include [ISO 3166](https://www.iso.org/iso-3166-country-codes.html) 3-digit country codes. For example, Australia uses three upper-case characters: AUS.
    public var filterCountries: [Swift.String]?
    /// The name of the place index resource you want to use for the search.
    /// This member is required.
    public var indexName: Swift.String?
    /// The optional [API key](https://docs.aws.amazon.com/location/latest/developerguide/using-apikeys.html) to authorize the request.
    public var key: Swift.String?
    /// The preferred language used to return results. The value must be a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for Athens, Greece, with the language parameter set to en. The result found will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the result found will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    public var language: Swift.String?
    /// An optional parameter. The maximum number of results returned per request. The default: 50
    public var maxResults: Swift.Int?
    /// The address, name, city, or region to be used in the search in free-form text format. For example, 123 Any Street.
    /// This member is required.
    public var text: Swift.String?

    public init(
        biasPosition: [Swift.Double]? = nil,
        filterBBox: [Swift.Double]? = nil,
        filterCategories: [Swift.String]? = nil,
        filterCountries: [Swift.String]? = nil,
        indexName: Swift.String? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        text: Swift.String? = nil
    )
    {
        self.biasPosition = biasPosition
        self.filterBBox = filterBBox
        self.filterCategories = filterCategories
        self.filterCountries = filterCountries
        self.indexName = indexName
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.text = text
    }
}

struct SearchPlaceIndexForTextInputBody: Swift.Equatable {
    let text: Swift.String?
    let biasPosition: [Swift.Double]?
    let filterBBox: [Swift.Double]?
    let filterCountries: [Swift.String]?
    let maxResults: Swift.Int?
    let language: Swift.String?
    let filterCategories: [Swift.String]?
}

extension SearchPlaceIndexForTextInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case biasPosition = "BiasPosition"
        case filterBBox = "FilterBBox"
        case filterCategories = "FilterCategories"
        case filterCountries = "FilterCountries"
        case language = "Language"
        case maxResults = "MaxResults"
        case text = "Text"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let biasPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .biasPosition)
        var biasPositionDecoded0:[Swift.Double]? = nil
        if let biasPositionContainer = biasPositionContainer {
            biasPositionDecoded0 = [Swift.Double]()
            for double0 in biasPositionContainer {
                if let double0 = double0 {
                    biasPositionDecoded0?.append(double0)
                }
            }
        }
        biasPosition = biasPositionDecoded0
        let filterBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .filterBBox)
        var filterBBoxDecoded0:[Swift.Double]? = nil
        if let filterBBoxContainer = filterBBoxContainer {
            filterBBoxDecoded0 = [Swift.Double]()
            for double0 in filterBBoxContainer {
                if let double0 = double0 {
                    filterBBoxDecoded0?.append(double0)
                }
            }
        }
        filterBBox = filterBBoxDecoded0
        let filterCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterCountries)
        var filterCountriesDecoded0:[Swift.String]? = nil
        if let filterCountriesContainer = filterCountriesContainer {
            filterCountriesDecoded0 = [Swift.String]()
            for string0 in filterCountriesContainer {
                if let string0 = string0 {
                    filterCountriesDecoded0?.append(string0)
                }
            }
        }
        filterCountries = filterCountriesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let filterCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterCategories)
        var filterCategoriesDecoded0:[Swift.String]? = nil
        if let filterCategoriesContainer = filterCategoriesContainer {
            filterCategoriesDecoded0 = [Swift.String]()
            for string0 in filterCategoriesContainer {
                if let string0 = string0 {
                    filterCategoriesDecoded0?.append(string0)
                }
            }
        }
        filterCategories = filterCategoriesDecoded0
    }
}

extension SearchPlaceIndexForTextOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchPlaceIndexForTextOutputBody = try responseDecoder.decode(responseBody: data)
            self.results = output.results
            self.summary = output.summary
        } else {
            self.results = nil
            self.summary = nil
        }
    }
}

public struct SearchPlaceIndexForTextOutput: Swift.Equatable {
    /// A list of Places matching the input text. Each result contains additional information about the specific point of interest. Not all response properties are included with all responses. Some properties may only be returned by specific data partners.
    /// This member is required.
    public var results: [LocationClientTypes.SearchForTextResult]?
    /// Contains a summary of the request. Echoes the input values for BiasPosition, FilterBBox, FilterCountries, Language, MaxResults, and Text. Also includes the DataSource of the place index and the bounding box, ResultBBox, which surrounds the search results.
    /// This member is required.
    public var summary: LocationClientTypes.SearchPlaceIndexForTextSummary?

    public init(
        results: [LocationClientTypes.SearchForTextResult]? = nil,
        summary: LocationClientTypes.SearchPlaceIndexForTextSummary? = nil
    )
    {
        self.results = results
        self.summary = summary
    }
}

struct SearchPlaceIndexForTextOutputBody: Swift.Equatable {
    let summary: LocationClientTypes.SearchPlaceIndexForTextSummary?
    let results: [LocationClientTypes.SearchForTextResult]?
}

extension SearchPlaceIndexForTextOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
        case summary = "Summary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.SearchPlaceIndexForTextSummary.self, forKey: .summary)
        summary = summaryDecoded
        let resultsContainer = try containerValues.decodeIfPresent([LocationClientTypes.SearchForTextResult?].self, forKey: .results)
        var resultsDecoded0:[LocationClientTypes.SearchForTextResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [LocationClientTypes.SearchForTextResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

enum SearchPlaceIndexForTextOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LocationClientTypes.SearchPlaceIndexForTextSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case biasPosition = "BiasPosition"
        case dataSource = "DataSource"
        case filterBBox = "FilterBBox"
        case filterCategories = "FilterCategories"
        case filterCountries = "FilterCountries"
        case language = "Language"
        case maxResults = "MaxResults"
        case resultBBox = "ResultBBox"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let biasPosition = biasPosition {
            var biasPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .biasPosition)
            for double0 in biasPosition {
                try biasPositionContainer.encode(double0)
            }
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let filterBBox = filterBBox {
            var filterBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterBBox)
            for double0 in filterBBox {
                try filterBBoxContainer.encode(double0)
            }
        }
        if let filterCategories = filterCategories {
            var filterCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCategories)
            for placecategory0 in filterCategories {
                try filterCategoriesContainer.encode(placecategory0)
            }
        }
        if let filterCountries = filterCountries {
            var filterCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCountries)
            for countrycode0 in filterCountries {
                try filterCountriesContainer.encode(countrycode0)
            }
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let resultBBox = resultBBox {
            var resultBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resultBBox)
            for double0 in resultBBox {
                try resultBBoxContainer.encode(double0)
            }
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let biasPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .biasPosition)
        var biasPositionDecoded0:[Swift.Double]? = nil
        if let biasPositionContainer = biasPositionContainer {
            biasPositionDecoded0 = [Swift.Double]()
            for double0 in biasPositionContainer {
                if let double0 = double0 {
                    biasPositionDecoded0?.append(double0)
                }
            }
        }
        biasPosition = biasPositionDecoded0
        let filterBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .filterBBox)
        var filterBBoxDecoded0:[Swift.Double]? = nil
        if let filterBBoxContainer = filterBBoxContainer {
            filterBBoxDecoded0 = [Swift.Double]()
            for double0 in filterBBoxContainer {
                if let double0 = double0 {
                    filterBBoxDecoded0?.append(double0)
                }
            }
        }
        filterBBox = filterBBoxDecoded0
        let filterCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterCountries)
        var filterCountriesDecoded0:[Swift.String]? = nil
        if let filterCountriesContainer = filterCountriesContainer {
            filterCountriesDecoded0 = [Swift.String]()
            for string0 in filterCountriesContainer {
                if let string0 = string0 {
                    filterCountriesDecoded0?.append(string0)
                }
            }
        }
        filterCountries = filterCountriesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resultBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .resultBBox)
        var resultBBoxDecoded0:[Swift.Double]? = nil
        if let resultBBoxContainer = resultBBoxContainer {
            resultBBoxDecoded0 = [Swift.Double]()
            for double0 in resultBBoxContainer {
                if let double0 = double0 {
                    resultBBoxDecoded0?.append(double0)
                }
            }
        }
        resultBBox = resultBBoxDecoded0
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let filterCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterCategories)
        var filterCategoriesDecoded0:[Swift.String]? = nil
        if let filterCategoriesContainer = filterCategoriesContainer {
            filterCategoriesDecoded0 = [Swift.String]()
            for string0 in filterCategoriesContainer {
                if let string0 = string0 {
                    filterCategoriesDecoded0?.append(string0)
                }
            }
        }
        filterCategories = filterCategoriesDecoded0
    }
}

extension LocationClientTypes.SearchPlaceIndexForTextSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForTextSummary(dataSource: \(Swift.String(describing: dataSource)), filterCategories: \(Swift.String(describing: filterCategories)), filterCountries: \(Swift.String(describing: filterCountries)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), biasPosition: \"CONTENT_REDACTED\", filterBBox: \"CONTENT_REDACTED\", resultBBox: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// A summary of the request sent by using SearchPlaceIndexForText.
    public struct SearchPlaceIndexForTextSummary: Swift.Equatable {
        /// Contains the coordinates for the optional bias position specified in the request. This parameter contains a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.
        public var biasPosition: [Swift.Double]?
        /// The geospatial data provider attached to the place index resource specified in the request. Values can be one of the following:
        ///
        /// * Esri
        ///
        /// * Grab
        ///
        /// * Here
        ///
        ///
        /// For more information about data providers, see [Amazon Location Service data providers](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).
        /// This member is required.
        public var dataSource: Swift.String?
        /// Contains the coordinates for the optional bounding box specified in the request.
        public var filterBBox: [Swift.Double]?
        /// The optional category filter specified in the request.
        public var filterCategories: [Swift.String]?
        /// Contains the optional country filter specified in the request.
        public var filterCountries: [Swift.String]?
        /// The preferred language used to return results. Matches the language in the request. The value is a valid [BCP 47](https://tools.ietf.org/search/bcp47) language tag, for example, en for English.
        public var language: Swift.String?
        /// Contains the optional result count limit specified in the request.
        public var maxResults: Swift.Int?
        /// The bounding box that fully contains all search results. If you specified the optional FilterBBox parameter in the request, ResultBBox is contained within FilterBBox.
        public var resultBBox: [Swift.Double]?
        /// The search text specified in the request.
        /// This member is required.
        public var text: Swift.String?

        public init(
            biasPosition: [Swift.Double]? = nil,
            dataSource: Swift.String? = nil,
            filterBBox: [Swift.Double]? = nil,
            filterCategories: [Swift.String]? = nil,
            filterCountries: [Swift.String]? = nil,
            language: Swift.String? = nil,
            maxResults: Swift.Int? = nil,
            resultBBox: [Swift.Double]? = nil,
            text: Swift.String? = nil
        )
        {
            self.biasPosition = biasPosition
            self.dataSource = dataSource
            self.filterBBox = filterBBox
            self.filterCategories = filterCategories
            self.filterCountries = filterCountries
            self.language = language
            self.maxResults = maxResults
            self.resultBBox = resultBBox
            self.text = text
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation was denied because the request would exceed the maximum [quota](https://docs.aws.amazon.com/location/latest/developerguide/location-quotas.html) set for Amazon Location Service.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message with the reason for the service quota exceeded exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// List all active API keys.
        case active
        /// List all expired API keys.
        case expired
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .active,
                .expired,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .expired: return "Expired"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes.Step: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distance = "Distance"
        case durationSeconds = "DurationSeconds"
        case endPosition = "EndPosition"
        case geometryOffset = "GeometryOffset"
        case startPosition = "StartPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distance = self.distance {
            try encodeContainer.encode(distance, forKey: .distance)
        }
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let endPosition = endPosition {
            var endPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endPosition)
            for double0 in endPosition {
                try endPositionContainer.encode(double0)
            }
        }
        if let geometryOffset = self.geometryOffset {
            try encodeContainer.encode(geometryOffset, forKey: .geometryOffset)
        }
        if let startPosition = startPosition {
            var startPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startPosition)
            for double0 in startPosition {
                try startPositionContainer.encode(double0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .startPosition)
        var startPositionDecoded0:[Swift.Double]? = nil
        if let startPositionContainer = startPositionContainer {
            startPositionDecoded0 = [Swift.Double]()
            for double0 in startPositionContainer {
                if let double0 = double0 {
                    startPositionDecoded0?.append(double0)
                }
            }
        }
        startPosition = startPositionDecoded0
        let endPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .endPosition)
        var endPositionDecoded0:[Swift.Double]? = nil
        if let endPositionContainer = endPositionContainer {
            endPositionDecoded0 = [Swift.Double]()
            for double0 in endPositionContainer {
                if let double0 = double0 {
                    endPositionDecoded0?.append(double0)
                }
            }
        }
        endPosition = endPositionDecoded0
        let distanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .distance)
        distance = distanceDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let geometryOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .geometryOffset)
        geometryOffset = geometryOffsetDecoded
    }
}

extension LocationClientTypes.Step: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Step(distance: \(Swift.String(describing: distance)), durationSeconds: \(Swift.String(describing: durationSeconds)), geometryOffset: \(Swift.String(describing: geometryOffset)), endPosition: \"CONTENT_REDACTED\", startPosition: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// Represents an element of a leg within a route. A step contains instructions for how to move to the next step in the leg.
    public struct Step: Swift.Equatable {
        /// The travel distance between the step's StartPosition and EndPosition.
        /// This member is required.
        public var distance: Swift.Double?
        /// The estimated travel time, in seconds, from the step's StartPosition to the EndPosition. . The travel mode and departure time that you specify in the request determines the calculated time.
        /// This member is required.
        public var durationSeconds: Swift.Double?
        /// The end position of a step. If the position the last step in the leg, this position is the same as the end position of the leg.
        /// This member is required.
        public var endPosition: [Swift.Double]?
        /// Represents the start position, or index, in a sequence of steps within the leg's line string geometry. For example, the index of the first step in a leg geometry is 0. Included in the response for queries that set IncludeLegGeometry to True.
        public var geometryOffset: Swift.Int?
        /// The starting position of a step. If the position is the first step in the leg, this position is the same as the start position of the leg.
        /// This member is required.
        public var startPosition: [Swift.Double]?

        public init(
            distance: Swift.Double? = nil,
            durationSeconds: Swift.Double? = nil,
            endPosition: [Swift.Double]? = nil,
            geometryOffset: Swift.Int? = nil,
            startPosition: [Swift.Double]? = nil
        )
        {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.endPosition = endPosition
            self.geometryOffset = geometryOffset
            self.startPosition = startPosition
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource whose tags you want to update.
    ///
    /// * Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Applies one or more tags to specific resource. A tag is a key-value pair that helps you manage, identify, search, and filter your resources. Format: "key" : "value" Restrictions:
    ///
    /// * Maximum 50 tags per resource.
    ///
    /// * Each tag key must be unique and must have exactly one associated value.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @
    ///
    /// * Cannot use "aws:" as a prefix for a key.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied because of request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes.TimeZone: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case offset = "Offset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let offset = self.offset {
            try encodeContainer.encode(offset, forKey: .offset)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offset)
        offset = offsetDecoded
    }
}

extension LocationClientTypes {
    /// Information about a time zone. Includes the name of the time zone and the offset from UTC in seconds.
    public struct TimeZone: Swift.Equatable {
        /// The name of the time zone, following the [ IANA time zone standard](https://www.iana.org/time-zones). For example, America/Los_Angeles.
        /// This member is required.
        public var name: Swift.String?
        /// The time zone's offset, in seconds, from UTC.
        public var offset: Swift.Int?

        public init(
            name: Swift.String? = nil,
            offset: Swift.Int? = nil
        )
        {
            self.name = name
            self.offset = offset
        }
    }

}

extension LocationClientTypes.TrackingFilterGeometry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case polygon = "Polygon"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let polygon = polygon {
            var polygonContainer = encodeContainer.nestedUnkeyedContainer(forKey: .polygon)
            for linearring0 in polygon {
                var linearring0Container = polygonContainer.nestedUnkeyedContainer()
                for position1 in linearring0 {
                    var position1Container = linearring0Container.nestedUnkeyedContainer()
                    for double2 in position1 {
                        try position1Container.encode(double2)
                    }
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let polygonContainer = try containerValues.decodeIfPresent([[[Swift.Double?]?]?].self, forKey: .polygon)
        var polygonDecoded0:[[[Swift.Double]]]? = nil
        if let polygonContainer = polygonContainer {
            polygonDecoded0 = [[[Swift.Double]]]()
            for list0 in polygonContainer {
                var list0Decoded0: [[Swift.Double]]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [[Swift.Double]]()
                    for list1 in list0 {
                        var list1Decoded1: [Swift.Double]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [Swift.Double]()
                            for double2 in list1 {
                                if let double2 = double2 {
                                    list1Decoded1?.append(double2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            list0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    polygonDecoded0?.append(list0Decoded0)
                }
            }
        }
        polygon = polygonDecoded0
    }
}

extension LocationClientTypes {
    /// The geomerty used to filter device positions.
    public struct TrackingFilterGeometry: Swift.Equatable {
        /// The set of arrays which define the polygon. A polygon can have between 4 and 1000 vertices.
        public var polygon: [[[Swift.Double]]]?

        public init(
            polygon: [[[Swift.Double]]]? = nil
        )
        {
            self.polygon = polygon
        }
    }

}

extension LocationClientTypes {
    public enum TravelMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bicycle
        case car
        case motorcycle
        case truck
        case walking
        case sdkUnknown(Swift.String)

        public static var allCases: [TravelMode] {
            return [
                .bicycle,
                .car,
                .motorcycle,
                .truck,
                .walking,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bicycle: return "Bicycle"
            case .car: return "Car"
            case .motorcycle: return "Motorcycle"
            case .truck: return "Truck"
            case .walking: return "Walking"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TravelMode(rawValue: rawValue) ?? TravelMode.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes.TruckDimensions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case height = "Height"
        case length = "Length"
        case unit = "Unit"
        case width = "Width"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let height = self.height {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let length = self.length {
            try encodeContainer.encode(length, forKey: .length)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let width = self.width {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lengthDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .length)
        length = lengthDecoded
        let heightDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .height)
        height = heightDecoded
        let widthDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .width)
        width = widthDecoded
        let unitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DimensionUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension LocationClientTypes {
    /// Contains details about the truck dimensions in the unit of measurement that you specify. Used to filter out roads that can't support or allow the specified dimensions for requests that specify TravelMode as Truck.
    public struct TruckDimensions: Swift.Equatable {
        /// The height of the truck.
        ///
        /// * For example, 4.5.
        ///
        ///
        /// For routes calculated with a HERE resource, this value must be between 0 and 50 meters.
        public var height: Swift.Double?
        /// The length of the truck.
        ///
        /// * For example, 15.5.
        ///
        ///
        /// For routes calculated with a HERE resource, this value must be between 0 and 300 meters.
        public var length: Swift.Double?
        /// Specifies the unit of measurement for the truck dimensions. Default Value: Meters
        public var unit: LocationClientTypes.DimensionUnit?
        /// The width of the truck.
        ///
        /// * For example, 4.5.
        ///
        ///
        /// For routes calculated with a HERE resource, this value must be between 0 and 50 meters.
        public var width: Swift.Double?

        public init(
            height: Swift.Double? = nil,
            length: Swift.Double? = nil,
            unit: LocationClientTypes.DimensionUnit? = nil,
            width: Swift.Double? = nil
        )
        {
            self.height = height
            self.length = length
            self.unit = unit
            self.width = width
        }
    }

}

extension LocationClientTypes.TruckWeight: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case total = "Total"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .total)
        total = totalDecoded
        let unitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.VehicleWeightUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension LocationClientTypes {
    /// Contains details about the truck's weight specifications. Used to avoid roads that can't support or allow the total weight for requests that specify TravelMode as Truck.
    public struct TruckWeight: Swift.Equatable {
        /// The total weight of the truck.
        ///
        /// * For example, 3500.
        public var total: Swift.Double?
        /// The unit of measurement to use for the truck weight. Default Value: Kilograms
        public var unit: LocationClientTypes.VehicleWeightUnit?

        public init(
            total: Swift.Double? = nil,
            unit: LocationClientTypes.VehicleWeightUnit? = nil
        )
        {
            self.total = total
            self.unit = unit
        }
    }

}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource from which you want to remove tags.
    ///
    /// * Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGeofenceCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = self.pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
    }
}

extension UpdateGeofenceCollectionInput {

    static func urlPathProvider(_ value: UpdateGeofenceCollectionInput) -> Swift.String? {
        guard let collectionName = value.collectionName else {
            return nil
        }
        return "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())"
    }
}

public struct UpdateGeofenceCollectionInput: Swift.Equatable {
    /// The name of the geofence collection to update.
    /// This member is required.
    public var collectionName: Swift.String?
    /// Updates the description for the geofence collection.
    public var description: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// This parameter is no longer used.
    @available(*, deprecated, message: "Deprecated. No longer allowed. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?

    public init(
        collectionName: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
        self.description = description
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
    }
}

struct UpdateGeofenceCollectionInputBody: Swift.Equatable {
    let pricingPlan: LocationClientTypes.PricingPlan?
    let pricingPlanDataSource: Swift.String?
    let description: Swift.String?
}

extension UpdateGeofenceCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGeofenceCollectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGeofenceCollectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.collectionArn = output.collectionArn
            self.collectionName = output.collectionName
            self.updateTime = output.updateTime
        } else {
            self.collectionArn = nil
            self.collectionName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateGeofenceCollectionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated geofence collection. Used to specify a resource across Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
    /// This member is required.
    public var collectionArn: Swift.String?
    /// The name of the updated geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The time when the geofence collection was last updated in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        collectionArn: Swift.String? = nil,
        collectionName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.collectionArn = collectionArn
        self.collectionName = collectionName
        self.updateTime = updateTime
    }
}

struct UpdateGeofenceCollectionOutputBody: Swift.Equatable {
    let collectionName: Swift.String?
    let collectionArn: Swift.String?
    let updateTime: ClientRuntime.Date?
}

extension UpdateGeofenceCollectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionArn = "CollectionArn"
        case collectionName = "CollectionName"
        case updateTime = "UpdateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let collectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionArn)
        collectionArn = collectionArnDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

enum UpdateGeofenceCollectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case expireTime = "ExpireTime"
        case forceUpdate = "ForceUpdate"
        case noExpiry = "NoExpiry"
        case restrictions = "Restrictions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expireTime = self.expireTime {
            try encodeContainer.encodeTimestamp(expireTime, format: .dateTime, forKey: .expireTime)
        }
        if let forceUpdate = self.forceUpdate {
            try encodeContainer.encode(forceUpdate, forKey: .forceUpdate)
        }
        if let noExpiry = self.noExpiry {
            try encodeContainer.encode(noExpiry, forKey: .noExpiry)
        }
        if let restrictions = self.restrictions {
            try encodeContainer.encode(restrictions, forKey: .restrictions)
        }
    }
}

extension UpdateKeyInput {

    static func urlPathProvider(_ value: UpdateKeyInput) -> Swift.String? {
        guard let keyName = value.keyName else {
            return nil
        }
        return "/metadata/v0/keys/\(keyName.urlPercentEncoding())"
    }
}

public struct UpdateKeyInput: Swift.Equatable {
    /// Updates the description for the API key resource.
    public var description: Swift.String?
    /// Updates the timestamp for when the API key resource will expire in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    public var expireTime: ClientRuntime.Date?
    /// The boolean flag to be included for updating ExpireTime or Restrictions details. Must be set to true to update an API key resource that has been used in the past 7 days. False if force update is not preferred Default value: False
    public var forceUpdate: Swift.Bool?
    /// The name of the API key resource to update.
    /// This member is required.
    public var keyName: Swift.String?
    /// Whether the API key should expire. Set to true to set the API key to have no expiration time.
    public var noExpiry: Swift.Bool?
    /// Updates the API key restrictions for the API key resource.
    public var restrictions: LocationClientTypes.ApiKeyRestrictions?

    public init(
        description: Swift.String? = nil,
        expireTime: ClientRuntime.Date? = nil,
        forceUpdate: Swift.Bool? = nil,
        keyName: Swift.String? = nil,
        noExpiry: Swift.Bool? = nil,
        restrictions: LocationClientTypes.ApiKeyRestrictions? = nil
    )
    {
        self.description = description
        self.expireTime = expireTime
        self.forceUpdate = forceUpdate
        self.keyName = keyName
        self.noExpiry = noExpiry
        self.restrictions = restrictions
    }
}

struct UpdateKeyInputBody: Swift.Equatable {
    let description: Swift.String?
    let expireTime: ClientRuntime.Date?
    let noExpiry: Swift.Bool?
    let forceUpdate: Swift.Bool?
    let restrictions: LocationClientTypes.ApiKeyRestrictions?
}

extension UpdateKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case expireTime = "ExpireTime"
        case forceUpdate = "ForceUpdate"
        case noExpiry = "NoExpiry"
        case restrictions = "Restrictions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expireTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expireTime)
        expireTime = expireTimeDecoded
        let noExpiryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .noExpiry)
        noExpiry = noExpiryDecoded
        let forceUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceUpdate)
        forceUpdate = forceUpdateDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.ApiKeyRestrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
    }
}

extension UpdateKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyArn = output.keyArn
            self.keyName = output.keyName
            self.updateTime = output.updateTime
        } else {
            self.keyArn = nil
            self.keyName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateKeyOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the API key resource. Used when you need to specify a resource across all Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:key/ExampleKey
    /// This member is required.
    public var keyArn: Swift.String?
    /// The name of the API key resource.
    /// This member is required.
    public var keyName: Swift.String?
    /// The timestamp for when the API key resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        keyArn: Swift.String? = nil,
        keyName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.keyArn = keyArn
        self.keyName = keyName
        self.updateTime = updateTime
    }
}

struct UpdateKeyOutputBody: Swift.Equatable {
    let keyArn: Swift.String?
    let keyName: Swift.String?
    let updateTime: ClientRuntime.Date?
}

extension UpdateKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyArn = "KeyArn"
        case keyName = "KeyName"
        case updateTime = "UpdateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

enum UpdateKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMapInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationUpdate = "ConfigurationUpdate"
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationUpdate = self.configurationUpdate {
            try encodeContainer.encode(configurationUpdate, forKey: .configurationUpdate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
    }
}

extension UpdateMapInput {

    static func urlPathProvider(_ value: UpdateMapInput) -> Swift.String? {
        guard let mapName = value.mapName else {
            return nil
        }
        return "/maps/v0/maps/\(mapName.urlPercentEncoding())"
    }
}

public struct UpdateMapInput: Swift.Equatable {
    /// Updates the parts of the map configuration that can be updated, including the political view.
    public var configurationUpdate: LocationClientTypes.MapConfigurationUpdate?
    /// Updates the description for the map resource.
    public var description: Swift.String?
    /// The name of the map resource to update.
    /// This member is required.
    public var mapName: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?

    public init(
        configurationUpdate: LocationClientTypes.MapConfigurationUpdate? = nil,
        description: Swift.String? = nil,
        mapName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil
    )
    {
        self.configurationUpdate = configurationUpdate
        self.description = description
        self.mapName = mapName
        self.pricingPlan = pricingPlan
    }
}

struct UpdateMapInputBody: Swift.Equatable {
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
    let configurationUpdate: LocationClientTypes.MapConfigurationUpdate?
}

extension UpdateMapInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationUpdate = "ConfigurationUpdate"
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let configurationUpdateDecoded = try containerValues.decodeIfPresent(LocationClientTypes.MapConfigurationUpdate.self, forKey: .configurationUpdate)
        configurationUpdate = configurationUpdateDecoded
    }
}

extension UpdateMapOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMapOutputBody = try responseDecoder.decode(responseBody: data)
            self.mapArn = output.mapArn
            self.mapName = output.mapName
            self.updateTime = output.updateTime
        } else {
            self.mapArn = nil
            self.mapName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateMapOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated map resource. Used to specify a resource across AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:map/ExampleMap
    /// This member is required.
    public var mapArn: Swift.String?
    /// The name of the updated map resource.
    /// This member is required.
    public var mapName: Swift.String?
    /// The timestamp for when the map resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        mapArn: Swift.String? = nil,
        mapName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.mapArn = mapArn
        self.mapName = mapName
        self.updateTime = updateTime
    }
}

struct UpdateMapOutputBody: Swift.Equatable {
    let mapName: Swift.String?
    let mapArn: Swift.String?
    let updateTime: ClientRuntime.Date?
}

extension UpdateMapOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mapArn = "MapArn"
        case mapName = "MapName"
        case updateTime = "UpdateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapName)
        mapName = mapNameDecoded
        let mapArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapArn)
        mapArn = mapArnDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

enum UpdateMapOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePlaceIndexInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceConfiguration = "DataSourceConfiguration"
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceConfiguration = self.dataSourceConfiguration {
            try encodeContainer.encode(dataSourceConfiguration, forKey: .dataSourceConfiguration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
    }
}

extension UpdatePlaceIndexInput {

    static func urlPathProvider(_ value: UpdatePlaceIndexInput) -> Swift.String? {
        guard let indexName = value.indexName else {
            return nil
        }
        return "/places/v0/indexes/\(indexName.urlPercentEncoding())"
    }
}

public struct UpdatePlaceIndexInput: Swift.Equatable {
    /// Updates the data storage option for the place index resource.
    public var dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    /// Updates the description for the place index resource.
    public var description: Swift.String?
    /// The name of the place index resource to update.
    /// This member is required.
    public var indexName: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?

    public init(
        dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        indexName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil
    )
    {
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.indexName = indexName
        self.pricingPlan = pricingPlan
    }
}

struct UpdatePlaceIndexInputBody: Swift.Equatable {
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
    let dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
}

extension UpdatePlaceIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceConfiguration = "DataSourceConfiguration"
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
    }
}

extension UpdatePlaceIndexOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePlaceIndexOutputBody = try responseDecoder.decode(responseBody: data)
            self.indexArn = output.indexArn
            self.indexName = output.indexName
            self.updateTime = output.updateTime
        } else {
            self.indexArn = nil
            self.indexName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdatePlaceIndexOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the upated place index resource. Used to specify a resource across Amazon Web Services.
    ///
    /// * Format example: arn:aws:geo:region:account-id:place- index/ExamplePlaceIndex
    /// This member is required.
    public var indexArn: Swift.String?
    /// The name of the updated place index resource.
    /// This member is required.
    public var indexName: Swift.String?
    /// The timestamp for when the place index resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.indexArn = indexArn
        self.indexName = indexName
        self.updateTime = updateTime
    }
}

struct UpdatePlaceIndexOutputBody: Swift.Equatable {
    let indexName: Swift.String?
    let indexArn: Swift.String?
    let updateTime: ClientRuntime.Date?
}

extension UpdatePlaceIndexOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexArn = "IndexArn"
        case indexName = "IndexName"
        case updateTime = "UpdateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let indexArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexArn)
        indexArn = indexArnDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

enum UpdatePlaceIndexOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRouteCalculatorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
    }
}

extension UpdateRouteCalculatorInput {

    static func urlPathProvider(_ value: UpdateRouteCalculatorInput) -> Swift.String? {
        guard let calculatorName = value.calculatorName else {
            return nil
        }
        return "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())"
    }
}

public struct UpdateRouteCalculatorInput: Swift.Equatable {
    /// The name of the route calculator resource to update.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// Updates the description for the route calculator resource.
    public var description: Swift.String?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?

    public init(
        calculatorName: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil
    )
    {
        self.calculatorName = calculatorName
        self.description = description
        self.pricingPlan = pricingPlan
    }
}

struct UpdateRouteCalculatorInputBody: Swift.Equatable {
    let pricingPlan: LocationClientTypes.PricingPlan?
    let description: Swift.String?
}

extension UpdateRouteCalculatorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRouteCalculatorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRouteCalculatorOutputBody = try responseDecoder.decode(responseBody: data)
            self.calculatorArn = output.calculatorArn
            self.calculatorName = output.calculatorName
            self.updateTime = output.updateTime
        } else {
            self.calculatorArn = nil
            self.calculatorName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateRouteCalculatorOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated route calculator resource. Used to specify a resource across AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:route- calculator/ExampleCalculator
    /// This member is required.
    public var calculatorArn: Swift.String?
    /// The name of the updated route calculator resource.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// The timestamp for when the route calculator was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        calculatorArn: Swift.String? = nil,
        calculatorName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.calculatorArn = calculatorArn
        self.calculatorName = calculatorName
        self.updateTime = updateTime
    }
}

struct UpdateRouteCalculatorOutputBody: Swift.Equatable {
    let calculatorName: Swift.String?
    let calculatorArn: Swift.String?
    let updateTime: ClientRuntime.Date?
}

extension UpdateRouteCalculatorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorArn = "CalculatorArn"
        case calculatorName = "CalculatorName"
        case updateTime = "UpdateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorName)
        calculatorName = calculatorNameDecoded
        let calculatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorArn)
        calculatorArn = calculatorArnDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

enum UpdateRouteCalculatorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTrackerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventBridgeEnabled = "EventBridgeEnabled"
        case kmsKeyEnableGeospatialQueries = "KmsKeyEnableGeospatialQueries"
        case positionFiltering = "PositionFiltering"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventBridgeEnabled = self.eventBridgeEnabled {
            try encodeContainer.encode(eventBridgeEnabled, forKey: .eventBridgeEnabled)
        }
        if let kmsKeyEnableGeospatialQueries = self.kmsKeyEnableGeospatialQueries {
            try encodeContainer.encode(kmsKeyEnableGeospatialQueries, forKey: .kmsKeyEnableGeospatialQueries)
        }
        if let positionFiltering = self.positionFiltering {
            try encodeContainer.encode(positionFiltering.rawValue, forKey: .positionFiltering)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = self.pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
    }
}

extension UpdateTrackerInput {

    static func urlPathProvider(_ value: UpdateTrackerInput) -> Swift.String? {
        guard let trackerName = value.trackerName else {
            return nil
        }
        return "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())"
    }
}

public struct UpdateTrackerInput: Swift.Equatable {
    /// Updates the description for the tracker resource.
    public var description: Swift.String?
    /// Whether to enable position UPDATE events from this tracker to be sent to EventBridge. You do not need enable this feature to get ENTER and EXIT events for geofences with this tracker. Those events are always sent to EventBridge.
    public var eventBridgeEnabled: Swift.Bool?
    /// Enables GeospatialQueries for a tracker that uses a [Amazon Web Services KMS customer managed key](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html). This parameter is only used if you are using a KMS customer managed key.
    public var kmsKeyEnableGeospatialQueries: Swift.Bool?
    /// Updates the position filtering for the tracker resource. Valid values:
    ///
    /// * TimeBased - Location updates are evaluated against linked geofence collections, but not every location update is stored. If your update frequency is more often than 30 seconds, only one update per 30 seconds is stored for each unique device ID.
    ///
    /// * DistanceBased - If the device has moved less than 30 m (98.4 ft), location updates are ignored. Location updates within this distance are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map.
    ///
    /// * AccuracyBased - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This helps educe the effects of GPS noise when displaying device trajectories on a map, and can help control costs by reducing the number of geofence evaluations.
    public var positionFiltering: LocationClientTypes.PositionFiltering?
    /// No longer used. If included, the only allowed value is RequestBasedUsage.
    @available(*, deprecated, message: "Deprecated. If included, the only allowed value is RequestBasedUsage. API deprecated since 2022-02-01")
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// This parameter is no longer used.
    @available(*, deprecated, message: "Deprecated. No longer allowed. API deprecated since 2022-02-01")
    public var pricingPlanDataSource: Swift.String?
    /// The name of the tracker resource to update.
    /// This member is required.
    public var trackerName: Swift.String?

    public init(
        description: Swift.String? = nil,
        eventBridgeEnabled: Swift.Bool? = nil,
        kmsKeyEnableGeospatialQueries: Swift.Bool? = nil,
        positionFiltering: LocationClientTypes.PositionFiltering? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.description = description
        self.eventBridgeEnabled = eventBridgeEnabled
        self.kmsKeyEnableGeospatialQueries = kmsKeyEnableGeospatialQueries
        self.positionFiltering = positionFiltering
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.trackerName = trackerName
    }
}

struct UpdateTrackerInputBody: Swift.Equatable {
    let pricingPlan: LocationClientTypes.PricingPlan?
    let pricingPlanDataSource: Swift.String?
    let description: Swift.String?
    let positionFiltering: LocationClientTypes.PositionFiltering?
    let eventBridgeEnabled: Swift.Bool?
    let kmsKeyEnableGeospatialQueries: Swift.Bool?
}

extension UpdateTrackerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventBridgeEnabled = "EventBridgeEnabled"
        case kmsKeyEnableGeospatialQueries = "KmsKeyEnableGeospatialQueries"
        case positionFiltering = "PositionFiltering"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let positionFilteringDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PositionFiltering.self, forKey: .positionFiltering)
        positionFiltering = positionFilteringDecoded
        let eventBridgeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .eventBridgeEnabled)
        eventBridgeEnabled = eventBridgeEnabledDecoded
        let kmsKeyEnableGeospatialQueriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kmsKeyEnableGeospatialQueries)
        kmsKeyEnableGeospatialQueries = kmsKeyEnableGeospatialQueriesDecoded
    }
}

extension UpdateTrackerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTrackerOutputBody = try responseDecoder.decode(responseBody: data)
            self.trackerArn = output.trackerArn
            self.trackerName = output.trackerName
            self.updateTime = output.updateTime
        } else {
            self.trackerArn = nil
            self.trackerName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateTrackerOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated tracker resource. Used to specify a resource across AWS.
    ///
    /// * Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
    /// This member is required.
    public var trackerArn: Swift.String?
    /// The name of the updated tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?
    /// The timestamp for when the tracker resource was last updated in [ ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        trackerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.trackerArn = trackerArn
        self.trackerName = trackerName
        self.updateTime = updateTime
    }
}

struct UpdateTrackerOutputBody: Swift.Equatable {
    let trackerName: Swift.String?
    let trackerArn: Swift.String?
    let updateTime: ClientRuntime.Date?
}

extension UpdateTrackerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trackerArn = "TrackerArn"
        case trackerName = "TrackerName"
        case updateTime = "UpdateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let trackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerArn)
        trackerArn = trackerArnDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

enum UpdateTrackerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input failed to meet the constraints specified by the AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field where the invalid entry was detected.
        /// This member is required.
        public internal(set) var fieldList: [LocationClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// A message with the reason for the validation exception error.
        /// This member is required.
        public internal(set) var reason: LocationClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [LocationClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: LocationClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: LocationClientTypes.ValidationExceptionReason?
    let fieldList: [LocationClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList = "fieldList"
        case message = "message"
        case reason = "reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(LocationClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([LocationClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[LocationClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [LocationClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension LocationClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes {
    /// The input failed to meet the constraints specified by the AWS service in a specified field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message with the reason for the validation exception error.
        /// This member is required.
        public var message: Swift.String?
        /// The field name where the invalid entry was detected.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension LocationClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The input cannot be parsed. For example a required JSON document, ARN identifier, date value, or numeric field cannot be parsed.
        case cannotparse
        /// The input is present and parsable, but it is otherwise invalid. For example, a required numeric argument is outside the allowed range.
        case fieldvalidationfailed
        /// The required input is missing.
        case missing
        /// The input is invalid but no more specific reason is applicable.
        case other
        /// No such operation is supported.
        case unknownoperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotparse,
                .fieldvalidationfailed,
                .missing,
                .other,
                .unknownoperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotparse: return "CannotParse"
            case .fieldvalidationfailed: return "FieldValidationFailed"
            case .missing: return "Missing"
            case .other: return "Other"
            case .unknownoperation: return "UnknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes {
    public enum VehicleWeightUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kilograms
        case pounds
        case sdkUnknown(Swift.String)

        public static var allCases: [VehicleWeightUnit] {
            return [
                .kilograms,
                .pounds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kilograms: return "Kilograms"
            case .pounds: return "Pounds"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VehicleWeightUnit(rawValue: rawValue) ?? VehicleWeightUnit.sdkUnknown(rawValue)
        }
    }
}
